<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OS-drill</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        /**
         * @typedef {Object} Drill
         * @property {number} section
         * @property {Array.<string>} correct
         * @property {Array.<string>} incorrect
         */
    </script>
</head>

<body class="p-1 md:p-5 max-w-screen-lg mx-auto">

</body>
<script>
    const body = document.querySelector('body');
    /** @type {Array.<Drill>} */
    const drill = [
        {
            "section": 1,
            "correct": [
                "instrukce tvaru ld reg_addr → reg_out načte hodnotu z paměti a uloží ji do registru; reg_addr je</br>registr, ve kterém je uložena adresa, kterou program požaduje</br></br>instrukce tvaru st reg_in → reg_addr naopak hodnotu do paměti uloží, a to opět na adresu zadanou registrem reg_addr.",
                "Každá adresa je číslo, ale ne každé číslo je platná adresa. Adresním prostorem</br>tedy budeme nazývat zejména množinu platných adres, ale můžeme v tomto pojmu zahrnout i případnou další</br>zajímavou strukturu paměti (např. to, že nějaká část adres má jiné vlastnosti než ty ostatní).</br>Adresní prostor se obvykle skládá ze souvislých bloků, kde jednotlivé bloky obsahují mnoho po sobě</br>jdoucích adres (řádově miliony).",
                "Program má při svém běhu k dispozici nějaký adresní prostor, který může používat</br>k ukládání dat. Krom pracovní paměti (do které si program ukládá libovolná data jak uzná za vhodné) je</br>součástí adresního prostoru programu také kód – adresy, na kterých jsou uloženy instrukce, ze kterých</br>program samotný sestává, a obvykle také hardwarový zásobník, který se používá k realizaci podprogramů</br>(volání funkcí).",
                "Fyzická paměť</br>Fyzické adresy (tedy adresy, které patří fyzickému adresnímu prostoru) přímo</br>pojmenovávají fyzické paměťové buňky hardwarových zařízení, zejména paměti RAM. Přestože se jedná</br>o jeden adresní prostor, podobně jako v případě paměti programu může mít další strukturu.</br>Největší a nejdůležitější blok (případně několik bloků) fyzických adres zpravidla patří operační paměti</br>(paměti s přímým přístupem, random access memory, RAM). Toto je paměť v klasickém smyslu tohoto slova,</br>a slouží především k ukládáni pracovních dat programů",
                "Virtualizace</br>V principu nic nebrání tomu, aby program používal k práci s pamětí přímo fyzické adresy.</br>V takovém případě bychom program přizpůsobili tomu, které fyzické adresy jsou na našem počítači platné</br>a odpovídají operační paměti.</br>Jakmile bychom ale chtěli na jednom počítači spustit několik programů najednou, začneme narážet na</br>problémy. Programy by mezi sebou musely použití adres koordinovat: používá-li program A adresu 0x1005</br>pro svoji proměnnou, nemůže ji zároveň používat program B.",
                "Virtuální a fyzické adresy</br>Bylo by tedy lepší, aby adresní prostor programu byl od toho fyzického</br>nezávislý. Proto procesory určené pro běžné počítače poskytují oddělený virtuální adresní prostor,</br>který je viditelný pro programy, a který je od toho fyzického důsledně oddělen. Fyzický adresní prostor</br>je uživatelským programům zcela nepřístupný.",
                "Překlad adres</br>Virtuální adresy budeme překládat na adresy fyzické, které již určí, kde budou příslušná data skutečně uložena.</br>O fyzické buňce pak můžeme říct, že má právě jednu fyzickou adresu (a ta je této buňce přidělena</br>pevně) a nějaké virtuální adresy (to jsou ty, které se přeloží na její fyzickou adresu). Buňka může mít</br>virtuálních adres hned několik, ale také třeba žádnou",
                "Jednotka správy paměti</br>Přístup do paměti (čtení, zápis) je časově kritickou operací – procesor</br>jich provádí miliony za vteřinu. Přitom adresní operand instrukce, která takový přístup realizuje,</br>představuje vždy virtuální adresu, která musí být ještě před samotným přístupem přeložena na adresu</br>fyzickou.",
                "Jednotka správy paměti</br>Překlad adres proto musí být velmi rychlý, a není nijak překvapivé, že je realizován specializovaným</br>hardwarem, který je přímo součástí procesoru. Zároveň ale potřebujeme zabezpečit, aby o konkrétní</br>podobě překladu mohl rozhodovat operační systém. Proto musí být tato tzv. jednotka správy paměti</br>programovatelná – pomocí vhodně sestavených tabulek může operační systém (konkrétně jeho jádro)</br>řídit mapování virtuálních adres na fyzické, a tedy i to, jak budou vypadat jednotlivé virtuální adresní</br>prostory.",
                "Stránky</br>Stránka je pak základní jednotkou překladu. Tím se jednak zmenší potřebné tabulky, jednak se tím</br>zjednoduší proces překladu. Budeme-li totiž požadovat, aby:</br></br>1. stránka obsahovala 2**n</br>adres (tj. měla velikost 2**n bajtů),</br>2. stránka začínala adresou, která je beze zbytku dělitelná 2**n</br>3. byla mapována na fyzickou adresu, která je také beze zbytku dělitelná 2**n,</br></br>můžeme spodních n bitů virtuální adresy přímo použít jako spodních n bitů adresy fyzické. Zbytek fyzické adresy již dopočítáme podle překladové tabulky.</br>To má mimo jiné za důsledek, že stránky se nemohou překrývat.",
                "Stránkové tabulky</br>Stránkové tabulky jsou uloženy v operační paměti, ale jejich přesná struktura</br>je opět vlastností konkrétního hardwaru. Protože moderní počítače mají velké adresní prostory (2**32 nebo 2**64 virtuálních adres), </br>používají obvykle řídké, víceúrovňové překladové tabulky.",
                "Proces</br>Pojem běžící program je poněkud vágní, proto si pro něj zavedeme formálnější alternativu</br>– proces. Tímto pojmem budeme označovat entitu, která:</br>• je spojena s virtuálním adresním prostorem, který</br>     ∘ obsahuje kód – instrukce – nějakého programu,</br>     ∘ veškerá data, která tento program potřebuje pro svůj běh,</br>• operační systém o ni vede záznam,</br>• může vlastnit krom paměti i další zdroje",
                "Ochrana paměti</br>• Kód programu (a případná data, která jsou určena výhradně ke čtení) může být ve fyzické paměti uložen</br>pouze jednou i v případě, kdy tento kód využívá více procesů. Jedná se o užitečnou a zároveň bezpečnou</br>optimalizaci, protože odpovídající virtuální adresy jsou v obou procesech označeny příznakem pouze</br>pro čtení, a procesy se tak nemohou skrze tyto adresy vzájemně ovlivňovat.</br>• Na žádost programu může být dvěma procesům do jejich virtuálních adresních prostorů namapován</br>stejný blok fyzické paměti i v režimu umožňujícím zápis. Smyslem takto namapované paměti je umožnit</br>komunikaci mezi dotčenými procesy: mohou si tímto způsobem totiž jednoduše předávat data. Pozor:</br>virtuální adresy takto namapované paměti nebudou obecně v obou procesech stejné.",
                "Přepnutí procesu</br>Zatím jsme nezmínili, jak procesor (resp. jednotka správy paměti) najde</br>stránkovou tabulku první úrovně. Odpověď na tuto otázku je klíčem k přepínání procesů:</br>1. fyzická adresa stránkové tabulky 1. úrovně je uložena ve speciálním registru procesoru,</br>2. tuto adresu je možné nastavit privilegovanou instrukcí (privilegovanou v tomto případě znamená, že</br>ji může provést pouze jádro),</br>3. změnou hodnoty v tomto registru se aktivuje překlad adres podle nově zavedené stránkové tabulky",
                "Vytvoření procesu</br>Asi nejjednodušší způsob, jak vytvořit nový proces, je duplikace nějakého</br>existujícího (POSIX této operaci říká fork). V mnoha operačních systémech je to dokonce způsob jediný.19</br>Mohlo by se zdát, že je to způsob dost neefektivní: procesy mohou mít virtuální adresní prostor</br>o velikosti mnoha GiB a duplikace takového množství paměti vyžaduje vynaložení značných prostředků.</br>Operační systémy proto používají trik, který zde vede k výrazné úspoře, a se kterým se setkáme ještě</br>v několika kontextech.</br>Tento trik nese název „copy on write“ a jeho myšlenka je poměrně jednoduchá:</br>1. vytvoříme kopii adresního prostoru (tedy relevantních stránkových tabulek, nikoliv samotných dat),</br>2. v obou kopiích označíme všechny stránky příznakem jen pro čtení a poznačíme si také, že se jedná o</br>„copy on write“ stránky.",
                "Externí stránkování </br>Má-li OS nedostatek použitelných fyzických adres (například proto, že běží hodně programů, které využívají hodně</br>paměti), může některou stránku odstěhovat z operační paměti někam jinam – např. na externí (pevné)</br>úložiště, které je sice obvykle mnohem pomalejší, ale také má obvykle mnohem větší kapacitu. Nebude-li</br>se stávat příliš často, že program potřebuje k takto „odklizené“ stránce přistoupit, nemusí se jednat</br>o zásadní problém.",
                "Rámce a stránky</br>• stránkou budeme i nadále označovat rozsah virtuálních adres,</br>   ∘ také stále platí, že stránky mají pevnou velikost (počet virtuálních adres, které obsahuje), a že</br>   ∘ nejnižší adresa stránky musí být beze zbytku dělitelná velikostí stránky,</br>• rámcem budeme označovat rozsah fyzických adres,</br>   ∘ které splňují stejné požadavky na velikost a zarovnání jako stránky,</br>   ∘ a na jeden rámec mapovat právě jednu stránku.</br>Lze pak mluvit o tom, že daná stránka je uložena v nějakém rámci, případně že daný rámec je volný.",
                "Líné načítání</br>Líné načítání lze také výhodně kombinovat s klasickým externím stránkováním – vybereme-li jako oběť</br>stránku s kódem (nebo konstantními daty) programu, není potřeba ji nikam ukládat – lze ji přímo odkázat</br>zpátky na spustitelný soubor.",
                "Mapování souborů</br>Posledním, jednoznačně nejdůležitějším, využitím externího stránkování je</br>mapování datových souborů do paměti (na žádost aplikace). V tomto režimu jsou externí stránky uloženy</br>v jinak běžném souboru. Místo komplikovaných vstupně-výstupních operací tak může program s obsahem</br>souboru pracovat stejně, jako by byl uložen v operační paměti. Využijeme-li tohoto mechanismu také</br>k zápisu změněných stránek zpátky do souboru, může program soubor i zcela transparentně upravovat."
            ],
            "incorrect": [
                "instrukce tvaru ld reg_addr → reg_out načte hodnotu z paměti a uloží ji do registru; reg_addr je</br>registr, ve kterém je uložena nějaká hodnota</br></br>instrukce tvaru st reg_in → reg_addr naopak hodnotu do paměti uloží, a to opět na adresu zadanou registrem reg_addr.",
                "Každá adresa je číslo, ale ne každé číslo je platná adresa. Adresním prostorem</br>tedy budeme nazývat zejména množinu platných adres, ale můžeme v tomto pojmu zahrnout i případnou dalš</br> zajímavou strukturu paměti (např. to, že nějaká část adres má jiné vlastnosti než ty ostatní).</br>Adresní prostor se obvykle skládá bloků, kde jednotlivé bloky obsahují libovolné adresy.",
                "Program má při svém běhu k dispozici nějaký adresní prostor, který může používat</br>k ukládání dat. Krom pracovní paměti (do které si program ukládá libovolná data jak uzná za vhodné) je</br>součástí adresního prostoru programu také kód – adresy, na kterých jsou uloženy instrukce, ze kterých</br>program samotný sestává, ovšem zásobník se zde obvykle nenachází.",
                "Fyzická paměť</br>Fyzické adresy (tedy adresy, které patří fyzickému adresnímu prostoru) přímo</br>pojmenovávají fyzické paměťové buňky procesoru. Přestože se jedná o jeden adresní prostor</br> podobně jako v případě paměti programu může mít další strukturu.</br>",
                "Virtualizace</br>V principu nic nebrání tomu, aby program používal k práci s pamětí přímo fyzické adresy.</br>V takovém případě bychom program přizpůsobili tomu, které fyzické adresy jsou na našem počítači platné</br>a odpovídají operační paměti.</br>Takto nemůžou vzniknout žádné problémy a tedy je virtualizace procesoru zbytečná.</br>",
                "Virtuální a fyzické adresy</br>Bylo by tedy lepší, aby adresní prostor programu na tom fyzickém závislý.</br>Proto procesory určené pro běžné počítače poskytují spojení virtuálních adresních prostorů s těmi fyzickými. Fyzický adresní prostor</br>je tedy uživatelským programům libovolně přístupný.",
                "Překlad adres</br>Virtuální adresy budeme překládat na adresy fyzické, které již určí, kde budou příslušná data skutečně uložena.</br>O fyzické buňce pak můžeme říct, že má právě jednu fyzickou adresu (a ta je této buňce přidělena</br>pevně) a právě jednu virtuální adresu (a ta není této buňce přidělena pevně).",
                "Jednotka správy paměti</br>Přístup do paměti (čtení, zápis) je časově kritickou operací – procesor</br>jich provádí miliony za vteřinu. Přitom adresní operand instrukce, která takový přístup realizuje,</br>představuje vždy fyzickou adresu, která musí být ještě před samotným přístupem přeložena na adresu</br>virtuální.",
                "Jednotka správy paměti</br>Překlad adres proto musí být velmi rychlý, a není nijak překvapivé, že je realizován specializovaným</br>hardwarem, který je přímo součástí procesoru. Zároveň ale nesmíme dovolit aby operační systém jakkoli, jinak by došlo k porušení abstrakce.",
                "Stránky</br>Stránka je pak základní jednotkou překladu. Tím se jednak zmenší potřebné tabulky, jednak se tím</br>zjednoduší proces překladu. Budeme-li totiž požadovat, aby:</br></br>1. stránka obsahovala 2**n</br>adres (tj. měla velikost 2**n bajtů),</br>2. stránka začínala adresou, která je beze zbytku dělitelná 2</br>3. byla mapována na fyzickou adresu, která je také beze zbytku dělitelná 2,</br></br>můžeme spodních n bitů virtuální adresy přímo použít jako spodních n bitů adresy fyzické. Zbytek fyzické adresy již dopočítáme podle překladové tabulky. </br>To má mimo jiné za důsledek, že stránky se nemohou překrývat.",
                "Stránkové tabulky</br>Stránkové tabulky jsou uloženy v operační paměti, ale jejich přesná struktura</br>je opět vlastností konkrétního hardwaru. Protože moderní počítače mají velké adresní prostory (2**32 nebo 2**64 virtuálních adres), </br>používají obvykle husté, jednoúrovňové překladové tabulky.",
                "Proces</br>Pojem běžící program je poněkud vágní, proto si pro něj zavedeme formálnější alternativu</br>– proces. Tímto pojmem budeme označovat entitu, která:</br>• je spojena s fyzickým adresním prostorem, který</br>     ∘ obsahuje kód – instrukce – nějakého programu,</br>     ∘ veškerá data, která tento program potřebuje pro svůj běh,</br>• operační systém o ni vede záznam,</br>• může vlastnit krom paměti i další zdroje",
                "Ochrana paměti</br>• Kód programu (a případná data, která jsou určena výhradně ke čtení) může být ve fyzické paměti uložen</br>pouze jednou i v případě, kdy tento kód využívá více procesů. Jedná se o užitečnou a zároveň bezpečnou</br>optimalizaci, protože odpovídající virtuální adresy jsou v obou procesech označeny příznakem pouze</br>pro čtení, a procesy se tak nemohou skrze tyto adresy vzájemně ovlivňovat.</br>• Na žádost programu může být dvěma procesům do jejich virtuálních adresních prostorů namapován</br>stejný blok fyzické paměti i v režimu umožňujícím zápis. Smyslem takto namapované paměti je umožnit</br>komunikaci mezi dotčenými procesy: mohou si tímto způsobem totiž jednoduše předávat data. Pozor:</br>virtuální adresy takto namapované paměti musí být v obou procesech stejné.",
                "Přepnutí procesu</br>Zatím jsme nezmínili, jak procesor (resp. jednotka správy paměti) najde</br>stránkovou tabulku první úrovně. Odpověď na tuto otázku je klíčem k přepínání procesů:</br>1. fyzická adresa stránkové tabulky 1. úrovně je uložena ve speciálním registru procesoru,</br>2. tuto adresu může nastavit libovolný uživatelský program ve speciálním režimu</br>3. změnou hodnoty v tomto registru se aktivuje překlad adres podle nově zavedené stránkové tabulky.",
                "Vytvoření procesu</br>Asi nejjednodušší způsob, jak vytvořit nový proces, je duplikace nějakého</br>existujícího (POSIX této operaci říká fork). V mnoha operačních systémech je to dokonce způsob jediný.19</br>Mohlo by se zdát, že je to způsob dost neefektivní: procesy mohou mít virtuální adresní prostor</br>o velikosti mnoha GiB a duplikace takového množství paměti vyžaduje vynaložení značných prostředků.</br>Operační systémy proto používají trik, který zde vede k výrazné úspoře, a se kterým se setkáme ještě</br>v několika kontextech.</br>Tento trik nese název „copy on write“ a jeho myšlenka je poměrně jednoduchá:</br>1. vytvoříme kopii fyzických adres (tedy relevantních fyzických buněk, nikoliv samotných dat),</br>2. v obou kopiích označíme všechny stránky příznakem jen pro čtení a poznačíme si také, že se jedná o</br>„copy on write“ stránky.",
                "Externí stránkování </br>Má-li OS nedostatek použitelných fyzických adres (například proto, že běží hodně programů, které využívají hodně</br>paměti), může některou stránku odstěhovat z operační paměti někam jinam – např. na externí (pevné)</br>úložiště, které je sice obvykle mnohem pomalejší, ale také má obvykle mnohem větší kapacitu. Nebude-li</br>se stávat příliš často, že program k dané stránce dlouhodobě nepřistupuje, nemusí se jednat</br>o zásadní problém.",
                "Rámce a stránky</br>• stránkou budeme i nadále označovat rozsah fyzických adres,</br>   ∘ také stále platí, že stránky mají pevnou velikost (počet virtuálních adres, které obsahuje), a že</br>   ∘ nejnižší adresa stránky musí být beze zbytku dělitelná velikostí stránky,</br>• rámcem budeme označovat rozsah virtuálních adres,</br>   ∘ které splňují stejné požadavky na velikost a zarovnání jako stránky,</br>   ∘ a na jeden rámec mapovat právě jednu stránku.</br>Lze pak mluvit o tom, že daná stránka je uložena v nějakém rámci, případně že daný rámec je volný.",
                "Líné načítání</br>Líné načítání lze také výhodně kombinovat s klasickým externím stránkováním – vybereme-li jako oběť</br>stránku s kódem (nebo konstantními daty) programu, stačí stránku uložit do operační paměti",
                "Mapování souborů</br>Posledním, jednoznačně nejdůležitějším, využitím externího stránkování je</br>mapování datových souborů do paměti (na žádost aplikace). V tomto režimu jsou externí stránky uloženy</br>v jinak běžném souboru. Místo komplikovaných vstupně-výstupních operací tak může program s obsahem</br>souboru pracovat stejně, jako by byl uložen v operační paměti. Toto ovšem zabraňujeprogramu soubor transparentně upravovat."
            ]
        },
        {
            "section": 2,
            "correct": [
                "Výpočet</br>Procesor vykonává instrukce, čím realizuje výpočet. Nejjednodušší třídou instrukcí jsou</br>tzv. aritmetické a logické instrukce (tedy ty, které provádí ALU – aritmeticko-logická jednotka). Tím se</br>myslí zejména:</br>• aritmetika: sčítání, odečítání, násobení a dělení,</br>• bitové operace: and, or, xor po bitech, bitové posuvy,</br>• srovnání dvou hodnot (rovnost, nerovnost) – výsledek se uloží do běžného registru nebo do stavového</br>příznaku procesoru.",
                "Registry</br>Podobně jako paměť, registry slouží k ukládáni čísel – existují dva klíčové rozdíly mezi</br>registry a pamětí:</br>1. pojmenování registru je pevnou součástí instrukce, kdežto paměťovou adresu lze vypočítat (paměť</br>lze indexovat, registry nikoliv),</br>2. reprezentace čísla v registru je monolitická – registry nejsou složené z bajtů, daný registr obsahuje</br>celé slovo (částečně důsledek předchozího bodu: registr lze pojmenovat pouze jako celek).",
                "Programový čítač</br>Vyhrazený registr (programový čítač, angl. program counter, někdy také instruction pointer, budeme</br>jej označovat pc) pak obsahuje virtuální adresu právě vykonávané instrukce. Tento registr rozhoduje</br>o tom, která instrukce se má vykonat, není do něj ale obvykle možné zapisovat běžnými (aritmetickými,</br>atp.) instrukcemi. K tomu jsou určeny instrukce řízení toku, kterých hlavním efektem je právě změna</br>hodnoty programového čítače.",
                "Instrukce</br>Instrukce je elementární příkaz strojového kódu; to znamená:</br>• elementární – je to nejmenší jednotka činnosti, kterou lze procesoru zadat,</br>• příkaz – instrukce řídí činnost procesoru, „přikazují“ mu provedení nějaké akce.</br>Instrukcí budeme nazývat pouze celek, který obsahuje veškeré informace potřebné k provedení konkrétních</br>akcí (zejména udává operaci, která se má provést, a konkrétní registry, se kterými se bude pracovat a</br>také konkrétní přímé operandy.</br>Instrukcí je pouze konečně mnoho, je tedy zejména možné je očíslovat (nebo jinak konečně kódovat,</br>např. do sekvencí bajtů). Každé takové číslo (kódování) popisuje konkrétní akci, kterou může procesor</br>provést.</br>",
                "Efekt instrukce</br>Každá instrukce má nějaký efekt na stav procesoru, a případně (podle konkrétní instrukce) na další připojená zařízení (zejména paměť). </br>Tento efekt je zároveň definující charakteristikou dané instrukce.</br>Program totiž nedělá nic jiného, než že vhodnou manipulací stavu (procesoru, paměti, periferií) postupuje</br>od vstupů k požadovaným výstupům. Této posloupnosti změn stavu říkáme výpočet.</br>",
                "Efekt instrukce</br>Jak vstupy tak výstupy programu jsou součástí stavu – vstupy na začátku, výstupy na konci výpočtu.</br>Vstup může být například hodnota zapsaná v nějaké buňce paměti; výstup může být třeba stav obrazovky,</br>kdy rozsvícené pixely vytváří obrazec, který přečteme jako slova hello world.</br>Efekt instrukce tedy není nic jiného, než elementární změna stavu, nebo jinak řečeno elementární výpočet.</br>Instrukci samotnou tak můžeme chápat jako pokyn k provedení takového elementárního výpočtu.",
                "Program</br>Co bude program počítat (resp. co bude počítat procesor řízený daným programem)</br>je určeno textem programu: instrukcemi uloženými v paměti. Instrukce, které nejsou skoky, obvykle</br>posouvají programový čítač za svůj vlastní konec, tedy na instrukci na nejbližší vyšší adrese. Většina</br>programu je tedy prováděna v pořadí od nižších k vyšším (virtuálním) adresám.</br>Výjimku samozřejmě tvoří instrukce skoku, které mohou některé adresy přeskočit (typicky podmíněné</br>příkazy – if), nebo se naopak vrátit k některé dřívější, už vykonané instrukci (typicky cykly – while)",
                "Zásobník</br>Za účelem aktivace podprogramu by se nám hodila jakási odlehčená verze virtualizace procesoru:</br>1. podprogram je dostatečně uzavřený celek na to, aby mělo smysl jej alespoň částečně oddělit od</br>ostatních výpočtů – často např. používá nějaká data, která mimo tento podprogram nemají žádný</br>význam (ve vyšším programovacím jazyce lokální proměnné),</br>2. protože takový podprogram je navíc často potřeba spouštět z různých míst programu, je žádoucí mít</br>nějaký mechanismus, který po ukončení výpočtu podprogramu vrátí řízení na místo, ze kterého byl</br>původně aktivován.</br>Obě tyto funkce zastává zásobník (hardwarový zásobník, zásobník volání, angl. call stack, atp.). Jedná</br>se o spojitou oblast virtuálního adresního prostoru, které rozsah je dán hodnotou ukazatele vrcholu</br>zásobníku (jedná se o druhý „speciální“ registr, vedle programového čítače) a pevným dnem.",
                "Aktivační záznam</br>Zásobník typického programu je složen z aktivačních záznamů, známých též</br>jako rámců (angl. call frame). Každý takový záznam odpovídá jedné aktivaci podprogramu, která</br>dosud neskončila. Jak jistě víte, podprogramy se mohou aktivovat (volat) vzájemně, nebo může dokonce</br>podprogram opakovaně aktivovat sám sebe – jev, který pravděpodobně znáte jako rekurzi.</br>Je také relativně logické, že má-li nějaký podprogram skončit (a tedy má být jeho aktivační záznam</br>odstraněn), musí nejprve skončit všechny podprogramy, které sám aktivoval (přímo či nepřímo). Tato</br>skutečnost je odpovědná za to, že aktivační rámce tvoří právě zásobník (a ne třeba frontu, strom,</br>graf, nebo jinou strukturu).",
                "Stav procesoru</br>Stav procesoru tedy sestává z:</br>1. hodnot uložených v aritmetických registrech,</br>2. hodnoty programového čítače,</br>3. hodnoty ukazatele zásobníku.</br>V případě, že:</br>• program neobsahuje instrukce přístupu do paměti,</br>• nebo celý virtuální adresní prostor je přístupný pouze aktivnímu programu,</br>je celý výpočet jednoznačně určen programem samotným a počátečním stavem procesoru (a případně</br>paměti).",
                "Vlákno</br>Nyní jsme konečně připraveni definovat pojem vlákno: je to</br>• výpočet (posloupnost změn stavu), který vznikne</br>• nepřerušenou činností jednoho procesoru, který je</br>• po celou dobu řízen jedním programem.</br>Všimněte si, že neklademe žádné požadavky na adresní prostor. Takový výpočet tedy není jednoznačně</br>určen, protože není izolován – součástí takového výpočtu může být synchronizace, a tedy průběh výpočtu</br>krom samotného programu a počátečního stavu bude záviset také na vnějších událostech, které může</br>vlákno skrze svůj adresní prostor pozorovat.</br>Za povšimnutí také stojí, že definice nepovoluje, aby se stav procesoru měnil jakkoliv jinak, než</br>řízením programu. Bude také výhodné předpokládat, že zásobník je pro externí entity nepřístupný a že</br>jej tedy chápat jako součást stavu vlákna (který je jinak shodný se stavem procesoru).",
                "Logický procesor</br>Definice vlákna se odvolává na nepřerušenou činnost procesoru. Pro účely této</br>definice si ale vystačíme s velmi abstraktním chápáním procesoru:</br>1. procesor má stav, který sestává právě z hodnot registrů,</br>2. procesor svůj stav mění vykonáváním instrukcí (a nijak jinak).</br>Takto popsaný procesor budeme nazývat logickým procesorem. Má několik zajímavých vlastností:</br>1. je zřejmé, že výpočet logického procesoru lze přímočaře realizovat na fyzickém procesoru,</br>2. stav logického procesoru je velmi jednoduchý a tedy není těžké si představit, že bychom ho mohli</br>například uložit do paměti (to se nakonec částečně děje i při aktivaci podprogramu),</br>3. lze si také představit, že bychom mohli fyzický procesor do takto uloženého stavu zase vrátit.</br>Předpokládejme, že operace z bodů 2 a 3 skutečně existují, a že je může operační systém provést bez</br>součinnosti aktuálně prováděného vlákna. Pak už je jednoduše vidět, jak realizovat několik logických</br>procesorů pomocí jednoho fyzického, a tím dosáhnout virtualizace procesoru</br>",
                "Přepnutí vlákna</br>Protože můžeme uložit, a později obnovit, stav logického procesoru, můžeme na</br>jednom fyzickém procesoru provádět střídavě několik různých vláken, a zároveň zabezpečit, že každé</br>vlákno má, ze svého vlastního pohledu, pomyslný vlastní procesor.</br>Co obnáší uložení a obnova registru závisí na jejich typu:</br>1. aritmetické registry – teoreticky nepředstavují problém, ale protože bez aritmetických registrů</br>nelze nic počítat, nelze bez asistence procesoru uložit ani obnovit všechny,</br>2. ukazatel zásobníku v principu jednoduché jak uložit tak obnovit, problém ale nastane, používáme-li</br>zásobníkové instrukce k manipulaci s ostatními registry,</br>3. programový čítač představuje největší problém: nelze přímo ani uložit (vyžadovalo by součinnost</br>prováděného programu), ani obnovit (obnovou automaticky ztrácíme kontrolu nad procesorem, musí</br>tedy být provedena v posledním kroku, kdy už ale nemáme k dispozici žádné aritmetické registry).</br>",
                "Plánovač</br>Části jádra operačního systému, která je odpovědná za přidělování procesorů vláknům</br>říkáme plánovač vláken, často také z historických důvodů plánovač procesů. Plánovač je na každém</br>procesoru aktivován v pravidelných intervalech a je mu tedy umožněno odebrat procesor aktivnímu</br>vláknu i bez součinnosti tohoto vlákna.</br>Základním rozhodnutím plánovače při každé aktivaci je: „Má aktivní vlákno (logický procesor) pokračovat</br>ve výpočtu, nebo má být přerušeno (preempted). Které vlákno má být na procesoru spuštěno jako další?</br>",
                "Cíle plánovače</br>Na plánovací algoritmus (a plánovač jako celek) máme několik základních požadavků:</br>1. maximalizovat propustnost</br>2. minimalizovat latenci (prodlevu)</br>3. udržovat férovost</br>Je na první pohled vidět, že některé požadavky jsou protichůdné: zejména latence a propustnost často</br>stojí proti sobě, a zlepšení jednoho parametru vede ke zhoršení toho druhého.",
                "Stav vlákna</br>Vlákno (které ještě neskončilo) může být, z pohledu plánovače, ve třech základních</br>stavech:</br>1. právě běží – má aktuálně přidělený procesor,</br>2. připraveno ke běhu, ale čeká na procesor – vlákno bylo přerušeno plánovačem (nebo nebylo dosud nikdy</br>spuštěno), ale jinak mu nic nebrání pokračovat ve výpočtu,</br>3. čeká na událost – vlákno je „zaseknuté“ v synchronizační smyčce a nemůže pokračovat ve výpočtu,</br>dokud nenastane nějaká externí událost (plánovači musí být tento stav explicitně oznámen, jinak jej</br>nemá jak rozeznat od běžného výpočtu).</br></br>nemůže se stát, že by vlákno, které čekalo na procesor, přešlo do stavu čekání na událost</br>– tento přechod totiž vyžaduje nějakou akci, kterou musí provést samotné vlákno.</br>",
                "Fronta úloh</br>Základním pracovním nástrojem plánovače jsou běhové fronty úloh (angl. run queue),</br>do kterých plánovač řadí vlákna, která čekají na procesor. Konkrétní plánovací algoritmy se pak liší</br>zejména v tom, jak se tyto fronty chovají.</br>",
                "Afinita</br>Protože migrace vlákna na jiný fyzický procesor není zadarmo, je žádoucí zbytečným</br>migracím vláken zamezit. Mluvíme v takovém případě o afinitě vlákna ke konkrétnímu fyzickému procesoru:</br>plánovač má snahu vlákno opakovaně plánovat na stejný fyzický procesor.</br>Mezní situace jsou:</br>1. plánovač zcela bez afinity: např. proto, že má globální frontu a tedy je prvnímu čekajícímu vláknu</br>vždy přidělen první uvolněný procesor,</br>2. plánovač bez možnosti migrace: např. proto, že má lokální fronty, a neumožňuje přesun vláken mezi</br>nimi.",
                "Prioritní fronty</br>Interaktivní plánovače používají téměř výhradně nějakou formu prioritního</br>plánování – vlákna mají přidělenu prioritu (staticky nebo dynamicky), která ovlivňuje jejich schopnost</br>získat procesor – a to jak latenci (jak dlouho musí vlákno čekat ve frontě) tak celkový přidělený</br>výpočetní čas (jaký díl procesorového času je vláknu přidělen).</br>",
                "Prioritní fronty</br>výhody:</br>• používá pouze jednoduché datové struktury,</br>• všechny operace jsou asymptoticky konstantní (vzhledem k počtu čekajících vláken – počet prioritních</br>tříd je pevný).</br>A také jednu důležitou nevýhodu:</br>• dlouho běžící výpočetní vlákno s vysokou prioritou zablokuje procesor pro všechna ostatní vlákna.</br>Tuto nevýhodu lze vyřešit dynamickou úpravou priority: za každou přidělenou jednotku výpočetního času</br>je vlákno „potrestáno“ snížením priority. Existují-li jiná čekající vlákna, dříve nebo později se tak</br>dostanou ke slovu.",
                "Férové plánování</br>Cílem férového plánovače je, aby každé vlákno dostalo přiděleno podle možnosti</br>stejné množství výpočetního času (případně váženo prioritou). V tomto se podobá na systém s dynamickou</br>úpravou priority z předchozí sekce, ale místo pevného systému prioritních tříd má priority v libovolném</br>rozsahu. Realizuje se proto klasickou (monolitickou) prioritní frontou – např. binární haldou nebo</br>binárním vyhledávacím stromem.",
                "Odebrání procesoru</br>Rozhodnutí o odebrání procesoru (tzn. přesunu vlákna ze stavu „běží“ do</br>stavu „čeká na procesor“) má dva základní vstupy:</br>1. jak dlouho již běží právě aktivní vlákno,</br>2. srovnání aktivního vlákna a následujícího vlákna ve frontě.</br>Konkrétní rozhodnutí opět závisí na konkrétním plánovacím algoritmu. Je ale obvyklé nechat aktivní</br>vlákno běžet nějaký minimální čas, i v případě, že další naplánované vlákno má vyšší prioritu (tímto se</br>brání příliš častému přepínání vláken) – tento minimální čas je plánovací kvantum. Delší kvantum má</br>pozitivní vliv na propustnost, ale negativní vliv na latenci (reakční dobu).",
                "Čekající vlákna</br>Vlákno je označeno jako čekající na událost (říkáme o něm také, že je uspané)</br>buď na vlastní žádost (umožňuje-li to operační systém a povaha události), nebo na popud některé jiné</br>části operačního systému:</br>• vyžádá-li například vlákno čtení ze souboru, a operační systém nemá aktuálně data k dispozici, zařádí</br>požadavek na data do fronty a vlákno uspí,</br>• pokusí-li se vstoupit do kritické sekce, která je aktuálně zamčená jiným vláknem,</br>• vyžádá vstup z klávesnice (a zrovna není žádný k dispozici),</br>",
                "Čekající vlákna</br>Události čekání jsou v zásadě dvou typů:</br>• čekání na vyřízení „soukromého“ požadavku: takto uspané vlákno je poznačeno u příslušného požadavku,</br>a jakmile je tento vyřízen, odpovědná komponenta vlákno probudí (aktivuje plánovač, který vlákno</br>přesune do běhové fronty, nebo mu ihned přidělí procesor),</br>• soutěž o nějaký zdroj (např. zmiňovaná kritická sekce), který může vlastnit v danou chvíli nejvýše</br>jedno vlákno, ale na který jich může zároveň čekat několik: takové zdroje mají čekací frontu (angl.</br>wait queue) a příslušná událost probudí (přesune do běhové fronty) pouze první vlákno z čekací fronty:</br>nemá smysl probouzet všechna, protože by okamžitě všechna krom jednoho musela být zase uspána</br>(vyhrát soutěž může nejvýše jedno).</br>"
            ]
            ,
            "incorrect": [
                "Výpočet</br>Operační paměť vykonává instrukce, čím realizuje výpočet. Nejjednodušší třídou instrukcí jsou</br>tzv. aritmetické a logické instrukce (tedy ty, které provádí ALU – aritmeticko-logická jednotka). Tím se</br>myslí zejména:</br>• aritmetika: sčítání, odečítání, násobení a dělení,</br>• bitové operace: and, or, xor po bitech, bitové posuvy,</br>• srovnání dvou hodnot (rovnost, nerovnost) – výsledek se uloží do běžného registru nebo do stavového</br>příznaku procesoru.",
                "Registry</br>Podobně jako paměť, registry slouží k ukládáni čísel – existují dva klíčové rozdíly mezi</br>registry a pamětí:</br>1. pojmenování registru je pevnou součástí instrukce, kdežto paměťovou adresu lze vypočítat (paměť</br>lze indexovat, registry nikoliv),</br>2. reprezentace čísla v registru – registry jsou složené z bajtů, daný registr obsahuje</br>bajty jako každá jíná část paměti",
                "Programový čítač</br>Vyhrazený registr (programový čítač, angl. program counter, někdy také instruction pointer, budeme</br>jej označovat pc) pak obsahuje fyzickou adresu právě vykonávané instrukce. Tento registr rozhoduje</br>o tom, která instrukce se má vykonat, není do něj ale obvykle možné zapisovat běžnými (aritmetickými,</br>atp.) instrukcemi. K tomu jsou určeny instrukce řízení toku, kterých hlavním efektem je právě změna</br>hodnoty programového čítače.",
                "Instrukce</br>Instrukce je elementární příkaz strojového kódu; to znamená:</br>• elementární – je to nejmenší jednotka činnosti, kterou lze procesoru zadat,</br>• příkaz – instrukce řídí činnost procesoru, „přikazují“ mu provedení nějaké akce.</br>Instrukcí budeme nazývat pouze celek, který obsahuje veškeré informace potřebné k provedení konkrétních</br>akcí (zejména udává operaci, která se má provést, a konkrétní registry, se kterými se bude pracovat a</br>také konkrétní přímé operandy.</br>Instrukcí je nekonečně mnoho, je tedy nepraktické je číslovat</br>",
                "Efekt instrukce</br>Každá instrukce má nějaký efekt na stav procesoru, a případně (podle konkrétní instrukce) na další připojená zařízení (zejména paměť). </br>Tento efekt není definující charakteristikou dané instrukce.</br>Program totiž nedělá nic jiného, než že vhodnou manipulací stavu (procesoru, paměti, periferií) postupuje</br>od vstupů k požadovaným výstupům. Této posloupnosti změn stavu říkáme výpočet.</br>",
                "Efekt instrukce</br>Jak vstupy tak výstupy programu jsou součástí stavu – vstupy na začátku, výstupy na konci výpočtu.</br>Vstup musí být hodnota zapsaná v nějaké buňce paměti; výstup může být třeba stav obrazovky,</br>kdy rozsvícené pixely vytváří obrazec, který přečteme jako slova hello world.</br>Efekt instrukce tedy není nic jiného, než elementární změna stavu, nebo jinak řečeno elementární výpočet.</br>Instrukci samotnou tak můžeme chápat jako pokyn k provedení takového elementárního výpočtu.",
                "Program</br>Co bude program počítat (resp. co bude počítat procesor řízený daným programem)</br>je určeno textem programu: instrukcemi uloženými v paměti. Instrukce, které nejsou skoky, obvykle</br>posouvají programový čítač za svůj vlastní konec, tedy na instrukci na nejbližší nižší adrese. Většina</br>programu je tedy prováděna v pořadí od vyšších k nižším (virtuálním) adresám.</br>Výjimku samozřejmě tvoří instrukce skoku, které mohou některé adresy přeskočit (typicky podmíněné</br>příkazy – if), nebo se naopak vrátit k některé dřívější, už vykonané instrukci (typicky cykly – while)",
                "Zásobník</br>Za účelem aktivace podprogramu by se nám hodila jakási odlehčená verze virtualizace procesoru:</br>1. podprogram není dostatečně uzavřený celek na to, aby mělo smysl jej  oddělit od ostatních výpočtů, proto ho neoddělujeme</br>2. protože takový podprogram je navíc často potřeba spouštět z různých míst programu, je žádoucí mít</br>nějaký mechanismus, který po ukončení výpočtu podprogramu vrátí řízení na místo, ze kterého byl</br>původně aktivován.</br>Obě tyto funkce zastává zásobník (hardwarový zásobník, zásobník volání, angl. call stack, atp.). Jedná</br>se o spojitou oblast virtuálního adresního prostoru, které rozsah je dán hodnotou ukazatele vrcholu</br>zásobníku (jedná se o druhý „speciální“ registr, vedle programového čítače) a pevným dnem.",
                "Aktivační záznam</br>Zásobník typického programu je složen z aktivačních záznamů, známých též</br>jako rámců (angl. call frame). Každý takový záznam odpovídá jedné aktivaci podprogramu, který již skončil.</br>Jak jistě víte, podprogramy se mohou aktivovat (volat) vzájemně, nebo může dokonce</br>podprogram opakovaně aktivovat sám sebe – jev, který pravděpodobně znáte jako rekurzi.</br>Je také relativně logické, že má-li nějaký podprogram skončit (a tedy má být jeho aktivační záznam</br>odstraněn), musí nejprve skončit všechny podprogramy, které sám aktivoval (přímo či nepřímo). Tato</br>skutečnost je odpovědná za to, že aktivační rámce tvoří právě zásobník (a ne třeba frontu, strom,</br>graf, nebo jinou strukturu).",
                "Stav procesoru</br>Stav procesoru tedy sestává z:</br>1. hodnot uložených v aritmetických registrech,</br>2. hodnoty programového čítače,</br>3. hodnoty ukazatele zásobníku.</br>V případě, že:</br>• program neobsahuje instrukce přístupu do paměti,</br>• a celý virtuální adresní prostor je přístupný pouze aktivnímu programu</br>je celý výpočet jednoznačně určen programem samotným a počátečním stavem procesoru (a případně</br>paměti).",
                "Vlákno</br>Nyní jsme konečně připraveni definovat pojem vlákno: je to</br>• výpočet (posloupnost změn stavu), který vznikne</br>• nepřerušenou činností jednoho procesoru, který je</br>• po celou dobu řízen jedním programem.</br>Všimněte si, že neklademe žádné požadavky na adresní prostor. Takový výpočet tedy je jednoznačně určen.</br>Za povšimnutí také stojí, že definice nepovoluje, aby se stav procesoru měnil jakkoliv jinak, než</br>řízením programu. Bude také výhodné předpokládat, že zásobník je pro externí entity nepřístupný a že</br>jej tedy chápat jako součást stavu vlákna (který je jinak shodný se stavem procesoru).",
                "Logický procesor</br>Definice vlákna se odvolává na nepřerušenou činnost procesoru. Pro účely této</br>definice si ale vystačíme s velmi abstraktním chápáním procesoru:</br>1. procesor má stav, který sestává právě z hodnot registrů,</br>2. procesor svůj stav mění vykonáváním instrukcí (a nijak jinak).</br>Takto popsaný procesor budeme nazývat logickým procesorem. Má několik zajímavých vlastností:</br>1. je zřejmé, že výpočet logického procesoru lze přímočaře realizovat na fyzickém procesoru,</br>2. stav logického procesoru je velmi složitý a tedy není možné ho uložit do paměti </br>",
                "Přepnutí vlákna</br>Protože můžeme uložit, a později obnovit, stav logického procesoru, můžeme na</br>jednom fyzickém procesoru provádět střídavě několik různých vláken, a zároveň zabezpečit, že každé</br>vlákno má, ze svého vlastního pohledu, pomyslný vlastní procesor.</br>Co obnáší uložení a obnova registru závisí na jejich typu:</br>1. aritmetické registry – teoreticky nepředstavují problém, protože je lze obnovit všechny,</br>2. ukazatel zásobníku v principu jednoduché jak uložit tak obnovit, problém ale nastane, používáme-li</br>zásobníkové instrukce k manipulaci s ostatními registry,</br>3. programový čítač představuje největší problém: nelze přímo ani uložit (vyžadovalo by součinnost</br>prováděného programu), ani obnovit (obnovou automaticky ztrácíme kontrolu nad procesorem, musí</br>tedy být provedena v posledním kroku, kdy už ale nemáme k dispozici žádné aritmetické registry).</br>",
                "Plánovač</br>Části jádra operačního systému, která je odpovědná za přidělování procesorů vláknům</br>říkáme plánovač vláken, často také z historických důvodů plánovač procesů. Plánovač je jen na hlavním</br>procesoru aktivován v pravidelných intervalech a je mu tedy umožněno odebrat procesor aktivnímu</br>vláknu i bez součinnosti tohoto vlákna.</br>Základním rozhodnutím plánovače při každé aktivaci je: „Má aktivní vlákno (logický procesor) pokračovat</br>ve výpočtu, nebo má být přerušeno (preempted). Které vlákno má být na procesoru spuštěno jako další?</br>",
                "Cíle plánovače</br>Na plánovací algoritmus (a plánovač jako celek) máme několik základních požadavků:</br>1. minimalizovat propustnost</br>2. maximalizovat latenci (prodlevu)</br>3. udržovat férovost</br>Je na první pohled vidět, že některé požadavky jsou protichůdné: zejména latence a propustnost často</br>stojí proti sobě, a zlepšení jednoho parametru vede ke zhoršení toho druhého.",
                "Stav vlákna</br>Vlákno (které ještě neskončilo) může být, z pohledu plánovače, ve třech základních</br>stavech:</br>1. právě běží – má aktuálně přidělený procesor,</br>2. připraveno ke běhu, ale čeká na procesor – vlákno bylo přerušeno plánovačem (nebo nebylo dosud nikdy</br>spuštěno), ale jinak mu nic nebrání pokračovat ve výpočtu,</br>3. čeká na událost – vlákno je „zaseknuté“ v synchronizační smyčce a nemůže pokračovat ve výpočtu,</br>dokud nenastane nějaká externí událost (plánovači musí být tento stav explicitně oznámen, jinak jej</br>nemá jak rozeznat od běžného výpočtu).</br></br>Vlákno může libovolně přecházet mezi všemi stavy, tyto přechody jsou řízeny procesorem",
                "Fronta úloh</br>Základním pracovním nástrojem plánovače jsou běhové fronty úloh (angl. run queue),</br>do kterých plánovač řadí vlákna, která čekají na událost. Konkrétní plánovací algoritmy se pak liší</br>zejména v tom, jak se tyto fronty chovají.</br>",
                "Afinita</br>Protože migrace vlákna na jiný fyzický procesor není zadarmo, je žádoucí zbytečným</br>migracím vláken zamezit. Mluvíme v takovém případě o afinitě vlákna ke konkrétnímu fyzickému procesoru:</br>plánovač má snahu vlákno opakovaně plánovat na stejný fyzický procesor.</br>Mezní situace jsou:</br>1. plánovač zcela bez afinity: např. proto, že má lokální fronty, a neumožňuje přesun vláken mezi</br>nim,</br>2. plánovač bez možnosti migrace: např. proto,že má globální frontu a tedy je prvnímu čekajícímu vláknu</br>vždy přidělen první uvolněný procesor.",
                "Prioritní fronty</br>Interaktivní plánovače používají téměř výhradně nějakou formu prioritního</br>plánování – vlákna mají přidělenu prioritu (staticky nebo dynamicky), která ovlivňuje jejich schopnost</br>získat procesor – a to jen latenci (jak dlouho musí vlákno čekat ve frontě), celkový přidělený</br>výpočetní čas ovlivňovat nemůže</br>",
                "Prioritní fronty</br>výhody:</br>• používá pouze jednoduché datové struktury,</br>• všechny operace jsou asymptoticky konstantní (vzhledem k počtu čekajících vláken – počet prioritních</br>tříd je pevný).</br>A také jednu důležitou nevýhodu:</br>• dlouho běžící výpočetní vlákno s vysokou prioritou zablokuje procesor pro všechna ostatní vlákna.</br>Tuto nevýhodu nelze vyřešit dynamickou úpravou priority, docházelo by k takzvanému hladovění vláken.",
                "Férové plánování</br>Cílem férového plánovače je, aby každé vlákno dostalo přiděleno podle možnosti</br>stejné množství výpočetního času (případně váženo prioritou). V tomto se podobá na systém s dynamickou</br>úpravou priority z předchozí sekce, ale místo pevného systému prioritních tříd má priority v libovolném</br>rozsahu. Realizuje se proto zásobníkem.",
                "Odebrání procesoru</br>Rozhodnutí o odebrání procesoru (tzn. přesunu vlákna ze stavu „běží“ do</br>stavu „čeká na procesor“) má dva základní vstupy:</br>1. jak dlouho již běží právě aktivní vlákno,</br>2. srovnání aktivního vlákna a následujícího vlákna ve frontě.</br>Konkrétní rozhodnutí opět závisí na konkrétním plánovacím algoritmu. Je ale obvyklé nechat aktivní</br>vlákno běžet nějaký minimální čas, i v případě, že další naplánované vlákno má vyšší prioritu (tímto se</br>brání příliš častému přepínání vláken) – tento minimální čas je plánovací kvantum. Delší kvantum má</br>negativní vliv na propustnost, ale pozitivní vliv na latenci (reakční dobu).",
                "Čekající vlákna</br>Vlákno je označeno jako čekající na událost (říkáme o něm také, že je uspané) na žádost pouze operačního systému, příklad:</br>• vyžádá-li například vlákno čtení ze souboru, a operační systém nemá aktuálně data k dispozici, zařádí</br>požadavek na data do fronty a vlákno uspí,</br>• pokusí-li se vstoupit do kritické sekce, která je aktuálně zamčená jiným vláknem,</br>• vyžádá vstup z klávesnice (a zrovna není žádný k dispozici),</br>",
                "Čekající vlákna</br>Události čekání jsou v zásadě dvou typů:</br>• čekání na vyřízení „soukromého“ požadavku: takto uspané vlákno je poznačeno u příslušného požadavku,</br>a jakmile je tento vyřízen, odpovědná komponenta vlákno přesune na jiný procesor.</br>• soutěž o nějaký zdroj (např. zmiňovaná kritická sekce), který může vlastnit v danou chvíli nejvýše</br>jedno vlákno, ale na který jich může zároveň čekat několik: takové zdroje mají čekací frontu (angl.</br>wait queue) a příslušná událost probudí (přesune do běhové fronty) pouze první vlákno z čekací fronty:</br>nemá smysl probouzet všechna, protože by okamžitě všechna krom jednoho musela být zase uspána</br>(vyhrát soutěž může nejvýše jedno).</br>"
            ]
        },
        {
            "section": 3,
            "correct": [
                " Bloková zařízení</br>Tento typ zařízení představuje abstrakci perzistentních úložišť. Operace (abstraktního) blokového</br>zařízení jsou přizpůsobené běžným schopnostem odpovídajících reálných zařízení:</br>• zápis a čtení je prováděno po blocích pevné velikosti,</br>• v libovolném pořadí, ale</br>• s velkou latencí a malou propustností (relativně k operační paměti).",
                "Trvalé úložiště</br>je fyzické zařízení, které se podobá na operační paměť (pamatuje si data),</br>s několika klíčovými rozdíly:</br>1. data zde uložená přetrvávají „dlouhodobě“, tedy zejména i po vypnutí počítače (nebo restartu</br>operačního systému),</br>2. přístup k datům je pomalejší – zejména má mnohem vyšší latenci (prodlevu) mezi vystavením požadavku</br>a odpovědí zařízení; je proto nepraktické adresovat takové zařízení po jednotlivých bajtech (jako</br>tomu je u operační paměti),</br>3. proto je obvyklé, že poskytují operace, které pracují s celými bloky dat najednou (velikost 512 bajtů</br>a víc, často 4 KiB) – základní operací je pak přesun takového bloku mezi zařízením a operační pamětí.",
                "Latence</br>doba mezi požadavkem a odpovědí; příliš velká, než aby bylo lze ignorovat; rozdíl proti</br>operační paměti: nelze skrýt hardwarově, musí řešit OS; problém zejména pro spolehlivé uložení dat –</br>durability v ACID – nutné čekat na potvrzení zápisu",
                " Mezipaměť</br>Hlavní problém, který mezipaměť řeší, je opakovaný přístup ke stejným adresám daného</br>datového úložiště. Přístup k datům obvykle není rovnoměrný – některá data jsou potřebná často (např.</br>aktivně využívaná databáze), zatímco jiná (archiv dat z minulého roku) jen velmi zřídka. Proto je výhodné</br>si nedávno čtená data pamatovat v rychlejší paměti: může se totiž lehce stát, že je bude potřeba přečíst</br>v blízké budoucnosti znovu.</br>Podobně má smysl některá data načíst do mezipaměti s předstihem (existuje-li volná přenosová kapacita;</br>této technice se angl. říká prefetch)",
                "Vyrovnávací paměť</br>Existují dvě základní možnosti, jak vyrovnávací paměti realizovat:</br>1. oddělené od mezipaměti: vyrovnávací paměť obsahuje jak samotné požadavky, tak veškerá data s nimi</br>spojená; jsou-li některé dotčené bloky uložené v mezipaměti, tyto jsou buď zneplatněny, nebo (častěji)</br>upraveny na místě,</br>2. propojená s mezipamětí: vyrovnávací paměť obsahuje pouze frontu požadavků na zápis – samotné</br>datové bloky se ukládají vždy do mezipaměti, fronta nevyřízených zápisů do ní pouze odkazuje; takto</br>koncipovaný systém se, jako celek, chová jako mezipaměť s opožděným zápisem (angl. write-back</br>cache).",
                " Plánování operací</br>U většiny úložišť platí, že sekvenční přístup (čtení po sobě následujících</br>adres) je mnohem rychlejší, než nahodilý přístup (postupné čtení adres, které spolu nijak nesouvisí).</br>Různé technologie navíc kladou další omezení na rychlost reakce – klasickým příkladem jsou rotační disky,</br>kde prodleva další operace závisí na vzdálenosti hlavy od místa, kde se potřebná data fyzicky nachází.</br>Naopak polovodičové paměti jsou často složené z nezávislých celků, které mohou pracovat souběžně, ale</br>požadavky do stejné části paměti musí vyčkat na dokončení těch předchozích.</br>Bez ohledu na technologii ukládání dat ale platí, že operace s trvalým úložištěm vykazují vysokou míru</br>souběžnosti: do systému přichází mnoho nezávislých požadavků na diskové operace a existuje tedy jistá</br>volnost odpovídat na tyto požadavky v různém pořadí. Je to způsobeno zejména tím, že je často spuštěno</br>několik (souběžných) vláken a každé z nich provádí vstupně-výstupní operace nezávisle na ostatních.",
                "Přeuspořádání operací má určitá úskalí, zejména v případech, kdy jsou prohozeny zápisy, které náleží</br>stejné aplikaci, nebo se jedná o operace související s údržbou metadat souborového systému. Vzniká tak</br>napětí mezi výkonem (více přeuspořádání → vyšší propustnost) a spolehlivostí (více přeuspořádání →</br>větší šance nekonzistence v případě výpadku).</br>Pokud jde o operace čtení, zde je prostor pro přeuspořádání obvykle menší, protože aplikace, která čtení</br>vyžádala, obvykle nemůže pokračovat ve své činnosti dříve, než jsou data k dispozici (a tedy zejména</br>nemůže vyžádat další operace čtení).",
                "Problémy virtualizace</br>Náš dosavadní přístup k virtualizaci nebude v případě trvalých úložišť</br>příliš dobře fungovat. Vzpomeňte si, že v případě paměti a procesoru řešení spočívalo ve vytvoření</br>soukromých (virtuálních) instancí příslušného zařízení. Taková instance je pak vždy ve výlučném užívání</br>jednoho programu.</br>Zde ale narážíme na to, že trvalé úložiště slouží především k ukládání uživatelsky zajímavých dat. Je</br>tedy potřebné, aby mohl uživatel s těmito daty nějak interagovat, a zejména tedy nemůžou být skryta</br>v soukromém prostoru jednoho programu.",
                "Problémy virtualizace</br>dvě možnosti řešení:</br>1. můžeme zcela změnit přístup k virtualizaci: místo toho, abychom virtualizací vytvořili věrný obraz</br>skutečného zařízení, může operační systém poskytovat nějaký jiný druh abstrakce, a trvalé úložiště</br>nebude aplikacím vůbec přístupné,</br>2. vyčleníme nějakou aplikaci, která bude odpovědná za správu uživatelských dat v trvalém úložišti, a</br>ostatní aplikace budou své požadavky na interakci s těmito daty řešit skrze tuto speciální aplikaci.</br></br>Obě řešení jsou ve skutečnosti (s trochou nadsázky) vlastně totéž řešení. V obou případech je přímý</br>přístup k úložišti omezen na jeden nebo několik málo programů (v prvním případě je tento program</br>součástí operačního systému), tento program rozhoduje o tom, jak budou data „fyzicky“ organizovaná,</br>jaké operace lze nad daty provádět, které další programy k nim budou mít přístup, atp.",
                "Metody virtualizace</br>1. souborový systém, nebo obecněji abstrakce na vyšší úrovni poskytovaná jako služba operačního systému,</br>která umožňuje řízený přístup k datům mnoha aplikacím současně, a zároveň umožňuje uživateli data</br>organizovat a spravovat,</br>2. virtualizace na aplikační úrovni, kdy je přímý přístup k úložišti poskytnut některé aplikaci, která</br>spravuje data a ostatním aplikacím poskytuje přístup pomocí vhodného aplikačního protokolu (typickým</br>příkladem jsou databázové systémy),",
                "RAID</br>Zatímco standardním řešením problému s nízkou propustností a/nebo velkou prodlevou paměťových operací jsou mezipaměti,</br>standardním řešením problémů se spolehlivostí paměti je redundance.</br>Nejjednodušší formou redundance je pořízení kopie (zálohy) – v případě ztráty primárních dat obnovíme</br>data ze záložní kopie. S tím jsou spojeny dva problémy:</br>1. aby byla užitečná, musíme takovou kopii udržovat aktuální a zároveň konzistentní,</br>2. při poruše musíme vyměnit dotčené zařízení a data překopírovat ze zálohy, přitom obě operace mohou</br>být poměrně zdlouhavé.",
                "Operace nad soubory</br>Základními operacemi pro práci se souborem je čtení (v POSIX-u voláním read) a zápis</br>(v POSIX-u write) souvislé posloupnosti bajtů (libovolné velikosti – abstrakce souboru skrývá blokový</br>charakter zařízení, na kterém je soubor uložen). Podobně může být libovolná velikost souboru (samozřejmě</br>ale musí soubor obsahovat celočíselný počet bajtů) – tuto velikost je navíc možné dynamicky měnit. Zápis</br>„za konec“ souboru jej automaticky prodlouží, zkrácení je nutné explicitně vyžádat (v POSIX-u voláním</br>ftruncate).",
                "soubory jsou obvykle perzistentní</br>– existují dlouhodobě, nezávisle na běžících procesech, nebo dokonce na tom, je-li vůbec aktivní operační</br>systém (nebo samotný hardware). Abychom mohli s perzistentními soubory rozumně pracovat, musí být</br>navíc tyto opatřeny identitou.</br>Abychom mohli se souborem pracovat, ve většině systémů je nutné jej otevřít – v systémech POSIX</br>k tomu slouží volání open, kterého výsledkem je popisovač otevřeného souboru (angl. file descriptor)",
                "Obyčejný soubor</br>je právě oním „motivačním případem“ – obyčejný soubor reprezentuje paměť, tzn.</br>jeho smyslem je uchovávat data (obyčejný soubor si tedy pamatuje posloupnost bajtů). Jaké konkrétní</br>bajty to jsou je irelevantní – souborový systém obsah obyčejných souborů nijak neinterpretuje.</br>Krom abstrakce (perzistentní – trvalé) paměti je obyčejný soubor také abstrakcí nad pevným úložištěm</br>v tom smyslu, že skrývá detaily přístupu k tomuto zařízení. Operace nad pevným úložištěm pracují po</br>jednotlivých blocích, přičemž bloky mají pevnou velikost a jejich počáteční adresa musí být dělitelná</br>touto velikostí – pro soubory žádné takové omezení neplatí. Zároveň je aplikace odstíněna od fyzického</br>umístění dat na pevném úložišti (funguje zde opět analogie s virtuálním adresním prostorem a překladem</br>virtuálních adres na fyzické). Analogie překladu adres je v tomto případě ale zcela v režii operačního</br>systému",
                "Mapováni do paměti</br>Operace read a write nejsou vždy efektivní, protože musí mimo jiné kopírovat</br>data mezi mezipamětí a pamětí, která náleží žádajícímu procesu.</br>Efektivita aplikací, které data</br>především čtou, může být výrazně zlepšena mapováním souborů do paměti za pomoci líného načítání.</br>V tomto režimu jsou externí stránky uloženy v jinak běžném souboru, ale místo komplikovaných vstupněvýstupních</br>operací může program s obsahem souboru pracovat stejně, jako by byl uložen v operační paměti.</br>Využijeme-li tohoto mechanismu také k zápisu změněných stránek zpátky do souboru, může program soubor</br>i zcela transparentně upravovat.",
                "Souběžný přístup</br>Jmenný prostor souborového systému (blíže jej popíšeme v další sekci) je</br>sdílený mezi všemi procesy, může se tedy lehce stát, že více procesů bude pracovat s jedním souborem.</br>Tato situace je analogická tomu, že stejná oblast operační paměti může být namapovaná ve více virtuálních</br>adresních prostorech. Jde-li o souběžný přístup pouze pro čtení, nevznikají žádné významnější problémy.</br>Vstoupí-li ale do hry zápisy, jak čtení tak jiné zápisy mohou způsobovat problémy – zejména různé</br>instance hazardu souběhu.</br>Aby se těmto problémům předešlo, operační systémy umožňují soubory zamykat čím je umožněno programům</br>k souboru přistupovat bezpečně – tzn. bez rizika poškození dat",
                "Spustitelný soubor</br>Spustitelné soubory představují programy v klidu (tzn. ve stavu, kdy nejsou spuštěné) a obsahují veškeré</br>informace, které jsou potřeba k tomu, aby bylo možné v nich obsažený program spustit. Hlavní část</br>spustitelného souboru je tvořena počátečním obrazem paměti, podle kterého se při spuštění programu</br>(v POSIX-u voláním exec v již existujícím procesu) inicializuje virtuální adresní prostor",
                "Roura</br>Roury se podobají na obyčejné soubory v tom, že je možné do nich zapisovat a číst z nich</br>data (bajty). Ve většině případů data jeden program (proces) zapisuje a jiný je čte – na rozdíl od</br>obyčejného souboru nejsou tato data nikde trvale uložena – z roury zmizí jakmile jsou přečtena.</br>S rourou je samozřejmě svázán buffer, ale je uložen pouze v operační paměti. Díky tomu lze do roury data</br>zapisovat i ve chvíli, kdy je právě druhá strana nečte – operační systém zapsaná data dočasně uchová.</br>Za normálních okolností je roura anonymní a přístupná pouze skrze popisovače otevřených souborů.",
                "Tvrdé odkazy</br>Jasným důsledkem výše popsané organizace složek je existence tzv. tvrdých odkazů</br>– situace, kdy několik adresářových položek (v jedné nebo několika složkách) odkazuje tutéž entitu</br>(i-uzel). Všechny odkazy na tentýž soubor jsou zcela rovnocenné a z pohledu uživatele se pouze tentýž</br>soubor objevuje na různých místech adresářové struktury.</br>I-uzly si navíc udržují počítadlo odkazů – samotný soubor (i-uzel) je zničen pouze v případě, kdy toto</br>počítadlo dojde na nulu. To mimo jiné znamená, že odstraněním adresářové položky (angl. unlinking) může,</br>ale nemusí způsobit smazání souboru.",
                "Měkké odkazy</br>Občas je užitečné odkazovat soubor nikoliv přímo, ale skrze nějakou cestu která</br>k němu vede. Toho lze dosáhnout tzv. měkkým odkazem: tento je (na rozdíl od tvrdého odkazu) skutečným</br>objektem v souborovém systému, který je reprezentován samostatným i-uzlem. Narazí-li při procházení</br>adresářové struktury (zejména při hledání i-uzlů podle cesty) operační systém přečte cestu obsaženou</br>v tomto měkkém odkazu a ve vyhledávání pokračuje touto cestou.",
                "Bitmapa </br>V souborových systémech se využívá několik velmi jednoduchých datových struktur, které</br>jsou díky své jednoduchosti zároveň relativně robustní. Asi nejjednodušší strukturou tohoto typu je</br>bitmapa, která se používá k mapování využitých resp. volných bloků nebo řádků v tabulkách (přiblížíme</br>si za chvíli).</br>Bitmapa udržuje informaci o lineárním sledu bloků a informace o jednotlivém bloku se omezuje na jediný</br>bit (obvykle právě ona využitost).",
                "Tabulka</br>Bitmapa je sice jednoduchá a rychlá, neumí ale uchovat příliš mnoho zajímavých informací.</br>O něco málo složitější datovou strukturou je tabulka, která v podstatě odpovídá klasickému poli:</br>1. je to souvislá oblast fixně velkých struktur (řádků, položek), zvolených tak, aby se jich do jednoho</br>bloku vešel celočíselný počet (vyhovuje například velikost jednoho řádku 128 nebo 256 bajtů),</br>2. alokace položek se provede např. bitmapou (určuje které řádky jsou resp. nejsou použité, aby bylo</br>v případě potřeby možné rychle najít řádek, do kterého můžeme zapsat novou položku),</br>3. chceme-li se do takové tabulky odkázat (např. proto, že se jedná o tabulku záznamů o souborech),</br>stačí nám znát číslo řádku (index).",
                "Konzistence</br>Důležitým problémem souborového systému je udržení konzistence metadat (jak</br>různých typů nebo složek metadat mezi sebou, tak se samotnými daty). Porušení konzistence může být</br>trojího typu:</br>1. narušení jednotlivé datové struktury, např.</br>∘ B-strom obsahuje uzel, který ve skutečnosti není platným uzlem, např. proto, že nový odkaz byl</br>zapsán dříve, než odkazovaný uzel,</br>2. konfliktní informace v různých datových strukturách, např.:</br>∘ bitmapa označuje řádek tabulky za volný, ale tento je zároveň vyplněn smysluplnými metadaty, nebo</br>∘ datový blok je označený jako volný (v bitmapě nebo B-stromě), ale zároveň je odkazován jako</br>součást nějakého souboru,</br>3. nesoulad mezi metadaty a datovými bloky – např.</br>∘ podle metadat je vlastníkem souboru uživatel B, ale odkazované datové bloky obsahují data uživatele</br>A",
                "Existují dva hlavní důvody, proč by mohlo dojít  k porušení konzistence u datových struktur:</br>1. přerušením kritické operace, která provádí více souvisejících změn, např. výpadkem napájení, nebo</br>kritickou chybou („pádem“) celého systému,</br>2. i v případě, kdy je souborový systém vůči takovému přerušení robustní, tato jeho vlastnost může být</br>narušena přeuspořádáním zápisů (plánovačem nebo samotným zařízením).</br>Existuje několik metod, jak se s problémem vypořádat. Jednou je detekce problému (např. příznakem,</br>který se zapíše při korektním ukončení operačního systému) a následná křížová kontrola všech metadat</br>v situaci, kdy mohlo k poškození teoreticky dojít. Tato kontrola může a nemusí být schopna souborový</br>systém vrátit do konzistentního stavu (v závislosti na rozsahu resp. povaze poškození).",
                "Žurnál</br>Oproti klasickým metadatům souborového systému má žurnál jednoduchou strukturu – záznamy jsou na</br>disku uloženy sekvenčně (obvykle „do kruhu“ – nový záznam přepíše nejstarší, už neplatný, záznam). Tato</br>struktura je velmi robustní, jak vůči nahodilému přerušení, tak proti typickým vzorům přeuspořádání.</br>Záznamy v žurnálu jsou obvykle seskupeny do transakcí (podobných těm, které znáte z relačních databázových systémů),</br>které mohou sestávat z několika provázaných operací. Změny v metadatech se začnou na</br>pevné úložiště posílat až ve chvíli, kdy je transakce ukončena a je potvrzen zápis příslušných položek</br>v žurnálu. Transakce, která není ukončená, se při obnově přeskočí, čím je zabezpečeno, že se ve výsledku</br>provede buď celá, nebo vůbec.",
                "Žurnál</br>Přerušená operace na datové struktuře může vést k nejednoznačnému stavu, kdy lze datovou strukturu</br>opravit více než jedním způsobem. Žurnál tento problém řeší tím, že existuje záznam o tom, jaká operace</br>probíhala a tedy je možné ji na základě této informace dokončit. Zároveň není potřeba kontrolovat resp.</br>opravovat konzistenci všech datových struktur (to může ve velkém souborovém systému trvat dlouhou</br>dobu), ale pouze těch (resp. těch jejich částí), kterých se dotýkají operace zanesené v žurnálu.",
                "Funkcionální metadata</br>inou možností jak předejít nekonzistenci je uspořádat metadata tak, že</br>použité datové struktury nebudeme na místě upravovat vůbec. Podobně jako ve funkcionálním programování</br>můžeme místo úpravy existující struktury vytvořit její novou verzi. Přitom využijeme toho, že nezměněné</br>části můžeme z nové verze odkázat – nemusíme tedy kopírovat celou datovou strukturu.</br>Takovému přístupu musí být ale příslušná datová struktura uzpůsobena – vhodné jsou zejména stromové</br>struktury (v souborových systémech tedy především B-stromy), kde změna v libovolném uzlu znamená</br>vytvoření nové verze tohoto uzlu a jeho předků (v předcích totiž nemůžeme upravit ukazatel na potomka</br>– to by narušilo princip neměnnosti staré verze), přitom ve vyváženém stromě je takových nejvýše</br>logaritmický počet. Všechny ostatní uzly ale zůstávají nezměněné.</br>",
                "Prázdné místo</br>Jsme tedy konečně vyzbrojeni datovými strukturami vhodnými pro použití v souborovém systému a můžeme se blíže podívat na jejich konkrétní využití.</br>Prvním úkolem bude organizace volných bloků, do kterých lze uložit nově příchozí data (např. proto, že</br>uživatel vytvořil nový soubor, přidal data do existujícího, ale třeba i proto, že vytvořil novou složku).</br>Vyhledání vhodného datového bloku je častá operace, musí být proto efektivní – jak samotné nalezení,</br>tak poznačení informace o tom, že vybraný blok (resp. bloky) již nejsou volné.</br>",
                "Externí a datová fragmentace</br>Ukládání strukturovaných dat do nestrukturovaného pole bajtů</br>vyžaduje vždy určité kompromisy. Jedním z nich je efektivita využití kapacity – ukládání dat více natěsno</br>většinou vede k pomalejším operacím a složitějším metadatům.</br>V případě souborů se musíme vypořádat jednak se situací, kdy se postupným vytvářením a mazáním souborů</br>prázdné místo rozptýlí mezi alokované bloky. Při vytváření nových souborů to znamená pracnější hledání</br>volných bloků, protože je nutné potřebné místo „slepit“ z několika nesouvislých oblastí (fragmentů).</br>Tím se jednak zvětšují potřebná metadata (průměrná délka spojitého rozsahu klesá) a zároveň dochází</br>k roztroušení – fragmentaci – samotných dat, která jsou do takto alokovaného souboru uložena. Přístup</br>k takovým souborům je pak méně efektivní, protože s každým skokem z jedné spojité oblasti do jiné je</br>spojena prodleva (daná povahou blokových zařízení).</br>",
                "Obyčejné soubory </br>Tradiční reprezentace obyčejného souboru na disku odkazuje každý datový</br>blok samostatně, pomocí krátké tabulky uvnitř i-uzlu (u větších souborů rozšířené pomocnými tabulkami</br>v tzv. nepřímých blocích). Běžným zlepšením je místo odkazu na jeden blok odkazovat celý spojitý rozsah</br>datových bloků (angl. extent). Hlavní nevýhodou tohoto přístupu je, že vyhledání bloku podle adresy</br>bajtu (offsetu) je v takto organizovaných metadatech lineární vzhledem k délce takové tabulky.",
                "Vnitřní fragmentace</br>Vnitřní fragmentace je způsobena zarovnáním – některé operace jsou</br>mnohem efektivnější, když každý soubor začíná na hranici bloku, a tedy je pro něj alokován bloků</br>celočíselný počet. Protože mají ale soubory libovolnou velikost, často je na konci souboru nějaké</br>nevyužité místo. Toto nevyužité místo představuje režii – neobsahuje žádná užitečná data. Jinými slovy</br>je na většiny souborů malý fragment paměti který nelze využít (protože je menší než nejmenší možná</br>velikost souboru – jeden blok).",
                "Adresáře</br>Existují tři základní možnosti, jak v souborovém systému reprezentovat složky:</br>1. Klasické → hledání podle jména a odstranění položky jsou lineární operace, vkládání je naopak</br>konstantní – takový přístup funguje dobře pro malé složky, ale protože souborový systém nemůže</br>obecně předvídat, kolik položek bude mít daný adresář, tato organizace se spíše nepoužívá.</br>2. Hašované → položky jsou uloženy v hašovací tabulce a jsou tedy „pravděpodobně“ konstantní – přesné</br>chování záleží na hašovací funkci a výběru jmen. Iterace vrací položky ve zdánlivě náhodném pořadí.</br>3. Stromové → položky jsou uloženy jako B-strom, jména položek jsou klíče – všechny operace jsou</br>zaručeně logaritmické a iterace vrací položky seřazené podle jména.</br>"
            ]
            ,
            "incorrect": [
                " Bloková zařízení</br>Tento typ zařízení představuje abstrakci perzistentních úložišť. Operace (abstraktního) blokového</br>zařízení jsou přizpůsobené běžným schopnostem odpovídajících reálných zařízení:</br>• zápis a čtení je prováděno po bajtech,</br>• v libovolném pořadí, ale</br>• s velkou latencí a malou propustností (relativně k operační paměti).",
                "Trvalé úložiště</br>je fyzické zařízení, které se podobá na operační paměť (pamatuje si data),</br>s několika klíčovými rozdíly:</br>1. data zde uložená přetrvávají „krátkodobě“, tedy zejména po vypnutí počítače jsou odstraněna,</br>2. přístup k datům je pomalejší – zejména má mnohem vyšší latenci (prodlevu) mezi vystavením požadavku</br>a odpovědí zařízení; je proto nepraktické adresovat takové zařízení po jednotlivých bajtech (jako</br>tomu je u operační paměti),</br>3. proto je obvyklé, že poskytují operace, které pracují s celými bloky dat najednou (velikost 512 bajtů</br>a víc, často 4 KiB) – základní operací je pak přesun takového bloku mezi zařízením a operační pamětí.",
                "Latence</br>doba mezi požadavkem a odpovědí; příliš velká, než aby bylo lze ignorovat; rozdíl proti</br>operační paměti: nelze skrýt softwarově, musí řešit HW",
                " Mezipaměť</br>Hlavní problém, který mezipaměť řeší, je opakovaný přístup ke stejným adresám daného</br>datového úložiště. Přístup k datům obvykle není rovnoměrný – některá data jsou potřebná často (např.</br>aktivně využívaná databáze), zatímco jiná (archiv dat z minulého roku) jen velmi zřídka. Proto je výhodné</br>si nedávno čtená data úkládat v procesoru: může se totiž lehce stát, že je bude potřeba přečíst</br>v blízké budoucnosti znovu.</br>Podobně má smysl některá data načíst do mezipaměti s předstihem (existuje-li volná přenosová kapacita;</br>této technice se angl. říká prefetch)",
                "Vyrovnávací paměť</br>Existují dvě základní možnosti, jak vyrovnávací paměti realizovat:</br>1. oddělené od mezipaměti: vyrovnávací paměť obsahuje jak samotné požadavky, tak veškerá data s nimi</br>spojená; jsou-li některé dotčené bloky uložené v mezipaměti, tyto jsou buď zneplatněny, nebo (častěji)</br>upraveny na místě,</br>2. propojená s mezipamětí: vyrovnávací paměť obsahuje pouze počítadlo požadavků na zápis – samotné</br>datové bloky se ukládají vždy do operační paměti.",
                " Plánování operací</br>U většiny úložišť platí, že sekvenční přístup (čtení po sobě následujících</br>adres) je mnohem rychlejší, než nahodilý přístup (postupné čtení adres, které spolu nijak nesouvisí).</br>Různé technologie navíc kladou další omezení na rychlost reakce – klasickým příkladem jsoupolovodičové paměti,</br>kde prodleva další operace závisí na vzdálenosti hlavy od místa, kde se potřebná data fyzicky nachází.</br>Naopak rotační disky jsou často složené z nezávislých celků, které mohou pracovat souběžně, ale</br>požadavky do stejné části paměti musí vyčkat na dokončení těch předchozích.</br>Bez ohledu na technologii ukládání dat ale platí, že operace s trvalým úložištěm vykazují vysokou míru</br>souběžnosti: do systému přichází mnoho nezávislých požadavků na diskové operace a existuje tedy jistá</br>volnost odpovídat na tyto požadavky v různém pořadí. Je to způsobeno zejména tím, že je často spuštěno</br>několik (souběžných) vláken a každé z nich provádí vstupně-výstupní operace nezávisle na ostatních.",
                "Přeuspořádání operací má určitá úskalí, zejména v případech, kdy jsou prohozeny zápisy, které náleží</br>stejné aplikaci, nebo se jedná o operace související s údržbou metadat souborového systému. Vzniká tak</br>napětí mezi výkonem (více přeuspořádání → vyšší propustnost) a spolehlivostí (více přeuspořádání →</br>větší šance nekonzistence v případě výpadku).</br>Pokud jde o operace čtení, zde je prostor pro přeuspořádání obvykle větší, protože aplikace, která čtení</br>vyžádala, obvykle může pokračovat ve své činnosti i když nejsou data k dispozici.",
                "Problémy virtualizace</br>Náš dosavadní přístup k virtualizaci bude v případě trvalých úložišť fungovat.</br>Vzpomeňte si, že v případě paměti a procesoru řešení spočívalo ve vytvoření</br>soukromých (virtuálních) instancí příslušného zařízení. Taková instance je pak vždy ve výlučném užívání</br>jednoho programu.</br>Trvalé úložiště slouží především k ukládání uživatelsky zajímavých dat. Je</br>tedy nežádoučí, aby mohl uživatel s těmito daty nějak interagovat, a zejména tedy musí být skryta</br>v soukromém prostoru jednoho programu.",
                "Problémy virtualizace</br>dvě možnosti řešení:</br>1. můžeme zcela změnit přístup k virtualizaci: místo toho, abychom virtualizací vytvořili věrný obraz</br>skutečného zařízení, může operační systém poskytovat nějaký jiný druh abstrakce, a trvalé úložiště</br>nebude aplikacím vůbec přístupné,</br>2. vyčleníme nějakou aplikaci, která bude odpovědná za správu uživatelských dat v trvalém úložišti, a</br>ostatní aplikace budou své požadavky na interakci s těmito daty řešit skrze tuto speciální aplikaci.</br></br>Obě řešení jsou ve skutečnosti (s trochou nadsázky) vlastně totéž řešení. V obou případech je přímý</br>přístup k úložišti omezen na procesorové jádro, to rozhoduje o tom, jak budou data „fyzicky“ organizovaná a</br>jaké další operace lze nad daty provádět.",
                "Metody virtualizace</br>1. souborový systém, nebo obecněji abstrakce na vyšší úrovni poskytovaná jako služba operačního systému,</br>která umožňuje řízený přístup k datům mnoha aplikacím současně, a zároveň umožňuje uživateli data</br>organizovat a spravovat,</br>2. virtualizace na aplikační úrovni, kdy je přímý přístup k úložišti řízen procesorem, který</br>spravuje data a ostatním částem OS poskytuje přístup pomocí vhodného mapování adres.",
                "RAID</br>Zatímco standardním řešením problému s nízkou propustností a/nebo velkou prodlevou paměťových operací jsou vyrovnávací paměti,</br>standardním řešením problémů se spolehlivostí paměti je redundance.</br>Nejjednodušší formou redundance je pořízení kopie (zálohy) – v případě ztráty primárních dat obnovíme</br>data ze záložní kopie. S tím jsou spojeny dva problémy:</br>1. aby byla užitečná, musíme takovou kopii udržovat aktuální ale nemusí být konzistentní,</br>2. při poruše musíme vyměnit dotčené zařízení a data překopírovat ze zálohy, přitom obě operace mohou</br>být poměrně zdlouhavé.",
                "Operace nad soubory</br>Základními operacemi pro práci se souborem je čtení (v POSIX-u voláním read) a zápis</br>(v POSIX-u write) souvislé posloupnosti bajtů (libovolné velikosti – abstrakce souboru skrývá blokový</br>charakter zařízení, na kterém je soubor uložen). Velikost souboru je ale pevně daná a to velikostí bitmapy.",
                "soubory jsou obvykle perzistentní</br>– existují dlouhodobě, jsou závislé na běžících procesech, ale nezávisí na tom, je-li vůbec aktivní operační</br>systém (nebo samotný hardware). Abychom mohli s perzistentními soubory rozumně pracovat, musí být</br>navíc tyto opatřeny identitou.</br>Abychom mohli se souborem pracovat, ve většině systémů je nutné jej otevřít – v systémech POSIX</br>k tomu slouží volání open, kterého výsledkem je popisovač otevřeného souboru (angl. file descriptor)",
                "Obyčejný soubor</br>je právě oním „motivačním případem“ – obyčejný soubor reprezentuje paměť, tzn.</br>jeho smyslem je uchovávat data (obyčejný soubor si tedy pamatuje posloupnost bajtů). Jaké konkrétní</br>bajty to jsou je irelevantní – souborový systém obsah obyčejných souborů nijak neinterpretuje.</br>Krom abstrakce (perzistentní – trvalé) paměti je obyčejný soubor také abstrakcí nad pevným úložištěm</br>v tom smyslu, že skrývá detaily přístupu k tomuto zařízení. Operace nad pevným úložištěm pracují po</br>jednotlivých blocích, přičemž bloky mají pevnou velikost a jejich počáteční adresa musí být dělitelná</br>touto velikostí – pro soubory platí stejná omezení. Zároveň je aplikace odstíněna od fyzického</br>umístění dat na pevném úložišti (funguje zde opět analogie s virtuálním adresním prostorem a překladem</br>virtuálních adres na fyzické). Analogie překladu adres je v tomto případě ale zcela v režii operačního</br>systému",
                "Mapováni do paměti</br>Operace read a write jsou vždy efektivní, protože nemusí kopírovat</br>data mezi mezipamětí a pamětí, která náleží žádajícímu procesu.</br>Efektivita aplikací, které data</br>především čtou, může být výrazně zlepšena mapováním souborů do paměti za pomoci líného načítání.</br>V tomto režimu jsou externí stránky uloženy v jinak běžném souboru, ale místo komplikovaných vstupněvýstupních</br>operací může program s obsahem souboru pracovat stejně, jako by byl uložen v operační paměti.</br>Využijeme-li tohoto mechanismu také k zápisu změněných stránek zpátky do souboru, může program soubor</br>i zcela transparentně upravovat.",
                "Souběžný přístup</br>Jmenný prostor souborového systému (blíže jej popíšeme v další sekci) je</br>sdílený mezi všemi procesy, může se tedy lehce stát, že více procesů bude pracovat s jedním souborem.</br>Tato situace je analogická tomu, že stejná oblast operační paměti může být namapovaná ve více virtuálních</br>adresních prostorech. Jde-li o souběžný přístup pouze pro čtení, nevznikají žádné významnější problémy.</br>Vstoupí-li ale do hry zápisy, jak čtení tak jiné zápisy mohou způsobovat problémy – zejména různé</br>instance hazardu souběhu.</br>Operační systémy neumožňují soubory zamykat proto musí být tento problém řešen jinak",
                "Spustitelný soubor</br>Spustitelné soubory představují jak programy v klidu tak i ty spuštěné a obsahují veškeré</br>informace, které jsou potřeba k tomu, aby bylo možné v nich obsažený program probíhat. Hlavní část</br>spustitelného souboru je tvořena počátečním obrazem paměti, podle kterého se při spuštění programu</br>(v POSIX-u voláním exec v již existujícím procesu) inicializuje virtuální adresní prostor",
                "Roura</br>Roury se podobají na obyčejné soubory v tom, že je možné do nich zapisovat a číst z nich</br>data (bajty). Ve většině případů data jeden program (proces) zapisuje a jiný je čte – na rozdíl od</br>obyčejného souboru nejsou tato data nikde trvale uložena – z roury zmizí po čase určeném speciálním registrem.</br>S rourou je samozřejmě svázán buffer, ale je uložen pouze v operační paměti. Díky tomu lze do roury data</br>zapisovat i ve chvíli, kdy je právě druhá strana nečte – operační systém zapsaná data dočasně uchová.</br>Za normálních okolností je roura anonymní a přístupná pouze skrze popisovače otevřených souborů.",
                "Tvrdé odkazy</br>Jasným důsledkem výše popsané organizace složek je existence tzv. tvrdých odkazů</br>– situace, kdy několik adresářových položek (v jedné nebo několika složkách) odkazuje tutéž entitu</br>(i-uzel). Existuje jeden hlavní a poté libovolný počet jiných odkazu, ale z pohledu uživatele se pouze tentýž</br>soubor objevuje na různých místech adresářové struktury.</br>I-uzly si navíc udržují počítadlo odkazů – samotný soubor (i-uzel) je zničen pouze v případě, kdy toto</br>počítadlo dojde na nulu. To mimo jiné znamená, že odstraněním adresářové položky (angl. unlinking) může,</br>ale nemusí způsobit smazání souboru.",
                "Měkké odkazy</br>Občas je užitečné odkazovat soubor nikoliv přímo, ale skrze nějakou cestu která</br>k němu vede. Toho lze dosáhnout tzv. měkkým odkazem: tento je (na rozdíl od tvrdého odkazu) skutečným</br>objektem v souborovém systému, který ale není reprezentován i-uzlem. Narazí-li při procházení</br>adresářové struktury (zejména při hledání souborů podle cesty) operační systém přečte cestu obsaženou</br>v tomto měkkém odkazu a ve vyhledávání pokračuje touto cestou.",
                "Bitmapa </br>V souborových systémech se využívá několik velmi jednoduchých datových struktur, které</br>jsou díky své jednoduchosti zároveň relativně robustní. Asi nejjednodušší strukturou tohoto typu je</br>bitmapa, která se používá k mapování využitých resp. volných bloků nebo řádků v tabulkách (přiblížíme</br>si za chvíli).</br>Bitmapa udržuje informaci o lineárním sledu bloků a informace o jednotlivém bloku se omezuje na jediný</br>bajt.",
                "Tabulka</br>Bitmapa je sice jednoduchá a rychlá, neumí ale uchovat příliš mnoho zajímavých informací.</br>O něco málo složitější datovou strukturou je tabulka, která v podstatě odpovídá klasickému poli:</br>1. je to souvislá oblast fixně velkých struktur (řádků, položek), libovolné velikosti.</br>2. alokace položek se provede např. bitmapou (určuje které řádky jsou resp. nejsou použité, aby bylo</br>v případě potřeby možné rychle najít řádek, do kterého můžeme zapsat novou položku),</br>3. chceme-li se do takové tabulky odkázat (např. proto, že se jedná o tabulku záznamů o souborech),</br>stačí nám znát číslo řádku (index).",
                "Konzistence</br>Důležitým problémem souborového systému je udržení konzistence metadat (jak</br>různých typů nebo složek metadat mezi sebou, tak se samotnými daty). K porušení konzistence nemůže dojít.",
                "Existují dva hlavní důvody, proč by mohlo dojít  k porušení konzistence u datových struktur:</br>1. přerušením kritické operace, která provádí více souvisejících změn, např. výpadkem napájení, nebo</br>kritickou chybou („pádem“) celého systému,</br>2. i v případě, kdy je souborový systém vůči takovému přerušení robustní, tato jeho vlastnost může být</br>narušena přeuspořádáním zápisů (plánovačem nebo samotným zařízením).</br>Existuje několik metod, jak se s problémem vypořádat. Jednou je detekce problému (např. příznakem,</br>který se zapíše při korektním ukončení operačního systému) a následná křížová kontrola všech metadat</br>v situaci, kdy mohlo k poškození teoreticky dojít. Tato kontrola je vždy schopna souborový</br>systém vrátit do konzistentního stavu.",
                "Žurnál</br>Oproti klasickým metadatům souborového systému má žurnál jednoduchou strukturu – záznamy jsou na</br>disku uloženy sekvenčně (obvykle „do kruhu“ – nový záznam přepíše nejstarší, už neplatný, záznam). Tato</br>struktura je velmi robustní, jak vůči nahodilému přerušení, tak proti typickým vzorům přeuspořádání.</br>Záznamy v žurnálu jsou obvykle seskupeny do transakcí (podobných těm, které znáte z relačních databázových systémů),</br>které mohou sestávat z několika provázaných operací. Změny v metadatech se začnou na</br>pevné úložiště posílat hned jak je transakce zahájena. Transakce, která není ukončená,</br>se při obnově přeskočí, čím je zabezpečeno, že se ve výsledku provede buď celá, nebo vůbec.",
                "Žurnál</br>Přerušená operace na datové struktuře může vést k nejednoznačnému stavu, kdy lze datovou strukturu</br>opravit více než jedním způsobem. Žurnál tento problém řeší tím, že existuje záznam o tom, jaká operace</br>probíhala a tedy je možné ji na základě této informace dokončit. Je ale nutné kontrolovat resp.</br>opravovat konzistenci všech datových struktur (to může ve velkém souborovém systému trvat dlouhou</br>dobu), toto není nutné pouze u těch (resp. těch jejich částí), kterých se dotýkají operace zanesené v žurnálu.",
                "Funkcionální metadata</br>inou možností jak předejít nekonzistenci je uspořádat metadata tak, že</br>použité datové struktury nebudeme na místě upravovat vůbec. Podobně jako ve funkcionálním programování</br>můžeme místo úpravy existující struktury vytvořit její novou verzi. Přitom využijeme toho, že nezměněné</br>části můžeme z nové verze odkázat – nemusíme tedy kopírovat celou datovou strukturu.</br>Takovému přístupu musí být ale příslušná datová struktura uzpůsobena – vhodné jsou zejména tabulky nikoliv stromové struktury, kde změna v libovolném uzlu znamená</br>vytvoření nové verze tohoto uzlu a jeho předků.</br>",
                "Prázdné místo</br>Jsme tedy konečně vyzbrojeni datovými strukturami vhodnými pro použití v souborovém systému a můžeme se blíže podívat na jejich konkrétní využití.</br>Prvním úkolem bude organizace volných bloků, do kterých lze uložit nově příchozí data (např. proto, že</br>uživatel vytvořil nový soubor, přidal data do existujícího, ale třeba i proto, že vytvořil novou složku).</br>Vyhledání vhodného datového bloku je častá operace, musí být proto efektivní platí hlavně pro nalezení takového bloku.</br>Poznačení informace o tom, že vybraný blok (resp. bloky) již nejsou volné nejsou prováděny často, tedy efektivní být nemusí.</br>",
                "Externí a datová fragmentace</br>Ukládání strukturovaných dat do nestrukturovaného pole bajtů</br>vyžaduje vždy určité kompromisy. Jedním z nich je efektivita využití kapacity – ukládání dat více natěsno</br>většinou vede k pomalejším operacím a složitějším metadatům.</br>V případě souborů se musíme vypořádat jednak se situací, kdy se postupným vytvářením a mazáním souborů</br>prázdné místo rozptýlí mezi alokované bloky. Při vytváření nových souborů to znamená pracnější hledání</br>volných bloků, protože je nutné potřebné místo „slepit“ z několika nesouvislých oblastí (fragmentů).</br>Tím se jednak zvětšují potřebná metadata (průměrná délka spojitého rozsahu klesá) a zároveň dochází</br>k roztroušení – fragmentaci – samotných dat, která jsou do takto alokovaného souboru uložena. Přístup</br>k takovým souborům je asymptoticky stejně efektivní, protože takovýto přístup je realizovaný přes tvrdé odkazy.</br>",
                "Obyčejné soubory </br>Tradiční reprezentace obyčejného souboru na disku odkazuje každý datový</br>blok samostatně, pomocí krátké tabulky uvnitř i-uzlu (u větších souborů rozšířené pomocnými tabulkami</br>v tzv. nepřímých blocích). Běžným zlepšením je místo odkazu na jeden blok odkazovat celý spojitý rozsah</br>datových bloků (angl. extent). Tímto zajistíme že vyhledání bloku podle adresy</br>bajtu (offsetu) je v takto organizovaných metadatech konstantí.",
                "Vnitřní fragmentace</br>Vnitřní fragmentace je způsobena zarovnáním – některé operace jsou</br>mnohem efektivnější, když každý soubor začíná na hranici bloku, a tedy je pro něj alokován bloků</br>celočíselný počet. Protože mají ale soubory libovolnou velikost, často je na konci souboru nějaké</br>nevyužité místo. Toto nevyužité místo lze spojit pomocí vnější fragmentace v blok, který již využitelný bude.",
                "Adresáře</br>Existují tři základní možnosti, jak v souborovém systému reprezentovat složky:</br>1. Klasické → hledání podle jména a odstranění položky jsou lineární operace, vkládání je naopak</br>konstantní – takový přístup funguje dobře pro malé složky, a proto je i nejčastěji používaný.</br>2. Hašované → položky jsou uloženy v hašovací tabulce a jsou tedy „pravděpodobně“ konstantní – přesné</br>chování záleží na hašovací funkci a výběru jmen. Iterace vrací položky ve zdánlivě náhodném pořadí.</br>3. Stromové → položky jsou uloženy jako B-strom, jména položek jsou klíče – všechny operace jsou</br>zaručeně logaritmické, ale nelze je vracet jako seřazené.</br>"
            ]
        },
        {
            "section": 4,
            "correct": [
                "Periferie</br>Zařízení, které produkuje a konzumuje data, případně události. Komunikace</br>v malém objemu se obvykle realizuje mapováním registrů zařízení na fyzické adresy. Pozor, je zde</br>důležitý rozdíl proti operační paměti: hodnoty se „samovolně“ (bez účasti hlavního procesoru, a tedy i</br>operačního systému) mění v čase – takovou změnu lze považovat za událost.",
                "Programovaný vstup/výstup (PIO)</br>Nejjednodušší metodou komunikace se zařízením je přenos dat</br>postupným čtením z paměti (registrů) zařízení (již zmiňovaným mapováním paměti zařízení na fyzické</br>adresy procesoru). Je-li tato činnost prováděna hlavním procesorem, mluvíme o tzv. „programovaném“</br>vstupu resp. výstupu (angl. programmed IO, PIO).</br>Tento způsob komunikace tedy vyžaduje aktivní účast procesoru v stanovených časových intervalech</br>(podle přenosové rychlosti, velikosti vyrovnávací paměti, atp.). Tato metoda je použitelná pro občasné</br>přenosy a/nebo přenosy s velmi malou šířkou pásma (počtem bajtů přenesených za sekundu). Při větších</br>objemech dat vede tento způsob komunikace k příliš vysoké režii.",
                " Přímý přístup do paměti (DMA)</br>Zdaleka nejčastějším cílem přenosu dat z periferie je jejich uložení do operační paměti – další</br>zpracování zpravidla musí vyčkat do doby, než je v operační paměti nějaký kompletní celek (blok, rámec,</br>atp.).</br>Asynchronní přenos dat (bez účasti procesoru, resp. bez účasti softwaru) může být realizován dvěma</br>základními metodami:</br>1. dedikovaným pomocným procesorem, který od hlavního procesoru přijímá pokyny na provedení přenosu</br>(z jaké periferie, na jakou adresu v operační paměti, kolik bajtů, případně opačně, z jaké adresy</br>v operační paměti a jaké periferii), a který je de-facto součástí sběrnice,</br>2. přenos je řízen přímo periferií (na základě podobného pokynu od hlavního procesoru).</br>Výhodou první metody je, že periferie nemusí nijak rozlišovat DMA a PIO režimy přenosu dat a může být</br>tedy jednodušší. Druhá metoda je obvykle efektivnější a v moderních systémech mnohem běžnější.</br>",
                " Je důležité rozlišovat přímý přístup do paměti (komunikuje periferie a operační paměť, bez účasti</br>procesoru) a mapování paměti zařízení do fyzického adresního prostoru (komunikuje procesor s periferií,</br>bez účasti operační paměti).",
                "IO-MMU</br>Přestože pro zařízení, které přenáší velké objemy dat (pevná úložiště, síťová rozhraní,</br>atp.), je DMA nepostradatelné, jsou s ním spojeny určitá bezpečnostní rizika. V klasické implementaci</br>DMA má totiž každá periferie neomezený přístup do fyzické paměti – operační systém sice dává periferii</br>pokyn, které fyzické adresy má použít, ale nemá jak vynutit, aby periferie takový pokyn dodržela.</br>V takovém systému tedy periferiím tedy nic tedy nebrání v tom libovolně upravovat obsah paměti –</br>například i přepsat kód jádra a získat tak plnou kontrolu nad systémem. Toto se týká nejen případných</br>podvratných periferií, ale i ovladačů, které mohou jinak nevinnou periferii naprogramovat tak, aby</br>narušila bezpečnost systému.</br>Toto je jistě nežádoucí, zejména chceme-li izolovat ovladače od zbytku jádra, nebo v případech, kdy</br>samotná periferie není nutně důvěryhodná. IO-MMU je zařízení, které tento problém řeší, a to tím, že</br>realizuje překlad adres pro periferie (podobně jako MMU realizuje překlad adres pro software). IO-MMU</br>je programovatelná operačním systémem (a pouze operačním systémem) a umožňuje tedy izolovat periferie</br>jak vzájemně, tak od operačního systému a softwaru obecně. Je-li IO-MMU správně naprogramovaná, je</br>DMA bezpečné.",
                "Sběrnice </br>Má dvě základní vrstvy:</br>1. fyzickou, která odpovídá za signalizaci a časování a</br>2. logickou (protokolovou), která popisuje chování zařízení na sběrnici na vyšší úrovni – adresaci,</br>konfiguraci zařízení, přenosy dat atp.</br>Sběrnic existuje v počítači celá řada a jsou vzájemně propojené. Ta strana sběrnice, která je blíže</br>hlavnímu procesoru, se obvykle nazývá hostitelská.",
                "Sběrnice</br>Hlavním úkolem sběrnice je přenos dat (a s tím související adresace) a signalizace událostí, vedlejším</br>pak konfigurace a enumerace připojených periferií. Má-li řadič sběrnice přidělen rozsah fyzických adres,</br>je také jeho úkolem tento dále rozdělit mezi připojené periferie (včetně podružných řadičů dalších</br>sběrnic).",
                "Ovladač</br>Jakmile je známý konkrétní typ zařízení, komunikaci s ním převezme ovladač – program,</br>který poskytuje softwarovou abstrakci dané třídy zařízení zbytku operačního systému (a nepřímo i</br>aplikacím).</br>Na jedné straně komunikuje ovladač se zbytkem operačního systému (pomocí vhodného rozhraní, které je</br>ale obvykle specifické pro daný operační systém), na straně druhé komunikuje s konkrétním fyzickým</br>zařízením (které je zase často specifické pro daný model, nebo alespoň modelovou řadu).</br>Připomínáme zde, že komunikace probíhá čtením a zápisem dat, a zpracování takových dat není nic jiného</br>než výpočet",
                "Ovladač</br>Hlavním úkolem ovladače je:</br>1. zpracování příchozích dat do formy, která je přijatelná pro zbytek systému (tzn. do formy nezávislé</br>na konkrétním modelu zařízení),</br>2. převod dat příchozích ze systému (které jsou ve formě nezávislé na konkrétním zařízení) do formy,</br>kterou umí daná periferie zpracovat,</br>3. to vše v reakci na události – buď požadavky ze systému na periferii, nebo naopak.</br>Data v tomto případě nemusí být pouze užitná data (bloky uložené na disku, rámce přijímané nebo odesílané</br>síťovým rozhraním, atp.), ale také řídící data, která ovlivňují jak se bude zařízení chovat, nebo přímo</br>aktivují další funkce zařízení (jiné, než je samotný přenos užitných dat).",
                "Tiskárny</br>1. virtualizace – jak tiskárnu sdílet mezi programy – tento problém je analogický k problému plánováni</br>úloh v dávkových systémech, a má i analogické řešení: frontu úloh ke zpracování,</br>2. abstrakce – jak zahladit rozdíly mezi jednotlivými tiskárnami tak, aby byly z pohledu programu podle</br>možnosti záměnné.</br>Řešení druhého bodu je trochu složitější, a některé aspekty tiskáren nelze úplně v aplikacích ignorovat</br>(černobílý vs barevný tisk, jednostranný vs oboustranný, atp.). Částečným řešením je použití společného</br>formátu pro popis dokumentů k tisku, přičemž operační systém již zařídí konverzi do formátu, který</br>tiskárna akceptuje. Starším standardem tohoto typu je PostScript, novějším PDF. Některé tiskárny</br>podporují tisk dokumentů v těchto formátech přímo, bez potřeby dalšího zpracování v operačním systému.</br>Z pohledu aplikace může mít tedy virtuální tiskárna jako svou hlavní operaci vložení dokumentu ve formátu</br>PDF do tiskové fronty",
                "Síťové vrstvy</br>1. fyzická – záležitost hardwaru, má ale dopad na vyšší vrstvy,</br>2. linková – tvoří faktické rozhraní mezi hardwarem a softwarem (operačním systémem),</br>3. síťová – na koncových stanicích řeší převážně software (operační systém), jejím úkolem je zabezpečit</br>komunikaci mezi koncovými uzly (resp. mezi operačními systémy na nich provozovanými),</br>4. transportní doručuje data mezi aplikacemi: tvoří rozhraní mezi operačním systémem a aplikací, a je</br>tak přirozeným místem pro virtualizaci,</br>5. a vyšší: záležitost aplikací, staví na virtualizaci poskytované 4. vrstvou.",
                "Odchozí fronta</br>Potřebuje-li operační systém odeslat paket (rámec) do sítě, přidá je na konec</br>tzv. odchozí fronty (angl. transmit queue, Tx queue). Z této fronty je vyzvedne hardware a jakmile je</br>to možné, provede fyzický přenos. Odchozí fronta funguje přibližně takto:</br>1. každá odchozí fronta (může jich existovat několik) má přiřazenu dvojici registrů mapovaných do</br>fyzického adresního prostoru: jeden reprezentuje hlavový ukazatel a ten druhý koncový (angl. head a</br>tail),</br>2. tyto ukazatele popisují kruhovou frontu pevné velikosti, uloženu v operační paměti, ke které síťové</br>rozhraní přistupuje za pomoci DMA; každá položka (buňka) této kruhové fronty reprezentuje jeden</br>rámec,</br>3. ukazatele dělí frontu na dvě části – jedna patří rozhraní a jedna operačnímu systému,</br>4. operační systém (resp. ovladač síťového rozhraní) upravuje koncový ukazatel:</br>a. pro odeslání rámce pro něj operační systém nejprve vyhradí paměť a uloží do ni obsah rámce (data),</br>b. zapíše příslušnou adresu a velikost do své části kruhové fronty,</br>c. posune koncový ukazatel, čím předá odpovědnost za nově vyplněné buňky síťovému rozhraní,</br>5. síťové rozhraní ovládá hlavový ukazatel: kdykoliv zpracuje odchozí rámec, posune hlavový ukazatel</br>tak, že paměť asociovaná s odeslaným rámcem se přesune do části fronty, která patří operačnímu</br>systému.</br>Události, které se zpracováním kruhové fronty souvisí, signalizuje síťové rozhraní pomocí přerušení",
                "Příjmová fronta</br>Síťové rozhraní popřidání prvků tuto změnu signalizuje přerušením. Alokace paměti pro rámce je v kompetenci operačního</br>systému – přesune-li operační systém nějakou položku (buňku) do části kruhové fronty, která náleží</br>síťovému rozhraní, dává tím najevo, že paměť touto položkou odkázaná může být přepsána novými daty.</br>Jakmile tak síťové rozhraní učiní, příslušnou buňku příjmové fronty přesune do části patřící operačnímu</br>systému.</br>Je obvyklé, že každý blok paměti, který operační systém rozhraní předá, má velikost největšího možného</br>rámce (MTU z angl. maximal transfer unit, obvykle 1500 bajtů), i když některá rozhraní umí příchozí</br>rámce rozdělit do více buněk, je-li to potřeba."
            ]
            ,
            "incorrect": [
                "Periferie</br>Zařízení, které produkuje a konzumuje data, případně události. Komunikace</br>v malém objemu se obvykle realizuje mapováním registrů zařízení na fyzické adresy. Pozor, je zde</br>důležitý rozdíl proti operační paměti: hodnoty se s vzájemnou účastí procesoru a</br>operačního systém mění v čase – takovou změnu lze považovat za událost.",
                "Programovaný vstup/výstup (PIO)</br>Nejjednodušší metodou komunikace se zařízením je přenos dat</br>postupným čtením z paměti (registrů) zařízení (již zmiňovaným mapováním paměti zařízení na fyzické</br>adresy procesoru). Je-li tato činnost prováděna hlavním procesorem, mluvíme o tzv. „programovaném“</br>vstupu resp. výstupu (angl. programmed IO, PIO).</br>Tento způsob komunikace tedy nevyžaduje aktivní účast procesoru. Tato metoda je použitelná pro občasné</br>přenosy a/nebo přenosy s velmi malou šířkou pásma (počtem bajtů přenesených za sekundu). Při větších</br>objemech dat vede tento způsob komunikace k příliš vysoké režii.",
                " Přímý přístup do paměti (DMA)</br>Zdaleka nejčastějším cílem přenosu dat z periferie je jejich uložení do operační paměti – další</br>zpracování zpravidla musí vyčkat do doby, než je v operační paměti nějaký kompletní celek (blok, rámec,</br>atp.).</br>Asynchronní přenos dat (bez účasti procesoru, resp. bez účasti softwaru) může být realizován dvěma</br>základními metodami:</br>1.  přenos je řízen přímo periferií (na základě podobného pokynu od hlavního procesoru).</br>2. dedikovaným pomocným procesorem, který od hlavního procesoru přijímá pokyny na provedení přenosu</br>(z jaké periferie, na jakou adresu v operační paměti, kolik bajtů, případně opačně, z jaké adresy</br>v operační paměti a jaké periferii), a který je de-facto součástí sběrnice</br>Výhodou první metody je, že periferie nemusí nijak rozlišovat DMA a PIO režimy přenosu dat a může být</br>tedy jednodušší. Druhá metoda je obvykle efektivnější a v moderních systémech mnohem běžnější.</br>",
                " Je důležité rozlišovat přímý přístup do paměti (komunikuje periferie a operační paměť, bez účasti</br>procesoru) a mapování paměti zařízení do fyzického adresního prostoru (komunikuje procesor s periferií za pomocí operační paměti).",
                "IO-MMU</br>Přestože pro zařízení, které přenáší velké objemy dat (pevná úložiště, síťová rozhraní,</br>atp.), je DMA nepostradatelné, jsou s ním spojeny určitá bezpečnostní rizika. V klasické implementaci</br>DMA má totiž každá periferie neomezený přístup do fyzické paměti – operační systém sice dává periferii</br>pokyn, které fyzické adresy má použít, ale nemá jak vynutit, aby periferie takový pokyn dodržela.</br>V takovém systému tedy periferiím tedy nic tedy nebrání v tom libovolně upravovat obsah paměti –</br>například i přepsat kód jádra a získat tak plnou kontrolu nad systémem. Toto se týká nejen případných</br>podvratných periferií, ale i ovladačů, které mohou jinak nevinnou periferii naprogramovat tak, aby</br>narušila bezpečnost systému.</br>Toto je jistě nežádoucí, zejména chceme-li izolovat ovladače od zbytku jádra, nebo v případech, kdy</br>samotná periferie není nutně důvěryhodná. IO-MMU je zařízení, které tento problém řeší, a to tím, že</br>realizuje překlad adres pro periferie (podobně jako MMU realizuje překlad adres pro software). IO-MMU</br>není programovatelná za normálních podmínek, pouze při konstrukci zařízení",
                "Sběrnice </br>Má dvě základní vrstvy:</br>1. fyzickou, která odpovídá za enumeraci</br>2. logickou (protokolovou), která popisuje chování zařízení na sběrnici na vyšší úrovni – adresaci,</br>konfiguraci zařízení, přenosy dat atp.</br>Sběrnic existuje v počítači celá řada a jsou vzájemně propojené. Ta strana sběrnice, která je blíže</br>hlavnímu procesoru, se obvykle nazývá hostitelská.",
                "Sběrnice</br>Hlavním úkolem sběrnice je přenos dat (a s tím související adresace) a signalizace událostí, vedlejším</br>pak konfigurace a enumerace připojených periferií. Má-li řadič sběrnice přidělen rozsah fyzických adres,</br>je také jeho úkolem tuto informaci sdělit procesoru.",
                "Ovladač</br>Jakmile je známý konkrétní typ zařízení, komunikaci s ním převezme ovladač – program,</br>který převezme kontrolu nad jádrem a následně spustí komunikaci s operačním systémem</br>Na jedné straně komunikuje ovladač se zbytkem operačního systému (pomocí vhodného rozhraní, které je</br>ale obvykle specifické pro daný operační systém), na straně druhé komunikuje s konkrétním fyzickým</br>zařízením (které je zase často specifické pro daný model, nebo alespoň modelovou řadu).</br>Připomínáme zde, že komunikace probíhá čtením a zápisem dat, a zpracování takových dat není nic jiného</br>než výpočet",
                "Ovladač</br>Hlavním úkolem ovladače je:</br>1. zpracování příchozích dat do formy, kterou může předat sběrnici a ta data přeložit.</br>kterou umí daná periferie zpracovat.</br>2. převod dat příchozích ze systému (které jsou ve formě nezávislé na konkrétním zařízení) do formy,</br>kterou umí daná periferie zpracovat,</br>3. to vše v reakci na události – buď požadavky ze systému na periferii, nebo naopak.</br>Data v tomto případě nemusí být pouze užitná data (bloky uložené na disku, rámce přijímané nebo odesílané</br>síťovým rozhraním, atp.), ale také řídící data, která ovlivňují jak se bude zařízení chovat, nebo přímo</br>aktivují další funkce zařízení (jiné, než je samotný přenos užitných dat).",
                "Tiskárny</br>1. virtualizace – jak tiskárnu sdílet mezi programy – tento problém je analogický k problému plánováni</br>úloh v dávkových systémech, a má i analogické řešení: frontu úloh ke zpracování,</br>2. abstrakce – jak zahladit rozdíly mezi jednotlivými tiskárnami tak, aby byly z pohledu programu podle</br>možnosti záměnné.</br>Řešení druhého bodu je trochu složitější, a některé aspekty tiskáren nelze úplně v aplikacích ignorovat</br>(černobílý vs barevný tisk, jednostranný vs oboustranný, atp.). Částečným řešením je použití společného</br>formátu pro popis dokumentů k tisku, přičemž operační systém již zařídí konverzi do formátu, který</br>tiskárna akceptuje. Starším standardem tohoto typu je PostScript, novějším NewScript. Některé tiskárny</br>podporují tisk dokumentů v těchto formátech přímo, bez potřeby dalšího zpracování v operačním systému.</br>Z pohledu aplikace může mít tedy virtuální tiskárna jako svou hlavní operaci vložení dokumentu ve formátu</br>NewScript do tiskové fronty",
                "Síťové vrstvy</br>1. fyzická – záležitost hardwaru, má ale dopad na vyšší vrstvy</br>2. síťová – na koncových stanicích řeší převážně software (operační systém), jejím úkolem je zabezpečit</br>komunikaci mezi koncovými uzly (resp. mezi operačními systémy na nich provozovanými)</br>3. , linková – tvoří faktické rozhraní mezi hardwarem a softwarem (operačním systémem)</br>4. transportní doručuje data mezi aplikacemi: tvoří rozhraní mezi operačním systémem a aplikací, a je</br>tak přirozeným místem pro virtualizaci</br>5. a vyšší: záležitost aplikací, staví na virtualizaci poskytované 4. vrstvou.",
                "Odchozí fronta</br>Potřebuje-li operační systém odeslat paket (rámec) do sítě, přidá je na konec</br>tzv. odchozí fronty (angl. transmit queue, Tx queue). Z této fronty je vyzvedne hardware a jakmile je</br>to možné, provede fyzický přenos. Odchozí fronta funguje přibližně takto:</br>1. každá odchozí fronta (může jich existovat několik) má přiřazenu dvojici registrů mapovaných do</br>fyzického adresního prostoru: jeden reprezentuje hlavový ukazatel a ten druhý koncový (angl. head a</br>tail),</br>2. tyto ukazatele popisují kruhovou frontu dynamické velikosti, uloženu v operační paměti, ke které síťové</br>rozhraní přistupuje za pomoci DMA; každá položka (buňka) této kruhové fronty reprezentuje jeden</br>rámec,</br>3. ukazatele dělí frontu na dvě části – jedna patří rozhraní a jedna operačnímu systému,</br>4. operační systém (resp. ovladač síťového rozhraní) upravuje koncový ukazatel:</br>a. pro odeslání rámce pro něj operační systém nejprve vyhradí paměť a uloží do ni obsah rámce (data),</br>b. zapíše příslušnou adresu a velikost do své části kruhové fronty,</br>c. posune koncový ukazatel, čím předá odpovědnost za nově vyplněné buňky síťovému rozhraní,</br>5. síťové rozhraní ovládá hlavový ukazatel: kdykoliv zpracuje odchozí rámec, posune hlavový ukazatel</br>tak, že paměť asociovaná s odeslaným rámcem se přesune do části fronty, která patří rozhraní</br>Události, které se zpracováním kruhové fronty souvisí, signalizuje síťové rozhraní pomocí přerušení",
                "Příjmová fronta</br>Síťové rozhraní po přidání prvků tuto změnu signalizuje přerušením. Alokace paměti pro rámce je v kompetenci operačního</br>systému – přesune-li operační systém nějakou položku (buňku) do části kruhové fronty, která náleží</br>síťovému rozhraní, dává tím najevo, že paměť touto položkou odkázaná může být přepsána novými daty.</br>Jakmile tak síťové rozhraní učiní, příslušnou buňku příjmové fronty přesune do části patřící operačnímu</br>systému.</br>Je obvyklé, že každý blok paměti, který operační systém rozhraní předá, má velikost 2 na n (kde n je velikost registrů procesoru)."
            ]
        },
        {
            "section": 5,
            "correct": [
                "Relace předcházení</br>Událost je jev, který nastane v čase (ne nutně pevně určeném nebo známém), který můžeme</br>pozorovat, a o kterém můžeme říct, že nastal před nebo po nějaké jiné události, případně že s ní</br>nastal souběžně. Relaci uspořádání, která tuto chronologii popisuje, budeme říkat předcházení (anglicky</br>„happens before“).</br>Takto definovaná relace určuje vztah „muselo se stát před“ neboli kauzální návaznost. Grafem předcházení</br>nazveme tranzitivní redukci této relace. Protože grafem uspořádání je acyklický orientovaný graf (angl.</br>DAG = directed acyclic graph), jeho tranzitivní redukce je určena jednoznačně (znáte nejspíš jako</br>Hasseův diagram).",
                "Relace předcházení</br>Vrcholy grafu předcházení jsou události (něco se stalo), jeho hrany budeme nazývat akce (něco se děje).</br>Akce tedy vedou od jedné události k nějaké další, ale nemohou je „přeskakovat“ (formálněji: existuje-li</br>mezi událostmi A a B cesta délky alespoň 2, neexistuje hrana/akce která vede z A do B přímo).",
                "Časový sled</br> Je-li nějaká relace předcházení lineární, mluvíme o časovém sledu.</br>Připomenutí: Časovým sledem událostí rozumíme lineární uspořádání událostí, tedy takové, že pro každou</br>dvojici A, B událostí platí buď:</br>• A předchází B nebo</br>• B předchází A.</br>Časový sled si můžeme představit i jako přiřazení časového razítka každé události takové, že žádné dvě</br>události nenastanou ve stejné chvíli.",
                "Hazard souběhu</br>Předcházení je abstrakce, která skrývá vnitřní detaily procesů (dějů odehrávajících se v</br>čase), které se mohou stát v různém pořadí díky náhodným vlivům, a snažíme se jejich vnější chování</br>popsat pomocí této relace. Vnější chování nějakého systému závisí pouze na jeho relaci předcházení,</br>nikoliv už na tom, jak přesně budou v čase rozloženy konkrétní události.</br>Je-li takto zavedená abstrakce porušena, mluvíme o hazardu souběhu. Jinými slovy, hazard souběhu nastává</br>kdykoliv vedou dva různé časové sledy, které jsou oba konzistentní s relací předcházení pro daný systém,</br>k různému vnějšímu chování.",
                "Hybatel</br>Akce (které reprezentujeme hranami v grafu předcházení) jsou prováděny vždy nějakým</br>hybatelem (v našem kontextu obvykle vláknem nebo periferií). Hrany (akce) tedy můžeme tomuto hybateli</br>přisoudit (např. můžeme říct, že vlákno T má modré hrany a periferie P má žluté hrany). Zároveň hybatele</br>můžeme považovat za „peška“ který se v grafu předcházení pohybuje po hranách své vlastní barvy.",
                "Synchronizace</br>Akce jsou souběžné právě tehdy, když jsou souběžné libovolné dvě události, kterých</br>se tyto akce týkají. Událost zejména nemůže být souběžná sama se sebou, a nemohou být souběžné ani</br>události spojené nějakou akcí.",
                "Stavový prostor je orientovaný graf kde vrcholy jsou stavy a hrany jsou akce (ve stejném smyslu jako</br>v grafu předcházení). Pojem „stav“ je v tomto kontextu velmi abstraktní, nicméně můžeme si bez velké</br>újmy nadále představovat stav jako:</br>• hodnoty procesorových registrů,</br>• buněk paměti (jak operační, tak paměti a registrů periferií).",
                "Běh</br>Orientovanou cestu ve stavovém prostoru označíme za běh. Je zde jasná korespondence mezi</br>během (posloupnost stavů propojených akcemi) a časovým sledem (posloupnost událostí propojených</br>akcemi). Sekvenci akcí můžeme chápat i jako běh i jako sled – v obou případech stačí určit počáteční</br>stav (událost) a zbytek běhu (sledu) je již určen akcemi jednoznačně.",
                "Kritická sekce Uvažme běh R ≡ (r1, r2, ..., rn) nějakého vlákna (nebo jiného hybatele) T1asouběžný běh S ≡ (s1, ..., sn).</br>Říkáme, že R je kritickou sekcí vůči S, vede-li (r1, ..., S, ..., rn) k události „chyba“, a to přesto, že samotné běhy R ani S k chybě nevedou.</br>Proto se tomuto typu problému také říká chyba atomicity.",
                "Čtenáři a písaři</br>Představme si situaci, kdy máme běhy R1, R2, … Rn a běhy W1, W2, …, Wm,</br>pro které platí:</br>1. ∀.i, j platí Ri není kritickou sekcí vůči Rj</br>2. ∀.i, j platí Ri je kritickou sekcí vůči Wj,</br>3. ∀.i, j platí Wi je kritickou sekcí vůči Wj</br>Takovou situaci nazýváme „čtenáři a písaři“ – máme tedy n čtenářů Ri a m písařů Wi.</br>Čtenáři si vzájemně nepřekáží – mohou číst zároveň v libovolném pořadí. </br>Písaři se chovají jinak: sdílená data nejen čtou, ale i modifikují – proto čtenář,</br>který by byl přerušen písařem, by mohl přečíst nekonzistentní data.</br>Podobně si překáží dva různí písaři – protože data jak čtou tak modifikují, může být výsledek opět nekonzistentní.",
                "Souběžná datová závislost </br>je vztah mezi akcemi, který je nejlépe vidět ve stavovém prostoru:</br>je-li vstupem nějaké akce Z paměťová buňka nebo registr, do které naposled zapisovala akce X, říkáme,</br>že Z má datovou závislost na X.</br>Uvažme zároveň situaci, kdy máme dva běhy, A ≡ (a1, ..., X, ...an), B ≡ (b1, ..., Z, ..., bm), které jsou</br>zcela souběžné. To se v programu může lehce stát, a často je těžké takovou chybu odhalit, zejména je-li</br>výpočet (a1, ..., X) krátký, zatímco (b1, ..., Z) dlouhý (časově náročný)",
                "Producenti a konzumenti</br>Uvažme situaci, kdy účelem několika vláken je vytvářet mezivýsledky</br>určené k dalšímu zpracování (tato vlákna – producenty – označíme P1...Pn), a několik dalších vláken</br>tyto mezivýsledky dále zpracovává (tato nazveme konzumenty a označíme K1...Km).</br>Všechna vlákna Pi jsou souběžná jak vzájemně tak s vlákny Ki.</br>Tato souběžnost je důležitá a užitečná:</br>umožňuje nám práci distribuovat na různá procesorová jádra a tím celý proces značně urychlit. Protože</br>jsou ale všechna vlákna souběžná, můžou lehce nastat dvě problémové situace:</br>1. producenti mohou generovat výsledky rychleji, než je konzumenti dokáží zpracovávat – mezivýsledky</br>se budou hromadit a postupně zaberou veškerou vyhrazenou paměť, nebo se začnou ztrácet (protože je</br>producenti začnou přepisovat dříve, než jsou zpracovány),</br>2. konzumenti mohou zpracovávat výsledky rychleji, než je producenti dokáží vytvářet – bez synchronizace</br>by taková situace vedla k opakovanému zpracování stejného mezivýsledku, případně k pokusu o zpracování</br>nějaké nesmyslné informace (je-li mezivýsledek očekáván na adrese, kam ještě nebyl producentem</br>zapsán).</br></br>V těchto dvou situacích se tedy musí konzumenti a producenti synchronizovat – je-li mezivýsledků</br>nedostatek, upřednostníme práci producentů, naopak je-li jich přebytek, upřednostníme práci konzumentů.</br>V ideálním případě tak, aby existovala nějaká pevná mez na počet nezpracovaných mezivýsledků (a tedy i</br>na množství paměti potřebné pro jejich uložení).",
                "Rozvětvení a setkán</br>Akce, které nejsou souběžné, nelze provádět paralelně. Máme-li tedy více výpočetních jader, než máme</br>vláken, nevyužíváme hardwarové zdroje efektivně. Relativně častým jevem je, že výpočet má dva (nebo</br>několik) bloků, které lze provést v libovolném pořadí, aniž by se změnil výsledek. V takovém případě</br>bychom chtěli výpočet rozvětvit tak, aby byl každý takový blok (běh) souběžný s těmi ostatními. Máme-li</br>procesorů málo, vykonají se v libovolném pořadí (to nám nevadí), ale máme-ji jich dostatek (nebo</br>přebytek), mohou se tyto běhy provést najednou (každý na jiném procesoru).</br>Tím ale vzniká nový problém – výpočet nemůže pokračovat, než skončí všechny takto vyčleněné bloky</br>– jinak bychom se dostali do situace „výpočetní závislost“ (a tím do známého terénu „příliš mnoho</br>souběžnosti“). Proto je potřeba, aby se běhy i setkaly."
            ]
            ,
            "incorrect": [
                "Relace předcházení</br>Událost je jev, který nastane v čase (ne nutně pevně určeném nebo známém), který můžeme</br>pozorovat, a o kterém můžeme říct, že nastal před nebo po nějaké jiné události, případně že s ní</br>nastal souběžně. Relaci uspořádání, která tuto chronologii popisuje, budeme říkat předcházení (anglicky</br>„happens before“).</br>Takto definovaná relace určuje vztah „muselo se stát před“ neboli kauzální návaznost. Grafem předcházení</br>nazveme tranzitivní redukci této relace. Protože grafem uspořádání je cyklický orientovaný graf (angl.</br>DCG = directed cyclic graph), jeho tranzitivní redukce je určena jednoznačně (znáte nejspíš jako</br>Hasseův diagram).",
                "Relace předcházení</br>Vrcholy grafu předcházení jsou události (něco se stalo), jeho hrany budeme nazývat akce (něco se děje).</br>Akce tedy vedou od jedné události k nějaké další, ale mohou je „přeskakovat“ (formálněji: existuje-li</br>mezi událostmi A a B cesta délky alespoň 2, může existovat hrana/akce která vede z A do B přímo).",
                "Časový sled</br>Je-li nějaká relace předcházení souběžná, mluvíme o časovém sledu.</br>Připomenutí: Časovým sledem událostí rozumíme souběžná uspořádání událostí, tedy takové, že pro každou</br>dvojici A, B událostí platí:</br>A a B nastanou libovoně, tedy nezávisle na sobě</br>Časový sled si můžeme představit i jako přiřazení časového razítka každé události takové, že žádné dvě</br>události nenastanou ve stejné chvíli.",
                "Předcházení je abstrakce, která skrývá vnitřní detaily procesů (dějů odehrávajících se v</br>čase), které se mohou stát v různém pořadí díky náhodným vlivům, a snažíme se jejich vnější chování</br>popsat pomocí této relace. Vnější chování nějakého systému závisí pouze na jeho relaci předcházení,</br>nikoliv už na tom, jak přesně budou v čase rozloženy konkrétní události.</br>Je-li takto zavedená abstrakce porušena, mluvíme o chybě atomicity. Jinými slovy, chyba atomicity nastává</br>kdykoliv vedou dva různé časové sledy, které jsou oba konzistentní s relací předcházení pro daný systém,</br>k různému vnějšímu chování.",
                "Hybatel</br>Akce (které reprezentujeme hranami v grafu předcházení) jsou prováděny vždy nějakým</br>hybatelem (v našem kontextu obvykle vláknem nebo periferií). Hrany (akce) tedy můžeme tomuto hybateli</br>přisoudit (např. můžeme říct, že vlákno T má modré hrany a periferie P má žluté hrany). Zároveň hybatele</br>můžeme považovat za „peška“ který se v grafu předcházení pohybuje po hranách libovoné barvy.",
                "Synchronizace</br>Akce jsou souběžné právě tehdy, když jsou souběžné libovolné dvě události, kterých</br>se tyto akce týkají. Událost můžou být souběžná sama se sebou, a také mohou být souběžné události spojené nějakou akcí.",
                "Stavový prostor je orientovaný graf kde vrcholy jsou akce a hrany jsou stavy (ve stejném smyslu jako</br>v grafu předcházení). Pojem „stav“ je v tomto kontextu velmi abstraktní, nicméně můžeme si bez velké</br>újmy nadále představovat stav jako:</br>• hodnoty procesorových registrů,</br>• buněk paměti (jak operační, tak paměti a registrů periferií).",
                "Běh</br>Orientovanou cestu ve stavovém prostoru označíme za běh. Je zde jasná korespondence mezi</br>během (posloupnost stavů propojených akcemi) a časovým sledem (posloupnost událostí propojených</br>akcemi). Sekvenci akcí můžeme chápat i jako běh ale nikoliv jako sled – v případě běhu stačí určit počáteční</br>stav (událost) a zbytek běhu je již určen akcemi jednoznačně.",
                "Kritická sekce Uvažme běh R ≡ (r1, r2, ..., rn) nějakého vlákna (nebo jiného hybatele) T1asouběžný běh S ≡ (s1, ..., sn).</br>Říkáme, že S je kritickou sekcí vůči R, vede-li (r1, ..., S, ..., rn) k události „chyba“, a to přesto, že samotné běhy R ani S k chybě nevedou.</br>Proto se tomuto typu problému také říká chyba atomicity.",
                "Čtenáři a písaři</br>Představme si situaci, kdy máme běhy R1, R2, … Rn a běhy W1, W2, …, Wm,</br>pro které platí:</br>1. ∀.i, j platí Wi není kritickou sekcí vůči Wj</br>2. ∀.i, j platí Ri je kritickou sekcí vůči Wj,</br>3. ∀.i, j platí Ri je kritickou sekcí vůči Rj</br>Takovou situaci nazýváme „čtenáři a písaři“ – máme tedy n čtenářů Ri a m písařů Wi.</br>Čtenáři si vzájemně nepřekáží – mohou číst zároveň v libovolném pořadí.</br>Písaři se chovají jinak: sdílená data nejen čtou, ale i modifikují – proto čtenář</br> který by byl přerušen písařem, by mohl přečíst nekonzistentní data.</br>Podobně si překáží dva různí písaři – protože data jak čtou tak modifikují, může být výsledek opět nekonzistentní.",
                "Souběžná datová závislost</br>je vztah mezi akcemi, který je nejlépe vidět ve stavovém prostoru:</br>je-li vstupem nějaké akce Z paměťová buňka nebo registr, do které naposled zapisovala akce X, říkáme,</br>že X má datovou závislost na Z.</br>Uvažme zároveň situaci, kdy máme dva běhy, A ≡ (a1, ..., X, ...an), B ≡ (b1, ..., Z, ..., bm), které jsou</br>zcela souběžné. To se v programu může lehce stát, a často je těžké takovou chybu odhalit, zejména je-li</br>výpočet (a1, ..., X) krátký, zatímco (b1, ..., Z) dlouhý (časově náročný)",
                "Producenti a konzumenti</br>Uvažme situaci, kdy účelem několika vláken je vytvářet mezivýsledky</br>určené k dalšímu zpracování (tato vlákna – producenty – označíme P1...Pn), a několik dalších vláken</br>tyto mezivýsledky dále zpracovává (tato nazveme konzumenty a označíme K1...Km).</br>Všechna vlákna Pi jsou souběžná jak vzájemně tak s vlákny Ki.</br>Tato souběžnost je důležitá a užitečná:</br>umožňuje nám práci distribuovat na různá procesorová jádra a tím celý proces značně urychlit. Protože</br>jsou ale všechna vlákna souběžná, můžou lehce nastat dvě problémové situace:</br>1. producenti mohou generovat výsledky rychleji, než je konzumenti dokáží zpracovávat – mezivýsledky</br>se budou hromadit a postupně zaberou veškerou vyhrazenou paměť, nebo se začnou ztrácet (protože je</br>producenti začnou přepisovat dříve, než jsou zpracovány),</br>2. konzumenti mohou zpracovávat výsledky rychleji, než je producenti dokáží vytvářet – bez synchronizace</br>by taková situace vedla k opakovanému zpracování stejného mezivýsledku, případně k pokusu o zpracování</br>nějaké nesmyslné informace (je-li mezivýsledek očekáván na adrese, kam ještě nebyl producentem</br>zapsán).</br></br>V těchto dvou situacích se tedy musí konzumenti a producenti synchronizovat – je-li mezivýsledků</br>nedostatek, upřednostníme práci producentů, naopak je-li jich přebytek, upřednostníme práci konzumentů.</br>V ideálním případě tak, aby existovala nějaká dynamická mez, která se podle potřeb systému mění.",
                "Rozvětvení a setkán</br>Akce, které nejsou souběžné, nelze provádět paralelně. Máme-li tedy více výpočetních jader, než máme</br>vláken, nevyužíváme hardwarové zdroje efektivně. Relativně častým jevem je, že výpočet má dva (nebo</br>několik) bloků, které lze provést v libovolném pořadí, aniž by se změnil výsledek. V takovém případě</br>bychom chtěli výpočet rozvětvit tak, aby byl každý takový blok (běh) souběžný s těmi ostatními. Máme-li</br>procesorů málo, vykonají se v libovolném pořadí (to nám nevadí), ale máme-ji jich dostatek (nebo</br>přebytek), mohou se tyto běhy provést najednou (každý na jiném procesoru).</br>Tím ale vzniká nový problém – výpočet nemůže pokračovat, než skončí alespoň některé takto vyčleněné bloky</br>– jinak bychom se dostali do situace „výpočetní závislost“ (a tím do známého terénu „příliš mnoho</br>souběžnosti“)."
            ]
        },
        {
            "section": 6,
            "correct": [
                "Synchronizační zařízení</br>synchronizační zařízení je (de facto) datová struktura – v programu může existovat v mnoha</br>nezávislých instancích. Mezi různými instancemi se žádná synchronizace neděje. Každé synchronizační</br>zařízení má nějaký stav, který musí být někde uložen: instanci synchronizačního zařízení tedy ztotožníme</br>s adresou, na které je uložen jeho stav",
                "Vzájemné vyloučení (mutex) </br>Zřejmě úplně nejjednodušším synchronizačním zařízením je mutex,</br>určený k ochraně kritické sekce. Aby byla kritická sekce ochráněna, musí být chráněná jak kritická sekce</br>samotná, tak i všechny běhy, vůči kterým je kritická, a to tím stejným mutexem.",
                "Spinlock</br>je synchronizační smyčka bez interakce s plánovačem (komunikace s plánovačem je</br>potenciálně drahá operace – neplánujeme-li čekat dlouho, může být nevýhodné ji provést).</br>V moderních systémech se spinlock implementuje pomocí atomické instrukce, která umožní provést</br>operaci ld, úpravu hodnoty a st jako jediný krok, který je pro všechny procesory v systému pozorovatelný</br>pouze jako celek. Atomických operací existuje celá řada, my použijeme operaci cmpxchg (z angl. „compare</br>and exchange“), která má 3 operandy: adresu, očekávanou hodnotu a požadovanou hodnotu.",
                "Spinlock (resp. aktivní čekání obecně) má ale jednu důležitou nevýhodu: soutěží-li o stejný zámek dvě</br>vlákna, která sdílí procesorové jádro, čekajícímu vláknu se nemůže podařit zámek získat, dokud nebude</br>vlastník zámku probuzen. Proto je použití spinlocku v uživatelských programech obvykle chybou (nelze</br>zaručit, že vlákna budou naplánována na různá procesorová jádra).",
                "Uspávající mutex </br>Operace lock je realizována jako služba operačního systému (systémové volání); jádro nejprve ověří, je-li zámek odemčen:</br>1. pokud ano, poznačí ho jako zamčený a vrátí kontrolu vláknu, které zámek vyžádalo,</br>2. v opačném případě zařadí vlákno do fronty, která danému mutexu náleží, a nechá plánovač probudit</br>nějaké jiné vlákno.</br>Odemčení zámku pak ověří, je-li nějaké další vlákno ve frontě, a pokud ano, mutex ihned zase zamkne a</br>předá ho prvnímu vláknu z této fronty",
                "Rychlý mutex</br>rozdělení odpovědnosti za dvě části stavu</br>mezi uživatelské vlákno a operační systém. Rozhodnutí o tom, je-li zámek zamčený nebo nikoliv, vyřeší</br>vlákno ve vlastní režii (stejně, jako by se jednalo o spinlock – pomocí atomické instrukce). Systémové</br>volání se provede pouze v případě, kdy pokus o zamčení selže.</br>Systémová část stavu se jmenuje futex (z angl. „fast mutex“), a sestává pouze z fronty uspaných</br>vláken. Fronty jsou s jednotlivými uživatelskými mutexy svázány adresou (tzn. operační systém má</br>pomyslný slovník front, kde klíčem je adresa příslušného mutexu)",
                " Read-Copy-Update</br>Princip fungování je jednoduchý: místo aby písař měnil datovou strukturu na místě, vytvoří její kopii</br>(skutečnou nebo pomyslnou resp. částečnou) a tuto kopii upraví – obě operace jsou bezpečné, protože</br>kopírování je vzhledem k původní datové struktuře forma čtení, a nová kopie je prozatím ve výlučném</br>vlastnictví písaře (jiná vlákna k ní nemají vůbec přístup). Jakmile je úprava hotová, přesměruje všechny</br>budoucí čtenáře na tuto novou verzi, obvykle tím, že upraví sdílený ukazatel. </br>Starší kopie je možné uvolnit až ve chvíli, kdy je jisté, že k nim nepřistupuje žádný čtenář – protože</br>čtenáři jsou se zapisujícím písařem souběžní, potřebujeme další synchronizační mechanismus – častou</br>volbou je počítadlo odkazů, které čtenáři udržují; poslední čtenář pak již nepotřebnou starší verzi dat</br>uvolní.",
                "Monitor</br>Monitor je jednoduchou, ale velmi užitečnou abstrakcí – uvažme datovou strukturu, která sestává z nějaké</br>datové reprezentace a operací nad ní. Realizace jednotlivé operace je často kritickou sekcí vůči ostatním</br>operacím (to platí zejména pro ty operace, které strukturu mění).</br>Organizujeme-li program tak, že jediný přístup přímo k datům takové struktury je skrze operace</br>definované v podprogramech, lze datové struktuře jako celku přidružit jeden mutex, který se na začátku</br>každé operace zamkne a na konci odemkne. Lze si zde představit dvě implementační strategie:</br>1. v ideálním případě zamykáni a odemykání v operacích řeší překladač (týká se některých OOP jazyků);</br>pak lze navíc v situaci, kdy jedna operace volá jinou operaci jako podprogram, zamykání přeskočit</br>(„staticky“ víme, že mutex je již zamčený),</br>2. v méně ideálním případě, kdy je „monitor“ pouze ručně udržovaný invariant, můžeme využít rekurzivního</br>mutexu (vnořené zamykání se tak vyřeší „dynamicky“ – za běhu).",
                "Monitor nemůže zaručit, že program jako celek nebude obsahovat chyby synchronizace – není</br>těžké představit si invariant, který přesahuje hranice jedné datové struktury, a kterého dočasné</br>porušení je kritickou sekcí.</br>",
                "Podmínková proměnná</br>Pro řešení problému souběžné datové závislosti lze použít synchronizační</br>zařízení, kterému se říká podmínková proměnná (angl. condition variable). Operace jsou jednoduché:</br>• wait – čekej – zablokuje volající vlákno až do chvíle, kdy nějaké jiné vlákno provede operaci signal,</br>• signal odblokuje vlákno (tzn. umožní mu pokračovat ve výpočtu) zablokované operací wait.",
                "Semafor</br>Klasický semafor přímo neřeší žádný zajímavý problém (který by mutex nebo některá</br>jeho varianta neřešila lépe), nicméně ze dvou semaforů lze sestavit řešení problému producentů a</br>konzumentů.</br>Semafor lze také mírně upravit tak, aby problém producentů a konzumentů řešil přímo – stačí změnit</br>operaci post tak, aby při pokusu o překročení hodnoty n blokovala. Takovému semaforu bychom mohli říkat</br>třeba symetrický (díky nově získané symetrii operací wait a post). Klasické řešení problému producentů</br>a konzumentů pak není nic jiného, než kombinace dvou klasických, asymetrických semaforů do jednoho</br>symetrického.</br>Význam semaforu E je počet volných míst ve frontě mezivýsledků, zatímco význam semaforu F je počet</br>zabraných míst ve frontě mezivýsledků. Operace udržují invariant E + F = n.",
                " Bariéra</br>Inverzní semafor – umožňuje pokračovat ve výpočtu, až když na bariéru čeká dostatek</br>vláken. Smyslem bariéry je řešit problém rozvětvení a setkání (zejména jeho druhou část – setkání</br>většího počtu vláken, které řeší nezávislé podproblémy nějakého většího výpočetního celku).</br>Bariéru lze implementovat například jako počítadlo + podmínkovou proměnnou."
            ]
            ,
            "incorrect": [
                "Synchronizační zařízení</br>synchronizační zařízení je (de facto) datová struktura – v programu může existovat v mnoha</br>nezávislých instancích. Mezi různými instancemi  může probíhat synchronizace. Každé synchronizační</br>zařízení má nějaký stav, který musí být někde uložen: instanci synchronizačního zařízení tedy ztotožníme</br>s adresou, na které je uložen jeho stav",
                "Vzájemné vyloučení (mutex) </br>Zřejmě úplně nejjednodušším synchronizačním zařízením je mutex,</br>určený k ochraně kritické sekce. Aby byla kritická sekce ochráněna,stačí když  bude chráněná samotná kritická sekce,</br> nic ostatního není potřeba, vychází z relace předcházení.",
                "Spinlock</br>je synchronizační smyčka, která interaguje s plánovačem (komunikace s plánovačem je</br>potenciálně drahá operace – neplánujeme-li čekat dlouho, může být nevýhodné ji provést).</br>V moderních systémech se spinlock implementuje pomocí atomické instrukce, která umožní provést</br>operaci ld, úpravu hodnoty a st jako jediný krok, který je pro všechny procesory v systému pozorovatelný</br>pouze jako celek. Atomických operací existuje celá řada, my použijeme operaci cmpxchg (z angl. „compare</br>and exchange“), která má 3 operandy: adresu, očekávanou hodnotu a požadovanou hodnotu.",
                "Spinlock (resp. aktivní čekání obecně) má ale jednu důležitou nevýhodu: soutěží-li o stejný zámek dvě</br>vlákna, která sdílí procesorové jádro, čekajícímu vláknu se nemůže podařit zámek získat, dokud nebude</br>vlastník zámku probuzen. Proto je použití spinlocku v uživatelských programech obvykle chybou (vlákna budou vždy naplánována na různá procesorová jádra).",
                "Uspávající mutex </br>Operace lock je realizována bez interakce s plánovačem; jádro nejprve ověří, je-li zámek odemčen:</br>1. pokud ano, poznačí ho jako zamčený a vrátí kontrolu vláknu, které zámek vyžádalo,</br>2. v opačném případě zařadí vlákno do fronty, která danému mutexu náleží, a nechá plánovač probudit</br>nějaké jiné vlákno.</br>Odemčení zámku pak ověří, je-li nějaké další vlákno ve frontě, a pokud ano, mutex ihned zase zamkne a</br>předá ho prvnímu vláknu z této fronty",
                "Rychlý mutex</br>rozdělení odpovědnosti za dvě části stavu</br>mezi uživatelské vlákno a operační systém. Rozhodnutí o tom, je-li zámek zamčený nebo nikoliv, vyřeší</br>vlákno ve vlastní režii (stejně, jako by se jednalo o spinlock – pomocí atomické instrukce). Systémové</br>volání se provede pouze v případě, kdy pokus o zamčení selže.</br>Systémová část stavu se jmenuje futex (z angl. „fast mutex“), a sestává pouze z fronty uspaných</br>vláken. Fronty jsou mezi jednotlivými uživatelskými mutexy sdílené napříč celým systémem.",
                "Read-Copy-Update</br>Princip fungování je jednoduchý: místo aby písař měnil datovou strukturu na místě, vytvoří její kopii</br>(skutečnou nebo pomyslnou resp. částečnou) a tuto kopii upraví – obě operace jsou bezpečné, protože</br>kopírování je vzhledem k původní datové struktuře forma čtení, a nová kopie je prozatím ve výlučném</br>vlastnictví písaře (jiná vlákna k ní nemají vůbec přístup). Jakmile je úprava hotová, přesměřujeme všechny aktuální i budoucí čtenáře na aktuální verzi.",
                "Monitor</br>Monitor je jednoduchou, ale velmi užitečnou abstrakcí – uvažme datovou strukturu, která sestává z nějaké</br>datové reprezentace a operací nad ní. Realizace jednotlivé operace je často kritickou sekcí vůči ostatním</br>operacím (to platí zejména pro ty operace, které strukturu mění).</br>Organizujeme-li program tak, že jediný přístup přímo k datům takové struktury je skrze operace</br>definované v podprogramech, lze datové struktuře jako celku přidružit několik mutexů, které vybere podle potřeby na začátku</br>každé operace a daný mutex zamkne a na konc zasei odemkne. Lze si zde představit dvě implementační strategie:</br>1. v ideálním případě zamykáni a odemykání v operacích řeší překladač (týká se některých OOP jazyků);</br>pak lze navíc v situaci, kdy jedna operace volá jinou operaci jako podprogram, zamykání přeskočit</br>(„staticky“ víme, že mutex je již zamčený),</br>2. v méně ideálním případě, kdy je „monitor“ pouze ručně udržovaný invariant, můžeme využít rekurzivního</br>mutexu (vnořené zamykání se tak vyřeší „dynamicky“ – za běhu).",
                "Monitor pomáhá zaručit, že program jako celek nebude obsahovat chyby synchronizace a chrání tak celou datovou strukturu a operace nad ní.",
                "Podmínková proměnná</br>Pro řešení problému čtenářů a písařů lze použít synchronizační</br>zařízení, kterému se říká podmínková proměnná (angl. condition variable). Operace jsou jednoduché:</br>• wait – čekej – zablokuje volající vlákno až do chvíle, kdy nějaké jiné vlákno provede operaci signal,</br>• signal odblokuje vlákno (tzn. umožní mu pokračovat ve výpočtu) zablokované operací wait.",
                "Semafor</br>Klasický semafor přímo neřeší žádný zajímavý problém (který by mutex nebo některá</br>jeho varianta neřešila lépe), nicméně ze dvou semaforů lze sestavit řešení problému producentů a</br>konzumentů.</br>Semafor lze také mírně upravit tak, aby problém producentů a konzumentů řešil přímo – stačí změnit</br>operaci post tak, aby při pokusu o překročení hodnoty n blokovala. Takovému semaforu bychom mohli říkat</br>třeba symetrický (díky nově získané symetrii operací wait a post). Klasické řešení problému producentů</br>a konzumentů pak není nic jiného, než kombinace dvou klasických, asymetrických semaforů do jednoho</br>symetrického.</br>Význam semaforu E je počet volných míst ve frontě mezivýsledků, zatímco význam semaforu F je počet</br>zabraných míst ve frontě mezivýsledků. Operace udržují invariant E * F = n.",
                " Bariéra</br>Inverzní semafor – umožňuje pokračovat ve výpočtu, až když na bariéru čeká dostatek</br>vláken. Smyslem bariéry je řešit problém rozvětvení většího </br>počtu vláken, které řeší nezávislé podproblémy nějakého většího výpočetního celku).</br>Bariéru lze implementovat například jako počítadlo + spinlock."
            ]
        },
        {
            "section": 7,
            "correct": [
                "Komunikace a Synchronizace</br>Každá komunikace je zároveň formou synchronizace: každé čtení</br>nějaké informace musí být předcházeno odpovídajícím zápisem. Nelze dost dobře obdržet zprávu, která</br>dosud nebyla odeslána. Proto je každé komunikační zařízení také zařízením synchronizačním. Opačný vztah</br>ale neplatí: komunikace přidává možnost předat nějakou informaci.",
                "Datové struktury pro komunikaci</br>Ke komunikaci lze použít celkem libovolnou datovou strukturu, je-li chráněna</br>mutexem nebo jiným vhodným synchronizačním zařízením (např. je realizována jako monitor).</br>Problém, který zde vzniká, je soutěž (angl. contention) o příslušný zámek. Takové kombinované</br>komunikační zařízení si lze představit jako klasickou poštovní schránku – vkládá-li právě pošťák psaní</br>do schránky, nemůžete si z ní dost dobře ve stejnou chvíli vyzvedávat nějaké jiné – jak přesně datová</br>struktura funguje vnitřně z tohoto pohledu není důležité.",
                "Roura</br>Specializace fronty, která pracuje s bajty. Vyznačuje se zejména efektivními dávkovými</br>operacemi – zápisem resp. čtením většího počtu položek (bajtů) najednou. Často je poskytována operačním</br>systémem. Prakticky vždy implementovaná jako omezená – existuje nějaký maximální objem dat, který lze</br>do roury zapsat, než musí další zápis vyčkat na čtení. Stejně jako omezená fronta má tedy synchronizační</br>chování stejné jako symetrický semafor.",
                "Alternativou ke sdílené paměti je předávání zpráv – má dvě výhody:</br>1. je bezpečnější na použití – méně problémů s hazardy souběhu,</br>2. lze použít i mezi různými počítači (po síti),</br>a dvě nevýhody:</br>1. méně pohodlné, protože nelze odkazovat do jiných datových struktur – všechna relevantní data je</br>potřeba „přibalit“ do samotné zprávy,</br>2. méně efektivní, jednak kvůli samotné konstrukci zpráv, jednak kvůli režii s kopírováním a předáváním</br>zprávy.",
                "Zpráva </br>Z pohledu systému pro předávání zpráv je obvykle obsah zprávy neprůhledný (jsou to pouze</br>bajty), důležitá jsou připojená metadata: zejména adresát. Způsob adresace je zároveň hlavní rozdíl </br>mezi předáváním zpráv a frontami – mezi pevnou dvojicí komunikujících vláken je jinak předávání zpráv</br>ekvivalentní dvojici komunikačních front",
                "Základní opreace</br>Je-li maximální počet nedoručených zpráv, které je systém ochoten uložit, nulový, mluvíme o tzv.</br>„setkání“ (rendezvous) – odesílající a přijímající vlákno se musí „sejít“ aby si mohly zprávu předat.</br>Synchronizační aspekt komunikace je zde obzvláště výrazný – dokonce mnohem výraznější, než je obvyklé</br>u synchronizačních zařízení.",
                "Zprostředkovatel</br>Úkolem zprostředkovatele je zprávu od odesílatele přebrat a doručit ji adresátovi. Předáni zprávy může</br>probíhat ve 3 režimech:</br>• Je-li operace odeslání synchronní a systém doručení spolehlivý, za zprávu je již dále odpovědný</br>zprostředkovatel – klient může věc považovat za vyřízenou.</br>• Je-li operace asynchronní, klient musí paměť se zprávou zachovat až do doby, než zprostředkovatel</br>potvrdí, že ji převzal.</br>• Je-li doručení zpráv nespolehlivé, a klient potřebuje zajištěné doručení, musí zprávu zachovat až do</br>doby, než mu ji příjemce potvrdí (opět odesláním zprávy).</br>Příjem zprávy obvykle funguje v jednom ze dvou režimů:</br>1. Synchronní, kdy se příjemce dotáže na další zprávu (případně na ni vyčká, není-li právě žádná</br>k dispozici), tuto zpracuje a poté se zeptá na další.</br>2. Asynchronní – klient zpracovává větší počet zpráv souběžně, a zpracováni příchozí zprávy začne na</br>výzvu zprostředkovatele. Lze realizovat buď pomocí klasických vláken, nebo tzv. fibrů.",
                "Existuje typ operačních systémů, kde je předávání zpráv základním mechanismem meziprocesové komunikace.</br>Tento návrh silně koreluje s mikrojádrovou architekturou. V takovém systému</br>jsou služby operačního systému z velké části realizovány „běžnými“ procesy, a proto je komunikace mezi</br>procesy v takových systémech velmi důležitá. Zprostředkovatelem je v takových systémech často samotné</br>mikrojádro.",
                "Hardwarové zdroje nejpřirozenějším typem zdroje je hardware: jak výpočetní (procesor, paměť)</br>tak periferie. V první části kurzu jsme se zabývali virtualizací, která nám umožňuje předstírat, že</br>zdroje vlastníme ve více instancích, než jich fyzicky existuje. To je sice velmi užitečná a úspěšná</br>taktika, ale není bez limitů.</br>Virtualizaci zdroje lze uplatnit jen v situacích, kdy každý uživatel daného zdroje využívá jen část jeho</br>skutečné kapacity – část obrazovky (okno), část procesorového jádra (vlákno), část operační paměti</br>(proces), část šířky přenosového pásma (síťové spojení) atp.",
                "Rezervace</br> Alternativou je rezervace, kterou využijeme v situacích, kdy virtualizaci použít nelze:</br>• neumožňuje to povaha zdroje (např. pásková jednotka nebo optická zapisovací mechanika) nebo</br>• nečekané selhání zdroje je nepřípustné (např. by došlo k ohrožení zdraví, života nebo majetku).</br>Rezervace a virtualizace není vzájemně výlučná – daný zdroj může být virtualizován, ale zároveň může</br>systém poskytovat možnost rezervovat zaručenou kapacitu – v takovém případě je rezervovaný zdroj</br>(dočasně) nepřístupný pro systém virtualizace. Operační systémy například běžně poskytují možnost</br>rezervovat pro daný proces nějaké množství fyzické paměti. Takto rezervovanou fyzickou paměť pak</br>systém nebude používat pro stránky jiných procesů, ani nebude stránky vlastníka z takto rezervované</br>paměti přesouvat do trvalého úložiště.",
                "Rezervace sestává ze dvou operací:</br>1. samotná rezervace, která od systému vyžádá nějaký zdroj (resp. nějaký počet jednotek zdroje), pro</br>výlučné použití daným programem (procesem, vláknem, atp.), – po úspěšném provedení rezervace je</br>zdroj ve vlastnictví příslušného programu,</br>2. uvolnění zdroje kdy vlastník zdroje oznámí systému, že již zdroj nebude využívat, a tento může být</br>vrácen „do oběhu“ (může být předán jinému programu, procesu, vláknu, …).",
                "Komunikace</br>Protože komunikace je zároveň synchronizací, jedná se (možná ne zcela intuitivně)</br>také o abstraktní zdroj. Novým aspektem je zde skutečnost, že rezervaci a uvolnění neprovádí nutně</br>tentýž aktér – předání zprávy (resp. obecně informace) může zároveň předat vlastnictví tohoto typu</br>„zdroje“.</br>Tento jev je vázán k problému producentů a konzumentů (který, jak jsme zmiňovali výše, s komunikací úzce</br>souvisí): vytvoření a (zejména) uložení mezivýsledku je formou rezervace – počet mezivýsledků, které</br>jsme si ochotni pamatovat, je omezené, a jedná se tedy o konečný zdroj, který musí být producentovi</br>přidělen. Takto zablokovaná instance se ale uvolní tím, že konzument mezivýsledek použije.",
                "Odnímatelné zdroje</br>Implicitně považujeme zdroje za neodnímatelné, ve smyslu, že jediný způsob,</br>jak může dojít k uvolnění zdroje, je dobrovolné vrácení vlastníkem. U řady zdrojů by mělo odebrání</br>pravděpodobně fatální následky minimálně pro dotčený program, a někdy také pro dotčený zdroj (3D</br>tiskárna, optická zapisovací mechanika, fotografická tiskárna, atp.). Uvážíme-li abstraktní zdroje,</br>násilné odebrání např. zmiňovaného mutex-u jistě nemůže mít pozitivní dopad na další fungování vlákna,</br>resp. programu jako celku.</br>Jiná je situace u zdrojů virtualizovaných, kde odebrání fyzického prostředku obvykle nepředstavuje</br>zásadní problém – plánovač vláken zcela běžně odebírá procesor běžícímu vláknu bez jeho souhlasu,</br>správce virtuální paměti může stránku přestěhovat z operační paměti do externí, atp. Na dotčený proces</br>(vlákno) to má jistě dopad, ale důsledky obvykle nejsou zdaleka tak závažné, jako v případě zdrojů</br>neodnímatelných.",
                "Podmínky uváznutí - Uváznutí může nastat, jsou-li splněny všechny 4 následující podmínky – přitom</br>požadovat umožnění každé z nich je samo o sobě přirozené a smysluplné</br>1. Vzájemné vyloučení</br>2. čekající vlastník</br>3. neodnímatelnost</br>4. kruhové čekání</br>Tyto podmínky nejsou postačující na to aby systém mohl uváznout.",
                "Podmínky uváznutí - Uváznutí může nastat, jsou-li splněny všechny 4 následující podmínky – přitom</br>požadovat umožnění každé z nich je samo o sobě přirozené a smysluplné</br>1. Vzájemné vyloučení</br>2. čekající vlastník</br>3. neodnímatelnost</br>4. kruhové čekání</br>Tyto podmínky nejsou postačující na to aby systém mohl uváznout.",
                "Detekce uváznutí</br>Jednou možností jak uváznutí detekovat je použít dynamickou variantu grafu</br>závislostí zdrojů, který jsme použili k definici kruhového čekání. V tomto případě obsahuje graf dva</br>různé typy uzlů: vlákna, nebo jiné potenciální vlastníky a zdroje",
                "Zotavení z uváznutí </br>Účastní-li se cyklického čekání alespoň jeden odnímatelný zdroj, může</br>k uváznutí sice dojít, ale na rozdíl od standardní situace se lze z tohoto typu uváznutí relativně lehce </br>zotavit (zejména se lze zotavit bez násilného ukončování vláken). Dočasným odebráním odnímatelného</br>zdroje se totiž cyklus čekajících vláken přeruší, a systém může pokračovat.",
                "Vyhýbání uváznutí</br>Jinou možností jak se s uváznutím vypořádat je technika vyhýbání (angl.</br>avoidance). Klíčovým prvkem je zamítnout některé požadavky na rezervaci, i když je příslušný zdroj</br>dostupný, může-li taková rezervace vést k pozdějšímu uváznutí. Stavy, ze kterých může vždy alespoň</br>jedno vlákno vyváznout a úspěšně skončit (resp. uvolnit zdroje) označíme jako bezpečné.</br>Asi nejznámějším algoritmem pro vyhýbání uváznutí je tzv. bankéřův algoritmus, navržený E. Dijkstrou.",
                "Zamezení předrezervací Myšlenka předrezervace je jednoduchá – nesmíme připustit, aby vlákno,</br>které nějaký zdroj již vlastní, čekalo na nějaký zdroj (je lehce vidět, že systém pak nemůže uváznout).</br>Rezervace proto připustíme pouze v situaci, kdy žádající vlákno žádné zdroje nevlastní – aby byl systém</br>prakticky použitelný, musíme ovšem povolit rezervaci několika zdrojů najednou (dávkově).</br>Potřebuje-li tedy vlákno využít více zdrojů, musí je vyžádat všechny jedinou atomickou akcí (uvolňovat</br>je ovšem může postupně). Je-li potřeba rezervovat nějaký zdroj v situaci, kdy už dané vlákno nějaký</br>jiný zdroj vlastní, musí nejprve všechny zdroje uvolnit a opět je rezervovat společně s tím novým.",
                "Zamezení virtualizací </br>Virtualizací jsme se podrobně zabývali v prvních 4 kapitolách – zdroje,</br>které jsou virtualizované, vůbec nepoužívají systém výlučné rezervace, nesplňují tedy podmínku vzá-</br>jemného vyloučení a nemohou přímo způsobit uváznutí. Mezi zdroje, které lze virtualizovat, patří</br>samozřejmě paměť, procesor a pevné úložiště (kapitoly 1–3) a některé periferie – terminál (obrazovka,</br>tiskárna, atp.) nebo síťová rozhraní (kapitola 4).",
                "Zamezení uspořádáním</br>Zbývá nám podmínka kruhového čekání – tomu lze zamezit například tím,</br>že se na zdrojích ustaví globální lineární uspořádání, které musí každé vlákno při rezervacích dodržet:</br>rezervovat lze pouze zdroj, který je v uspořádání větší než dosud největší zdroj vláknu přisouzený.</br>V takovém systému je statický graf závislostí zdrojů acyklický, k uváznutí tak nemůže dojít.</br>Podobně jako v případě předrezervace lze řešit i situace, kdy potřebujeme globální pořadí porušit –</br>vlákno se musí nejprve vzdát některých zdrojů a pak je znovu rezervovat ve správném pořadí.</br>Tento přístup je poměrně praktický na úrovni jednotlivého programu, nebo jiného uzavřeného systému,</br>nicméně pro operační systém jako celek se nehodí"
            ]
            ,
            "incorrect": [
                "Komunikace a Synchronizace</br>Každá synchronizace je zároveň formou komunikace: každé čtení</br>nějaké informace musí být předcházeno odpovídajícím zápisem. Nelze dost dobře obdržet zprávu, která</br>dosud nebyla odeslána. Proto je každé synchronizační zařízení také zařízením komunikačním. Opačný vztah</br>ale neplatí.",
                "Datové struktury pro komunikaci</br>Ke komunikaci lze použít celkem libovolnou datovou strukturu,nesmí být ale chráněna žádným synchronizačním zařízením.</br>Problém, který zde vzniká, je soutěž (angl. contention) o příslušný zámek. Takové kombinované</br>komunikační zařízení si lze představit jako klasickou poštovní schránku – vkládá-li právě pošťák psaní</br>do schránky, nemůžete si z ní dost dobře ve stejnou chvíli vyzvedávat nějaké jiné – jak přesně datová</br>struktura funguje vnitřně z tohoto pohledu není důležité.",
                "Roura</br>Specializace fronty, která pracuje s bajty. Vyznačuje se zejména efektivními dávkovými</br>operacemi – zápisem resp. čtením většího počtu položek (bajtů) najednou. Často je poskytována operačním</br>systémem. Prakticky neomezená –  neexistuje maximální objem dat, který je roura schopna pojmout.",
                "Alternativou ke sdílené paměti je předávání zpráv – má dvě výhody:</br>1. efektivnější</br>2. lze použít i mezi různými počítači (po síti),</br>a dvě nevýhody:</br>1. méně pohodlné, protože nelze odkazovat do jiných datových struktur – všechna relevantní data je</br>potřeba „přibalit“ do samotné zprávy,</br>2. je méně bezpečné na použití – více problémů s hazardy souběhu,",
                "Zpráva </br>Z pohledu systému pro předávání zpráv je obvykle obsah zprávy neprůhledný (jsou to pouze</br>bajty), důležitá jsou připojená metadata: zejména adresát. Způsob adresace je zároveň hlavní rozdíl </br>mezi předáváním zpráv a frontami – mezi pevnou dvojicí komunikujících vláken je jinak předávání zpráv</br>ekvivalentní bitmapě.",
                "Základní opreace</br>Je-li maximální počet nedoručených zpráv, v daný moment roven nule, mluvíme o tzv.</br>„setkání“ (rendezvous) – odesílající a přijímající vlákno se setkaly aby si mohly zprávu předat.</br>Synchronizační aspekt komunikace je zde obzvláště výrazný – dokonce mnohem výraznější, než je obvyklé</br>u komunikační zařízení.",
                "Zprostředkovatel</br>Úkolem zprostředkovatele je zprávu od odesílatele přebrat a doručit ji adresátovi. Předáni zprávy může</br>probíhat ve 3 režimech:</br>• Je-li operace odeslání synchronní a systém doručení spolehlivý, za zprávu je již dále odpovědný</br>zprostředkovatel – klient může věc považovat za vyřízenou.</br>• Je-li operace asynchronní, klient musí paměť se zprávou zachovat až do doby, než zprostředkovatel</br>potvrdí, že ji převzal.</br>• Je-li doručení zpráv nespolehlivé, a klient potřebuje zajištěné doručení, musí zprávu zachovat až do</br>doby, než mu ji příjemce potvrdí (opět odesláním zprávy).</br>Příjem zprávy obvykle funguje v jednom ze dvou režimů:</br>1. Synchronní, kdy se příjemce dotáže na další zprávu (případně na ni vyčká, není-li právě žádná</br>k dispozici), tuto zpracuje a poté se zeptá na další.</br>2. Asynchronní – klient zpracovává větší počet zpráv souběžně, a zpracováni příchozí zprávy začne na</br>výzvu zprostředkovatele. Lze realizovat buď pomocí klasických vláken, nebo tzv. fibrů.",
                "Existuje typ operačních systémů, kde je předávání zpráv základním mechanismem meziprocesové komunikace.</br>Tento návrh silně koreluje s makrojádrovou architekturou. V takovém systému</br>jsou služby operačního systému z velké části realizovány „běžnými“ procesy, a proto je komunikace mezi</br>procesy v takových systémech velmi důležitá. Zprostředkovatelem je v takových systémech často samotné</br>makrojádro.",
                "Hardwarové zdroje nejpřirozenějším typem zdroje je hardware: jak výpočetní (procesor, paměť)</br>tak periferie. V první části kurzu jsme se zabývali virtualizací, která nám umožňuje předstírat, že</br>zdroje vlastníme ve více instancích, než jich fyzicky existuje. To je sice velmi užitečná a úspěšná</br>taktika, ale není bez limitů.</br>Virtualizaci zdroje lze uplatnit jen v situacích, kdy uživatel využívá zdroje jako celek.",
                "Rezervace</br> Alternativou je rezervace, kterou využijeme v situacích, kdy virtualizaci použít nelze:</br>• neumožňuje to povaha zdroje (např. pásková jednotka nebo optická zapisovací mechanika) nebo</br>• nečekané selhání zdroje je nepřípustné (např. by došlo k ohrožení zdraví, života nebo majetku).</br>Rezervace a virtualizace je vzájemně výlučná – daný zdroj může být virtualizován, ale zároveň nemůže</br>systém poskytovat možnost rezervovat zaručenou kapacitu – v takovém případě by byl rezervovaný zdroj</br>(dočasně) nepřístupný pro celý systém. Operační systémy například běžně poskytují možnost</br>rezervovat pro daný proces nějaké množství fyzické paměti. Takto rezervovanou fyzickou paměť pak</br>systém nebude používat pro stránky jiných procesů, ani nebude stránky vlastníka z takto rezervované</br>paměti přesouvat do trvalého úložiště.",
                "Rezervace sestává ze dvou operací:</br>1. samotná rezervace, která od systému vyžádá nějaký zdroj (resp. nějaký počet jednotek zdroje), pro</br>výlučné použití daným programem (procesem, vláknem, atp.), – po úspěšném provedení rezervace je</br>zdroj ve vlastnictví příslušného programu,</br>2.odebrání zdroje, kdy systém odebere zdroj vlastníkovy, aby tento mohl být</br>vrácen „do oběhu“ (může být předán jinému programu, procesu, vláknu, …).",
                "Komunikace</br>Protože komunikace je zároveň synchronizací, jedná se (možná ne zcela intuitivně)</br>také o abstraktní zdroj. Novým aspektem je zde skutečnost, že rezervaci a uvolnění musí provést stejný aktér – předání zprávy (resp. obecně informace) může zároveň předat vlastnictví tohoto typu</br>„zdroje“.</br>Tento jev je vázán k problému producentů a konzumentů (který, jak jsme zmiňovali výše, s komunikací úzce</br>souvisí): vytvoření a (zejména) uložení mezivýsledku je formou rezervace – počet mezivýsledků, které</br>jsme si ochotni pamatovat, je omezené, a jedná se tedy o konečný zdroj, který musí být producentovi</br>přidělen. Takto zablokovaná instance se ale uvolní tím, že konzument mezivýsledek použije.",
                "Odnímatelné zdroje</br>Implicitně považujeme zdroje za neodnímatelné, ve smyslu, že jediný způsob,</br>jak může dojít k uvolnění zdroje, je dobrovolné vrácení vlastníkem. U řady zdrojů by mělo odebrání</br>pravděpodobně fatální následky minimálně pro dotčený program, a někdy také pro dotčený zdroj (3D</br>tiskárna, optická zapisovací mechanika, fotografická tiskárna, atp.). Uvážíme-li abstraktní zdroje,</br>násilné odebrání např. zmiňovaného mutex-u jistě nemůže mít pozitivní dopad na další fungování vlákna,</br>resp. programu jako celku.</br>Situace u zdrojů virtualizovaných, je obdobná.",
                "Podmínky uváznutí - Uváznutí může nastat, jsou-li splněny všechny 4 následující podmínky – přitom</br>požadovat umožnění každé z nich je samo o sobě přirozené a smysluplné</br>1. Vzájemné vyloučení</br>2. čekající vlastník</br>3. neodnímatelnost</br>4. kruhové čekání</br>Tyto podmínky jsou postačující na to aby systém mohl uváznout.",
                "Podmínky uváznutí - Uváznutí může nastat, je li splněna alespoň jedna z následující podmínek</br>1. Vzájemné vyloučení</br>2. čekající vlastník</br>3. neodnímatelnost</br>4. kruhové čekání</br>Jakákoliv z těchto podmínek je postačující aby systém mohl uváznout.",
                "Detekce uváznutí</br>Jednou možností jak uváznutí detekovat je použít statickou variantu grafu</br>závislostí zdrojů, který jsme použili k definici globálního uspořádání. V tomto případě obsahuje graf dva</br>různé typy uzlů: vlákna, nebo jiné potenciální vlastníky a zdroje",
                "Zotavení z uváznutí </br>Účastní-li se cyklického čekání alespoň jeden odnímatelný zdroj, může</br>k uváznutí sice dojít, ale na rozdíl od standardní situace se lze z tohoto typu uváznutí relativně lehce </br>zotavit a to násilným ukončením vlákna.",
                "Vyhýbání uváznutí</br>Jinou možností jak se s uváznutím vypořádat je technika vyhýbání (angl.</br>avoidance). Klíčovým prvkem je zamítnout některé požadavky na rezervaci, i když je příslušný zdroj</br>dostupný, může-li taková rezervace vést k pozdějšímu uváznutí. Stavy, ze kterých může vždy alespoň</br>jedno vlákno vyváznout a úspěšně skončit (resp. uvolnit zdroje) označíme jako bezpečné.</br>Asi nejznámějším algoritmem pro vyhýbání uváznutí je tzv. makleřův algoritmus, navržený E. Dijkstrou.",
                "Zamezení předrezervací Myšlenka předrezervace je jednoduchá – nesmíme připustit, aby vlákno,</br>které nějaký zdroj již vlastní, čekalo na nějaký zdroj (je lehce vidět, že systém pak nemůže uváznout).</br>Rezervace proto připustíme pouze v situaci, kdy žádající vlákno vlastní nějaké zdroje – aby byl systém</br>prakticky použitelný, musíme ovšem povolit rezervaci několika zdrojů najednou (dávkově).</br>Potřebuje-li tedy vlákno využít více zdrojů, musí je vyžádat všechny jedinou atomickou akcí (uvolňovat</br>je ovšem může postupně). Je-li potřeba rezervovat nějaký zdroj v situaci, kdy už dané vlákno nějaký</br>jiný zdroj vlastní, musí nejprve všechny zdroje uvolnit a opět je rezervovat společně s tím novým.",
                "Zamezení virtualizací </br>Virtualizací jsme se podrobně zabývali v prvních 4 kapitolách – zdroje,</br>které jsou virtualizované, používají systém výlučné rezervace, splňují tedy podmínku vzá-</br>jemného vyloučení a nemohou přímo způsobit uváznutí. Mezi zdroje, které lze virtualizovat, patří</br>samozřejmě paměť, procesor a pevné úložiště (kapitoly 1–3) a některé periferie – terminál (obrazovka,</br>tiskárna, atp.) nebo síťová rozhraní (kapitola 4).",
                "Zamezení uspořádáním</br>Zbývá nám podmínka kruhového čekání – tomu lze zamezit například tím,</br>že se na zdrojích ustaví globální lineární uspořádání, které musí každé vlákno při rezervacích dodržet:</br>rezervovat lze pouze zdroj, který je v uspořádání menší než dosud největší zdroj vláknu přisouzený.</br>V takovém systému je statický graf závislostí zdrojů acyklický, k uváznutí tak nemůže dojít.</br>Podobně jako v případě předrezervace lze řešit i situace, kdy potřebujeme globální pořadí porušit –</br>vlákno se musí nejprve vzdát některých zdrojů a pak je znovu rezervovat ve správném pořadí.</br>Tento přístup je poměrně praktický na úrovni jednotlivého programu, nebo jiného uzavřeného systému,</br>nicméně pro operační systém jako celek se nehodí"
            ]
        },
        {
            "section": 8,
            "correct": [
                "Přerušení je mechanismus, který umožňuje synchronizovat periferii a software –</br>v abstraktní rovině lze tedy o přerušení uvažovat jako o synchronizačním zařízení.</br>– přerušení je asymetrické v tom smyslu, že ho může vyvolat pouze periferie, nikoliv operační systém</br>nebo software obecně. Máme tedy zařízení, které je vždy aktivováno periferií – operační systém je</br>vždy pasivním účastníkem. Až na tyto rozdíly se přerušení podobá na podmínkovou proměnnou – slouží</br>k signalizaci nějaké události.",
                "Operační systém je samozřejmě program, který musí být vykonáván procesorem – proto</br>krom periferie a operačního systému musí do hry vstoupit i procesor.</br>Zejména se může stát, že ve chvíli, kdy přerušení nastane (je periferií vyvoláno), procesor nějaký</br>program právě vykonává. Navíc je často důležité, aby byla reakce na přerušení dostatečně rychlá – velká</br>prodleva obsluhy může mít řadu důsledků, od uživatelského nepohodlí až ke ztrátě dat.</br>Aby se prodleva minimalizovala, přerušení je realizováno preemptivně – cokoliv procesor v danou chvíli</br>prováděl je pozastaveno, aktuální stav vlákna (hodnoty registrů) je uložen do paměti a je spuštěna</br>obsluha přerušení.",
                "Instance přerušení</br>Obsluha přerušení je realizována podprogramem, kterého adresa je uvedena ve speciální</br>tabulce obsluhy přerušení. Chápeme-li přerušení jako synchronizační zařízení (podobné podmínkové</br>proměnné), je přirozené, že může existovat ve vícero instancích. Protože je ale realizováno hardwarově</br>na relativně nízké úrovni, těchto instancí je pevný počet (často do 256). Tabulka obsluhy přerušení</br>má pak pro každou instanci jednu položku, která určí který podprogram je daným přerušením aktivován.</br>Různé periferie pak typicky používají různé instance přerušení (instance jsou identifikovány číslem).",
                "Obslužný podprogram přerušení je (až na speciální prolog a epilog) stejný jako</br>libovolný jiný – může být třeba zapsaný v jazyce C, a zejména může volat další podprogramy. Proto musí</br>mít k dispozici jak registry (zabezpečeno uložením stavu procesoru před jeho aktivací), tak zásobník.</br>Protože na zásobníku, který byl ve chvíli kdy k přerušení došlo, nemusí být volné místo, je obvyklé, že</br>dojde také k přepnutí zásobníku. Konečně procesor se přepne do režimu jádra (privilegovaného režimu)</br>– obsluha přerušení má tedy stejný privilegovaný přístup k výpočetním zdrojům jako jakákoliv jiná</br>součást jádra.",
                "Obsluha přerušení</br>se nápadně podobá na aktivaci vlákna. Zároveň má ale vlastnosti aktivace podprogramu,</br>protože na rozdíl od vlákna se při ukončení obsluhy stav procesoru neukládá, a v obsluze tedy po jejím</br>ukončení nelze pokračovat. Můžeme tak obsluhu přerušení chápat jako vlákno s velmi krátkým životem.",
                "Obsluha přerušení musí řešit 3 synchronizační scénáře:</br>1. synchronizace se zbytkem systému, který běží paralelně na jiných procesorových jádrech (včetně</br>případné obsluhy přerušení tam probíhající) – zde je v nějakém smyslu největší volnost, obvykle lze</br>použít spinlocky, případně některé nezamykající komunikační zařízení,</br>2. synchronizace se zbytkem systému, který běžel na stejném procesorovém jádře a byl obsluhou přerušen</br>– zde spinlock nepřichází v úvahu, protože přerušený podprogram nemůže být spuštěn před ukončením</br>obsluhy,</br>3. synchronizace s obsluhou souběžného přerušení vyvolané na stejném procesorovém jádře – spinlock</br>opět nepřichází v úvahu (ze stejného důvodu), pomůže zde ale speciální jednoúčelové synchronizační</br>zařízení – zákaz přerušení.</br>Je-li v platnosti zákaz daného přerušení, obsluha případného příchozího přerušení je odložena až do</br>chvíle, kdy je přerušení opět povoleno. Jedná se tak o formu vzájemného vyloučení specifickou pro</br>obslužné podprogramy.",
                "Vzpomeňme, že aktivace procesu je relativně drahá operace: musí se změnit mapování paměti.</br>Proto se při aktivaci obsluhy přerušení proces nepřepíná: běží v adresním prostoru, který byl zrovna</br>aktivní. To mimo jiné znamená, že struktury, které obsluha využívá, musí být dostupné ve všech virtuálních</br>adresních prostorech, a navíc musí být dostupné na stejných adresách. Obsluha přerušení tak vytvoří</br>pomyslné vlákno v procesu, který je právě aktivní.",
                "Struktura obsluhy</br>1. při vstupu do obsluhy přerušení se zakážou další přerušení (může vykonat přímo procesor jako součást</br>aktivace obsluhy) –</br>∘ minimálně toho typu, které bylo právě aktivováno, mají-li přerušení priority tak také všechna</br>přerušení nižších priorit, a v některých systémech úplně všechna přerušení,</br>∘ tím jsou ochráněny libovolné kritické sekce obsluhy přerušení vůči sobě samé, a také je tím</br>omezen počet aktivačních záznamů na zásobníku (jinak by hrozilo, že příliš mnoho rychle příchozích</br>přerušení zásobník vyčerpá),</br>2. obsluha vykoná minimální nutnou akci, která uvede systém do provozuschopného stavu:</br>∘ např. vyprázdní mezipaměti, které by jinak přetekly, a provede další akce, které nelze odložit,</br>∘ minimálně část plánovače je tohoto charakteru (je aktivován obsluhou přerušení časovače – více</br>později),</br>∘ libovolné datové struktury, které zde využívá, a které využívá i jiná část jádra, musí být buď</br>použitelné zcela bez zamykání (např. některé komunikační zařízení probrané v předchozí kapitole,</br>které nepoužívá zámky), nebo musí být na straně zbytku jádra chráněny zákazem přerušení,</br>3. naplánuje zbývající akce (obsluha druhé úrovně) na pozdější vykonání – tento krok vyžaduje komunikaci</br>se zbytkem jádra (někde musí informaci o potřebné návazné akci převzít jiná část jádra, která je</br>s obsluhou přerušení jinak souběžná).",
                "Notifikace</br>Nejzákladnější formou přerušení je notifikace – upozornění na nějakou obecnou událost.</br>Tento typ přerušení je obvykle relativně nezávazný v tom smyslu, že zdržení nebo i úplný výpadek obsluhy</br>systém ani zpracovávaná data nijak neohrozí. ",
                "DMA</br>Zařízení s větší šířkou pásma obvykle pro přenos dat používají DMA, tzn. režim, kdy periferie</br>přesouvá data do operační paměti souběžně s běžným provozem zbytku systému. Tyto přenosy je ale</br>nutné synchronizovat s operačním systémem (resp. s ovladačem zařízení, který je součástí operačního</br>systému).</br>Směrem k periferii je synchronizace realizována zápisem do registru, opačným směrem ale podobný</br>mechanismus použít nelze – periferie místo toho signalizuje dokončení přenosu přerušením.</br>",
                "Časovač - mainupalce s frontami vláken</br>Tyto operace musí být:</br>1. chráněny proti zásahům jiných procesorových jader (obvykle spinlockem, alternativně by mohl být</br>celý plánovač postaven na komunikačních zařízeních bez zámků; uspání zde nepřichází v úvahu),</br>2. chráněny proti přerušení (zákazem) a tedy musí být zároveň</br>3. efektivní (konstantní nebo nejvýše logaritmické v počtu vláken),</br>4. synchronizace v bodech 1 a 2 musí být velmi důsledně koordinovaná: plánovač nesmí zamknout spinlock,</br>aniž by byla zároveň zakázána přerušení (jinak by mohlo dojít k uváznutí), ale zároveň nesmí na</br>spinlock příliš dlouho čekat (protože musí být při čekání zakázaná přerušení, tzn. jedná se o časově</br>kritickou operaci).</br>"
            ]
            ,
            "incorrect": [
                "Přerušení je mechanismus, který umožňuje synchronizovat periferii a software –</br>v abstraktní rovině lze tedy o přerušení uvažovat jako o synchronizačním zařízení.</br>– přerušení je symetrické v tom smyslu, že ho může vyvolat jak periferie tak i operační systém.</br> Máme tedy zařízení, které je vždy aktivováno periferií nebo operačním systémem a ten druhý je</br>vždy pasivním účastníkem. Až na tyto rozdíly se přerušení podobá na podmínkovou proměnnou – slouží</br>k signalizaci nějaké události.",
                "Operační systém je samozřejmě program, který musí být vykonáván procesorem – proto</br>krom periferie a operačního systému musí do hry vstoupit i procesor.</br>Zejména se může stát, že ve chvíli, kdy přerušení nastane (je periferií vyvoláno), procesor nějaký</br>program právě vykonává. Navíc je často důležité, aby operační systém daný program nepřerušil násilím,</br>proto je přerušení realizováno postemptivně – cokoliv procesor v danou chvíli prováděl je dokončeno a</br>až poté se spustí obsluha přerušení.",
                "Instance přerušení</br>Obsluha přerušení je realizována podprogramem, kterého adresa je uvedena ve speciální</br>registru. Chápeme-li přerušení jako synchronizační zařízení (podobné podmínkové</br>proměnné), je přirozené, že může existovat ve vícero instancích. Protože je ale realizováno hardwarově</br>na relativně nízké úrovni, těchto instancí je pevný počet (často do 256).</br>Podprogram má pak pro každou instanci speciální funkci, tzv. řadič přerušení,</br>který určí který podprogram je daným přerušením aktivován.</br>Různé periferie pak typicky používají různé instance přerušení (instance jsou identifikovány číslem).",
                "Obslužný podprogram přerušení je (až na speciální prolog a epilog) stejný jako</br>libovolný jiný až na jednu vyjímku – může být třeba zapsaný v jazyce C, ale nemůže volat další podprogramy, protože jádro je jen jedno.</br>Proto musí mít k dispozici jak registry (zabezpečeno uložením stavu procesoru před jeho aktivací), tak zásobník.</br>Protože na zásobníku, který byl ve chvíli kdy k přerušení došlo, nemusí být volné místo, je obvyklé, že</br>dojde také k přepnutí zásobníku. Konečně procesor se přepne do režimu jádra (privilegovaného režimu)</br>– obsluha přerušení má tedy stejný privilegovaný přístup k výpočetním zdrojům jako jakákoliv jiná</br>součást jádra.",
                "Obsluha přerušení</br>se nápadně podobá na aktivaci vlákna. Zároveň má ale vlastnosti aktivace podprogramu,</br>protože může být aktivována, uložena a případně obnovena v budoucnu. Můžeme tak obsluhu přerušení chápat jako speciální typ vlákna.",
                "Obsluha přerušení musí řešit 3 synchronizační scénáře:</br>1. synchronizace s obsluhou souběžného přerušení vyvolané na stejném procesorovém jádře – zde je v nějakém smyslu největší volnost, obvykle lze</br>použít spinlocky, případně některé nezamykající komunikační zařízení,</br>2. synchronizace se zbytkem systému, který běžel na stejném procesorovém jádře a byl obsluhou přerušen</br>– zde spinlock nepřichází v úvahu, protože přerušený podprogram nemůže být spuštěn před ukončením</br>obsluhy,</br>3.  synchronizace se zbytkem systému, který běží paralelně na jiných procesorových jádrech (včetně</br>případné obsluhy přerušení tam probíhající) – spinlock</br>opět nepřichází v úvahu (ze stejného důvodu), pomůže zde ale speciální jednoúčelové synchronizační</br>zařízení – zákaz přerušení.</br>Je-li v platnosti zákaz daného přerušení, obsluha případného příchozího přerušení je odložena až do</br>chvíle, kdy je přerušení opět povoleno. Jedná se tak o formu vzájemného vyloučení specifickou pro</br>obslužné podprogramy.",
                "Vzpomeňme, že aktivace procesu je relativně drahá operace: musí se změnit mapování paměti.</br>Proto se při aktivaci obsluhy přerušení proces nepřepíná: běží v adresním prostoru, který byl zrovna</br>aktivní. To mimo jiné znamená, že struktury, které obsluha využívá, musí být nějakým způsobem dostupné pro všechny procesory.</br>Obsluha přerušení tak využívá speciální procesor přímo určený na tuto činnost.",
                "Struktura obsluhy</br>1. při vstupu do obsluhy přerušení se zakážou další přerušení (může vykonat přímo procesor jako součást</br>aktivace obsluhy) –</br>∘ minimálně toho typu, které bylo právě aktivováno, mají-li přerušení priority tak také všechna</br>přerušení nižších priorit, a v některých systémech úplně všechna přerušení,</br>∘ tím jsou ochráněny libovolné kritické sekce obsluhy přerušení vůči sobě samé, a také je tím</br>omezen počet aktivačních záznamů na zásobníku (jinak by hrozilo, že příliš mnoho rychle příchozích</br>přerušení zásobník vyčerpá),</br>2. obsluha vykoná minimální nutnou akci, která uvede systém do provozuschopného stavu:</br>∘ např. vyprázdní mezipaměti, které by jinak přetekly, a provede další akce, které nelze odložit,</br>∘ minimálně část plánovače je tohoto charakteru (je aktivován obsluhou přerušení časovače – více</br>později),</br>∘ libovolné datové struktury, které zde využívá, a které využívá i jiná část jádra, musí být </br>zamykatelné (spinlockem nebo jiným synchronizačním zařízením) nebo musí být v části jádra, která není chráněny zákazem přerušení,</br>3. naplánuje zbývající akce (obsluha druhé úrovně) na pozdější vykonání – tento krok vyžaduje komunikaci</br>se zbytkem jádra (někde musí informaci o potřebné návazné akci převzít jiná část jádra, která je</br>s obsluhou přerušení jinak souběžná).",
                "Notifikace</br>Nejzákladnější formou přerušení je notifikace – upozornění na nějakou obecnou událost.</br>Tento typ přerušení je extrémně spolehlivý a nedovoluje chyby, protože zdržení nebo i úplný výpadek obsluhy může</br>systém nebo data ohrozit. ",
                "DMA</br>Zařízení s větší šířkou pásma obvykle pro přenos dat používají DMA, tzn. režim, kdy periferie</br>přesouvá data do operační paměti souběžně s běžným provozem zbytku systému. Tyto přenosy je ale</br>nutné synchronizovat s operačním systémem (resp. s ovladačem zařízení, který je součástí operačního</br>systému).</br>Směrem k periferii je synchronizace realizována přerušením, opačným směrem ale podobný</br>mechanismus použít nelze – periferie místo toho zapisuje přímo do registrů procesoru.</br>",
                "Časovač - mainupalce s frontami vláken</br>Tyto operace musí být:</br>1. chráněny proti zásahům jiných procesorových jader (obvykle spinlockem, alternativně by mohl být</br>celý plánovač postaven na komunikačních zařízeních bez zámků; uspání zde nepřichází v úvahu),</br>2. chráněny proti přerušení (zákazem) a tedy musí být zároveň</br>3. efektivní (konstantní nebo nejvýše logaritmické v počtu vláken),</br>4. synchronizace v bodech 1 a 2 musí být velmi důsledně koordinovaná: plánovač musí zamknout spinlock,</br>a zároveň musí být platný zakáz přerušení (jinak by mohlo dojít k uváznutí), ale zároveň nesmí na</br>spinlock příliš dlouho čekat (protože musí být při čekání zakázaná přerušení, tzn. jedná se o časově</br>kritickou operaci).</br>"
            ]
        }
    ]

    /**
     * @param {number} themeNum
     */
    function renderTheme(themeNum, testAll = false) {
        const backBtn = document.createElement('button');
        backBtn.innerText = '⬅️Back';
        backBtn.className = 'px-4 py-2 bg-blue-500 text-white rounded';
        backBtn.onclick = () => {
            renderPickTheme();
        };
        const title = document.createElement('h1');
        title.innerText = `Theme ${testAll ? "all" : themeNum}`;
        title.className = 'text-2xl font-semibold';

        body.innerHTML = '';
        body.appendChild(backBtn);
        body.appendChild(title);

        const theme = (() => {
            if (testAll) {
                return drill.reduce((acc, {correct, incorrect}) => {
                    acc.correct.push(...correct);
                    acc.incorrect.push(...incorrect);
                    return acc;
                }, {correct: [], incorrect: []});
            }
            return drill.find((theme) => theme.section === themeNum);
        })();
        if (theme == null) {
            alert('theme is null');
            console.error('theme is null');
            renderPickTheme();
            return;
        }

        const correctNum = Math.floor(Math.random() * 3) + 1;
        const incorrectNum = 5 - correctNum;
        const mixed = [];

        /** type {Array.<string>} */
        const correct = []
        do {
            const index = Math.floor(Math.random() * theme.correct.length);
            if (correct.includes(theme.correct[index])) {
                continue;
            }
            correct.push(theme.correct[index]);
            mixed.push(theme.correct[index]);
        } while (correct.length < correctNum);

        /** type {Array.<string>} */
        const incorrect = []
        /** type {Array.<string>} */
        const incorrect_correct = []
        do {
            const index = Math.floor(Math.random() * theme.incorrect.length);
            if (incorrect.includes(theme.incorrect[index])) {
                continue;
            }
            incorrect.push(theme.incorrect[index]);
            incorrect_correct.push(theme.correct[index]);
            mixed.push(theme.incorrect[index]);
        } while (incorrect.length < incorrectNum);

        //shuffle
        for (let i = mixed.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [mixed[i], mixed[j]] = [mixed[j], mixed[i]];
        }

        const form = document.createElement('form');
        form.className = 'flex flex-col gap-2';
        mixed.forEach((question, index) => {
            const div = document.createElement('div');
            div.id = `question-${index}-wrapper`;
            div.className = 'flex flex-row gap-2 hover:bg-gray-100 p-2 border rounded items-center';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.value = question;
            checkbox.id = `question-${index}`;
            checkbox.className = 'w-5 h-5 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600';

            const label = document.createElement('label');
            label.className = 'flex-1';
            label.id = `question-${index}-label`;
            label.htmlFor = `question-${index}`;
            label.innerHTML = question;

            div.appendChild(checkbox);
            div.appendChild(label);
            form.appendChild(div);
        });
        form.onsubmit = (event) => {
            event.preventDefault();
            const checkboxes = Array.from(form.querySelectorAll('input[type="checkbox"]'));
            for (const checkbox of checkboxes) {
                checkbox.disabled = true;

                const wrapper = document.getElementById(`${checkbox.id}-wrapper`);
                wrapper.classList.remove('hover:bg-gray-100');
                if (correct.includes(checkbox.value)) {
                    wrapper.classList.add('bg-green-200');
                } else {
                    wrapper.classList.add('bg-red-200');
                    const label = document.getElementById(`${checkbox.id}-label`);
                    const toggleCorrectBtn = document.createElement('button');
                    const toggleIncorrectBtn = document.createElement('button');

                    toggleCorrectBtn.innerText = 'Show correct';
                    toggleCorrectBtn.className = 'px-2 py-1 italic underline font-semibold';
                    toggleCorrectBtn.onclick = () => {
                        const correct_value = incorrect_correct[incorrect.indexOf(checkbox.value)];
                        label.innerHTML = correct_value + '<br/><br/>';
                        label.appendChild(toggleIncorrectBtn);
                    };

                    toggleIncorrectBtn.innerText = 'Show incorrect';
                    toggleIncorrectBtn.className = 'px-2 py-1 italic underline font-semibold';
                    toggleIncorrectBtn.onclick = () => {
                        const incorrect_value = checkbox.value;
                        label.innerHTML = incorrect_value + '<br/><br/>';
                        label.appendChild(toggleCorrectBtn);
                    };

                    label.innerHTML = checkbox.value + '<br/><br/>';
                    label.appendChild(toggleCorrectBtn);
                }

                if (checkbox.checked && correct.includes(checkbox.value)) {
                    const correctIcon = document.createElement('span');
                    correctIcon.innerText = '✅';
                    correctIcon.className = 'text-green-500 text-3xl';
                    wrapper.appendChild(correctIcon);
                } else if (checkbox.checked && incorrect.includes(checkbox.value)) {
                    const incorrectIcon = document.createElement('span');
                    incorrectIcon.innerText = '❌';
                    incorrectIcon.className = 'text-red-500 text-3xl';
                    wrapper.appendChild(incorrectIcon);
                }
            }
        };

        const reload = document.createElement('button');
        reload.innerText = 'Reload';
        reload.className = 'px-6 py-4 bg-blue-500 text-white rounded';
        reload.onclick = () => {
            renderTheme(themeNum, testAll);
        };

        const submit = document.createElement('button');
        submit.type = 'submit';
        submit.innerText = 'Submit';
        submit.className = 'px-2 py-4 bg-blue-500 text-white rounded';
        submit.onclick = () => {
            form.onsubmit(new Event('submit'));
            form.appendChild(reload);
            form.removeChild(submit);
        };
        form.appendChild(submit);

        body.appendChild(form);
    }

    function renderPickTheme() {
        body.innerHTML = '<h1 class="text-2xl font-semibold">Pick theme</h1>';
        drill.forEach(({section, correct, incorrect}, index) => {
            if (section == null) {
                alert('section is null');
                console.error('section is null');
                return;
            }
            if (correct == null) {
                alert('correct is null');
                console.error('correct is null');
                return;
            }
            if (incorrect == null) {
                alert('incorrect is null');
                console.error('incorrect is null');
                return;
            }

            const button = document.createElement('button');
            button.className = 'py-2 px-4 m-2 bg-blue-500 text-white rounded';
            button.innerText = `Theme ${section}`;
            button.onclick = () => renderTheme(section);
            body.appendChild(button);
        });
        const button = document.createElement('button');
        button.className = 'py-2 px-4 m-2 bg-blue-500 text-white rounded';
        button.innerText = `All themes`;
        button.onclick = () => renderTheme(null, true);
        body.appendChild(button);
    }

    renderPickTheme();
</script>

</html>
