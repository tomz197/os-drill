function Hd(e,o){for(var n=0;n<o.length;n++){const t=o[n];if(typeof t!="string"&&!Array.isArray(t)){for(const r in t)if(r!=="default"&&!(r in e)){const a=Object.getOwnPropertyDescriptor(t,r);a&&Object.defineProperty(e,r,a.get?a:{enumerable:!0,get:()=>t[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const o=document.createElement("link").relList;if(o&&o.supports&&o.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))t(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&t(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function t(r){if(r.ep)return;r.ep=!0;const a=n(r);fetch(r.href,a)}})();function Xd(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Zd={exports:{}},ui={},Wd={exports:{}},J={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ur=Symbol.for("react.element"),Gk=Symbol.for("react.portal"),Jk=Symbol.for("react.fragment"),Qk=Symbol.for("react.strict_mode"),Yk=Symbol.for("react.profiler"),qk=Symbol.for("react.provider"),eh=Symbol.for("react.context"),oh=Symbol.for("react.forward_ref"),nh=Symbol.for("react.suspense"),th=Symbol.for("react.memo"),rh=Symbol.for("react.lazy"),$u=Symbol.iterator;function ah(e){return e===null||typeof e!="object"?null:(e=$u&&e[$u]||e["@@iterator"],typeof e=="function"?e:null)}var Gd={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Jd=Object.assign,Qd={};function It(e,o,n){this.props=e,this.context=o,this.refs=Qd,this.updater=n||Gd}It.prototype.isReactComponent={};It.prototype.setState=function(e,o){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,o,"setState")};It.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function Yd(){}Yd.prototype=It.prototype;function gc(e,o,n){this.props=e,this.context=o,this.refs=Qd,this.updater=n||Gd}var Tc=gc.prototype=new Yd;Tc.constructor=gc;Jd(Tc,It.prototype);Tc.isPureReactComponent=!0;var Hu=Array.isArray,qd=Object.prototype.hasOwnProperty,Nc={current:null},ep={key:!0,ref:!0,__self:!0,__source:!0};function op(e,o,n){var t,r={},a=null,i=null;if(o!=null)for(t in o.ref!==void 0&&(i=o.ref),o.key!==void 0&&(a=""+o.key),o)qd.call(o,t)&&!ep.hasOwnProperty(t)&&(r[t]=o[t]);var s=arguments.length-2;if(s===1)r.children=n;else if(1<s){for(var c=Array(s),u=0;u<s;u++)c[u]=arguments[u+2];r.children=c}if(e&&e.defaultProps)for(t in s=e.defaultProps,s)r[t]===void 0&&(r[t]=s[t]);return{$$typeof:Ur,type:e,key:a,ref:i,props:r,_owner:Nc.current}}function ih(e,o){return{$$typeof:Ur,type:e.type,key:o,ref:e.ref,props:e.props,_owner:e._owner}}function Pc(e){return typeof e=="object"&&e!==null&&e.$$typeof===Ur}function sh(e){var o={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return o[n]})}var Xu=/\/+/g;function Vi(e,o){return typeof e=="object"&&e!==null&&e.key!=null?sh(""+e.key):o.toString(36)}function ga(e,o,n,t,r){var a=typeof e;(a==="undefined"||a==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(a){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case Ur:case Gk:i=!0}}if(i)return i=e,r=r(i),e=t===""?"."+Vi(i,0):t,Hu(r)?(n="",e!=null&&(n=e.replace(Xu,"$&/")+"/"),ga(r,o,n,"",function(u){return u})):r!=null&&(Pc(r)&&(r=ih(r,n+(!r.key||i&&i.key===r.key?"":(""+r.key).replace(Xu,"$&/")+"/")+e)),o.push(r)),1;if(i=0,t=t===""?".":t+":",Hu(e))for(var s=0;s<e.length;s++){a=e[s];var c=t+Vi(a,s);i+=ga(a,o,n,c,r)}else if(c=ah(e),typeof c=="function")for(e=c.call(e),s=0;!(a=e.next()).done;)a=a.value,c=t+Vi(a,s++),i+=ga(a,o,n,c,r);else if(a==="object")throw o=String(e),Error("Objects are not valid as a React child (found: "+(o==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":o)+"). If you meant to render a collection of children, use an array instead.");return i}function qr(e,o,n){if(e==null)return e;var t=[],r=0;return ga(e,t,"","",function(a){return o.call(n,a,r++)}),t}function ch(e){if(e._status===-1){var o=e._result;o=o(),o.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=o)}if(e._status===1)return e._result.default;throw e._result}var De={current:null},Ta={transition:null},uh={ReactCurrentDispatcher:De,ReactCurrentBatchConfig:Ta,ReactCurrentOwner:Nc};function np(){throw Error("act(...) is not supported in production builds of React.")}J.Children={map:qr,forEach:function(e,o,n){qr(e,function(){o.apply(this,arguments)},n)},count:function(e){var o=0;return qr(e,function(){o++}),o},toArray:function(e){return qr(e,function(o){return o})||[]},only:function(e){if(!Pc(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};J.Component=It;J.Fragment=Jk;J.Profiler=Yk;J.PureComponent=gc;J.StrictMode=Qk;J.Suspense=nh;J.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=uh;J.act=np;J.cloneElement=function(e,o,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var t=Jd({},e.props),r=e.key,a=e.ref,i=e._owner;if(o!=null){if(o.ref!==void 0&&(a=o.ref,i=Nc.current),o.key!==void 0&&(r=""+o.key),e.type&&e.type.defaultProps)var s=e.type.defaultProps;for(c in o)qd.call(o,c)&&!ep.hasOwnProperty(c)&&(t[c]=o[c]===void 0&&s!==void 0?s[c]:o[c])}var c=arguments.length-2;if(c===1)t.children=n;else if(1<c){s=Array(c);for(var u=0;u<c;u++)s[u]=arguments[u+2];t.children=s}return{$$typeof:Ur,type:e.type,key:r,ref:a,props:t,_owner:i}};J.createContext=function(e){return e={$$typeof:eh,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:qk,_context:e},e.Consumer=e};J.createElement=op;J.createFactory=function(e){var o=op.bind(null,e);return o.type=e,o};J.createRef=function(){return{current:null}};J.forwardRef=function(e){return{$$typeof:oh,render:e}};J.isValidElement=Pc;J.lazy=function(e){return{$$typeof:rh,_payload:{_status:-1,_result:e},_init:ch}};J.memo=function(e,o){return{$$typeof:th,type:e,compare:o===void 0?null:o}};J.startTransition=function(e){var o=Ta.transition;Ta.transition={};try{e()}finally{Ta.transition=o}};J.unstable_act=np;J.useCallback=function(e,o){return De.current.useCallback(e,o)};J.useContext=function(e){return De.current.useContext(e)};J.useDebugValue=function(){};J.useDeferredValue=function(e){return De.current.useDeferredValue(e)};J.useEffect=function(e,o){return De.current.useEffect(e,o)};J.useId=function(){return De.current.useId()};J.useImperativeHandle=function(e,o,n){return De.current.useImperativeHandle(e,o,n)};J.useInsertionEffect=function(e,o){return De.current.useInsertionEffect(e,o)};J.useLayoutEffect=function(e,o){return De.current.useLayoutEffect(e,o)};J.useMemo=function(e,o){return De.current.useMemo(e,o)};J.useReducer=function(e,o,n){return De.current.useReducer(e,o,n)};J.useRef=function(e){return De.current.useRef(e)};J.useState=function(e){return De.current.useState(e)};J.useSyncExternalStore=function(e,o,n){return De.current.useSyncExternalStore(e,o,n)};J.useTransition=function(){return De.current.useTransition()};J.version="18.3.1";Wd.exports=J;var l=Wd.exports;const tp=Xd(l),rp=Hd({__proto__:null,default:tp},[l]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var lh=l,dh=Symbol.for("react.element"),ph=Symbol.for("react.fragment"),vh=Object.prototype.hasOwnProperty,mh=lh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,kh={key:!0,ref:!0,__self:!0,__source:!0};function ap(e,o,n){var t,r={},a=null,i=null;n!==void 0&&(a=""+n),o.key!==void 0&&(a=""+o.key),o.ref!==void 0&&(i=o.ref);for(t in o)vh.call(o,t)&&!kh.hasOwnProperty(t)&&(r[t]=o[t]);if(e&&e.defaultProps)for(t in o=e.defaultProps,o)r[t]===void 0&&(r[t]=o[t]);return{$$typeof:dh,type:e,key:a,ref:i,props:r,_owner:mh.current}}ui.Fragment=ph;ui.jsx=ap;ui.jsxs=ap;Zd.exports=ui;var j=Zd.exports,ys={},ip={exports:{}},qe={},sp={exports:{}},cp={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function o(M,U){var F=M.length;M.push(U);e:for(;0<F;){var W=F-1>>>1,ee=M[W];if(0<r(ee,U))M[W]=U,M[F]=ee,F=W;else break e}}function n(M){return M.length===0?null:M[0]}function t(M){if(M.length===0)return null;var U=M[0],F=M.pop();if(F!==U){M[0]=F;e:for(var W=0,ee=M.length,vo=ee>>>1;W<vo;){var Xe=2*(W+1)-1,Ze=M[Xe],Ve=Xe+1,oo=M[Ve];if(0>r(Ze,F))Ve<ee&&0>r(oo,Ze)?(M[W]=oo,M[Ve]=F,W=Ve):(M[W]=Ze,M[Xe]=F,W=Xe);else if(Ve<ee&&0>r(oo,F))M[W]=oo,M[Ve]=F,W=Ve;else break e}}return U}function r(M,U){var F=M.sortIndex-U.sortIndex;return F!==0?F:M.id-U.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;e.unstable_now=function(){return a.now()}}else{var i=Date,s=i.now();e.unstable_now=function(){return i.now()-s}}var c=[],u=[],d=1,p=null,v=3,z=!1,f=!1,h=!1,T=typeof setTimeout=="function"?setTimeout:null,k=typeof clearTimeout=="function"?clearTimeout:null,m=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function b(M){for(var U=n(u);U!==null;){if(U.callback===null)t(u);else if(U.startTime<=M)t(u),U.sortIndex=U.expirationTime,o(c,U);else break;U=n(u)}}function N(M){if(h=!1,b(M),!f)if(n(c)!==null)f=!0,He(S);else{var U=n(u);U!==null&&po(N,U.startTime-M)}}function S(M,U){f=!1,h&&(h=!1,k(C),C=-1),z=!0;var F=v;try{for(b(U),p=n(c);p!==null&&(!(p.expirationTime>U)||M&&!Z());){var W=p.callback;if(typeof W=="function"){p.callback=null,v=p.priorityLevel;var ee=W(p.expirationTime<=U);U=e.unstable_now(),typeof ee=="function"?p.callback=ee:p===n(c)&&t(c),b(U)}else t(c);p=n(c)}if(p!==null)var vo=!0;else{var Xe=n(u);Xe!==null&&po(N,Xe.startTime-U),vo=!1}return vo}finally{p=null,v=F,z=!1}}var A=!1,y=null,C=-1,R=5,V=-1;function Z(){return!(e.unstable_now()-V<R)}function B(){if(y!==null){var M=e.unstable_now();V=M;var U=!0;try{U=y(!0,M)}finally{U?oe():(A=!1,y=null)}}else A=!1}var oe;if(typeof m=="function")oe=function(){m(B)};else if(typeof MessageChannel<"u"){var ve=new MessageChannel,Le=ve.port2;ve.port1.onmessage=B,oe=function(){Le.postMessage(null)}}else oe=function(){T(B,0)};function He(M){y=M,A||(A=!0,oe())}function po(M,U){C=T(function(){M(e.unstable_now())},U)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(M){M.callback=null},e.unstable_continueExecution=function(){f||z||(f=!0,He(S))},e.unstable_forceFrameRate=function(M){0>M||125<M?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):R=0<M?Math.floor(1e3/M):5},e.unstable_getCurrentPriorityLevel=function(){return v},e.unstable_getFirstCallbackNode=function(){return n(c)},e.unstable_next=function(M){switch(v){case 1:case 2:case 3:var U=3;break;default:U=v}var F=v;v=U;try{return M()}finally{v=F}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(M,U){switch(M){case 1:case 2:case 3:case 4:case 5:break;default:M=3}var F=v;v=M;try{return U()}finally{v=F}},e.unstable_scheduleCallback=function(M,U,F){var W=e.unstable_now();switch(typeof F=="object"&&F!==null?(F=F.delay,F=typeof F=="number"&&0<F?W+F:W):F=W,M){case 1:var ee=-1;break;case 2:ee=250;break;case 5:ee=1073741823;break;case 4:ee=1e4;break;default:ee=5e3}return ee=F+ee,M={id:d++,callback:U,priorityLevel:M,startTime:F,expirationTime:ee,sortIndex:-1},F>W?(M.sortIndex=F,o(u,M),n(c)===null&&M===n(u)&&(h?(k(C),C=-1):h=!0,po(N,F-W))):(M.sortIndex=ee,o(c,M),f||z||(f=!0,He(S))),M},e.unstable_shouldYield=Z,e.unstable_wrapCallback=function(M){var U=v;return function(){var F=v;v=U;try{return M.apply(this,arguments)}finally{v=F}}}})(cp);sp.exports=cp;var hh=sp.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var bh=l,Ye=hh;function w(e){for(var o="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)o+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+o+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var up=new Set,br={};function Kn(e,o){Nt(e,o),Nt(e+"Capture",o)}function Nt(e,o){for(br[e]=o,e=0;e<o.length;e++)up.add(o[e])}var Fo=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),zs=Object.prototype.hasOwnProperty,yh=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Zu={},Wu={};function zh(e){return zs.call(Wu,e)?!0:zs.call(Zu,e)?!1:yh.test(e)?Wu[e]=!0:(Zu[e]=!0,!1)}function jh(e,o,n,t){if(n!==null&&n.type===0)return!1;switch(typeof o){case"function":case"symbol":return!0;case"boolean":return t?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function fh(e,o,n,t){if(o===null||typeof o>"u"||jh(e,o,n,t))return!0;if(t)return!1;if(n!==null)switch(n.type){case 3:return!o;case 4:return o===!1;case 5:return isNaN(o);case 6:return isNaN(o)||1>o}return!1}function Ue(e,o,n,t,r,a,i){this.acceptsBooleans=o===2||o===3||o===4,this.attributeName=t,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=o,this.sanitizeURL=a,this.removeEmptyString=i}var we={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){we[e]=new Ue(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var o=e[0];we[o]=new Ue(o,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){we[e]=new Ue(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){we[e]=new Ue(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){we[e]=new Ue(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){we[e]=new Ue(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){we[e]=new Ue(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){we[e]=new Ue(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){we[e]=new Ue(e,5,!1,e.toLowerCase(),null,!1,!1)});var xc=/[\-:]([a-z])/g;function Sc(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var o=e.replace(xc,Sc);we[o]=new Ue(o,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var o=e.replace(xc,Sc);we[o]=new Ue(o,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var o=e.replace(xc,Sc);we[o]=new Ue(o,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){we[e]=new Ue(e,1,!1,e.toLowerCase(),null,!1,!1)});we.xlinkHref=new Ue("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){we[e]=new Ue(e,1,!1,e.toLowerCase(),null,!0,!0)});function wc(e,o,n,t){var r=we.hasOwnProperty(o)?we[o]:null;(r!==null?r.type!==0:t||!(2<o.length)||o[0]!=="o"&&o[0]!=="O"||o[1]!=="n"&&o[1]!=="N")&&(fh(o,n,r,t)&&(n=null),t||r===null?zh(o)&&(n===null?e.removeAttribute(o):e.setAttribute(o,""+n)):r.mustUseProperty?e[r.propertyName]=n===null?r.type===3?!1:"":n:(o=r.attributeName,t=r.attributeNamespace,n===null?e.removeAttribute(o):(r=r.type,n=r===3||r===4&&n===!0?"":""+n,t?e.setAttributeNS(t,o,n):e.setAttribute(o,n))))}var $o=bh.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ea=Symbol.for("react.element"),ot=Symbol.for("react.portal"),nt=Symbol.for("react.fragment"),Cc=Symbol.for("react.strict_mode"),js=Symbol.for("react.profiler"),lp=Symbol.for("react.provider"),dp=Symbol.for("react.context"),Mc=Symbol.for("react.forward_ref"),fs=Symbol.for("react.suspense"),gs=Symbol.for("react.suspense_list"),Ic=Symbol.for("react.memo"),on=Symbol.for("react.lazy"),pp=Symbol.for("react.offscreen"),Gu=Symbol.iterator;function Kt(e){return e===null||typeof e!="object"?null:(e=Gu&&e[Gu]||e["@@iterator"],typeof e=="function"?e:null)}var pe=Object.assign,Oi;function nr(e){if(Oi===void 0)try{throw Error()}catch(n){var o=n.stack.trim().match(/\n( *(at )?)/);Oi=o&&o[1]||""}return`
`+Oi+e}var Ei=!1;function Ri(e,o){if(!e||Ei)return"";Ei=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(o)if(o=function(){throw Error()},Object.defineProperty(o.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(o,[])}catch(u){var t=u}Reflect.construct(e,[],o)}else{try{o.call()}catch(u){t=u}e.call(o.prototype)}else{try{throw Error()}catch(u){t=u}e()}}catch(u){if(u&&t&&typeof u.stack=="string"){for(var r=u.stack.split(`
`),a=t.stack.split(`
`),i=r.length-1,s=a.length-1;1<=i&&0<=s&&r[i]!==a[s];)s--;for(;1<=i&&0<=s;i--,s--)if(r[i]!==a[s]){if(i!==1||s!==1)do if(i--,s--,0>s||r[i]!==a[s]){var c=`
`+r[i].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}while(1<=i&&0<=s);break}}}finally{Ei=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?nr(e):""}function gh(e){switch(e.tag){case 5:return nr(e.type);case 16:return nr("Lazy");case 13:return nr("Suspense");case 19:return nr("SuspenseList");case 0:case 2:case 15:return e=Ri(e.type,!1),e;case 11:return e=Ri(e.type.render,!1),e;case 1:return e=Ri(e.type,!0),e;default:return""}}function Ts(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case nt:return"Fragment";case ot:return"Portal";case js:return"Profiler";case Cc:return"StrictMode";case fs:return"Suspense";case gs:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case dp:return(e.displayName||"Context")+".Consumer";case lp:return(e._context.displayName||"Context")+".Provider";case Mc:var o=e.render;return e=e.displayName,e||(e=o.displayName||o.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Ic:return o=e.displayName||null,o!==null?o:Ts(e.type)||"Memo";case on:o=e._payload,e=e._init;try{return Ts(e(o))}catch{}}return null}function Th(e){var o=e.type;switch(e.tag){case 24:return"Cache";case 9:return(o.displayName||"Context")+".Consumer";case 10:return(o._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=o.render,e=e.displayName||e.name||"",o.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return o;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Ts(o);case 8:return o===Cc?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof o=="function")return o.displayName||o.name||null;if(typeof o=="string")return o}return null}function hn(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function vp(e){var o=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(o==="checkbox"||o==="radio")}function Nh(e){var o=vp(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,o),t=""+e[o];if(!e.hasOwnProperty(o)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var r=n.get,a=n.set;return Object.defineProperty(e,o,{configurable:!0,get:function(){return r.call(this)},set:function(i){t=""+i,a.call(this,i)}}),Object.defineProperty(e,o,{enumerable:n.enumerable}),{getValue:function(){return t},setValue:function(i){t=""+i},stopTracking:function(){e._valueTracker=null,delete e[o]}}}}function oa(e){e._valueTracker||(e._valueTracker=Nh(e))}function mp(e){if(!e)return!1;var o=e._valueTracker;if(!o)return!0;var n=o.getValue(),t="";return e&&(t=vp(e)?e.checked?"true":"false":e.value),e=t,e!==n?(o.setValue(e),!0):!1}function Ra(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Ns(e,o){var n=o.checked;return pe({},o,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function Ju(e,o){var n=o.defaultValue==null?"":o.defaultValue,t=o.checked!=null?o.checked:o.defaultChecked;n=hn(o.value!=null?o.value:n),e._wrapperState={initialChecked:t,initialValue:n,controlled:o.type==="checkbox"||o.type==="radio"?o.checked!=null:o.value!=null}}function kp(e,o){o=o.checked,o!=null&&wc(e,"checked",o,!1)}function Ps(e,o){kp(e,o);var n=hn(o.value),t=o.type;if(n!=null)t==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(t==="submit"||t==="reset"){e.removeAttribute("value");return}o.hasOwnProperty("value")?xs(e,o.type,n):o.hasOwnProperty("defaultValue")&&xs(e,o.type,hn(o.defaultValue)),o.checked==null&&o.defaultChecked!=null&&(e.defaultChecked=!!o.defaultChecked)}function Qu(e,o,n){if(o.hasOwnProperty("value")||o.hasOwnProperty("defaultValue")){var t=o.type;if(!(t!=="submit"&&t!=="reset"||o.value!==void 0&&o.value!==null))return;o=""+e._wrapperState.initialValue,n||o===e.value||(e.value=o),e.defaultValue=o}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function xs(e,o,n){(o!=="number"||Ra(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var tr=Array.isArray;function kt(e,o,n,t){if(e=e.options,o){o={};for(var r=0;r<n.length;r++)o["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=o.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&t&&(e[n].defaultSelected=!0)}else{for(n=""+hn(n),o=null,r=0;r<e.length;r++){if(e[r].value===n){e[r].selected=!0,t&&(e[r].defaultSelected=!0);return}o!==null||e[r].disabled||(o=e[r])}o!==null&&(o.selected=!0)}}function Ss(e,o){if(o.dangerouslySetInnerHTML!=null)throw Error(w(91));return pe({},o,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function Yu(e,o){var n=o.value;if(n==null){if(n=o.children,o=o.defaultValue,n!=null){if(o!=null)throw Error(w(92));if(tr(n)){if(1<n.length)throw Error(w(93));n=n[0]}o=n}o==null&&(o=""),n=o}e._wrapperState={initialValue:hn(n)}}function hp(e,o){var n=hn(o.value),t=hn(o.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),o.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),t!=null&&(e.defaultValue=""+t)}function qu(e){var o=e.textContent;o===e._wrapperState.initialValue&&o!==""&&o!==null&&(e.value=o)}function bp(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ws(e,o){return e==null||e==="http://www.w3.org/1999/xhtml"?bp(o):e==="http://www.w3.org/2000/svg"&&o==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var na,yp=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(o,n,t,r){MSApp.execUnsafeLocalFunction(function(){return e(o,n,t,r)})}:e}(function(e,o){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=o;else{for(na=na||document.createElement("div"),na.innerHTML="<svg>"+o.valueOf().toString()+"</svg>",o=na.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;o.firstChild;)e.appendChild(o.firstChild)}});function yr(e,o){if(o){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=o;return}}e.textContent=o}var ir={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Ph=["Webkit","ms","Moz","O"];Object.keys(ir).forEach(function(e){Ph.forEach(function(o){o=o+e.charAt(0).toUpperCase()+e.substring(1),ir[o]=ir[e]})});function zp(e,o,n){return o==null||typeof o=="boolean"||o===""?"":n||typeof o!="number"||o===0||ir.hasOwnProperty(e)&&ir[e]?(""+o).trim():o+"px"}function jp(e,o){e=e.style;for(var n in o)if(o.hasOwnProperty(n)){var t=n.indexOf("--")===0,r=zp(n,o[n],t);n==="float"&&(n="cssFloat"),t?e.setProperty(n,r):e[n]=r}}var xh=pe({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Cs(e,o){if(o){if(xh[e]&&(o.children!=null||o.dangerouslySetInnerHTML!=null))throw Error(w(137,e));if(o.dangerouslySetInnerHTML!=null){if(o.children!=null)throw Error(w(60));if(typeof o.dangerouslySetInnerHTML!="object"||!("__html"in o.dangerouslySetInnerHTML))throw Error(w(61))}if(o.style!=null&&typeof o.style!="object")throw Error(w(62))}}function Ms(e,o){if(e.indexOf("-")===-1)return typeof o.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Is=null;function Ac(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var As=null,ht=null,bt=null;function el(e){if(e=Br(e)){if(typeof As!="function")throw Error(w(280));var o=e.stateNode;o&&(o=mi(o),As(e.stateNode,e.type,o))}}function fp(e){ht?bt?bt.push(e):bt=[e]:ht=e}function gp(){if(ht){var e=ht,o=bt;if(bt=ht=null,el(e),o)for(e=0;e<o.length;e++)el(o[e])}}function Tp(e,o){return e(o)}function Np(){}var Di=!1;function Pp(e,o,n){if(Di)return e(o,n);Di=!0;try{return Tp(e,o,n)}finally{Di=!1,(ht!==null||bt!==null)&&(Np(),gp())}}function zr(e,o){var n=e.stateNode;if(n===null)return null;var t=mi(n);if(t===null)return null;n=t[o];e:switch(o){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(t=!t.disabled)||(e=e.type,t=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!t;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(w(231,o,typeof n));return n}var Vs=!1;if(Fo)try{var $t={};Object.defineProperty($t,"passive",{get:function(){Vs=!0}}),window.addEventListener("test",$t,$t),window.removeEventListener("test",$t,$t)}catch{Vs=!1}function Sh(e,o,n,t,r,a,i,s,c){var u=Array.prototype.slice.call(arguments,3);try{o.apply(n,u)}catch(d){this.onError(d)}}var sr=!1,Da=null,Ua=!1,Os=null,wh={onError:function(e){sr=!0,Da=e}};function Ch(e,o,n,t,r,a,i,s,c){sr=!1,Da=null,Sh.apply(wh,arguments)}function Mh(e,o,n,t,r,a,i,s,c){if(Ch.apply(this,arguments),sr){if(sr){var u=Da;sr=!1,Da=null}else throw Error(w(198));Ua||(Ua=!0,Os=u)}}function $n(e){var o=e,n=e;if(e.alternate)for(;o.return;)o=o.return;else{e=o;do o=e,o.flags&4098&&(n=o.return),e=o.return;while(e)}return o.tag===3?n:null}function xp(e){if(e.tag===13){var o=e.memoizedState;if(o===null&&(e=e.alternate,e!==null&&(o=e.memoizedState)),o!==null)return o.dehydrated}return null}function ol(e){if($n(e)!==e)throw Error(w(188))}function Ih(e){var o=e.alternate;if(!o){if(o=$n(e),o===null)throw Error(w(188));return o!==e?null:e}for(var n=e,t=o;;){var r=n.return;if(r===null)break;var a=r.alternate;if(a===null){if(t=r.return,t!==null){n=t;continue}break}if(r.child===a.child){for(a=r.child;a;){if(a===n)return ol(r),e;if(a===t)return ol(r),o;a=a.sibling}throw Error(w(188))}if(n.return!==t.return)n=r,t=a;else{for(var i=!1,s=r.child;s;){if(s===n){i=!0,n=r,t=a;break}if(s===t){i=!0,t=r,n=a;break}s=s.sibling}if(!i){for(s=a.child;s;){if(s===n){i=!0,n=a,t=r;break}if(s===t){i=!0,t=a,n=r;break}s=s.sibling}if(!i)throw Error(w(189))}}if(n.alternate!==t)throw Error(w(190))}if(n.tag!==3)throw Error(w(188));return n.stateNode.current===n?e:o}function Sp(e){return e=Ih(e),e!==null?wp(e):null}function wp(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var o=wp(e);if(o!==null)return o;e=e.sibling}return null}var Cp=Ye.unstable_scheduleCallback,nl=Ye.unstable_cancelCallback,Ah=Ye.unstable_shouldYield,Vh=Ye.unstable_requestPaint,ke=Ye.unstable_now,Oh=Ye.unstable_getCurrentPriorityLevel,Vc=Ye.unstable_ImmediatePriority,Mp=Ye.unstable_UserBlockingPriority,La=Ye.unstable_NormalPriority,Eh=Ye.unstable_LowPriority,Ip=Ye.unstable_IdlePriority,li=null,Mo=null;function Rh(e){if(Mo&&typeof Mo.onCommitFiberRoot=="function")try{Mo.onCommitFiberRoot(li,e,void 0,(e.current.flags&128)===128)}catch{}}var jo=Math.clz32?Math.clz32:Lh,Dh=Math.log,Uh=Math.LN2;function Lh(e){return e>>>=0,e===0?32:31-(Dh(e)/Uh|0)|0}var ta=64,ra=4194304;function rr(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Fa(e,o){var n=e.pendingLanes;if(n===0)return 0;var t=0,r=e.suspendedLanes,a=e.pingedLanes,i=n&268435455;if(i!==0){var s=i&~r;s!==0?t=rr(s):(a&=i,a!==0&&(t=rr(a)))}else i=n&~r,i!==0?t=rr(i):a!==0&&(t=rr(a));if(t===0)return 0;if(o!==0&&o!==t&&!(o&r)&&(r=t&-t,a=o&-o,r>=a||r===16&&(a&4194240)!==0))return o;if(t&4&&(t|=n&16),o=e.entangledLanes,o!==0)for(e=e.entanglements,o&=t;0<o;)n=31-jo(o),r=1<<n,t|=e[n],o&=~r;return t}function Fh(e,o){switch(e){case 1:case 2:case 4:return o+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return o+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Bh(e,o){for(var n=e.suspendedLanes,t=e.pingedLanes,r=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-jo(a),s=1<<i,c=r[i];c===-1?(!(s&n)||s&t)&&(r[i]=Fh(s,o)):c<=o&&(e.expiredLanes|=s),a&=~s}}function Es(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function Ap(){var e=ta;return ta<<=1,!(ta&4194240)&&(ta=64),e}function Ui(e){for(var o=[],n=0;31>n;n++)o.push(e);return o}function Lr(e,o,n){e.pendingLanes|=o,o!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,o=31-jo(o),e[o]=n}function _h(e,o){var n=e.pendingLanes&~o;e.pendingLanes=o,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=o,e.mutableReadLanes&=o,e.entangledLanes&=o,o=e.entanglements;var t=e.eventTimes;for(e=e.expirationTimes;0<n;){var r=31-jo(n),a=1<<r;o[r]=0,t[r]=-1,e[r]=-1,n&=~a}}function Oc(e,o){var n=e.entangledLanes|=o;for(e=e.entanglements;n;){var t=31-jo(n),r=1<<t;r&o|e[t]&o&&(e[t]|=o),n&=~r}}var q=0;function Vp(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var Op,Ec,Ep,Rp,Dp,Rs=!1,aa=[],cn=null,un=null,ln=null,jr=new Map,fr=new Map,tn=[],Kh="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function tl(e,o){switch(e){case"focusin":case"focusout":cn=null;break;case"dragenter":case"dragleave":un=null;break;case"mouseover":case"mouseout":ln=null;break;case"pointerover":case"pointerout":jr.delete(o.pointerId);break;case"gotpointercapture":case"lostpointercapture":fr.delete(o.pointerId)}}function Ht(e,o,n,t,r,a){return e===null||e.nativeEvent!==a?(e={blockedOn:o,domEventName:n,eventSystemFlags:t,nativeEvent:a,targetContainers:[r]},o!==null&&(o=Br(o),o!==null&&Ec(o)),e):(e.eventSystemFlags|=t,o=e.targetContainers,r!==null&&o.indexOf(r)===-1&&o.push(r),e)}function $h(e,o,n,t,r){switch(o){case"focusin":return cn=Ht(cn,e,o,n,t,r),!0;case"dragenter":return un=Ht(un,e,o,n,t,r),!0;case"mouseover":return ln=Ht(ln,e,o,n,t,r),!0;case"pointerover":var a=r.pointerId;return jr.set(a,Ht(jr.get(a)||null,e,o,n,t,r)),!0;case"gotpointercapture":return a=r.pointerId,fr.set(a,Ht(fr.get(a)||null,e,o,n,t,r)),!0}return!1}function Up(e){var o=Pn(e.target);if(o!==null){var n=$n(o);if(n!==null){if(o=n.tag,o===13){if(o=xp(n),o!==null){e.blockedOn=o,Dp(e.priority,function(){Ep(n)});return}}else if(o===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Na(e){if(e.blockedOn!==null)return!1;for(var o=e.targetContainers;0<o.length;){var n=Ds(e.domEventName,e.eventSystemFlags,o[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var t=new n.constructor(n.type,n);Is=t,n.target.dispatchEvent(t),Is=null}else return o=Br(n),o!==null&&Ec(o),e.blockedOn=n,!1;o.shift()}return!0}function rl(e,o,n){Na(e)&&n.delete(o)}function Hh(){Rs=!1,cn!==null&&Na(cn)&&(cn=null),un!==null&&Na(un)&&(un=null),ln!==null&&Na(ln)&&(ln=null),jr.forEach(rl),fr.forEach(rl)}function Xt(e,o){e.blockedOn===o&&(e.blockedOn=null,Rs||(Rs=!0,Ye.unstable_scheduleCallback(Ye.unstable_NormalPriority,Hh)))}function gr(e){function o(r){return Xt(r,e)}if(0<aa.length){Xt(aa[0],e);for(var n=1;n<aa.length;n++){var t=aa[n];t.blockedOn===e&&(t.blockedOn=null)}}for(cn!==null&&Xt(cn,e),un!==null&&Xt(un,e),ln!==null&&Xt(ln,e),jr.forEach(o),fr.forEach(o),n=0;n<tn.length;n++)t=tn[n],t.blockedOn===e&&(t.blockedOn=null);for(;0<tn.length&&(n=tn[0],n.blockedOn===null);)Up(n),n.blockedOn===null&&tn.shift()}var yt=$o.ReactCurrentBatchConfig,Ba=!0;function Xh(e,o,n,t){var r=q,a=yt.transition;yt.transition=null;try{q=1,Rc(e,o,n,t)}finally{q=r,yt.transition=a}}function Zh(e,o,n,t){var r=q,a=yt.transition;yt.transition=null;try{q=4,Rc(e,o,n,t)}finally{q=r,yt.transition=a}}function Rc(e,o,n,t){if(Ba){var r=Ds(e,o,n,t);if(r===null)Wi(e,o,t,_a,n),tl(e,t);else if($h(r,e,o,n,t))t.stopPropagation();else if(tl(e,t),o&4&&-1<Kh.indexOf(e)){for(;r!==null;){var a=Br(r);if(a!==null&&Op(a),a=Ds(e,o,n,t),a===null&&Wi(e,o,t,_a,n),a===r)break;r=a}r!==null&&t.stopPropagation()}else Wi(e,o,t,null,n)}}var _a=null;function Ds(e,o,n,t){if(_a=null,e=Ac(t),e=Pn(e),e!==null)if(o=$n(e),o===null)e=null;else if(n=o.tag,n===13){if(e=xp(o),e!==null)return e;e=null}else if(n===3){if(o.stateNode.current.memoizedState.isDehydrated)return o.tag===3?o.stateNode.containerInfo:null;e=null}else o!==e&&(e=null);return _a=e,null}function Lp(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Oh()){case Vc:return 1;case Mp:return 4;case La:case Eh:return 16;case Ip:return 536870912;default:return 16}default:return 16}}var an=null,Dc=null,Pa=null;function Fp(){if(Pa)return Pa;var e,o=Dc,n=o.length,t,r="value"in an?an.value:an.textContent,a=r.length;for(e=0;e<n&&o[e]===r[e];e++);var i=n-e;for(t=1;t<=i&&o[n-t]===r[a-t];t++);return Pa=r.slice(e,1<t?1-t:void 0)}function xa(e){var o=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&o===13&&(e=13)):e=o,e===10&&(e=13),32<=e||e===13?e:0}function ia(){return!0}function al(){return!1}function eo(e){function o(n,t,r,a,i){this._reactName=n,this._targetInst=r,this.type=t,this.nativeEvent=a,this.target=i,this.currentTarget=null;for(var s in e)e.hasOwnProperty(s)&&(n=e[s],this[s]=n?n(a):a[s]);return this.isDefaultPrevented=(a.defaultPrevented!=null?a.defaultPrevented:a.returnValue===!1)?ia:al,this.isPropagationStopped=al,this}return pe(o.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=ia)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=ia)},persist:function(){},isPersistent:ia}),o}var At={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Uc=eo(At),Fr=pe({},At,{view:0,detail:0}),Wh=eo(Fr),Li,Fi,Zt,di=pe({},Fr,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Lc,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Zt&&(Zt&&e.type==="mousemove"?(Li=e.screenX-Zt.screenX,Fi=e.screenY-Zt.screenY):Fi=Li=0,Zt=e),Li)},movementY:function(e){return"movementY"in e?e.movementY:Fi}}),il=eo(di),Gh=pe({},di,{dataTransfer:0}),Jh=eo(Gh),Qh=pe({},Fr,{relatedTarget:0}),Bi=eo(Qh),Yh=pe({},At,{animationName:0,elapsedTime:0,pseudoElement:0}),qh=eo(Yh),eb=pe({},At,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),ob=eo(eb),nb=pe({},At,{data:0}),sl=eo(nb),tb={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},rb={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},ab={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function ib(e){var o=this.nativeEvent;return o.getModifierState?o.getModifierState(e):(e=ab[e])?!!o[e]:!1}function Lc(){return ib}var sb=pe({},Fr,{key:function(e){if(e.key){var o=tb[e.key]||e.key;if(o!=="Unidentified")return o}return e.type==="keypress"?(e=xa(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?rb[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Lc,charCode:function(e){return e.type==="keypress"?xa(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?xa(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),cb=eo(sb),ub=pe({},di,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),cl=eo(ub),lb=pe({},Fr,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Lc}),db=eo(lb),pb=pe({},At,{propertyName:0,elapsedTime:0,pseudoElement:0}),vb=eo(pb),mb=pe({},di,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),kb=eo(mb),hb=[9,13,27,32],Fc=Fo&&"CompositionEvent"in window,cr=null;Fo&&"documentMode"in document&&(cr=document.documentMode);var bb=Fo&&"TextEvent"in window&&!cr,Bp=Fo&&(!Fc||cr&&8<cr&&11>=cr),ul=" ",ll=!1;function _p(e,o){switch(e){case"keyup":return hb.indexOf(o.keyCode)!==-1;case"keydown":return o.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Kp(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var tt=!1;function yb(e,o){switch(e){case"compositionend":return Kp(o);case"keypress":return o.which!==32?null:(ll=!0,ul);case"textInput":return e=o.data,e===ul&&ll?null:e;default:return null}}function zb(e,o){if(tt)return e==="compositionend"||!Fc&&_p(e,o)?(e=Fp(),Pa=Dc=an=null,tt=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(o.ctrlKey||o.altKey||o.metaKey)||o.ctrlKey&&o.altKey){if(o.char&&1<o.char.length)return o.char;if(o.which)return String.fromCharCode(o.which)}return null;case"compositionend":return Bp&&o.locale!=="ko"?null:o.data;default:return null}}var jb={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function dl(e){var o=e&&e.nodeName&&e.nodeName.toLowerCase();return o==="input"?!!jb[e.type]:o==="textarea"}function $p(e,o,n,t){fp(t),o=Ka(o,"onChange"),0<o.length&&(n=new Uc("onChange","change",null,n,t),e.push({event:n,listeners:o}))}var ur=null,Tr=null;function fb(e){ov(e,0)}function pi(e){var o=it(e);if(mp(o))return e}function gb(e,o){if(e==="change")return o}var Hp=!1;if(Fo){var _i;if(Fo){var Ki="oninput"in document;if(!Ki){var pl=document.createElement("div");pl.setAttribute("oninput","return;"),Ki=typeof pl.oninput=="function"}_i=Ki}else _i=!1;Hp=_i&&(!document.documentMode||9<document.documentMode)}function vl(){ur&&(ur.detachEvent("onpropertychange",Xp),Tr=ur=null)}function Xp(e){if(e.propertyName==="value"&&pi(Tr)){var o=[];$p(o,Tr,e,Ac(e)),Pp(fb,o)}}function Tb(e,o,n){e==="focusin"?(vl(),ur=o,Tr=n,ur.attachEvent("onpropertychange",Xp)):e==="focusout"&&vl()}function Nb(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return pi(Tr)}function Pb(e,o){if(e==="click")return pi(o)}function xb(e,o){if(e==="input"||e==="change")return pi(o)}function Sb(e,o){return e===o&&(e!==0||1/e===1/o)||e!==e&&o!==o}var go=typeof Object.is=="function"?Object.is:Sb;function Nr(e,o){if(go(e,o))return!0;if(typeof e!="object"||e===null||typeof o!="object"||o===null)return!1;var n=Object.keys(e),t=Object.keys(o);if(n.length!==t.length)return!1;for(t=0;t<n.length;t++){var r=n[t];if(!zs.call(o,r)||!go(e[r],o[r]))return!1}return!0}function ml(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function kl(e,o){var n=ml(e);e=0;for(var t;n;){if(n.nodeType===3){if(t=e+n.textContent.length,e<=o&&t>=o)return{node:n,offset:o-e};e=t}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=ml(n)}}function Zp(e,o){return e&&o?e===o?!0:e&&e.nodeType===3?!1:o&&o.nodeType===3?Zp(e,o.parentNode):"contains"in e?e.contains(o):e.compareDocumentPosition?!!(e.compareDocumentPosition(o)&16):!1:!1}function Wp(){for(var e=window,o=Ra();o instanceof e.HTMLIFrameElement;){try{var n=typeof o.contentWindow.location.href=="string"}catch{n=!1}if(n)e=o.contentWindow;else break;o=Ra(e.document)}return o}function Bc(e){var o=e&&e.nodeName&&e.nodeName.toLowerCase();return o&&(o==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||o==="textarea"||e.contentEditable==="true")}function wb(e){var o=Wp(),n=e.focusedElem,t=e.selectionRange;if(o!==n&&n&&n.ownerDocument&&Zp(n.ownerDocument.documentElement,n)){if(t!==null&&Bc(n)){if(o=t.start,e=t.end,e===void 0&&(e=o),"selectionStart"in n)n.selectionStart=o,n.selectionEnd=Math.min(e,n.value.length);else if(e=(o=n.ownerDocument||document)&&o.defaultView||window,e.getSelection){e=e.getSelection();var r=n.textContent.length,a=Math.min(t.start,r);t=t.end===void 0?a:Math.min(t.end,r),!e.extend&&a>t&&(r=t,t=a,a=r),r=kl(n,a);var i=kl(n,t);r&&i&&(e.rangeCount!==1||e.anchorNode!==r.node||e.anchorOffset!==r.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&(o=o.createRange(),o.setStart(r.node,r.offset),e.removeAllRanges(),a>t?(e.addRange(o),e.extend(i.node,i.offset)):(o.setEnd(i.node,i.offset),e.addRange(o)))}}for(o=[],e=n;e=e.parentNode;)e.nodeType===1&&o.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<o.length;n++)e=o[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var Cb=Fo&&"documentMode"in document&&11>=document.documentMode,rt=null,Us=null,lr=null,Ls=!1;function hl(e,o,n){var t=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;Ls||rt==null||rt!==Ra(t)||(t=rt,"selectionStart"in t&&Bc(t)?t={start:t.selectionStart,end:t.selectionEnd}:(t=(t.ownerDocument&&t.ownerDocument.defaultView||window).getSelection(),t={anchorNode:t.anchorNode,anchorOffset:t.anchorOffset,focusNode:t.focusNode,focusOffset:t.focusOffset}),lr&&Nr(lr,t)||(lr=t,t=Ka(Us,"onSelect"),0<t.length&&(o=new Uc("onSelect","select",null,o,n),e.push({event:o,listeners:t}),o.target=rt)))}function sa(e,o){var n={};return n[e.toLowerCase()]=o.toLowerCase(),n["Webkit"+e]="webkit"+o,n["Moz"+e]="moz"+o,n}var at={animationend:sa("Animation","AnimationEnd"),animationiteration:sa("Animation","AnimationIteration"),animationstart:sa("Animation","AnimationStart"),transitionend:sa("Transition","TransitionEnd")},$i={},Gp={};Fo&&(Gp=document.createElement("div").style,"AnimationEvent"in window||(delete at.animationend.animation,delete at.animationiteration.animation,delete at.animationstart.animation),"TransitionEvent"in window||delete at.transitionend.transition);function vi(e){if($i[e])return $i[e];if(!at[e])return e;var o=at[e],n;for(n in o)if(o.hasOwnProperty(n)&&n in Gp)return $i[e]=o[n];return e}var Jp=vi("animationend"),Qp=vi("animationiteration"),Yp=vi("animationstart"),qp=vi("transitionend"),ev=new Map,bl="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function zn(e,o){ev.set(e,o),Kn(o,[e])}for(var Hi=0;Hi<bl.length;Hi++){var Xi=bl[Hi],Mb=Xi.toLowerCase(),Ib=Xi[0].toUpperCase()+Xi.slice(1);zn(Mb,"on"+Ib)}zn(Jp,"onAnimationEnd");zn(Qp,"onAnimationIteration");zn(Yp,"onAnimationStart");zn("dblclick","onDoubleClick");zn("focusin","onFocus");zn("focusout","onBlur");zn(qp,"onTransitionEnd");Nt("onMouseEnter",["mouseout","mouseover"]);Nt("onMouseLeave",["mouseout","mouseover"]);Nt("onPointerEnter",["pointerout","pointerover"]);Nt("onPointerLeave",["pointerout","pointerover"]);Kn("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Kn("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Kn("onBeforeInput",["compositionend","keypress","textInput","paste"]);Kn("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Kn("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Kn("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ar="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ab=new Set("cancel close invalid load scroll toggle".split(" ").concat(ar));function yl(e,o,n){var t=e.type||"unknown-event";e.currentTarget=n,Mh(t,o,void 0,e),e.currentTarget=null}function ov(e,o){o=(o&4)!==0;for(var n=0;n<e.length;n++){var t=e[n],r=t.event;t=t.listeners;e:{var a=void 0;if(o)for(var i=t.length-1;0<=i;i--){var s=t[i],c=s.instance,u=s.currentTarget;if(s=s.listener,c!==a&&r.isPropagationStopped())break e;yl(r,s,u),a=c}else for(i=0;i<t.length;i++){if(s=t[i],c=s.instance,u=s.currentTarget,s=s.listener,c!==a&&r.isPropagationStopped())break e;yl(r,s,u),a=c}}}if(Ua)throw e=Os,Ua=!1,Os=null,e}function re(e,o){var n=o[$s];n===void 0&&(n=o[$s]=new Set);var t=e+"__bubble";n.has(t)||(nv(o,e,2,!1),n.add(t))}function Zi(e,o,n){var t=0;o&&(t|=4),nv(n,e,t,o)}var ca="_reactListening"+Math.random().toString(36).slice(2);function Pr(e){if(!e[ca]){e[ca]=!0,up.forEach(function(n){n!=="selectionchange"&&(Ab.has(n)||Zi(n,!1,e),Zi(n,!0,e))});var o=e.nodeType===9?e:e.ownerDocument;o===null||o[ca]||(o[ca]=!0,Zi("selectionchange",!1,o))}}function nv(e,o,n,t){switch(Lp(o)){case 1:var r=Xh;break;case 4:r=Zh;break;default:r=Rc}n=r.bind(null,o,n,e),r=void 0,!Vs||o!=="touchstart"&&o!=="touchmove"&&o!=="wheel"||(r=!0),t?r!==void 0?e.addEventListener(o,n,{capture:!0,passive:r}):e.addEventListener(o,n,!0):r!==void 0?e.addEventListener(o,n,{passive:r}):e.addEventListener(o,n,!1)}function Wi(e,o,n,t,r){var a=t;if(!(o&1)&&!(o&2)&&t!==null)e:for(;;){if(t===null)return;var i=t.tag;if(i===3||i===4){var s=t.stateNode.containerInfo;if(s===r||s.nodeType===8&&s.parentNode===r)break;if(i===4)for(i=t.return;i!==null;){var c=i.tag;if((c===3||c===4)&&(c=i.stateNode.containerInfo,c===r||c.nodeType===8&&c.parentNode===r))return;i=i.return}for(;s!==null;){if(i=Pn(s),i===null)return;if(c=i.tag,c===5||c===6){t=a=i;continue e}s=s.parentNode}}t=t.return}Pp(function(){var u=a,d=Ac(n),p=[];e:{var v=ev.get(e);if(v!==void 0){var z=Uc,f=e;switch(e){case"keypress":if(xa(n)===0)break e;case"keydown":case"keyup":z=cb;break;case"focusin":f="focus",z=Bi;break;case"focusout":f="blur",z=Bi;break;case"beforeblur":case"afterblur":z=Bi;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":z=il;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":z=Jh;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":z=db;break;case Jp:case Qp:case Yp:z=qh;break;case qp:z=vb;break;case"scroll":z=Wh;break;case"wheel":z=kb;break;case"copy":case"cut":case"paste":z=ob;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":z=cl}var h=(o&4)!==0,T=!h&&e==="scroll",k=h?v!==null?v+"Capture":null:v;h=[];for(var m=u,b;m!==null;){b=m;var N=b.stateNode;if(b.tag===5&&N!==null&&(b=N,k!==null&&(N=zr(m,k),N!=null&&h.push(xr(m,N,b)))),T)break;m=m.return}0<h.length&&(v=new z(v,f,null,n,d),p.push({event:v,listeners:h}))}}if(!(o&7)){e:{if(v=e==="mouseover"||e==="pointerover",z=e==="mouseout"||e==="pointerout",v&&n!==Is&&(f=n.relatedTarget||n.fromElement)&&(Pn(f)||f[Bo]))break e;if((z||v)&&(v=d.window===d?d:(v=d.ownerDocument)?v.defaultView||v.parentWindow:window,z?(f=n.relatedTarget||n.toElement,z=u,f=f?Pn(f):null,f!==null&&(T=$n(f),f!==T||f.tag!==5&&f.tag!==6)&&(f=null)):(z=null,f=u),z!==f)){if(h=il,N="onMouseLeave",k="onMouseEnter",m="mouse",(e==="pointerout"||e==="pointerover")&&(h=cl,N="onPointerLeave",k="onPointerEnter",m="pointer"),T=z==null?v:it(z),b=f==null?v:it(f),v=new h(N,m+"leave",z,n,d),v.target=T,v.relatedTarget=b,N=null,Pn(d)===u&&(h=new h(k,m+"enter",f,n,d),h.target=b,h.relatedTarget=T,N=h),T=N,z&&f)o:{for(h=z,k=f,m=0,b=h;b;b=Jn(b))m++;for(b=0,N=k;N;N=Jn(N))b++;for(;0<m-b;)h=Jn(h),m--;for(;0<b-m;)k=Jn(k),b--;for(;m--;){if(h===k||k!==null&&h===k.alternate)break o;h=Jn(h),k=Jn(k)}h=null}else h=null;z!==null&&zl(p,v,z,h,!1),f!==null&&T!==null&&zl(p,T,f,h,!0)}}e:{if(v=u?it(u):window,z=v.nodeName&&v.nodeName.toLowerCase(),z==="select"||z==="input"&&v.type==="file")var S=gb;else if(dl(v))if(Hp)S=xb;else{S=Nb;var A=Tb}else(z=v.nodeName)&&z.toLowerCase()==="input"&&(v.type==="checkbox"||v.type==="radio")&&(S=Pb);if(S&&(S=S(e,u))){$p(p,S,n,d);break e}A&&A(e,v,u),e==="focusout"&&(A=v._wrapperState)&&A.controlled&&v.type==="number"&&xs(v,"number",v.value)}switch(A=u?it(u):window,e){case"focusin":(dl(A)||A.contentEditable==="true")&&(rt=A,Us=u,lr=null);break;case"focusout":lr=Us=rt=null;break;case"mousedown":Ls=!0;break;case"contextmenu":case"mouseup":case"dragend":Ls=!1,hl(p,n,d);break;case"selectionchange":if(Cb)break;case"keydown":case"keyup":hl(p,n,d)}var y;if(Fc)e:{switch(e){case"compositionstart":var C="onCompositionStart";break e;case"compositionend":C="onCompositionEnd";break e;case"compositionupdate":C="onCompositionUpdate";break e}C=void 0}else tt?_p(e,n)&&(C="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(C="onCompositionStart");C&&(Bp&&n.locale!=="ko"&&(tt||C!=="onCompositionStart"?C==="onCompositionEnd"&&tt&&(y=Fp()):(an=d,Dc="value"in an?an.value:an.textContent,tt=!0)),A=Ka(u,C),0<A.length&&(C=new sl(C,e,null,n,d),p.push({event:C,listeners:A}),y?C.data=y:(y=Kp(n),y!==null&&(C.data=y)))),(y=bb?yb(e,n):zb(e,n))&&(u=Ka(u,"onBeforeInput"),0<u.length&&(d=new sl("onBeforeInput","beforeinput",null,n,d),p.push({event:d,listeners:u}),d.data=y))}ov(p,o)})}function xr(e,o,n){return{instance:e,listener:o,currentTarget:n}}function Ka(e,o){for(var n=o+"Capture",t=[];e!==null;){var r=e,a=r.stateNode;r.tag===5&&a!==null&&(r=a,a=zr(e,n),a!=null&&t.unshift(xr(e,a,r)),a=zr(e,o),a!=null&&t.push(xr(e,a,r))),e=e.return}return t}function Jn(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function zl(e,o,n,t,r){for(var a=o._reactName,i=[];n!==null&&n!==t;){var s=n,c=s.alternate,u=s.stateNode;if(c!==null&&c===t)break;s.tag===5&&u!==null&&(s=u,r?(c=zr(n,a),c!=null&&i.unshift(xr(n,c,s))):r||(c=zr(n,a),c!=null&&i.push(xr(n,c,s)))),n=n.return}i.length!==0&&e.push({event:o,listeners:i})}var Vb=/\r\n?/g,Ob=/\u0000|\uFFFD/g;function jl(e){return(typeof e=="string"?e:""+e).replace(Vb,`
`).replace(Ob,"")}function ua(e,o,n){if(o=jl(o),jl(e)!==o&&n)throw Error(w(425))}function $a(){}var Fs=null,Bs=null;function _s(e,o){return e==="textarea"||e==="noscript"||typeof o.children=="string"||typeof o.children=="number"||typeof o.dangerouslySetInnerHTML=="object"&&o.dangerouslySetInnerHTML!==null&&o.dangerouslySetInnerHTML.__html!=null}var Ks=typeof setTimeout=="function"?setTimeout:void 0,Eb=typeof clearTimeout=="function"?clearTimeout:void 0,fl=typeof Promise=="function"?Promise:void 0,Rb=typeof queueMicrotask=="function"?queueMicrotask:typeof fl<"u"?function(e){return fl.resolve(null).then(e).catch(Db)}:Ks;function Db(e){setTimeout(function(){throw e})}function Gi(e,o){var n=o,t=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&r.nodeType===8)if(n=r.data,n==="/$"){if(t===0){e.removeChild(r),gr(o);return}t--}else n!=="$"&&n!=="$?"&&n!=="$!"||t++;n=r}while(n);gr(o)}function dn(e){for(;e!=null;e=e.nextSibling){var o=e.nodeType;if(o===1||o===3)break;if(o===8){if(o=e.data,o==="$"||o==="$!"||o==="$?")break;if(o==="/$")return null}}return e}function gl(e){e=e.previousSibling;for(var o=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(o===0)return e;o--}else n==="/$"&&o++}e=e.previousSibling}return null}var Vt=Math.random().toString(36).slice(2),So="__reactFiber$"+Vt,Sr="__reactProps$"+Vt,Bo="__reactContainer$"+Vt,$s="__reactEvents$"+Vt,Ub="__reactListeners$"+Vt,Lb="__reactHandles$"+Vt;function Pn(e){var o=e[So];if(o)return o;for(var n=e.parentNode;n;){if(o=n[Bo]||n[So]){if(n=o.alternate,o.child!==null||n!==null&&n.child!==null)for(e=gl(e);e!==null;){if(n=e[So])return n;e=gl(e)}return o}e=n,n=e.parentNode}return null}function Br(e){return e=e[So]||e[Bo],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function it(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(w(33))}function mi(e){return e[Sr]||null}var Hs=[],st=-1;function jn(e){return{current:e}}function ae(e){0>st||(e.current=Hs[st],Hs[st]=null,st--)}function ne(e,o){st++,Hs[st]=e.current,e.current=o}var bn={},Ae=jn(bn),_e=jn(!1),Vn=bn;function Pt(e,o){var n=e.type.contextTypes;if(!n)return bn;var t=e.stateNode;if(t&&t.__reactInternalMemoizedUnmaskedChildContext===o)return t.__reactInternalMemoizedMaskedChildContext;var r={},a;for(a in n)r[a]=o[a];return t&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=o,e.__reactInternalMemoizedMaskedChildContext=r),r}function Ke(e){return e=e.childContextTypes,e!=null}function Ha(){ae(_e),ae(Ae)}function Tl(e,o,n){if(Ae.current!==bn)throw Error(w(168));ne(Ae,o),ne(_e,n)}function tv(e,o,n){var t=e.stateNode;if(o=o.childContextTypes,typeof t.getChildContext!="function")return n;t=t.getChildContext();for(var r in t)if(!(r in o))throw Error(w(108,Th(e)||"Unknown",r));return pe({},n,t)}function Xa(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||bn,Vn=Ae.current,ne(Ae,e),ne(_e,_e.current),!0}function Nl(e,o,n){var t=e.stateNode;if(!t)throw Error(w(169));n?(e=tv(e,o,Vn),t.__reactInternalMemoizedMergedChildContext=e,ae(_e),ae(Ae),ne(Ae,e)):ae(_e),ne(_e,n)}var Eo=null,ki=!1,Ji=!1;function rv(e){Eo===null?Eo=[e]:Eo.push(e)}function Fb(e){ki=!0,rv(e)}function fn(){if(!Ji&&Eo!==null){Ji=!0;var e=0,o=q;try{var n=Eo;for(q=1;e<n.length;e++){var t=n[e];do t=t(!0);while(t!==null)}Eo=null,ki=!1}catch(r){throw Eo!==null&&(Eo=Eo.slice(e+1)),Cp(Vc,fn),r}finally{q=o,Ji=!1}}return null}var ct=[],ut=0,Za=null,Wa=0,ro=[],ao=0,On=null,Ro=1,Do="";function Tn(e,o){ct[ut++]=Wa,ct[ut++]=Za,Za=e,Wa=o}function av(e,o,n){ro[ao++]=Ro,ro[ao++]=Do,ro[ao++]=On,On=e;var t=Ro;e=Do;var r=32-jo(t)-1;t&=~(1<<r),n+=1;var a=32-jo(o)+r;if(30<a){var i=r-r%5;a=(t&(1<<i)-1).toString(32),t>>=i,r-=i,Ro=1<<32-jo(o)+r|n<<r|t,Do=a+e}else Ro=1<<a|n<<r|t,Do=e}function _c(e){e.return!==null&&(Tn(e,1),av(e,1,0))}function Kc(e){for(;e===Za;)Za=ct[--ut],ct[ut]=null,Wa=ct[--ut],ct[ut]=null;for(;e===On;)On=ro[--ao],ro[ao]=null,Do=ro[--ao],ro[ao]=null,Ro=ro[--ao],ro[ao]=null}var Qe=null,Je=null,ue=!1,yo=null;function iv(e,o){var n=so(5,null,null,0);n.elementType="DELETED",n.stateNode=o,n.return=e,o=e.deletions,o===null?(e.deletions=[n],e.flags|=16):o.push(n)}function Pl(e,o){switch(e.tag){case 5:var n=e.type;return o=o.nodeType!==1||n.toLowerCase()!==o.nodeName.toLowerCase()?null:o,o!==null?(e.stateNode=o,Qe=e,Je=dn(o.firstChild),!0):!1;case 6:return o=e.pendingProps===""||o.nodeType!==3?null:o,o!==null?(e.stateNode=o,Qe=e,Je=null,!0):!1;case 13:return o=o.nodeType!==8?null:o,o!==null?(n=On!==null?{id:Ro,overflow:Do}:null,e.memoizedState={dehydrated:o,treeContext:n,retryLane:1073741824},n=so(18,null,null,0),n.stateNode=o,n.return=e,e.child=n,Qe=e,Je=null,!0):!1;default:return!1}}function Xs(e){return(e.mode&1)!==0&&(e.flags&128)===0}function Zs(e){if(ue){var o=Je;if(o){var n=o;if(!Pl(e,o)){if(Xs(e))throw Error(w(418));o=dn(n.nextSibling);var t=Qe;o&&Pl(e,o)?iv(t,n):(e.flags=e.flags&-4097|2,ue=!1,Qe=e)}}else{if(Xs(e))throw Error(w(418));e.flags=e.flags&-4097|2,ue=!1,Qe=e}}}function xl(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Qe=e}function la(e){if(e!==Qe)return!1;if(!ue)return xl(e),ue=!0,!1;var o;if((o=e.tag!==3)&&!(o=e.tag!==5)&&(o=e.type,o=o!=="head"&&o!=="body"&&!_s(e.type,e.memoizedProps)),o&&(o=Je)){if(Xs(e))throw sv(),Error(w(418));for(;o;)iv(e,o),o=dn(o.nextSibling)}if(xl(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(w(317));e:{for(e=e.nextSibling,o=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(o===0){Je=dn(e.nextSibling);break e}o--}else n!=="$"&&n!=="$!"&&n!=="$?"||o++}e=e.nextSibling}Je=null}}else Je=Qe?dn(e.stateNode.nextSibling):null;return!0}function sv(){for(var e=Je;e;)e=dn(e.nextSibling)}function xt(){Je=Qe=null,ue=!1}function $c(e){yo===null?yo=[e]:yo.push(e)}var Bb=$o.ReactCurrentBatchConfig;function Wt(e,o,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(w(309));var t=n.stateNode}if(!t)throw Error(w(147,e));var r=t,a=""+e;return o!==null&&o.ref!==null&&typeof o.ref=="function"&&o.ref._stringRef===a?o.ref:(o=function(i){var s=r.refs;i===null?delete s[a]:s[a]=i},o._stringRef=a,o)}if(typeof e!="string")throw Error(w(284));if(!n._owner)throw Error(w(290,e))}return e}function da(e,o){throw e=Object.prototype.toString.call(o),Error(w(31,e==="[object Object]"?"object with keys {"+Object.keys(o).join(", ")+"}":e))}function Sl(e){var o=e._init;return o(e._payload)}function cv(e){function o(k,m){if(e){var b=k.deletions;b===null?(k.deletions=[m],k.flags|=16):b.push(m)}}function n(k,m){if(!e)return null;for(;m!==null;)o(k,m),m=m.sibling;return null}function t(k,m){for(k=new Map;m!==null;)m.key!==null?k.set(m.key,m):k.set(m.index,m),m=m.sibling;return k}function r(k,m){return k=kn(k,m),k.index=0,k.sibling=null,k}function a(k,m,b){return k.index=b,e?(b=k.alternate,b!==null?(b=b.index,b<m?(k.flags|=2,m):b):(k.flags|=2,m)):(k.flags|=1048576,m)}function i(k){return e&&k.alternate===null&&(k.flags|=2),k}function s(k,m,b,N){return m===null||m.tag!==6?(m=ts(b,k.mode,N),m.return=k,m):(m=r(m,b),m.return=k,m)}function c(k,m,b,N){var S=b.type;return S===nt?d(k,m,b.props.children,N,b.key):m!==null&&(m.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===on&&Sl(S)===m.type)?(N=r(m,b.props),N.ref=Wt(k,m,b),N.return=k,N):(N=Va(b.type,b.key,b.props,null,k.mode,N),N.ref=Wt(k,m,b),N.return=k,N)}function u(k,m,b,N){return m===null||m.tag!==4||m.stateNode.containerInfo!==b.containerInfo||m.stateNode.implementation!==b.implementation?(m=rs(b,k.mode,N),m.return=k,m):(m=r(m,b.children||[]),m.return=k,m)}function d(k,m,b,N,S){return m===null||m.tag!==7?(m=In(b,k.mode,N,S),m.return=k,m):(m=r(m,b),m.return=k,m)}function p(k,m,b){if(typeof m=="string"&&m!==""||typeof m=="number")return m=ts(""+m,k.mode,b),m.return=k,m;if(typeof m=="object"&&m!==null){switch(m.$$typeof){case ea:return b=Va(m.type,m.key,m.props,null,k.mode,b),b.ref=Wt(k,null,m),b.return=k,b;case ot:return m=rs(m,k.mode,b),m.return=k,m;case on:var N=m._init;return p(k,N(m._payload),b)}if(tr(m)||Kt(m))return m=In(m,k.mode,b,null),m.return=k,m;da(k,m)}return null}function v(k,m,b,N){var S=m!==null?m.key:null;if(typeof b=="string"&&b!==""||typeof b=="number")return S!==null?null:s(k,m,""+b,N);if(typeof b=="object"&&b!==null){switch(b.$$typeof){case ea:return b.key===S?c(k,m,b,N):null;case ot:return b.key===S?u(k,m,b,N):null;case on:return S=b._init,v(k,m,S(b._payload),N)}if(tr(b)||Kt(b))return S!==null?null:d(k,m,b,N,null);da(k,b)}return null}function z(k,m,b,N,S){if(typeof N=="string"&&N!==""||typeof N=="number")return k=k.get(b)||null,s(m,k,""+N,S);if(typeof N=="object"&&N!==null){switch(N.$$typeof){case ea:return k=k.get(N.key===null?b:N.key)||null,c(m,k,N,S);case ot:return k=k.get(N.key===null?b:N.key)||null,u(m,k,N,S);case on:var A=N._init;return z(k,m,b,A(N._payload),S)}if(tr(N)||Kt(N))return k=k.get(b)||null,d(m,k,N,S,null);da(m,N)}return null}function f(k,m,b,N){for(var S=null,A=null,y=m,C=m=0,R=null;y!==null&&C<b.length;C++){y.index>C?(R=y,y=null):R=y.sibling;var V=v(k,y,b[C],N);if(V===null){y===null&&(y=R);break}e&&y&&V.alternate===null&&o(k,y),m=a(V,m,C),A===null?S=V:A.sibling=V,A=V,y=R}if(C===b.length)return n(k,y),ue&&Tn(k,C),S;if(y===null){for(;C<b.length;C++)y=p(k,b[C],N),y!==null&&(m=a(y,m,C),A===null?S=y:A.sibling=y,A=y);return ue&&Tn(k,C),S}for(y=t(k,y);C<b.length;C++)R=z(y,k,C,b[C],N),R!==null&&(e&&R.alternate!==null&&y.delete(R.key===null?C:R.key),m=a(R,m,C),A===null?S=R:A.sibling=R,A=R);return e&&y.forEach(function(Z){return o(k,Z)}),ue&&Tn(k,C),S}function h(k,m,b,N){var S=Kt(b);if(typeof S!="function")throw Error(w(150));if(b=S.call(b),b==null)throw Error(w(151));for(var A=S=null,y=m,C=m=0,R=null,V=b.next();y!==null&&!V.done;C++,V=b.next()){y.index>C?(R=y,y=null):R=y.sibling;var Z=v(k,y,V.value,N);if(Z===null){y===null&&(y=R);break}e&&y&&Z.alternate===null&&o(k,y),m=a(Z,m,C),A===null?S=Z:A.sibling=Z,A=Z,y=R}if(V.done)return n(k,y),ue&&Tn(k,C),S;if(y===null){for(;!V.done;C++,V=b.next())V=p(k,V.value,N),V!==null&&(m=a(V,m,C),A===null?S=V:A.sibling=V,A=V);return ue&&Tn(k,C),S}for(y=t(k,y);!V.done;C++,V=b.next())V=z(y,k,C,V.value,N),V!==null&&(e&&V.alternate!==null&&y.delete(V.key===null?C:V.key),m=a(V,m,C),A===null?S=V:A.sibling=V,A=V);return e&&y.forEach(function(B){return o(k,B)}),ue&&Tn(k,C),S}function T(k,m,b,N){if(typeof b=="object"&&b!==null&&b.type===nt&&b.key===null&&(b=b.props.children),typeof b=="object"&&b!==null){switch(b.$$typeof){case ea:e:{for(var S=b.key,A=m;A!==null;){if(A.key===S){if(S=b.type,S===nt){if(A.tag===7){n(k,A.sibling),m=r(A,b.props.children),m.return=k,k=m;break e}}else if(A.elementType===S||typeof S=="object"&&S!==null&&S.$$typeof===on&&Sl(S)===A.type){n(k,A.sibling),m=r(A,b.props),m.ref=Wt(k,A,b),m.return=k,k=m;break e}n(k,A);break}else o(k,A);A=A.sibling}b.type===nt?(m=In(b.props.children,k.mode,N,b.key),m.return=k,k=m):(N=Va(b.type,b.key,b.props,null,k.mode,N),N.ref=Wt(k,m,b),N.return=k,k=N)}return i(k);case ot:e:{for(A=b.key;m!==null;){if(m.key===A)if(m.tag===4&&m.stateNode.containerInfo===b.containerInfo&&m.stateNode.implementation===b.implementation){n(k,m.sibling),m=r(m,b.children||[]),m.return=k,k=m;break e}else{n(k,m);break}else o(k,m);m=m.sibling}m=rs(b,k.mode,N),m.return=k,k=m}return i(k);case on:return A=b._init,T(k,m,A(b._payload),N)}if(tr(b))return f(k,m,b,N);if(Kt(b))return h(k,m,b,N);da(k,b)}return typeof b=="string"&&b!==""||typeof b=="number"?(b=""+b,m!==null&&m.tag===6?(n(k,m.sibling),m=r(m,b),m.return=k,k=m):(n(k,m),m=ts(b,k.mode,N),m.return=k,k=m),i(k)):n(k,m)}return T}var St=cv(!0),uv=cv(!1),Ga=jn(null),Ja=null,lt=null,Hc=null;function Xc(){Hc=lt=Ja=null}function Zc(e){var o=Ga.current;ae(Ga),e._currentValue=o}function Ws(e,o,n){for(;e!==null;){var t=e.alternate;if((e.childLanes&o)!==o?(e.childLanes|=o,t!==null&&(t.childLanes|=o)):t!==null&&(t.childLanes&o)!==o&&(t.childLanes|=o),e===n)break;e=e.return}}function zt(e,o){Ja=e,Hc=lt=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&o&&(Be=!0),e.firstContext=null)}function uo(e){var o=e._currentValue;if(Hc!==e)if(e={context:e,memoizedValue:o,next:null},lt===null){if(Ja===null)throw Error(w(308));lt=e,Ja.dependencies={lanes:0,firstContext:e}}else lt=lt.next=e;return o}var xn=null;function Wc(e){xn===null?xn=[e]:xn.push(e)}function lv(e,o,n,t){var r=o.interleaved;return r===null?(n.next=n,Wc(o)):(n.next=r.next,r.next=n),o.interleaved=n,_o(e,t)}function _o(e,o){e.lanes|=o;var n=e.alternate;for(n!==null&&(n.lanes|=o),n=e,e=e.return;e!==null;)e.childLanes|=o,n=e.alternate,n!==null&&(n.childLanes|=o),n=e,e=e.return;return n.tag===3?n.stateNode:null}var nn=!1;function Gc(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function dv(e,o){e=e.updateQueue,o.updateQueue===e&&(o.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Uo(e,o){return{eventTime:e,lane:o,tag:0,payload:null,callback:null,next:null}}function pn(e,o,n){var t=e.updateQueue;if(t===null)return null;if(t=t.shared,Y&2){var r=t.pending;return r===null?o.next=o:(o.next=r.next,r.next=o),t.pending=o,_o(e,n)}return r=t.interleaved,r===null?(o.next=o,Wc(t)):(o.next=r.next,r.next=o),t.interleaved=o,_o(e,n)}function Sa(e,o,n){if(o=o.updateQueue,o!==null&&(o=o.shared,(n&4194240)!==0)){var t=o.lanes;t&=e.pendingLanes,n|=t,o.lanes=n,Oc(e,n)}}function wl(e,o){var n=e.updateQueue,t=e.alternate;if(t!==null&&(t=t.updateQueue,n===t)){var r=null,a=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};a===null?r=a=i:a=a.next=i,n=n.next}while(n!==null);a===null?r=a=o:a=a.next=o}else r=a=o;n={baseState:t.baseState,firstBaseUpdate:r,lastBaseUpdate:a,shared:t.shared,effects:t.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=o:e.next=o,n.lastBaseUpdate=o}function Qa(e,o,n,t){var r=e.updateQueue;nn=!1;var a=r.firstBaseUpdate,i=r.lastBaseUpdate,s=r.shared.pending;if(s!==null){r.shared.pending=null;var c=s,u=c.next;c.next=null,i===null?a=u:i.next=u,i=c;var d=e.alternate;d!==null&&(d=d.updateQueue,s=d.lastBaseUpdate,s!==i&&(s===null?d.firstBaseUpdate=u:s.next=u,d.lastBaseUpdate=c))}if(a!==null){var p=r.baseState;i=0,d=u=c=null,s=a;do{var v=s.lane,z=s.eventTime;if((t&v)===v){d!==null&&(d=d.next={eventTime:z,lane:0,tag:s.tag,payload:s.payload,callback:s.callback,next:null});e:{var f=e,h=s;switch(v=o,z=n,h.tag){case 1:if(f=h.payload,typeof f=="function"){p=f.call(z,p,v);break e}p=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=h.payload,v=typeof f=="function"?f.call(z,p,v):f,v==null)break e;p=pe({},p,v);break e;case 2:nn=!0}}s.callback!==null&&s.lane!==0&&(e.flags|=64,v=r.effects,v===null?r.effects=[s]:v.push(s))}else z={eventTime:z,lane:v,tag:s.tag,payload:s.payload,callback:s.callback,next:null},d===null?(u=d=z,c=p):d=d.next=z,i|=v;if(s=s.next,s===null){if(s=r.shared.pending,s===null)break;v=s,s=v.next,v.next=null,r.lastBaseUpdate=v,r.shared.pending=null}}while(!0);if(d===null&&(c=p),r.baseState=c,r.firstBaseUpdate=u,r.lastBaseUpdate=d,o=r.shared.interleaved,o!==null){r=o;do i|=r.lane,r=r.next;while(r!==o)}else a===null&&(r.shared.lanes=0);Rn|=i,e.lanes=i,e.memoizedState=p}}function Cl(e,o,n){if(e=o.effects,o.effects=null,e!==null)for(o=0;o<e.length;o++){var t=e[o],r=t.callback;if(r!==null){if(t.callback=null,t=n,typeof r!="function")throw Error(w(191,r));r.call(t)}}}var _r={},Io=jn(_r),wr=jn(_r),Cr=jn(_r);function Sn(e){if(e===_r)throw Error(w(174));return e}function Jc(e,o){switch(ne(Cr,o),ne(wr,e),ne(Io,_r),e=o.nodeType,e){case 9:case 11:o=(o=o.documentElement)?o.namespaceURI:ws(null,"");break;default:e=e===8?o.parentNode:o,o=e.namespaceURI||null,e=e.tagName,o=ws(o,e)}ae(Io),ne(Io,o)}function wt(){ae(Io),ae(wr),ae(Cr)}function pv(e){Sn(Cr.current);var o=Sn(Io.current),n=ws(o,e.type);o!==n&&(ne(wr,e),ne(Io,n))}function Qc(e){wr.current===e&&(ae(Io),ae(wr))}var le=jn(0);function Ya(e){for(var o=e;o!==null;){if(o.tag===13){var n=o.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return o}else if(o.tag===19&&o.memoizedProps.revealOrder!==void 0){if(o.flags&128)return o}else if(o.child!==null){o.child.return=o,o=o.child;continue}if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return null;o=o.return}o.sibling.return=o.return,o=o.sibling}return null}var Qi=[];function Yc(){for(var e=0;e<Qi.length;e++)Qi[e]._workInProgressVersionPrimary=null;Qi.length=0}var wa=$o.ReactCurrentDispatcher,Yi=$o.ReactCurrentBatchConfig,En=0,de=null,ye=null,fe=null,qa=!1,dr=!1,Mr=0,_b=0;function Ce(){throw Error(w(321))}function qc(e,o){if(o===null)return!1;for(var n=0;n<o.length&&n<e.length;n++)if(!go(e[n],o[n]))return!1;return!0}function eu(e,o,n,t,r,a){if(En=a,de=o,o.memoizedState=null,o.updateQueue=null,o.lanes=0,wa.current=e===null||e.memoizedState===null?Xb:Zb,e=n(t,r),dr){a=0;do{if(dr=!1,Mr=0,25<=a)throw Error(w(301));a+=1,fe=ye=null,o.updateQueue=null,wa.current=Wb,e=n(t,r)}while(dr)}if(wa.current=ei,o=ye!==null&&ye.next!==null,En=0,fe=ye=de=null,qa=!1,o)throw Error(w(300));return e}function ou(){var e=Mr!==0;return Mr=0,e}function xo(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return fe===null?de.memoizedState=fe=e:fe=fe.next=e,fe}function lo(){if(ye===null){var e=de.alternate;e=e!==null?e.memoizedState:null}else e=ye.next;var o=fe===null?de.memoizedState:fe.next;if(o!==null)fe=o,ye=e;else{if(e===null)throw Error(w(310));ye=e,e={memoizedState:ye.memoizedState,baseState:ye.baseState,baseQueue:ye.baseQueue,queue:ye.queue,next:null},fe===null?de.memoizedState=fe=e:fe=fe.next=e}return fe}function Ir(e,o){return typeof o=="function"?o(e):o}function qi(e){var o=lo(),n=o.queue;if(n===null)throw Error(w(311));n.lastRenderedReducer=e;var t=ye,r=t.baseQueue,a=n.pending;if(a!==null){if(r!==null){var i=r.next;r.next=a.next,a.next=i}t.baseQueue=r=a,n.pending=null}if(r!==null){a=r.next,t=t.baseState;var s=i=null,c=null,u=a;do{var d=u.lane;if((En&d)===d)c!==null&&(c=c.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),t=u.hasEagerState?u.eagerState:e(t,u.action);else{var p={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};c===null?(s=c=p,i=t):c=c.next=p,de.lanes|=d,Rn|=d}u=u.next}while(u!==null&&u!==a);c===null?i=t:c.next=s,go(t,o.memoizedState)||(Be=!0),o.memoizedState=t,o.baseState=i,o.baseQueue=c,n.lastRenderedState=t}if(e=n.interleaved,e!==null){r=e;do a=r.lane,de.lanes|=a,Rn|=a,r=r.next;while(r!==e)}else r===null&&(n.lanes=0);return[o.memoizedState,n.dispatch]}function es(e){var o=lo(),n=o.queue;if(n===null)throw Error(w(311));n.lastRenderedReducer=e;var t=n.dispatch,r=n.pending,a=o.memoizedState;if(r!==null){n.pending=null;var i=r=r.next;do a=e(a,i.action),i=i.next;while(i!==r);go(a,o.memoizedState)||(Be=!0),o.memoizedState=a,o.baseQueue===null&&(o.baseState=a),n.lastRenderedState=a}return[a,t]}function vv(){}function mv(e,o){var n=de,t=lo(),r=o(),a=!go(t.memoizedState,r);if(a&&(t.memoizedState=r,Be=!0),t=t.queue,nu(bv.bind(null,n,t,e),[e]),t.getSnapshot!==o||a||fe!==null&&fe.memoizedState.tag&1){if(n.flags|=2048,Ar(9,hv.bind(null,n,t,r,o),void 0,null),ge===null)throw Error(w(349));En&30||kv(n,o,r)}return r}function kv(e,o,n){e.flags|=16384,e={getSnapshot:o,value:n},o=de.updateQueue,o===null?(o={lastEffect:null,stores:null},de.updateQueue=o,o.stores=[e]):(n=o.stores,n===null?o.stores=[e]:n.push(e))}function hv(e,o,n,t){o.value=n,o.getSnapshot=t,yv(o)&&zv(e)}function bv(e,o,n){return n(function(){yv(o)&&zv(e)})}function yv(e){var o=e.getSnapshot;e=e.value;try{var n=o();return!go(e,n)}catch{return!0}}function zv(e){var o=_o(e,1);o!==null&&fo(o,e,1,-1)}function Ml(e){var o=xo();return typeof e=="function"&&(e=e()),o.memoizedState=o.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Ir,lastRenderedState:e},o.queue=e,e=e.dispatch=Hb.bind(null,de,e),[o.memoizedState,e]}function Ar(e,o,n,t){return e={tag:e,create:o,destroy:n,deps:t,next:null},o=de.updateQueue,o===null?(o={lastEffect:null,stores:null},de.updateQueue=o,o.lastEffect=e.next=e):(n=o.lastEffect,n===null?o.lastEffect=e.next=e:(t=n.next,n.next=e,e.next=t,o.lastEffect=e)),e}function jv(){return lo().memoizedState}function Ca(e,o,n,t){var r=xo();de.flags|=e,r.memoizedState=Ar(1|o,n,void 0,t===void 0?null:t)}function hi(e,o,n,t){var r=lo();t=t===void 0?null:t;var a=void 0;if(ye!==null){var i=ye.memoizedState;if(a=i.destroy,t!==null&&qc(t,i.deps)){r.memoizedState=Ar(o,n,a,t);return}}de.flags|=e,r.memoizedState=Ar(1|o,n,a,t)}function Il(e,o){return Ca(8390656,8,e,o)}function nu(e,o){return hi(2048,8,e,o)}function fv(e,o){return hi(4,2,e,o)}function gv(e,o){return hi(4,4,e,o)}function Tv(e,o){if(typeof o=="function")return e=e(),o(e),function(){o(null)};if(o!=null)return e=e(),o.current=e,function(){o.current=null}}function Nv(e,o,n){return n=n!=null?n.concat([e]):null,hi(4,4,Tv.bind(null,o,e),n)}function tu(){}function Pv(e,o){var n=lo();o=o===void 0?null:o;var t=n.memoizedState;return t!==null&&o!==null&&qc(o,t[1])?t[0]:(n.memoizedState=[e,o],e)}function xv(e,o){var n=lo();o=o===void 0?null:o;var t=n.memoizedState;return t!==null&&o!==null&&qc(o,t[1])?t[0]:(e=e(),n.memoizedState=[e,o],e)}function Sv(e,o,n){return En&21?(go(n,o)||(n=Ap(),de.lanes|=n,Rn|=n,e.baseState=!0),o):(e.baseState&&(e.baseState=!1,Be=!0),e.memoizedState=n)}function Kb(e,o){var n=q;q=n!==0&&4>n?n:4,e(!0);var t=Yi.transition;Yi.transition={};try{e(!1),o()}finally{q=n,Yi.transition=t}}function wv(){return lo().memoizedState}function $b(e,o,n){var t=mn(e);if(n={lane:t,action:n,hasEagerState:!1,eagerState:null,next:null},Cv(e))Mv(o,n);else if(n=lv(e,o,n,t),n!==null){var r=Re();fo(n,e,t,r),Iv(n,o,t)}}function Hb(e,o,n){var t=mn(e),r={lane:t,action:n,hasEagerState:!1,eagerState:null,next:null};if(Cv(e))Mv(o,r);else{var a=e.alternate;if(e.lanes===0&&(a===null||a.lanes===0)&&(a=o.lastRenderedReducer,a!==null))try{var i=o.lastRenderedState,s=a(i,n);if(r.hasEagerState=!0,r.eagerState=s,go(s,i)){var c=o.interleaved;c===null?(r.next=r,Wc(o)):(r.next=c.next,c.next=r),o.interleaved=r;return}}catch{}finally{}n=lv(e,o,r,t),n!==null&&(r=Re(),fo(n,e,t,r),Iv(n,o,t))}}function Cv(e){var o=e.alternate;return e===de||o!==null&&o===de}function Mv(e,o){dr=qa=!0;var n=e.pending;n===null?o.next=o:(o.next=n.next,n.next=o),e.pending=o}function Iv(e,o,n){if(n&4194240){var t=o.lanes;t&=e.pendingLanes,n|=t,o.lanes=n,Oc(e,n)}}var ei={readContext:uo,useCallback:Ce,useContext:Ce,useEffect:Ce,useImperativeHandle:Ce,useInsertionEffect:Ce,useLayoutEffect:Ce,useMemo:Ce,useReducer:Ce,useRef:Ce,useState:Ce,useDebugValue:Ce,useDeferredValue:Ce,useTransition:Ce,useMutableSource:Ce,useSyncExternalStore:Ce,useId:Ce,unstable_isNewReconciler:!1},Xb={readContext:uo,useCallback:function(e,o){return xo().memoizedState=[e,o===void 0?null:o],e},useContext:uo,useEffect:Il,useImperativeHandle:function(e,o,n){return n=n!=null?n.concat([e]):null,Ca(4194308,4,Tv.bind(null,o,e),n)},useLayoutEffect:function(e,o){return Ca(4194308,4,e,o)},useInsertionEffect:function(e,o){return Ca(4,2,e,o)},useMemo:function(e,o){var n=xo();return o=o===void 0?null:o,e=e(),n.memoizedState=[e,o],e},useReducer:function(e,o,n){var t=xo();return o=n!==void 0?n(o):o,t.memoizedState=t.baseState=o,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:o},t.queue=e,e=e.dispatch=$b.bind(null,de,e),[t.memoizedState,e]},useRef:function(e){var o=xo();return e={current:e},o.memoizedState=e},useState:Ml,useDebugValue:tu,useDeferredValue:function(e){return xo().memoizedState=e},useTransition:function(){var e=Ml(!1),o=e[0];return e=Kb.bind(null,e[1]),xo().memoizedState=e,[o,e]},useMutableSource:function(){},useSyncExternalStore:function(e,o,n){var t=de,r=xo();if(ue){if(n===void 0)throw Error(w(407));n=n()}else{if(n=o(),ge===null)throw Error(w(349));En&30||kv(t,o,n)}r.memoizedState=n;var a={value:n,getSnapshot:o};return r.queue=a,Il(bv.bind(null,t,a,e),[e]),t.flags|=2048,Ar(9,hv.bind(null,t,a,n,o),void 0,null),n},useId:function(){var e=xo(),o=ge.identifierPrefix;if(ue){var n=Do,t=Ro;n=(t&~(1<<32-jo(t)-1)).toString(32)+n,o=":"+o+"R"+n,n=Mr++,0<n&&(o+="H"+n.toString(32)),o+=":"}else n=_b++,o=":"+o+"r"+n.toString(32)+":";return e.memoizedState=o},unstable_isNewReconciler:!1},Zb={readContext:uo,useCallback:Pv,useContext:uo,useEffect:nu,useImperativeHandle:Nv,useInsertionEffect:fv,useLayoutEffect:gv,useMemo:xv,useReducer:qi,useRef:jv,useState:function(){return qi(Ir)},useDebugValue:tu,useDeferredValue:function(e){var o=lo();return Sv(o,ye.memoizedState,e)},useTransition:function(){var e=qi(Ir)[0],o=lo().memoizedState;return[e,o]},useMutableSource:vv,useSyncExternalStore:mv,useId:wv,unstable_isNewReconciler:!1},Wb={readContext:uo,useCallback:Pv,useContext:uo,useEffect:nu,useImperativeHandle:Nv,useInsertionEffect:fv,useLayoutEffect:gv,useMemo:xv,useReducer:es,useRef:jv,useState:function(){return es(Ir)},useDebugValue:tu,useDeferredValue:function(e){var o=lo();return ye===null?o.memoizedState=e:Sv(o,ye.memoizedState,e)},useTransition:function(){var e=es(Ir)[0],o=lo().memoizedState;return[e,o]},useMutableSource:vv,useSyncExternalStore:mv,useId:wv,unstable_isNewReconciler:!1};function ko(e,o){if(e&&e.defaultProps){o=pe({},o),e=e.defaultProps;for(var n in e)o[n]===void 0&&(o[n]=e[n]);return o}return o}function Gs(e,o,n,t){o=e.memoizedState,n=n(t,o),n=n==null?o:pe({},o,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var bi={isMounted:function(e){return(e=e._reactInternals)?$n(e)===e:!1},enqueueSetState:function(e,o,n){e=e._reactInternals;var t=Re(),r=mn(e),a=Uo(t,r);a.payload=o,n!=null&&(a.callback=n),o=pn(e,a,r),o!==null&&(fo(o,e,r,t),Sa(o,e,r))},enqueueReplaceState:function(e,o,n){e=e._reactInternals;var t=Re(),r=mn(e),a=Uo(t,r);a.tag=1,a.payload=o,n!=null&&(a.callback=n),o=pn(e,a,r),o!==null&&(fo(o,e,r,t),Sa(o,e,r))},enqueueForceUpdate:function(e,o){e=e._reactInternals;var n=Re(),t=mn(e),r=Uo(n,t);r.tag=2,o!=null&&(r.callback=o),o=pn(e,r,t),o!==null&&(fo(o,e,t,n),Sa(o,e,t))}};function Al(e,o,n,t,r,a,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(t,a,i):o.prototype&&o.prototype.isPureReactComponent?!Nr(n,t)||!Nr(r,a):!0}function Av(e,o,n){var t=!1,r=bn,a=o.contextType;return typeof a=="object"&&a!==null?a=uo(a):(r=Ke(o)?Vn:Ae.current,t=o.contextTypes,a=(t=t!=null)?Pt(e,r):bn),o=new o(n,a),e.memoizedState=o.state!==null&&o.state!==void 0?o.state:null,o.updater=bi,e.stateNode=o,o._reactInternals=e,t&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=a),o}function Vl(e,o,n,t){e=o.state,typeof o.componentWillReceiveProps=="function"&&o.componentWillReceiveProps(n,t),typeof o.UNSAFE_componentWillReceiveProps=="function"&&o.UNSAFE_componentWillReceiveProps(n,t),o.state!==e&&bi.enqueueReplaceState(o,o.state,null)}function Js(e,o,n,t){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs={},Gc(e);var a=o.contextType;typeof a=="object"&&a!==null?r.context=uo(a):(a=Ke(o)?Vn:Ae.current,r.context=Pt(e,a)),r.state=e.memoizedState,a=o.getDerivedStateFromProps,typeof a=="function"&&(Gs(e,o,a,n),r.state=e.memoizedState),typeof o.getDerivedStateFromProps=="function"||typeof r.getSnapshotBeforeUpdate=="function"||typeof r.UNSAFE_componentWillMount!="function"&&typeof r.componentWillMount!="function"||(o=r.state,typeof r.componentWillMount=="function"&&r.componentWillMount(),typeof r.UNSAFE_componentWillMount=="function"&&r.UNSAFE_componentWillMount(),o!==r.state&&bi.enqueueReplaceState(r,r.state,null),Qa(e,n,r,t),r.state=e.memoizedState),typeof r.componentDidMount=="function"&&(e.flags|=4194308)}function Ct(e,o){try{var n="",t=o;do n+=gh(t),t=t.return;while(t);var r=n}catch(a){r=`
Error generating stack: `+a.message+`
`+a.stack}return{value:e,source:o,stack:r,digest:null}}function os(e,o,n){return{value:e,source:null,stack:n??null,digest:o??null}}function Qs(e,o){try{console.error(o.value)}catch(n){setTimeout(function(){throw n})}}var Gb=typeof WeakMap=="function"?WeakMap:Map;function Vv(e,o,n){n=Uo(-1,n),n.tag=3,n.payload={element:null};var t=o.value;return n.callback=function(){ni||(ni=!0,sc=t),Qs(e,o)},n}function Ov(e,o,n){n=Uo(-1,n),n.tag=3;var t=e.type.getDerivedStateFromError;if(typeof t=="function"){var r=o.value;n.payload=function(){return t(r)},n.callback=function(){Qs(e,o)}}var a=e.stateNode;return a!==null&&typeof a.componentDidCatch=="function"&&(n.callback=function(){Qs(e,o),typeof t!="function"&&(vn===null?vn=new Set([this]):vn.add(this));var i=o.stack;this.componentDidCatch(o.value,{componentStack:i!==null?i:""})}),n}function Ol(e,o,n){var t=e.pingCache;if(t===null){t=e.pingCache=new Gb;var r=new Set;t.set(o,r)}else r=t.get(o),r===void 0&&(r=new Set,t.set(o,r));r.has(n)||(r.add(n),e=uy.bind(null,e,o,n),o.then(e,e))}function El(e){do{var o;if((o=e.tag===13)&&(o=e.memoizedState,o=o!==null?o.dehydrated!==null:!0),o)return e;e=e.return}while(e!==null);return null}function Rl(e,o,n,t,r){return e.mode&1?(e.flags|=65536,e.lanes=r,e):(e===o?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(o=Uo(-1,1),o.tag=2,pn(n,o,1))),n.lanes|=1),e)}var Jb=$o.ReactCurrentOwner,Be=!1;function Ee(e,o,n,t){o.child=e===null?uv(o,null,n,t):St(o,e.child,n,t)}function Dl(e,o,n,t,r){n=n.render;var a=o.ref;return zt(o,r),t=eu(e,o,n,t,a,r),n=ou(),e!==null&&!Be?(o.updateQueue=e.updateQueue,o.flags&=-2053,e.lanes&=~r,Ko(e,o,r)):(ue&&n&&_c(o),o.flags|=1,Ee(e,o,t,r),o.child)}function Ul(e,o,n,t,r){if(e===null){var a=n.type;return typeof a=="function"&&!du(a)&&a.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(o.tag=15,o.type=a,Ev(e,o,a,t,r)):(e=Va(n.type,null,t,o,o.mode,r),e.ref=o.ref,e.return=o,o.child=e)}if(a=e.child,!(e.lanes&r)){var i=a.memoizedProps;if(n=n.compare,n=n!==null?n:Nr,n(i,t)&&e.ref===o.ref)return Ko(e,o,r)}return o.flags|=1,e=kn(a,t),e.ref=o.ref,e.return=o,o.child=e}function Ev(e,o,n,t,r){if(e!==null){var a=e.memoizedProps;if(Nr(a,t)&&e.ref===o.ref)if(Be=!1,o.pendingProps=t=a,(e.lanes&r)!==0)e.flags&131072&&(Be=!0);else return o.lanes=e.lanes,Ko(e,o,r)}return Ys(e,o,n,t,r)}function Rv(e,o,n){var t=o.pendingProps,r=t.children,a=e!==null?e.memoizedState:null;if(t.mode==="hidden")if(!(o.mode&1))o.memoizedState={baseLanes:0,cachePool:null,transitions:null},ne(pt,Ge),Ge|=n;else{if(!(n&1073741824))return e=a!==null?a.baseLanes|n:n,o.lanes=o.childLanes=1073741824,o.memoizedState={baseLanes:e,cachePool:null,transitions:null},o.updateQueue=null,ne(pt,Ge),Ge|=e,null;o.memoizedState={baseLanes:0,cachePool:null,transitions:null},t=a!==null?a.baseLanes:n,ne(pt,Ge),Ge|=t}else a!==null?(t=a.baseLanes|n,o.memoizedState=null):t=n,ne(pt,Ge),Ge|=t;return Ee(e,o,r,n),o.child}function Dv(e,o){var n=o.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(o.flags|=512,o.flags|=2097152)}function Ys(e,o,n,t,r){var a=Ke(n)?Vn:Ae.current;return a=Pt(o,a),zt(o,r),n=eu(e,o,n,t,a,r),t=ou(),e!==null&&!Be?(o.updateQueue=e.updateQueue,o.flags&=-2053,e.lanes&=~r,Ko(e,o,r)):(ue&&t&&_c(o),o.flags|=1,Ee(e,o,n,r),o.child)}function Ll(e,o,n,t,r){if(Ke(n)){var a=!0;Xa(o)}else a=!1;if(zt(o,r),o.stateNode===null)Ma(e,o),Av(o,n,t),Js(o,n,t,r),t=!0;else if(e===null){var i=o.stateNode,s=o.memoizedProps;i.props=s;var c=i.context,u=n.contextType;typeof u=="object"&&u!==null?u=uo(u):(u=Ke(n)?Vn:Ae.current,u=Pt(o,u));var d=n.getDerivedStateFromProps,p=typeof d=="function"||typeof i.getSnapshotBeforeUpdate=="function";p||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(s!==t||c!==u)&&Vl(o,i,t,u),nn=!1;var v=o.memoizedState;i.state=v,Qa(o,t,i,r),c=o.memoizedState,s!==t||v!==c||_e.current||nn?(typeof d=="function"&&(Gs(o,n,d,t),c=o.memoizedState),(s=nn||Al(o,n,s,t,v,c,u))?(p||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(o.flags|=4194308)):(typeof i.componentDidMount=="function"&&(o.flags|=4194308),o.memoizedProps=t,o.memoizedState=c),i.props=t,i.state=c,i.context=u,t=s):(typeof i.componentDidMount=="function"&&(o.flags|=4194308),t=!1)}else{i=o.stateNode,dv(e,o),s=o.memoizedProps,u=o.type===o.elementType?s:ko(o.type,s),i.props=u,p=o.pendingProps,v=i.context,c=n.contextType,typeof c=="object"&&c!==null?c=uo(c):(c=Ke(n)?Vn:Ae.current,c=Pt(o,c));var z=n.getDerivedStateFromProps;(d=typeof z=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(s!==p||v!==c)&&Vl(o,i,t,c),nn=!1,v=o.memoizedState,i.state=v,Qa(o,t,i,r);var f=o.memoizedState;s!==p||v!==f||_e.current||nn?(typeof z=="function"&&(Gs(o,n,z,t),f=o.memoizedState),(u=nn||Al(o,n,u,t,v,f,c)||!1)?(d||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(t,f,c),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(t,f,c)),typeof i.componentDidUpdate=="function"&&(o.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(o.flags|=1024)):(typeof i.componentDidUpdate!="function"||s===e.memoizedProps&&v===e.memoizedState||(o.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||s===e.memoizedProps&&v===e.memoizedState||(o.flags|=1024),o.memoizedProps=t,o.memoizedState=f),i.props=t,i.state=f,i.context=c,t=u):(typeof i.componentDidUpdate!="function"||s===e.memoizedProps&&v===e.memoizedState||(o.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||s===e.memoizedProps&&v===e.memoizedState||(o.flags|=1024),t=!1)}return qs(e,o,n,t,a,r)}function qs(e,o,n,t,r,a){Dv(e,o);var i=(o.flags&128)!==0;if(!t&&!i)return r&&Nl(o,n,!1),Ko(e,o,a);t=o.stateNode,Jb.current=o;var s=i&&typeof n.getDerivedStateFromError!="function"?null:t.render();return o.flags|=1,e!==null&&i?(o.child=St(o,e.child,null,a),o.child=St(o,null,s,a)):Ee(e,o,s,a),o.memoizedState=t.state,r&&Nl(o,n,!0),o.child}function Uv(e){var o=e.stateNode;o.pendingContext?Tl(e,o.pendingContext,o.pendingContext!==o.context):o.context&&Tl(e,o.context,!1),Jc(e,o.containerInfo)}function Fl(e,o,n,t,r){return xt(),$c(r),o.flags|=256,Ee(e,o,n,t),o.child}var ec={dehydrated:null,treeContext:null,retryLane:0};function oc(e){return{baseLanes:e,cachePool:null,transitions:null}}function Lv(e,o,n){var t=o.pendingProps,r=le.current,a=!1,i=(o.flags&128)!==0,s;if((s=i)||(s=e!==null&&e.memoizedState===null?!1:(r&2)!==0),s?(a=!0,o.flags&=-129):(e===null||e.memoizedState!==null)&&(r|=1),ne(le,r&1),e===null)return Zs(o),e=o.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(o.mode&1?e.data==="$!"?o.lanes=8:o.lanes=1073741824:o.lanes=1,null):(i=t.children,e=t.fallback,a?(t=o.mode,a=o.child,i={mode:"hidden",children:i},!(t&1)&&a!==null?(a.childLanes=0,a.pendingProps=i):a=ji(i,t,0,null),e=In(e,t,n,null),a.return=o,e.return=o,a.sibling=e,o.child=a,o.child.memoizedState=oc(n),o.memoizedState=ec,e):ru(o,i));if(r=e.memoizedState,r!==null&&(s=r.dehydrated,s!==null))return Qb(e,o,i,t,s,r,n);if(a){a=t.fallback,i=o.mode,r=e.child,s=r.sibling;var c={mode:"hidden",children:t.children};return!(i&1)&&o.child!==r?(t=o.child,t.childLanes=0,t.pendingProps=c,o.deletions=null):(t=kn(r,c),t.subtreeFlags=r.subtreeFlags&14680064),s!==null?a=kn(s,a):(a=In(a,i,n,null),a.flags|=2),a.return=o,t.return=o,t.sibling=a,o.child=t,t=a,a=o.child,i=e.child.memoizedState,i=i===null?oc(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},a.memoizedState=i,a.childLanes=e.childLanes&~n,o.memoizedState=ec,t}return a=e.child,e=a.sibling,t=kn(a,{mode:"visible",children:t.children}),!(o.mode&1)&&(t.lanes=n),t.return=o,t.sibling=null,e!==null&&(n=o.deletions,n===null?(o.deletions=[e],o.flags|=16):n.push(e)),o.child=t,o.memoizedState=null,t}function ru(e,o){return o=ji({mode:"visible",children:o},e.mode,0,null),o.return=e,e.child=o}function pa(e,o,n,t){return t!==null&&$c(t),St(o,e.child,null,n),e=ru(o,o.pendingProps.children),e.flags|=2,o.memoizedState=null,e}function Qb(e,o,n,t,r,a,i){if(n)return o.flags&256?(o.flags&=-257,t=os(Error(w(422))),pa(e,o,i,t)):o.memoizedState!==null?(o.child=e.child,o.flags|=128,null):(a=t.fallback,r=o.mode,t=ji({mode:"visible",children:t.children},r,0,null),a=In(a,r,i,null),a.flags|=2,t.return=o,a.return=o,t.sibling=a,o.child=t,o.mode&1&&St(o,e.child,null,i),o.child.memoizedState=oc(i),o.memoizedState=ec,a);if(!(o.mode&1))return pa(e,o,i,null);if(r.data==="$!"){if(t=r.nextSibling&&r.nextSibling.dataset,t)var s=t.dgst;return t=s,a=Error(w(419)),t=os(a,t,void 0),pa(e,o,i,t)}if(s=(i&e.childLanes)!==0,Be||s){if(t=ge,t!==null){switch(i&-i){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}r=r&(t.suspendedLanes|i)?0:r,r!==0&&r!==a.retryLane&&(a.retryLane=r,_o(e,r),fo(t,e,r,-1))}return lu(),t=os(Error(w(421))),pa(e,o,i,t)}return r.data==="$?"?(o.flags|=128,o.child=e.child,o=ly.bind(null,e),r._reactRetry=o,null):(e=a.treeContext,Je=dn(r.nextSibling),Qe=o,ue=!0,yo=null,e!==null&&(ro[ao++]=Ro,ro[ao++]=Do,ro[ao++]=On,Ro=e.id,Do=e.overflow,On=o),o=ru(o,t.children),o.flags|=4096,o)}function Bl(e,o,n){e.lanes|=o;var t=e.alternate;t!==null&&(t.lanes|=o),Ws(e.return,o,n)}function ns(e,o,n,t,r){var a=e.memoizedState;a===null?e.memoizedState={isBackwards:o,rendering:null,renderingStartTime:0,last:t,tail:n,tailMode:r}:(a.isBackwards=o,a.rendering=null,a.renderingStartTime=0,a.last=t,a.tail=n,a.tailMode=r)}function Fv(e,o,n){var t=o.pendingProps,r=t.revealOrder,a=t.tail;if(Ee(e,o,t.children,n),t=le.current,t&2)t=t&1|2,o.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=o.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&Bl(e,n,o);else if(e.tag===19)Bl(e,n,o);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===o)break e;for(;e.sibling===null;){if(e.return===null||e.return===o)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}t&=1}if(ne(le,t),!(o.mode&1))o.memoizedState=null;else switch(r){case"forwards":for(n=o.child,r=null;n!==null;)e=n.alternate,e!==null&&Ya(e)===null&&(r=n),n=n.sibling;n=r,n===null?(r=o.child,o.child=null):(r=n.sibling,n.sibling=null),ns(o,!1,r,n,a);break;case"backwards":for(n=null,r=o.child,o.child=null;r!==null;){if(e=r.alternate,e!==null&&Ya(e)===null){o.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}ns(o,!0,n,null,a);break;case"together":ns(o,!1,null,null,void 0);break;default:o.memoizedState=null}return o.child}function Ma(e,o){!(o.mode&1)&&e!==null&&(e.alternate=null,o.alternate=null,o.flags|=2)}function Ko(e,o,n){if(e!==null&&(o.dependencies=e.dependencies),Rn|=o.lanes,!(n&o.childLanes))return null;if(e!==null&&o.child!==e.child)throw Error(w(153));if(o.child!==null){for(e=o.child,n=kn(e,e.pendingProps),o.child=n,n.return=o;e.sibling!==null;)e=e.sibling,n=n.sibling=kn(e,e.pendingProps),n.return=o;n.sibling=null}return o.child}function Yb(e,o,n){switch(o.tag){case 3:Uv(o),xt();break;case 5:pv(o);break;case 1:Ke(o.type)&&Xa(o);break;case 4:Jc(o,o.stateNode.containerInfo);break;case 10:var t=o.type._context,r=o.memoizedProps.value;ne(Ga,t._currentValue),t._currentValue=r;break;case 13:if(t=o.memoizedState,t!==null)return t.dehydrated!==null?(ne(le,le.current&1),o.flags|=128,null):n&o.child.childLanes?Lv(e,o,n):(ne(le,le.current&1),e=Ko(e,o,n),e!==null?e.sibling:null);ne(le,le.current&1);break;case 19:if(t=(n&o.childLanes)!==0,e.flags&128){if(t)return Fv(e,o,n);o.flags|=128}if(r=o.memoizedState,r!==null&&(r.rendering=null,r.tail=null,r.lastEffect=null),ne(le,le.current),t)break;return null;case 22:case 23:return o.lanes=0,Rv(e,o,n)}return Ko(e,o,n)}var Bv,nc,_v,Kv;Bv=function(e,o){for(var n=o.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===o)break;for(;n.sibling===null;){if(n.return===null||n.return===o)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};nc=function(){};_v=function(e,o,n,t){var r=e.memoizedProps;if(r!==t){e=o.stateNode,Sn(Io.current);var a=null;switch(n){case"input":r=Ns(e,r),t=Ns(e,t),a=[];break;case"select":r=pe({},r,{value:void 0}),t=pe({},t,{value:void 0}),a=[];break;case"textarea":r=Ss(e,r),t=Ss(e,t),a=[];break;default:typeof r.onClick!="function"&&typeof t.onClick=="function"&&(e.onclick=$a)}Cs(n,t);var i;n=null;for(u in r)if(!t.hasOwnProperty(u)&&r.hasOwnProperty(u)&&r[u]!=null)if(u==="style"){var s=r[u];for(i in s)s.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(br.hasOwnProperty(u)?a||(a=[]):(a=a||[]).push(u,null));for(u in t){var c=t[u];if(s=r!=null?r[u]:void 0,t.hasOwnProperty(u)&&c!==s&&(c!=null||s!=null))if(u==="style")if(s){for(i in s)!s.hasOwnProperty(i)||c&&c.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in c)c.hasOwnProperty(i)&&s[i]!==c[i]&&(n||(n={}),n[i]=c[i])}else n||(a||(a=[]),a.push(u,n)),n=c;else u==="dangerouslySetInnerHTML"?(c=c?c.__html:void 0,s=s?s.__html:void 0,c!=null&&s!==c&&(a=a||[]).push(u,c)):u==="children"?typeof c!="string"&&typeof c!="number"||(a=a||[]).push(u,""+c):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(br.hasOwnProperty(u)?(c!=null&&u==="onScroll"&&re("scroll",e),a||s===c||(a=[])):(a=a||[]).push(u,c))}n&&(a=a||[]).push("style",n);var u=a;(o.updateQueue=u)&&(o.flags|=4)}};Kv=function(e,o,n,t){n!==t&&(o.flags|=4)};function Gt(e,o){if(!ue)switch(e.tailMode){case"hidden":o=e.tail;for(var n=null;o!==null;)o.alternate!==null&&(n=o),o=o.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var t=null;n!==null;)n.alternate!==null&&(t=n),n=n.sibling;t===null?o||e.tail===null?e.tail=null:e.tail.sibling=null:t.sibling=null}}function Me(e){var o=e.alternate!==null&&e.alternate.child===e.child,n=0,t=0;if(o)for(var r=e.child;r!==null;)n|=r.lanes|r.childLanes,t|=r.subtreeFlags&14680064,t|=r.flags&14680064,r.return=e,r=r.sibling;else for(r=e.child;r!==null;)n|=r.lanes|r.childLanes,t|=r.subtreeFlags,t|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=t,e.childLanes=n,o}function qb(e,o,n){var t=o.pendingProps;switch(Kc(o),o.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Me(o),null;case 1:return Ke(o.type)&&Ha(),Me(o),null;case 3:return t=o.stateNode,wt(),ae(_e),ae(Ae),Yc(),t.pendingContext&&(t.context=t.pendingContext,t.pendingContext=null),(e===null||e.child===null)&&(la(o)?o.flags|=4:e===null||e.memoizedState.isDehydrated&&!(o.flags&256)||(o.flags|=1024,yo!==null&&(lc(yo),yo=null))),nc(e,o),Me(o),null;case 5:Qc(o);var r=Sn(Cr.current);if(n=o.type,e!==null&&o.stateNode!=null)_v(e,o,n,t,r),e.ref!==o.ref&&(o.flags|=512,o.flags|=2097152);else{if(!t){if(o.stateNode===null)throw Error(w(166));return Me(o),null}if(e=Sn(Io.current),la(o)){t=o.stateNode,n=o.type;var a=o.memoizedProps;switch(t[So]=o,t[Sr]=a,e=(o.mode&1)!==0,n){case"dialog":re("cancel",t),re("close",t);break;case"iframe":case"object":case"embed":re("load",t);break;case"video":case"audio":for(r=0;r<ar.length;r++)re(ar[r],t);break;case"source":re("error",t);break;case"img":case"image":case"link":re("error",t),re("load",t);break;case"details":re("toggle",t);break;case"input":Ju(t,a),re("invalid",t);break;case"select":t._wrapperState={wasMultiple:!!a.multiple},re("invalid",t);break;case"textarea":Yu(t,a),re("invalid",t)}Cs(n,a),r=null;for(var i in a)if(a.hasOwnProperty(i)){var s=a[i];i==="children"?typeof s=="string"?t.textContent!==s&&(a.suppressHydrationWarning!==!0&&ua(t.textContent,s,e),r=["children",s]):typeof s=="number"&&t.textContent!==""+s&&(a.suppressHydrationWarning!==!0&&ua(t.textContent,s,e),r=["children",""+s]):br.hasOwnProperty(i)&&s!=null&&i==="onScroll"&&re("scroll",t)}switch(n){case"input":oa(t),Qu(t,a,!0);break;case"textarea":oa(t),qu(t);break;case"select":case"option":break;default:typeof a.onClick=="function"&&(t.onclick=$a)}t=r,o.updateQueue=t,t!==null&&(o.flags|=4)}else{i=r.nodeType===9?r:r.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=bp(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=i.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof t.is=="string"?e=i.createElement(n,{is:t.is}):(e=i.createElement(n),n==="select"&&(i=e,t.multiple?i.multiple=!0:t.size&&(i.size=t.size))):e=i.createElementNS(e,n),e[So]=o,e[Sr]=t,Bv(e,o,!1,!1),o.stateNode=e;e:{switch(i=Ms(n,t),n){case"dialog":re("cancel",e),re("close",e),r=t;break;case"iframe":case"object":case"embed":re("load",e),r=t;break;case"video":case"audio":for(r=0;r<ar.length;r++)re(ar[r],e);r=t;break;case"source":re("error",e),r=t;break;case"img":case"image":case"link":re("error",e),re("load",e),r=t;break;case"details":re("toggle",e),r=t;break;case"input":Ju(e,t),r=Ns(e,t),re("invalid",e);break;case"option":r=t;break;case"select":e._wrapperState={wasMultiple:!!t.multiple},r=pe({},t,{value:void 0}),re("invalid",e);break;case"textarea":Yu(e,t),r=Ss(e,t),re("invalid",e);break;default:r=t}Cs(n,r),s=r;for(a in s)if(s.hasOwnProperty(a)){var c=s[a];a==="style"?jp(e,c):a==="dangerouslySetInnerHTML"?(c=c?c.__html:void 0,c!=null&&yp(e,c)):a==="children"?typeof c=="string"?(n!=="textarea"||c!=="")&&yr(e,c):typeof c=="number"&&yr(e,""+c):a!=="suppressContentEditableWarning"&&a!=="suppressHydrationWarning"&&a!=="autoFocus"&&(br.hasOwnProperty(a)?c!=null&&a==="onScroll"&&re("scroll",e):c!=null&&wc(e,a,c,i))}switch(n){case"input":oa(e),Qu(e,t,!1);break;case"textarea":oa(e),qu(e);break;case"option":t.value!=null&&e.setAttribute("value",""+hn(t.value));break;case"select":e.multiple=!!t.multiple,a=t.value,a!=null?kt(e,!!t.multiple,a,!1):t.defaultValue!=null&&kt(e,!!t.multiple,t.defaultValue,!0);break;default:typeof r.onClick=="function"&&(e.onclick=$a)}switch(n){case"button":case"input":case"select":case"textarea":t=!!t.autoFocus;break e;case"img":t=!0;break e;default:t=!1}}t&&(o.flags|=4)}o.ref!==null&&(o.flags|=512,o.flags|=2097152)}return Me(o),null;case 6:if(e&&o.stateNode!=null)Kv(e,o,e.memoizedProps,t);else{if(typeof t!="string"&&o.stateNode===null)throw Error(w(166));if(n=Sn(Cr.current),Sn(Io.current),la(o)){if(t=o.stateNode,n=o.memoizedProps,t[So]=o,(a=t.nodeValue!==n)&&(e=Qe,e!==null))switch(e.tag){case 3:ua(t.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&ua(t.nodeValue,n,(e.mode&1)!==0)}a&&(o.flags|=4)}else t=(n.nodeType===9?n:n.ownerDocument).createTextNode(t),t[So]=o,o.stateNode=t}return Me(o),null;case 13:if(ae(le),t=o.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(ue&&Je!==null&&o.mode&1&&!(o.flags&128))sv(),xt(),o.flags|=98560,a=!1;else if(a=la(o),t!==null&&t.dehydrated!==null){if(e===null){if(!a)throw Error(w(318));if(a=o.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(w(317));a[So]=o}else xt(),!(o.flags&128)&&(o.memoizedState=null),o.flags|=4;Me(o),a=!1}else yo!==null&&(lc(yo),yo=null),a=!0;if(!a)return o.flags&65536?o:null}return o.flags&128?(o.lanes=n,o):(t=t!==null,t!==(e!==null&&e.memoizedState!==null)&&t&&(o.child.flags|=8192,o.mode&1&&(e===null||le.current&1?ze===0&&(ze=3):lu())),o.updateQueue!==null&&(o.flags|=4),Me(o),null);case 4:return wt(),nc(e,o),e===null&&Pr(o.stateNode.containerInfo),Me(o),null;case 10:return Zc(o.type._context),Me(o),null;case 17:return Ke(o.type)&&Ha(),Me(o),null;case 19:if(ae(le),a=o.memoizedState,a===null)return Me(o),null;if(t=(o.flags&128)!==0,i=a.rendering,i===null)if(t)Gt(a,!1);else{if(ze!==0||e!==null&&e.flags&128)for(e=o.child;e!==null;){if(i=Ya(e),i!==null){for(o.flags|=128,Gt(a,!1),t=i.updateQueue,t!==null&&(o.updateQueue=t,o.flags|=4),o.subtreeFlags=0,t=n,n=o.child;n!==null;)a=n,e=t,a.flags&=14680066,i=a.alternate,i===null?(a.childLanes=0,a.lanes=e,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=i.childLanes,a.lanes=i.lanes,a.child=i.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=i.memoizedProps,a.memoizedState=i.memoizedState,a.updateQueue=i.updateQueue,a.type=i.type,e=i.dependencies,a.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return ne(le,le.current&1|2),o.child}e=e.sibling}a.tail!==null&&ke()>Mt&&(o.flags|=128,t=!0,Gt(a,!1),o.lanes=4194304)}else{if(!t)if(e=Ya(i),e!==null){if(o.flags|=128,t=!0,n=e.updateQueue,n!==null&&(o.updateQueue=n,o.flags|=4),Gt(a,!0),a.tail===null&&a.tailMode==="hidden"&&!i.alternate&&!ue)return Me(o),null}else 2*ke()-a.renderingStartTime>Mt&&n!==1073741824&&(o.flags|=128,t=!0,Gt(a,!1),o.lanes=4194304);a.isBackwards?(i.sibling=o.child,o.child=i):(n=a.last,n!==null?n.sibling=i:o.child=i,a.last=i)}return a.tail!==null?(o=a.tail,a.rendering=o,a.tail=o.sibling,a.renderingStartTime=ke(),o.sibling=null,n=le.current,ne(le,t?n&1|2:n&1),o):(Me(o),null);case 22:case 23:return uu(),t=o.memoizedState!==null,e!==null&&e.memoizedState!==null!==t&&(o.flags|=8192),t&&o.mode&1?Ge&1073741824&&(Me(o),o.subtreeFlags&6&&(o.flags|=8192)):Me(o),null;case 24:return null;case 25:return null}throw Error(w(156,o.tag))}function ey(e,o){switch(Kc(o),o.tag){case 1:return Ke(o.type)&&Ha(),e=o.flags,e&65536?(o.flags=e&-65537|128,o):null;case 3:return wt(),ae(_e),ae(Ae),Yc(),e=o.flags,e&65536&&!(e&128)?(o.flags=e&-65537|128,o):null;case 5:return Qc(o),null;case 13:if(ae(le),e=o.memoizedState,e!==null&&e.dehydrated!==null){if(o.alternate===null)throw Error(w(340));xt()}return e=o.flags,e&65536?(o.flags=e&-65537|128,o):null;case 19:return ae(le),null;case 4:return wt(),null;case 10:return Zc(o.type._context),null;case 22:case 23:return uu(),null;case 24:return null;default:return null}}var va=!1,Ie=!1,oy=typeof WeakSet=="function"?WeakSet:Set,O=null;function dt(e,o){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(t){me(e,o,t)}else n.current=null}function tc(e,o,n){try{n()}catch(t){me(e,o,t)}}var _l=!1;function ny(e,o){if(Fs=Ba,e=Wp(),Bc(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var t=n.getSelection&&n.getSelection();if(t&&t.rangeCount!==0){n=t.anchorNode;var r=t.anchorOffset,a=t.focusNode;t=t.focusOffset;try{n.nodeType,a.nodeType}catch{n=null;break e}var i=0,s=-1,c=-1,u=0,d=0,p=e,v=null;o:for(;;){for(var z;p!==n||r!==0&&p.nodeType!==3||(s=i+r),p!==a||t!==0&&p.nodeType!==3||(c=i+t),p.nodeType===3&&(i+=p.nodeValue.length),(z=p.firstChild)!==null;)v=p,p=z;for(;;){if(p===e)break o;if(v===n&&++u===r&&(s=i),v===a&&++d===t&&(c=i),(z=p.nextSibling)!==null)break;p=v,v=p.parentNode}p=z}n=s===-1||c===-1?null:{start:s,end:c}}else n=null}n=n||{start:0,end:0}}else n=null;for(Bs={focusedElem:e,selectionRange:n},Ba=!1,O=o;O!==null;)if(o=O,e=o.child,(o.subtreeFlags&1028)!==0&&e!==null)e.return=o,O=e;else for(;O!==null;){o=O;try{var f=o.alternate;if(o.flags&1024)switch(o.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var h=f.memoizedProps,T=f.memoizedState,k=o.stateNode,m=k.getSnapshotBeforeUpdate(o.elementType===o.type?h:ko(o.type,h),T);k.__reactInternalSnapshotBeforeUpdate=m}break;case 3:var b=o.stateNode.containerInfo;b.nodeType===1?b.textContent="":b.nodeType===9&&b.documentElement&&b.removeChild(b.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(w(163))}}catch(N){me(o,o.return,N)}if(e=o.sibling,e!==null){e.return=o.return,O=e;break}O=o.return}return f=_l,_l=!1,f}function pr(e,o,n){var t=o.updateQueue;if(t=t!==null?t.lastEffect:null,t!==null){var r=t=t.next;do{if((r.tag&e)===e){var a=r.destroy;r.destroy=void 0,a!==void 0&&tc(o,n,a)}r=r.next}while(r!==t)}}function yi(e,o){if(o=o.updateQueue,o=o!==null?o.lastEffect:null,o!==null){var n=o=o.next;do{if((n.tag&e)===e){var t=n.create;n.destroy=t()}n=n.next}while(n!==o)}}function rc(e){var o=e.ref;if(o!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof o=="function"?o(e):o.current=e}}function $v(e){var o=e.alternate;o!==null&&(e.alternate=null,$v(o)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(o=e.stateNode,o!==null&&(delete o[So],delete o[Sr],delete o[$s],delete o[Ub],delete o[Lb])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function Hv(e){return e.tag===5||e.tag===3||e.tag===4}function Kl(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Hv(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function ac(e,o,n){var t=e.tag;if(t===5||t===6)e=e.stateNode,o?n.nodeType===8?n.parentNode.insertBefore(e,o):n.insertBefore(e,o):(n.nodeType===8?(o=n.parentNode,o.insertBefore(e,n)):(o=n,o.appendChild(e)),n=n._reactRootContainer,n!=null||o.onclick!==null||(o.onclick=$a));else if(t!==4&&(e=e.child,e!==null))for(ac(e,o,n),e=e.sibling;e!==null;)ac(e,o,n),e=e.sibling}function ic(e,o,n){var t=e.tag;if(t===5||t===6)e=e.stateNode,o?n.insertBefore(e,o):n.appendChild(e);else if(t!==4&&(e=e.child,e!==null))for(ic(e,o,n),e=e.sibling;e!==null;)ic(e,o,n),e=e.sibling}var xe=null,ho=!1;function Jo(e,o,n){for(n=n.child;n!==null;)Xv(e,o,n),n=n.sibling}function Xv(e,o,n){if(Mo&&typeof Mo.onCommitFiberUnmount=="function")try{Mo.onCommitFiberUnmount(li,n)}catch{}switch(n.tag){case 5:Ie||dt(n,o);case 6:var t=xe,r=ho;xe=null,Jo(e,o,n),xe=t,ho=r,xe!==null&&(ho?(e=xe,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):xe.removeChild(n.stateNode));break;case 18:xe!==null&&(ho?(e=xe,n=n.stateNode,e.nodeType===8?Gi(e.parentNode,n):e.nodeType===1&&Gi(e,n),gr(e)):Gi(xe,n.stateNode));break;case 4:t=xe,r=ho,xe=n.stateNode.containerInfo,ho=!0,Jo(e,o,n),xe=t,ho=r;break;case 0:case 11:case 14:case 15:if(!Ie&&(t=n.updateQueue,t!==null&&(t=t.lastEffect,t!==null))){r=t=t.next;do{var a=r,i=a.destroy;a=a.tag,i!==void 0&&(a&2||a&4)&&tc(n,o,i),r=r.next}while(r!==t)}Jo(e,o,n);break;case 1:if(!Ie&&(dt(n,o),t=n.stateNode,typeof t.componentWillUnmount=="function"))try{t.props=n.memoizedProps,t.state=n.memoizedState,t.componentWillUnmount()}catch(s){me(n,o,s)}Jo(e,o,n);break;case 21:Jo(e,o,n);break;case 22:n.mode&1?(Ie=(t=Ie)||n.memoizedState!==null,Jo(e,o,n),Ie=t):Jo(e,o,n);break;default:Jo(e,o,n)}}function $l(e){var o=e.updateQueue;if(o!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new oy),o.forEach(function(t){var r=dy.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))})}}function mo(e,o){var n=o.deletions;if(n!==null)for(var t=0;t<n.length;t++){var r=n[t];try{var a=e,i=o,s=i;e:for(;s!==null;){switch(s.tag){case 5:xe=s.stateNode,ho=!1;break e;case 3:xe=s.stateNode.containerInfo,ho=!0;break e;case 4:xe=s.stateNode.containerInfo,ho=!0;break e}s=s.return}if(xe===null)throw Error(w(160));Xv(a,i,r),xe=null,ho=!1;var c=r.alternate;c!==null&&(c.return=null),r.return=null}catch(u){me(r,o,u)}}if(o.subtreeFlags&12854)for(o=o.child;o!==null;)Zv(o,e),o=o.sibling}function Zv(e,o){var n=e.alternate,t=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(mo(o,e),Po(e),t&4){try{pr(3,e,e.return),yi(3,e)}catch(h){me(e,e.return,h)}try{pr(5,e,e.return)}catch(h){me(e,e.return,h)}}break;case 1:mo(o,e),Po(e),t&512&&n!==null&&dt(n,n.return);break;case 5:if(mo(o,e),Po(e),t&512&&n!==null&&dt(n,n.return),e.flags&32){var r=e.stateNode;try{yr(r,"")}catch(h){me(e,e.return,h)}}if(t&4&&(r=e.stateNode,r!=null)){var a=e.memoizedProps,i=n!==null?n.memoizedProps:a,s=e.type,c=e.updateQueue;if(e.updateQueue=null,c!==null)try{s==="input"&&a.type==="radio"&&a.name!=null&&kp(r,a),Ms(s,i);var u=Ms(s,a);for(i=0;i<c.length;i+=2){var d=c[i],p=c[i+1];d==="style"?jp(r,p):d==="dangerouslySetInnerHTML"?yp(r,p):d==="children"?yr(r,p):wc(r,d,p,u)}switch(s){case"input":Ps(r,a);break;case"textarea":hp(r,a);break;case"select":var v=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!a.multiple;var z=a.value;z!=null?kt(r,!!a.multiple,z,!1):v!==!!a.multiple&&(a.defaultValue!=null?kt(r,!!a.multiple,a.defaultValue,!0):kt(r,!!a.multiple,a.multiple?[]:"",!1))}r[Sr]=a}catch(h){me(e,e.return,h)}}break;case 6:if(mo(o,e),Po(e),t&4){if(e.stateNode===null)throw Error(w(162));r=e.stateNode,a=e.memoizedProps;try{r.nodeValue=a}catch(h){me(e,e.return,h)}}break;case 3:if(mo(o,e),Po(e),t&4&&n!==null&&n.memoizedState.isDehydrated)try{gr(o.containerInfo)}catch(h){me(e,e.return,h)}break;case 4:mo(o,e),Po(e);break;case 13:mo(o,e),Po(e),r=e.child,r.flags&8192&&(a=r.memoizedState!==null,r.stateNode.isHidden=a,!a||r.alternate!==null&&r.alternate.memoizedState!==null||(su=ke())),t&4&&$l(e);break;case 22:if(d=n!==null&&n.memoizedState!==null,e.mode&1?(Ie=(u=Ie)||d,mo(o,e),Ie=u):mo(o,e),Po(e),t&8192){if(u=e.memoizedState!==null,(e.stateNode.isHidden=u)&&!d&&e.mode&1)for(O=e,d=e.child;d!==null;){for(p=O=d;O!==null;){switch(v=O,z=v.child,v.tag){case 0:case 11:case 14:case 15:pr(4,v,v.return);break;case 1:dt(v,v.return);var f=v.stateNode;if(typeof f.componentWillUnmount=="function"){t=v,n=v.return;try{o=t,f.props=o.memoizedProps,f.state=o.memoizedState,f.componentWillUnmount()}catch(h){me(t,n,h)}}break;case 5:dt(v,v.return);break;case 22:if(v.memoizedState!==null){Xl(p);continue}}z!==null?(z.return=v,O=z):Xl(p)}d=d.sibling}e:for(d=null,p=e;;){if(p.tag===5){if(d===null){d=p;try{r=p.stateNode,u?(a=r.style,typeof a.setProperty=="function"?a.setProperty("display","none","important"):a.display="none"):(s=p.stateNode,c=p.memoizedProps.style,i=c!=null&&c.hasOwnProperty("display")?c.display:null,s.style.display=zp("display",i))}catch(h){me(e,e.return,h)}}}else if(p.tag===6){if(d===null)try{p.stateNode.nodeValue=u?"":p.memoizedProps}catch(h){me(e,e.return,h)}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===e)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===e)break e;for(;p.sibling===null;){if(p.return===null||p.return===e)break e;d===p&&(d=null),p=p.return}d===p&&(d=null),p.sibling.return=p.return,p=p.sibling}}break;case 19:mo(o,e),Po(e),t&4&&$l(e);break;case 21:break;default:mo(o,e),Po(e)}}function Po(e){var o=e.flags;if(o&2){try{e:{for(var n=e.return;n!==null;){if(Hv(n)){var t=n;break e}n=n.return}throw Error(w(160))}switch(t.tag){case 5:var r=t.stateNode;t.flags&32&&(yr(r,""),t.flags&=-33);var a=Kl(e);ic(e,a,r);break;case 3:case 4:var i=t.stateNode.containerInfo,s=Kl(e);ac(e,s,i);break;default:throw Error(w(161))}}catch(c){me(e,e.return,c)}e.flags&=-3}o&4096&&(e.flags&=-4097)}function ty(e,o,n){O=e,Wv(e)}function Wv(e,o,n){for(var t=(e.mode&1)!==0;O!==null;){var r=O,a=r.child;if(r.tag===22&&t){var i=r.memoizedState!==null||va;if(!i){var s=r.alternate,c=s!==null&&s.memoizedState!==null||Ie;s=va;var u=Ie;if(va=i,(Ie=c)&&!u)for(O=r;O!==null;)i=O,c=i.child,i.tag===22&&i.memoizedState!==null?Zl(r):c!==null?(c.return=i,O=c):Zl(r);for(;a!==null;)O=a,Wv(a),a=a.sibling;O=r,va=s,Ie=u}Hl(e)}else r.subtreeFlags&8772&&a!==null?(a.return=r,O=a):Hl(e)}}function Hl(e){for(;O!==null;){var o=O;if(o.flags&8772){var n=o.alternate;try{if(o.flags&8772)switch(o.tag){case 0:case 11:case 15:Ie||yi(5,o);break;case 1:var t=o.stateNode;if(o.flags&4&&!Ie)if(n===null)t.componentDidMount();else{var r=o.elementType===o.type?n.memoizedProps:ko(o.type,n.memoizedProps);t.componentDidUpdate(r,n.memoizedState,t.__reactInternalSnapshotBeforeUpdate)}var a=o.updateQueue;a!==null&&Cl(o,a,t);break;case 3:var i=o.updateQueue;if(i!==null){if(n=null,o.child!==null)switch(o.child.tag){case 5:n=o.child.stateNode;break;case 1:n=o.child.stateNode}Cl(o,i,n)}break;case 5:var s=o.stateNode;if(n===null&&o.flags&4){n=s;var c=o.memoizedProps;switch(o.type){case"button":case"input":case"select":case"textarea":c.autoFocus&&n.focus();break;case"img":c.src&&(n.src=c.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(o.memoizedState===null){var u=o.alternate;if(u!==null){var d=u.memoizedState;if(d!==null){var p=d.dehydrated;p!==null&&gr(p)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(w(163))}Ie||o.flags&512&&rc(o)}catch(v){me(o,o.return,v)}}if(o===e){O=null;break}if(n=o.sibling,n!==null){n.return=o.return,O=n;break}O=o.return}}function Xl(e){for(;O!==null;){var o=O;if(o===e){O=null;break}var n=o.sibling;if(n!==null){n.return=o.return,O=n;break}O=o.return}}function Zl(e){for(;O!==null;){var o=O;try{switch(o.tag){case 0:case 11:case 15:var n=o.return;try{yi(4,o)}catch(c){me(o,n,c)}break;case 1:var t=o.stateNode;if(typeof t.componentDidMount=="function"){var r=o.return;try{t.componentDidMount()}catch(c){me(o,r,c)}}var a=o.return;try{rc(o)}catch(c){me(o,a,c)}break;case 5:var i=o.return;try{rc(o)}catch(c){me(o,i,c)}}}catch(c){me(o,o.return,c)}if(o===e){O=null;break}var s=o.sibling;if(s!==null){s.return=o.return,O=s;break}O=o.return}}var ry=Math.ceil,oi=$o.ReactCurrentDispatcher,au=$o.ReactCurrentOwner,co=$o.ReactCurrentBatchConfig,Y=0,ge=null,be=null,Se=0,Ge=0,pt=jn(0),ze=0,Vr=null,Rn=0,zi=0,iu=0,vr=null,Fe=null,su=0,Mt=1/0,Oo=null,ni=!1,sc=null,vn=null,ma=!1,sn=null,ti=0,mr=0,cc=null,Ia=-1,Aa=0;function Re(){return Y&6?ke():Ia!==-1?Ia:Ia=ke()}function mn(e){return e.mode&1?Y&2&&Se!==0?Se&-Se:Bb.transition!==null?(Aa===0&&(Aa=Ap()),Aa):(e=q,e!==0||(e=window.event,e=e===void 0?16:Lp(e.type)),e):1}function fo(e,o,n,t){if(50<mr)throw mr=0,cc=null,Error(w(185));Lr(e,n,t),(!(Y&2)||e!==ge)&&(e===ge&&(!(Y&2)&&(zi|=n),ze===4&&rn(e,Se)),$e(e,t),n===1&&Y===0&&!(o.mode&1)&&(Mt=ke()+500,ki&&fn()))}function $e(e,o){var n=e.callbackNode;Bh(e,o);var t=Fa(e,e===ge?Se:0);if(t===0)n!==null&&nl(n),e.callbackNode=null,e.callbackPriority=0;else if(o=t&-t,e.callbackPriority!==o){if(n!=null&&nl(n),o===1)e.tag===0?Fb(Wl.bind(null,e)):rv(Wl.bind(null,e)),Rb(function(){!(Y&6)&&fn()}),n=null;else{switch(Vp(t)){case 1:n=Vc;break;case 4:n=Mp;break;case 16:n=La;break;case 536870912:n=Ip;break;default:n=La}n=nm(n,Gv.bind(null,e))}e.callbackPriority=o,e.callbackNode=n}}function Gv(e,o){if(Ia=-1,Aa=0,Y&6)throw Error(w(327));var n=e.callbackNode;if(jt()&&e.callbackNode!==n)return null;var t=Fa(e,e===ge?Se:0);if(t===0)return null;if(t&30||t&e.expiredLanes||o)o=ri(e,t);else{o=t;var r=Y;Y|=2;var a=Qv();(ge!==e||Se!==o)&&(Oo=null,Mt=ke()+500,Mn(e,o));do try{sy();break}catch(s){Jv(e,s)}while(!0);Xc(),oi.current=a,Y=r,be!==null?o=0:(ge=null,Se=0,o=ze)}if(o!==0){if(o===2&&(r=Es(e),r!==0&&(t=r,o=uc(e,r))),o===1)throw n=Vr,Mn(e,0),rn(e,t),$e(e,ke()),n;if(o===6)rn(e,t);else{if(r=e.current.alternate,!(t&30)&&!ay(r)&&(o=ri(e,t),o===2&&(a=Es(e),a!==0&&(t=a,o=uc(e,a))),o===1))throw n=Vr,Mn(e,0),rn(e,t),$e(e,ke()),n;switch(e.finishedWork=r,e.finishedLanes=t,o){case 0:case 1:throw Error(w(345));case 2:Nn(e,Fe,Oo);break;case 3:if(rn(e,t),(t&130023424)===t&&(o=su+500-ke(),10<o)){if(Fa(e,0)!==0)break;if(r=e.suspendedLanes,(r&t)!==t){Re(),e.pingedLanes|=e.suspendedLanes&r;break}e.timeoutHandle=Ks(Nn.bind(null,e,Fe,Oo),o);break}Nn(e,Fe,Oo);break;case 4:if(rn(e,t),(t&4194240)===t)break;for(o=e.eventTimes,r=-1;0<t;){var i=31-jo(t);a=1<<i,i=o[i],i>r&&(r=i),t&=~a}if(t=r,t=ke()-t,t=(120>t?120:480>t?480:1080>t?1080:1920>t?1920:3e3>t?3e3:4320>t?4320:1960*ry(t/1960))-t,10<t){e.timeoutHandle=Ks(Nn.bind(null,e,Fe,Oo),t);break}Nn(e,Fe,Oo);break;case 5:Nn(e,Fe,Oo);break;default:throw Error(w(329))}}}return $e(e,ke()),e.callbackNode===n?Gv.bind(null,e):null}function uc(e,o){var n=vr;return e.current.memoizedState.isDehydrated&&(Mn(e,o).flags|=256),e=ri(e,o),e!==2&&(o=Fe,Fe=n,o!==null&&lc(o)),e}function lc(e){Fe===null?Fe=e:Fe.push.apply(Fe,e)}function ay(e){for(var o=e;;){if(o.flags&16384){var n=o.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var t=0;t<n.length;t++){var r=n[t],a=r.getSnapshot;r=r.value;try{if(!go(a(),r))return!1}catch{return!1}}}if(n=o.child,o.subtreeFlags&16384&&n!==null)n.return=o,o=n;else{if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return!0;o=o.return}o.sibling.return=o.return,o=o.sibling}}return!0}function rn(e,o){for(o&=~iu,o&=~zi,e.suspendedLanes|=o,e.pingedLanes&=~o,e=e.expirationTimes;0<o;){var n=31-jo(o),t=1<<n;e[n]=-1,o&=~t}}function Wl(e){if(Y&6)throw Error(w(327));jt();var o=Fa(e,0);if(!(o&1))return $e(e,ke()),null;var n=ri(e,o);if(e.tag!==0&&n===2){var t=Es(e);t!==0&&(o=t,n=uc(e,t))}if(n===1)throw n=Vr,Mn(e,0),rn(e,o),$e(e,ke()),n;if(n===6)throw Error(w(345));return e.finishedWork=e.current.alternate,e.finishedLanes=o,Nn(e,Fe,Oo),$e(e,ke()),null}function cu(e,o){var n=Y;Y|=1;try{return e(o)}finally{Y=n,Y===0&&(Mt=ke()+500,ki&&fn())}}function Dn(e){sn!==null&&sn.tag===0&&!(Y&6)&&jt();var o=Y;Y|=1;var n=co.transition,t=q;try{if(co.transition=null,q=1,e)return e()}finally{q=t,co.transition=n,Y=o,!(Y&6)&&fn()}}function uu(){Ge=pt.current,ae(pt)}function Mn(e,o){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,Eb(n)),be!==null)for(n=be.return;n!==null;){var t=n;switch(Kc(t),t.tag){case 1:t=t.type.childContextTypes,t!=null&&Ha();break;case 3:wt(),ae(_e),ae(Ae),Yc();break;case 5:Qc(t);break;case 4:wt();break;case 13:ae(le);break;case 19:ae(le);break;case 10:Zc(t.type._context);break;case 22:case 23:uu()}n=n.return}if(ge=e,be=e=kn(e.current,null),Se=Ge=o,ze=0,Vr=null,iu=zi=Rn=0,Fe=vr=null,xn!==null){for(o=0;o<xn.length;o++)if(n=xn[o],t=n.interleaved,t!==null){n.interleaved=null;var r=t.next,a=n.pending;if(a!==null){var i=a.next;a.next=r,t.next=i}n.pending=t}xn=null}return e}function Jv(e,o){do{var n=be;try{if(Xc(),wa.current=ei,qa){for(var t=de.memoizedState;t!==null;){var r=t.queue;r!==null&&(r.pending=null),t=t.next}qa=!1}if(En=0,fe=ye=de=null,dr=!1,Mr=0,au.current=null,n===null||n.return===null){ze=1,Vr=o,be=null;break}e:{var a=e,i=n.return,s=n,c=o;if(o=Se,s.flags|=32768,c!==null&&typeof c=="object"&&typeof c.then=="function"){var u=c,d=s,p=d.tag;if(!(d.mode&1)&&(p===0||p===11||p===15)){var v=d.alternate;v?(d.updateQueue=v.updateQueue,d.memoizedState=v.memoizedState,d.lanes=v.lanes):(d.updateQueue=null,d.memoizedState=null)}var z=El(i);if(z!==null){z.flags&=-257,Rl(z,i,s,a,o),z.mode&1&&Ol(a,u,o),o=z,c=u;var f=o.updateQueue;if(f===null){var h=new Set;h.add(c),o.updateQueue=h}else f.add(c);break e}else{if(!(o&1)){Ol(a,u,o),lu();break e}c=Error(w(426))}}else if(ue&&s.mode&1){var T=El(i);if(T!==null){!(T.flags&65536)&&(T.flags|=256),Rl(T,i,s,a,o),$c(Ct(c,s));break e}}a=c=Ct(c,s),ze!==4&&(ze=2),vr===null?vr=[a]:vr.push(a),a=i;do{switch(a.tag){case 3:a.flags|=65536,o&=-o,a.lanes|=o;var k=Vv(a,c,o);wl(a,k);break e;case 1:s=c;var m=a.type,b=a.stateNode;if(!(a.flags&128)&&(typeof m.getDerivedStateFromError=="function"||b!==null&&typeof b.componentDidCatch=="function"&&(vn===null||!vn.has(b)))){a.flags|=65536,o&=-o,a.lanes|=o;var N=Ov(a,s,o);wl(a,N);break e}}a=a.return}while(a!==null)}qv(n)}catch(S){o=S,be===n&&n!==null&&(be=n=n.return);continue}break}while(!0)}function Qv(){var e=oi.current;return oi.current=ei,e===null?ei:e}function lu(){(ze===0||ze===3||ze===2)&&(ze=4),ge===null||!(Rn&268435455)&&!(zi&268435455)||rn(ge,Se)}function ri(e,o){var n=Y;Y|=2;var t=Qv();(ge!==e||Se!==o)&&(Oo=null,Mn(e,o));do try{iy();break}catch(r){Jv(e,r)}while(!0);if(Xc(),Y=n,oi.current=t,be!==null)throw Error(w(261));return ge=null,Se=0,ze}function iy(){for(;be!==null;)Yv(be)}function sy(){for(;be!==null&&!Ah();)Yv(be)}function Yv(e){var o=om(e.alternate,e,Ge);e.memoizedProps=e.pendingProps,o===null?qv(e):be=o,au.current=null}function qv(e){var o=e;do{var n=o.alternate;if(e=o.return,o.flags&32768){if(n=ey(n,o),n!==null){n.flags&=32767,be=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{ze=6,be=null;return}}else if(n=qb(n,o,Ge),n!==null){be=n;return}if(o=o.sibling,o!==null){be=o;return}be=o=e}while(o!==null);ze===0&&(ze=5)}function Nn(e,o,n){var t=q,r=co.transition;try{co.transition=null,q=1,cy(e,o,n,t)}finally{co.transition=r,q=t}return null}function cy(e,o,n,t){do jt();while(sn!==null);if(Y&6)throw Error(w(327));n=e.finishedWork;var r=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(w(177));e.callbackNode=null,e.callbackPriority=0;var a=n.lanes|n.childLanes;if(_h(e,a),e===ge&&(be=ge=null,Se=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||ma||(ma=!0,nm(La,function(){return jt(),null})),a=(n.flags&15990)!==0,n.subtreeFlags&15990||a){a=co.transition,co.transition=null;var i=q;q=1;var s=Y;Y|=4,au.current=null,ny(e,n),Zv(n,e),wb(Bs),Ba=!!Fs,Bs=Fs=null,e.current=n,ty(n),Vh(),Y=s,q=i,co.transition=a}else e.current=n;if(ma&&(ma=!1,sn=e,ti=r),a=e.pendingLanes,a===0&&(vn=null),Rh(n.stateNode),$e(e,ke()),o!==null)for(t=e.onRecoverableError,n=0;n<o.length;n++)r=o[n],t(r.value,{componentStack:r.stack,digest:r.digest});if(ni)throw ni=!1,e=sc,sc=null,e;return ti&1&&e.tag!==0&&jt(),a=e.pendingLanes,a&1?e===cc?mr++:(mr=0,cc=e):mr=0,fn(),null}function jt(){if(sn!==null){var e=Vp(ti),o=co.transition,n=q;try{if(co.transition=null,q=16>e?16:e,sn===null)var t=!1;else{if(e=sn,sn=null,ti=0,Y&6)throw Error(w(331));var r=Y;for(Y|=4,O=e.current;O!==null;){var a=O,i=a.child;if(O.flags&16){var s=a.deletions;if(s!==null){for(var c=0;c<s.length;c++){var u=s[c];for(O=u;O!==null;){var d=O;switch(d.tag){case 0:case 11:case 15:pr(8,d,a)}var p=d.child;if(p!==null)p.return=d,O=p;else for(;O!==null;){d=O;var v=d.sibling,z=d.return;if($v(d),d===u){O=null;break}if(v!==null){v.return=z,O=v;break}O=z}}}var f=a.alternate;if(f!==null){var h=f.child;if(h!==null){f.child=null;do{var T=h.sibling;h.sibling=null,h=T}while(h!==null)}}O=a}}if(a.subtreeFlags&2064&&i!==null)i.return=a,O=i;else e:for(;O!==null;){if(a=O,a.flags&2048)switch(a.tag){case 0:case 11:case 15:pr(9,a,a.return)}var k=a.sibling;if(k!==null){k.return=a.return,O=k;break e}O=a.return}}var m=e.current;for(O=m;O!==null;){i=O;var b=i.child;if(i.subtreeFlags&2064&&b!==null)b.return=i,O=b;else e:for(i=m;O!==null;){if(s=O,s.flags&2048)try{switch(s.tag){case 0:case 11:case 15:yi(9,s)}}catch(S){me(s,s.return,S)}if(s===i){O=null;break e}var N=s.sibling;if(N!==null){N.return=s.return,O=N;break e}O=s.return}}if(Y=r,fn(),Mo&&typeof Mo.onPostCommitFiberRoot=="function")try{Mo.onPostCommitFiberRoot(li,e)}catch{}t=!0}return t}finally{q=n,co.transition=o}}return!1}function Gl(e,o,n){o=Ct(n,o),o=Vv(e,o,1),e=pn(e,o,1),o=Re(),e!==null&&(Lr(e,1,o),$e(e,o))}function me(e,o,n){if(e.tag===3)Gl(e,e,n);else for(;o!==null;){if(o.tag===3){Gl(o,e,n);break}else if(o.tag===1){var t=o.stateNode;if(typeof o.type.getDerivedStateFromError=="function"||typeof t.componentDidCatch=="function"&&(vn===null||!vn.has(t))){e=Ct(n,e),e=Ov(o,e,1),o=pn(o,e,1),e=Re(),o!==null&&(Lr(o,1,e),$e(o,e));break}}o=o.return}}function uy(e,o,n){var t=e.pingCache;t!==null&&t.delete(o),o=Re(),e.pingedLanes|=e.suspendedLanes&n,ge===e&&(Se&n)===n&&(ze===4||ze===3&&(Se&130023424)===Se&&500>ke()-su?Mn(e,0):iu|=n),$e(e,o)}function em(e,o){o===0&&(e.mode&1?(o=ra,ra<<=1,!(ra&130023424)&&(ra=4194304)):o=1);var n=Re();e=_o(e,o),e!==null&&(Lr(e,o,n),$e(e,n))}function ly(e){var o=e.memoizedState,n=0;o!==null&&(n=o.retryLane),em(e,n)}function dy(e,o){var n=0;switch(e.tag){case 13:var t=e.stateNode,r=e.memoizedState;r!==null&&(n=r.retryLane);break;case 19:t=e.stateNode;break;default:throw Error(w(314))}t!==null&&t.delete(o),em(e,n)}var om;om=function(e,o,n){if(e!==null)if(e.memoizedProps!==o.pendingProps||_e.current)Be=!0;else{if(!(e.lanes&n)&&!(o.flags&128))return Be=!1,Yb(e,o,n);Be=!!(e.flags&131072)}else Be=!1,ue&&o.flags&1048576&&av(o,Wa,o.index);switch(o.lanes=0,o.tag){case 2:var t=o.type;Ma(e,o),e=o.pendingProps;var r=Pt(o,Ae.current);zt(o,n),r=eu(null,o,t,e,r,n);var a=ou();return o.flags|=1,typeof r=="object"&&r!==null&&typeof r.render=="function"&&r.$$typeof===void 0?(o.tag=1,o.memoizedState=null,o.updateQueue=null,Ke(t)?(a=!0,Xa(o)):a=!1,o.memoizedState=r.state!==null&&r.state!==void 0?r.state:null,Gc(o),r.updater=bi,o.stateNode=r,r._reactInternals=o,Js(o,t,e,n),o=qs(null,o,t,!0,a,n)):(o.tag=0,ue&&a&&_c(o),Ee(null,o,r,n),o=o.child),o;case 16:t=o.elementType;e:{switch(Ma(e,o),e=o.pendingProps,r=t._init,t=r(t._payload),o.type=t,r=o.tag=vy(t),e=ko(t,e),r){case 0:o=Ys(null,o,t,e,n);break e;case 1:o=Ll(null,o,t,e,n);break e;case 11:o=Dl(null,o,t,e,n);break e;case 14:o=Ul(null,o,t,ko(t.type,e),n);break e}throw Error(w(306,t,""))}return o;case 0:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),Ys(e,o,t,r,n);case 1:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),Ll(e,o,t,r,n);case 3:e:{if(Uv(o),e===null)throw Error(w(387));t=o.pendingProps,a=o.memoizedState,r=a.element,dv(e,o),Qa(o,t,null,n);var i=o.memoizedState;if(t=i.element,a.isDehydrated)if(a={element:t,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},o.updateQueue.baseState=a,o.memoizedState=a,o.flags&256){r=Ct(Error(w(423)),o),o=Fl(e,o,t,n,r);break e}else if(t!==r){r=Ct(Error(w(424)),o),o=Fl(e,o,t,n,r);break e}else for(Je=dn(o.stateNode.containerInfo.firstChild),Qe=o,ue=!0,yo=null,n=uv(o,null,t,n),o.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(xt(),t===r){o=Ko(e,o,n);break e}Ee(e,o,t,n)}o=o.child}return o;case 5:return pv(o),e===null&&Zs(o),t=o.type,r=o.pendingProps,a=e!==null?e.memoizedProps:null,i=r.children,_s(t,r)?i=null:a!==null&&_s(t,a)&&(o.flags|=32),Dv(e,o),Ee(e,o,i,n),o.child;case 6:return e===null&&Zs(o),null;case 13:return Lv(e,o,n);case 4:return Jc(o,o.stateNode.containerInfo),t=o.pendingProps,e===null?o.child=St(o,null,t,n):Ee(e,o,t,n),o.child;case 11:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),Dl(e,o,t,r,n);case 7:return Ee(e,o,o.pendingProps,n),o.child;case 8:return Ee(e,o,o.pendingProps.children,n),o.child;case 12:return Ee(e,o,o.pendingProps.children,n),o.child;case 10:e:{if(t=o.type._context,r=o.pendingProps,a=o.memoizedProps,i=r.value,ne(Ga,t._currentValue),t._currentValue=i,a!==null)if(go(a.value,i)){if(a.children===r.children&&!_e.current){o=Ko(e,o,n);break e}}else for(a=o.child,a!==null&&(a.return=o);a!==null;){var s=a.dependencies;if(s!==null){i=a.child;for(var c=s.firstContext;c!==null;){if(c.context===t){if(a.tag===1){c=Uo(-1,n&-n),c.tag=2;var u=a.updateQueue;if(u!==null){u=u.shared;var d=u.pending;d===null?c.next=c:(c.next=d.next,d.next=c),u.pending=c}}a.lanes|=n,c=a.alternate,c!==null&&(c.lanes|=n),Ws(a.return,n,o),s.lanes|=n;break}c=c.next}}else if(a.tag===10)i=a.type===o.type?null:a.child;else if(a.tag===18){if(i=a.return,i===null)throw Error(w(341));i.lanes|=n,s=i.alternate,s!==null&&(s.lanes|=n),Ws(i,n,o),i=a.sibling}else i=a.child;if(i!==null)i.return=a;else for(i=a;i!==null;){if(i===o){i=null;break}if(a=i.sibling,a!==null){a.return=i.return,i=a;break}i=i.return}a=i}Ee(e,o,r.children,n),o=o.child}return o;case 9:return r=o.type,t=o.pendingProps.children,zt(o,n),r=uo(r),t=t(r),o.flags|=1,Ee(e,o,t,n),o.child;case 14:return t=o.type,r=ko(t,o.pendingProps),r=ko(t.type,r),Ul(e,o,t,r,n);case 15:return Ev(e,o,o.type,o.pendingProps,n);case 17:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),Ma(e,o),o.tag=1,Ke(t)?(e=!0,Xa(o)):e=!1,zt(o,n),Av(o,t,r),Js(o,t,r,n),qs(null,o,t,!0,e,n);case 19:return Fv(e,o,n);case 22:return Rv(e,o,n)}throw Error(w(156,o.tag))};function nm(e,o){return Cp(e,o)}function py(e,o,n,t){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=o,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=t,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function so(e,o,n,t){return new py(e,o,n,t)}function du(e){return e=e.prototype,!(!e||!e.isReactComponent)}function vy(e){if(typeof e=="function")return du(e)?1:0;if(e!=null){if(e=e.$$typeof,e===Mc)return 11;if(e===Ic)return 14}return 2}function kn(e,o){var n=e.alternate;return n===null?(n=so(e.tag,o,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=o,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,o=e.dependencies,n.dependencies=o===null?null:{lanes:o.lanes,firstContext:o.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Va(e,o,n,t,r,a){var i=2;if(t=e,typeof e=="function")du(e)&&(i=1);else if(typeof e=="string")i=5;else e:switch(e){case nt:return In(n.children,r,a,o);case Cc:i=8,r|=8;break;case js:return e=so(12,n,o,r|2),e.elementType=js,e.lanes=a,e;case fs:return e=so(13,n,o,r),e.elementType=fs,e.lanes=a,e;case gs:return e=so(19,n,o,r),e.elementType=gs,e.lanes=a,e;case pp:return ji(n,r,a,o);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case lp:i=10;break e;case dp:i=9;break e;case Mc:i=11;break e;case Ic:i=14;break e;case on:i=16,t=null;break e}throw Error(w(130,e==null?e:typeof e,""))}return o=so(i,n,o,r),o.elementType=e,o.type=t,o.lanes=a,o}function In(e,o,n,t){return e=so(7,e,t,o),e.lanes=n,e}function ji(e,o,n,t){return e=so(22,e,t,o),e.elementType=pp,e.lanes=n,e.stateNode={isHidden:!1},e}function ts(e,o,n){return e=so(6,e,null,o),e.lanes=n,e}function rs(e,o,n){return o=so(4,e.children!==null?e.children:[],e.key,o),o.lanes=n,o.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},o}function my(e,o,n,t,r){this.tag=o,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Ui(0),this.expirationTimes=Ui(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ui(0),this.identifierPrefix=t,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function pu(e,o,n,t,r,a,i,s,c){return e=new my(e,o,n,s,c),o===1?(o=1,a===!0&&(o|=8)):o=0,a=so(3,null,null,o),e.current=a,a.stateNode=e,a.memoizedState={element:t,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Gc(a),e}function ky(e,o,n){var t=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:ot,key:t==null?null:""+t,children:e,containerInfo:o,implementation:n}}function tm(e){if(!e)return bn;e=e._reactInternals;e:{if($n(e)!==e||e.tag!==1)throw Error(w(170));var o=e;do{switch(o.tag){case 3:o=o.stateNode.context;break e;case 1:if(Ke(o.type)){o=o.stateNode.__reactInternalMemoizedMergedChildContext;break e}}o=o.return}while(o!==null);throw Error(w(171))}if(e.tag===1){var n=e.type;if(Ke(n))return tv(e,n,o)}return o}function rm(e,o,n,t,r,a,i,s,c){return e=pu(n,t,!0,e,r,a,i,s,c),e.context=tm(null),n=e.current,t=Re(),r=mn(n),a=Uo(t,r),a.callback=o??null,pn(n,a,r),e.current.lanes=r,Lr(e,r,t),$e(e,t),e}function fi(e,o,n,t){var r=o.current,a=Re(),i=mn(r);return n=tm(n),o.context===null?o.context=n:o.pendingContext=n,o=Uo(a,i),o.payload={element:e},t=t===void 0?null:t,t!==null&&(o.callback=t),e=pn(r,o,i),e!==null&&(fo(e,r,i,a),Sa(e,r,i)),i}function ai(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Jl(e,o){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<o?n:o}}function vu(e,o){Jl(e,o),(e=e.alternate)&&Jl(e,o)}function hy(){return null}var am=typeof reportError=="function"?reportError:function(e){console.error(e)};function mu(e){this._internalRoot=e}gi.prototype.render=mu.prototype.render=function(e){var o=this._internalRoot;if(o===null)throw Error(w(409));fi(e,o,null,null)};gi.prototype.unmount=mu.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var o=e.containerInfo;Dn(function(){fi(null,e,null,null)}),o[Bo]=null}};function gi(e){this._internalRoot=e}gi.prototype.unstable_scheduleHydration=function(e){if(e){var o=Rp();e={blockedOn:null,target:e,priority:o};for(var n=0;n<tn.length&&o!==0&&o<tn[n].priority;n++);tn.splice(n,0,e),n===0&&Up(e)}};function ku(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Ti(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function Ql(){}function by(e,o,n,t,r){if(r){if(typeof t=="function"){var a=t;t=function(){var u=ai(i);a.call(u)}}var i=rm(o,t,e,0,null,!1,!1,"",Ql);return e._reactRootContainer=i,e[Bo]=i.current,Pr(e.nodeType===8?e.parentNode:e),Dn(),i}for(;r=e.lastChild;)e.removeChild(r);if(typeof t=="function"){var s=t;t=function(){var u=ai(c);s.call(u)}}var c=pu(e,0,!1,null,null,!1,!1,"",Ql);return e._reactRootContainer=c,e[Bo]=c.current,Pr(e.nodeType===8?e.parentNode:e),Dn(function(){fi(o,c,n,t)}),c}function Ni(e,o,n,t,r){var a=n._reactRootContainer;if(a){var i=a;if(typeof r=="function"){var s=r;r=function(){var c=ai(i);s.call(c)}}fi(o,i,e,r)}else i=by(n,o,e,r,t);return ai(i)}Op=function(e){switch(e.tag){case 3:var o=e.stateNode;if(o.current.memoizedState.isDehydrated){var n=rr(o.pendingLanes);n!==0&&(Oc(o,n|1),$e(o,ke()),!(Y&6)&&(Mt=ke()+500,fn()))}break;case 13:Dn(function(){var t=_o(e,1);if(t!==null){var r=Re();fo(t,e,1,r)}}),vu(e,1)}};Ec=function(e){if(e.tag===13){var o=_o(e,134217728);if(o!==null){var n=Re();fo(o,e,134217728,n)}vu(e,134217728)}};Ep=function(e){if(e.tag===13){var o=mn(e),n=_o(e,o);if(n!==null){var t=Re();fo(n,e,o,t)}vu(e,o)}};Rp=function(){return q};Dp=function(e,o){var n=q;try{return q=e,o()}finally{q=n}};As=function(e,o,n){switch(o){case"input":if(Ps(e,n),o=n.name,n.type==="radio"&&o!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+o)+'][type="radio"]'),o=0;o<n.length;o++){var t=n[o];if(t!==e&&t.form===e.form){var r=mi(t);if(!r)throw Error(w(90));mp(t),Ps(t,r)}}}break;case"textarea":hp(e,n);break;case"select":o=n.value,o!=null&&kt(e,!!n.multiple,o,!1)}};Tp=cu;Np=Dn;var yy={usingClientEntryPoint:!1,Events:[Br,it,mi,fp,gp,cu]},Jt={findFiberByHostInstance:Pn,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},zy={bundleType:Jt.bundleType,version:Jt.version,rendererPackageName:Jt.rendererPackageName,rendererConfig:Jt.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:$o.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=Sp(e),e===null?null:e.stateNode},findFiberByHostInstance:Jt.findFiberByHostInstance||hy,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var ka=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!ka.isDisabled&&ka.supportsFiber)try{li=ka.inject(zy),Mo=ka}catch{}}qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=yy;qe.createPortal=function(e,o){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!ku(o))throw Error(w(200));return ky(e,o,null,n)};qe.createRoot=function(e,o){if(!ku(e))throw Error(w(299));var n=!1,t="",r=am;return o!=null&&(o.unstable_strictMode===!0&&(n=!0),o.identifierPrefix!==void 0&&(t=o.identifierPrefix),o.onRecoverableError!==void 0&&(r=o.onRecoverableError)),o=pu(e,1,!1,null,null,n,!1,t,r),e[Bo]=o.current,Pr(e.nodeType===8?e.parentNode:e),new mu(o)};qe.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var o=e._reactInternals;if(o===void 0)throw typeof e.render=="function"?Error(w(188)):(e=Object.keys(e).join(","),Error(w(268,e)));return e=Sp(o),e=e===null?null:e.stateNode,e};qe.flushSync=function(e){return Dn(e)};qe.hydrate=function(e,o,n){if(!Ti(o))throw Error(w(200));return Ni(null,e,o,!0,n)};qe.hydrateRoot=function(e,o,n){if(!ku(e))throw Error(w(405));var t=n!=null&&n.hydratedSources||null,r=!1,a="",i=am;if(n!=null&&(n.unstable_strictMode===!0&&(r=!0),n.identifierPrefix!==void 0&&(a=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),o=rm(o,null,e,1,n??null,r,!1,a,i),e[Bo]=o.current,Pr(e),t)for(e=0;e<t.length;e++)n=t[e],r=n._getVersion,r=r(n._source),o.mutableSourceEagerHydrationData==null?o.mutableSourceEagerHydrationData=[n,r]:o.mutableSourceEagerHydrationData.push(n,r);return new gi(o)};qe.render=function(e,o,n){if(!Ti(o))throw Error(w(200));return Ni(null,e,o,!1,n)};qe.unmountComponentAtNode=function(e){if(!Ti(e))throw Error(w(40));return e._reactRootContainer?(Dn(function(){Ni(null,null,e,!1,function(){e._reactRootContainer=null,e[Bo]=null})}),!0):!1};qe.unstable_batchedUpdates=cu;qe.unstable_renderSubtreeIntoContainer=function(e,o,n,t){if(!Ti(n))throw Error(w(200));if(e==null||e._reactInternals===void 0)throw Error(w(38));return Ni(e,o,n,!1,t)};qe.version="18.3.1-next-f1338f8080-20240426";function im(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(im)}catch(e){console.error(e)}}im(),ip.exports=qe;var Kr=ip.exports;const sm=Xd(Kr),jy=Hd({__proto__:null,default:sm},[Kr]);var Yl=Kr;ys.createRoot=Yl.createRoot,ys.hydrateRoot=Yl.hydrateRoot;function ql(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function fy(...e){return o=>{let n=!1;const t=e.map(r=>{const a=ql(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():ql(e[r],null)}}}}var Hn=l.forwardRef((e,o)=>{const{children:n,...t}=e,r=l.Children.toArray(n),a=r.find(Ty);if(a){const i=a.props.children,s=r.map(c=>c===a?l.Children.count(i)>1?l.Children.only(null):l.isValidElement(i)?i.props.children:null:c);return j.jsx(dc,{...t,ref:o,children:l.isValidElement(i)?l.cloneElement(i,void 0,s):null})}return j.jsx(dc,{...t,ref:o,children:n})});Hn.displayName="Slot";var dc=l.forwardRef((e,o)=>{const{children:n,...t}=e;if(l.isValidElement(n)){const r=Py(n),a=Ny(t,n.props);return n.type!==l.Fragment&&(a.ref=o?fy(o,r):r),l.cloneElement(n,a)}return l.Children.count(n)>1?l.Children.only(null):null});dc.displayName="SlotClone";var gy=({children:e})=>j.jsx(j.Fragment,{children:e});function Ty(e){return l.isValidElement(e)&&e.type===gy}function Ny(e,o){const n={...o};for(const t in o){const r=e[t],a=o[t];/^on[A-Z]/.test(t)?r&&a?n[t]=(...s)=>{a(...s),r(...s)}:r&&(n[t]=r):t==="style"?n[t]={...r,...a}:t==="className"&&(n[t]=[r,a].filter(Boolean).join(" "))}return{...e,...n}}function Py(e){var t,r;let o=(t=Object.getOwnPropertyDescriptor(e.props,"ref"))==null?void 0:t.get,n=o&&"isReactWarning"in o&&o.isReactWarning;return n?e.ref:(o=(r=Object.getOwnPropertyDescriptor(e,"ref"))==null?void 0:r.get,n=o&&"isReactWarning"in o&&o.isReactWarning,n?e.props.ref:e.props.ref||e.ref)}function cm(e){var o,n,t="";if(typeof e=="string"||typeof e=="number")t+=e;else if(typeof e=="object")if(Array.isArray(e)){var r=e.length;for(o=0;o<r;o++)e[o]&&(n=cm(e[o]))&&(t&&(t+=" "),t+=n)}else for(n in e)e[n]&&(t&&(t+=" "),t+=n);return t}function um(){for(var e,o,n=0,t="",r=arguments.length;n<r;n++)(e=arguments[n])&&(o=cm(e))&&(t&&(t+=" "),t+=o);return t}const ed=e=>typeof e=="boolean"?`${e}`:e===0?"0":e,od=um,xy=(e,o)=>n=>{var t;if((o==null?void 0:o.variants)==null)return od(e,n==null?void 0:n.class,n==null?void 0:n.className);const{variants:r,defaultVariants:a}=o,i=Object.keys(r).map(u=>{const d=n==null?void 0:n[u],p=a==null?void 0:a[u];if(d===null)return null;const v=ed(d)||ed(p);return r[u][v]}),s=n&&Object.entries(n).reduce((u,d)=>{let[p,v]=d;return v===void 0||(u[p]=v),u},{}),c=o==null||(t=o.compoundVariants)===null||t===void 0?void 0:t.reduce((u,d)=>{let{class:p,className:v,...z}=d;return Object.entries(z).every(f=>{let[h,T]=f;return Array.isArray(T)?T.includes({...a,...s}[h]):{...a,...s}[h]===T})?[...u,p,v]:u},[]);return od(e,i,c,n==null?void 0:n.class,n==null?void 0:n.className)},hu="-",Sy=e=>{const o=Cy(e),{conflictingClassGroups:n,conflictingClassGroupModifiers:t}=e;return{getClassGroupId:i=>{const s=i.split(hu);return s[0]===""&&s.length!==1&&s.shift(),lm(s,o)||wy(i)},getConflictingClassGroupIds:(i,s)=>{const c=n[i]||[];return s&&t[i]?[...c,...t[i]]:c}}},lm=(e,o)=>{var i;if(e.length===0)return o.classGroupId;const n=e[0],t=o.nextPart.get(n),r=t?lm(e.slice(1),t):void 0;if(r)return r;if(o.validators.length===0)return;const a=e.join(hu);return(i=o.validators.find(({validator:s})=>s(a)))==null?void 0:i.classGroupId},nd=/^\[(.+)\]$/,wy=e=>{if(nd.test(e)){const o=nd.exec(e)[1],n=o==null?void 0:o.substring(0,o.indexOf(":"));if(n)return"arbitrary.."+n}},Cy=e=>{const{theme:o,prefix:n}=e,t={nextPart:new Map,validators:[]};return Iy(Object.entries(e.classGroups),n).forEach(([a,i])=>{pc(i,t,a,o)}),t},pc=(e,o,n,t)=>{e.forEach(r=>{if(typeof r=="string"){const a=r===""?o:td(o,r);a.classGroupId=n;return}if(typeof r=="function"){if(My(r)){pc(r(t),o,n,t);return}o.validators.push({validator:r,classGroupId:n});return}Object.entries(r).forEach(([a,i])=>{pc(i,td(o,a),n,t)})})},td=(e,o)=>{let n=e;return o.split(hu).forEach(t=>{n.nextPart.has(t)||n.nextPart.set(t,{nextPart:new Map,validators:[]}),n=n.nextPart.get(t)}),n},My=e=>e.isThemeGetter,Iy=(e,o)=>o?e.map(([n,t])=>{const r=t.map(a=>typeof a=="string"?o+a:typeof a=="object"?Object.fromEntries(Object.entries(a).map(([i,s])=>[o+i,s])):a);return[n,r]}):e,Ay=e=>{if(e<1)return{get:()=>{},set:()=>{}};let o=0,n=new Map,t=new Map;const r=(a,i)=>{n.set(a,i),o++,o>e&&(o=0,t=n,n=new Map)};return{get(a){let i=n.get(a);if(i!==void 0)return i;if((i=t.get(a))!==void 0)return r(a,i),i},set(a,i){n.has(a)?n.set(a,i):r(a,i)}}},dm="!",Vy=e=>{const{separator:o,experimentalParseClassName:n}=e,t=o.length===1,r=o[0],a=o.length,i=s=>{const c=[];let u=0,d=0,p;for(let T=0;T<s.length;T++){let k=s[T];if(u===0){if(k===r&&(t||s.slice(T,T+a)===o)){c.push(s.slice(d,T)),d=T+a;continue}if(k==="/"){p=T;continue}}k==="["?u++:k==="]"&&u--}const v=c.length===0?s:s.substring(d),z=v.startsWith(dm),f=z?v.substring(1):v,h=p&&p>d?p-d:void 0;return{modifiers:c,hasImportantModifier:z,baseClassName:f,maybePostfixModifierPosition:h}};return n?s=>n({className:s,parseClassName:i}):i},Oy=e=>{if(e.length<=1)return e;const o=[];let n=[];return e.forEach(t=>{t[0]==="["?(o.push(...n.sort(),t),n=[]):n.push(t)}),o.push(...n.sort()),o},Ey=e=>({cache:Ay(e.cacheSize),parseClassName:Vy(e),...Sy(e)}),Ry=/\s+/,Dy=(e,o)=>{const{parseClassName:n,getClassGroupId:t,getConflictingClassGroupIds:r}=o,a=[],i=e.trim().split(Ry);let s="";for(let c=i.length-1;c>=0;c-=1){const u=i[c],{modifiers:d,hasImportantModifier:p,baseClassName:v,maybePostfixModifierPosition:z}=n(u);let f=!!z,h=t(f?v.substring(0,z):v);if(!h){if(!f){s=u+(s.length>0?" "+s:s);continue}if(h=t(v),!h){s=u+(s.length>0?" "+s:s);continue}f=!1}const T=Oy(d).join(":"),k=p?T+dm:T,m=k+h;if(a.includes(m))continue;a.push(m);const b=r(h,f);for(let N=0;N<b.length;++N){const S=b[N];a.push(k+S)}s=u+(s.length>0?" "+s:s)}return s};function Uy(){let e=0,o,n,t="";for(;e<arguments.length;)(o=arguments[e++])&&(n=pm(o))&&(t&&(t+=" "),t+=n);return t}const pm=e=>{if(typeof e=="string")return e;let o,n="";for(let t=0;t<e.length;t++)e[t]&&(o=pm(e[t]))&&(n&&(n+=" "),n+=o);return n};function Ly(e,...o){let n,t,r,a=i;function i(c){const u=o.reduce((d,p)=>p(d),e());return n=Ey(u),t=n.cache.get,r=n.cache.set,a=s,s(c)}function s(c){const u=t(c);if(u)return u;const d=Dy(c,n);return r(c,d),d}return function(){return a(Uy.apply(null,arguments))}}const te=e=>{const o=n=>n[e]||[];return o.isThemeGetter=!0,o},vm=/^\[(?:([a-z-]+):)?(.+)\]$/i,Fy=/^\d+\/\d+$/,By=new Set(["px","full","screen"]),_y=/^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,Ky=/\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,$y=/^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,Hy=/^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,Xy=/^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,Vo=e=>ft(e)||By.has(e)||Fy.test(e),Qo=e=>Ot(e,"length",ez),ft=e=>!!e&&!Number.isNaN(Number(e)),as=e=>Ot(e,"number",ft),Qt=e=>!!e&&Number.isInteger(Number(e)),Zy=e=>e.endsWith("%")&&ft(e.slice(0,-1)),X=e=>vm.test(e),Yo=e=>_y.test(e),Wy=new Set(["length","size","percentage"]),Gy=e=>Ot(e,Wy,mm),Jy=e=>Ot(e,"position",mm),Qy=new Set(["image","url"]),Yy=e=>Ot(e,Qy,nz),qy=e=>Ot(e,"",oz),Yt=()=>!0,Ot=(e,o,n)=>{const t=vm.exec(e);return t?t[1]?typeof o=="string"?t[1]===o:o.has(t[1]):n(t[2]):!1},ez=e=>Ky.test(e)&&!$y.test(e),mm=()=>!1,oz=e=>Hy.test(e),nz=e=>Xy.test(e),tz=()=>{const e=te("colors"),o=te("spacing"),n=te("blur"),t=te("brightness"),r=te("borderColor"),a=te("borderRadius"),i=te("borderSpacing"),s=te("borderWidth"),c=te("contrast"),u=te("grayscale"),d=te("hueRotate"),p=te("invert"),v=te("gap"),z=te("gradientColorStops"),f=te("gradientColorStopPositions"),h=te("inset"),T=te("margin"),k=te("opacity"),m=te("padding"),b=te("saturate"),N=te("scale"),S=te("sepia"),A=te("skew"),y=te("space"),C=te("translate"),R=()=>["auto","contain","none"],V=()=>["auto","hidden","clip","visible","scroll"],Z=()=>["auto",X,o],B=()=>[X,o],oe=()=>["",Vo,Qo],ve=()=>["auto",ft,X],Le=()=>["bottom","center","left","left-bottom","left-top","right","right-bottom","right-top","top"],He=()=>["solid","dashed","dotted","double","none"],po=()=>["normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn","hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"],M=()=>["start","end","center","between","around","evenly","stretch"],U=()=>["","0",X],F=()=>["auto","avoid","all","avoid-page","page","left","right","column"],W=()=>[ft,X];return{cacheSize:500,separator:":",theme:{colors:[Yt],spacing:[Vo,Qo],blur:["none","",Yo,X],brightness:W(),borderColor:[e],borderRadius:["none","","full",Yo,X],borderSpacing:B(),borderWidth:oe(),contrast:W(),grayscale:U(),hueRotate:W(),invert:U(),gap:B(),gradientColorStops:[e],gradientColorStopPositions:[Zy,Qo],inset:Z(),margin:Z(),opacity:W(),padding:B(),saturate:W(),scale:W(),sepia:U(),skew:W(),space:B(),translate:B()},classGroups:{aspect:[{aspect:["auto","square","video",X]}],container:["container"],columns:[{columns:[Yo]}],"break-after":[{"break-after":F()}],"break-before":[{"break-before":F()}],"break-inside":[{"break-inside":["auto","avoid","avoid-page","avoid-column"]}],"box-decoration":[{"box-decoration":["slice","clone"]}],box:[{box:["border","content"]}],display:["block","inline-block","inline","flex","inline-flex","table","inline-table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row-group","table-row","flow-root","grid","inline-grid","contents","list-item","hidden"],float:[{float:["right","left","none","start","end"]}],clear:[{clear:["left","right","both","none","start","end"]}],isolation:["isolate","isolation-auto"],"object-fit":[{object:["contain","cover","fill","none","scale-down"]}],"object-position":[{object:[...Le(),X]}],overflow:[{overflow:V()}],"overflow-x":[{"overflow-x":V()}],"overflow-y":[{"overflow-y":V()}],overscroll:[{overscroll:R()}],"overscroll-x":[{"overscroll-x":R()}],"overscroll-y":[{"overscroll-y":R()}],position:["static","fixed","absolute","relative","sticky"],inset:[{inset:[h]}],"inset-x":[{"inset-x":[h]}],"inset-y":[{"inset-y":[h]}],start:[{start:[h]}],end:[{end:[h]}],top:[{top:[h]}],right:[{right:[h]}],bottom:[{bottom:[h]}],left:[{left:[h]}],visibility:["visible","invisible","collapse"],z:[{z:["auto",Qt,X]}],basis:[{basis:Z()}],"flex-direction":[{flex:["row","row-reverse","col","col-reverse"]}],"flex-wrap":[{flex:["wrap","wrap-reverse","nowrap"]}],flex:[{flex:["1","auto","initial","none",X]}],grow:[{grow:U()}],shrink:[{shrink:U()}],order:[{order:["first","last","none",Qt,X]}],"grid-cols":[{"grid-cols":[Yt]}],"col-start-end":[{col:["auto",{span:["full",Qt,X]},X]}],"col-start":[{"col-start":ve()}],"col-end":[{"col-end":ve()}],"grid-rows":[{"grid-rows":[Yt]}],"row-start-end":[{row:["auto",{span:[Qt,X]},X]}],"row-start":[{"row-start":ve()}],"row-end":[{"row-end":ve()}],"grid-flow":[{"grid-flow":["row","col","dense","row-dense","col-dense"]}],"auto-cols":[{"auto-cols":["auto","min","max","fr",X]}],"auto-rows":[{"auto-rows":["auto","min","max","fr",X]}],gap:[{gap:[v]}],"gap-x":[{"gap-x":[v]}],"gap-y":[{"gap-y":[v]}],"justify-content":[{justify:["normal",...M()]}],"justify-items":[{"justify-items":["start","end","center","stretch"]}],"justify-self":[{"justify-self":["auto","start","end","center","stretch"]}],"align-content":[{content:["normal",...M(),"baseline"]}],"align-items":[{items:["start","end","center","baseline","stretch"]}],"align-self":[{self:["auto","start","end","center","stretch","baseline"]}],"place-content":[{"place-content":[...M(),"baseline"]}],"place-items":[{"place-items":["start","end","center","baseline","stretch"]}],"place-self":[{"place-self":["auto","start","end","center","stretch"]}],p:[{p:[m]}],px:[{px:[m]}],py:[{py:[m]}],ps:[{ps:[m]}],pe:[{pe:[m]}],pt:[{pt:[m]}],pr:[{pr:[m]}],pb:[{pb:[m]}],pl:[{pl:[m]}],m:[{m:[T]}],mx:[{mx:[T]}],my:[{my:[T]}],ms:[{ms:[T]}],me:[{me:[T]}],mt:[{mt:[T]}],mr:[{mr:[T]}],mb:[{mb:[T]}],ml:[{ml:[T]}],"space-x":[{"space-x":[y]}],"space-x-reverse":["space-x-reverse"],"space-y":[{"space-y":[y]}],"space-y-reverse":["space-y-reverse"],w:[{w:["auto","min","max","fit","svw","lvw","dvw",X,o]}],"min-w":[{"min-w":[X,o,"min","max","fit"]}],"max-w":[{"max-w":[X,o,"none","full","min","max","fit","prose",{screen:[Yo]},Yo]}],h:[{h:[X,o,"auto","min","max","fit","svh","lvh","dvh"]}],"min-h":[{"min-h":[X,o,"min","max","fit","svh","lvh","dvh"]}],"max-h":[{"max-h":[X,o,"min","max","fit","svh","lvh","dvh"]}],size:[{size:[X,o,"auto","min","max","fit"]}],"font-size":[{text:["base",Yo,Qo]}],"font-smoothing":["antialiased","subpixel-antialiased"],"font-style":["italic","not-italic"],"font-weight":[{font:["thin","extralight","light","normal","medium","semibold","bold","extrabold","black",as]}],"font-family":[{font:[Yt]}],"fvn-normal":["normal-nums"],"fvn-ordinal":["ordinal"],"fvn-slashed-zero":["slashed-zero"],"fvn-figure":["lining-nums","oldstyle-nums"],"fvn-spacing":["proportional-nums","tabular-nums"],"fvn-fraction":["diagonal-fractions","stacked-fractions"],tracking:[{tracking:["tighter","tight","normal","wide","wider","widest",X]}],"line-clamp":[{"line-clamp":["none",ft,as]}],leading:[{leading:["none","tight","snug","normal","relaxed","loose",Vo,X]}],"list-image":[{"list-image":["none",X]}],"list-style-type":[{list:["none","disc","decimal",X]}],"list-style-position":[{list:["inside","outside"]}],"placeholder-color":[{placeholder:[e]}],"placeholder-opacity":[{"placeholder-opacity":[k]}],"text-alignment":[{text:["left","center","right","justify","start","end"]}],"text-color":[{text:[e]}],"text-opacity":[{"text-opacity":[k]}],"text-decoration":["underline","overline","line-through","no-underline"],"text-decoration-style":[{decoration:[...He(),"wavy"]}],"text-decoration-thickness":[{decoration:["auto","from-font",Vo,Qo]}],"underline-offset":[{"underline-offset":["auto",Vo,X]}],"text-decoration-color":[{decoration:[e]}],"text-transform":["uppercase","lowercase","capitalize","normal-case"],"text-overflow":["truncate","text-ellipsis","text-clip"],"text-wrap":[{text:["wrap","nowrap","balance","pretty"]}],indent:[{indent:B()}],"vertical-align":[{align:["baseline","top","middle","bottom","text-top","text-bottom","sub","super",X]}],whitespace:[{whitespace:["normal","nowrap","pre","pre-line","pre-wrap","break-spaces"]}],break:[{break:["normal","words","all","keep"]}],hyphens:[{hyphens:["none","manual","auto"]}],content:[{content:["none",X]}],"bg-attachment":[{bg:["fixed","local","scroll"]}],"bg-clip":[{"bg-clip":["border","padding","content","text"]}],"bg-opacity":[{"bg-opacity":[k]}],"bg-origin":[{"bg-origin":["border","padding","content"]}],"bg-position":[{bg:[...Le(),Jy]}],"bg-repeat":[{bg:["no-repeat",{repeat:["","x","y","round","space"]}]}],"bg-size":[{bg:["auto","cover","contain",Gy]}],"bg-image":[{bg:["none",{"gradient-to":["t","tr","r","br","b","bl","l","tl"]},Yy]}],"bg-color":[{bg:[e]}],"gradient-from-pos":[{from:[f]}],"gradient-via-pos":[{via:[f]}],"gradient-to-pos":[{to:[f]}],"gradient-from":[{from:[z]}],"gradient-via":[{via:[z]}],"gradient-to":[{to:[z]}],rounded:[{rounded:[a]}],"rounded-s":[{"rounded-s":[a]}],"rounded-e":[{"rounded-e":[a]}],"rounded-t":[{"rounded-t":[a]}],"rounded-r":[{"rounded-r":[a]}],"rounded-b":[{"rounded-b":[a]}],"rounded-l":[{"rounded-l":[a]}],"rounded-ss":[{"rounded-ss":[a]}],"rounded-se":[{"rounded-se":[a]}],"rounded-ee":[{"rounded-ee":[a]}],"rounded-es":[{"rounded-es":[a]}],"rounded-tl":[{"rounded-tl":[a]}],"rounded-tr":[{"rounded-tr":[a]}],"rounded-br":[{"rounded-br":[a]}],"rounded-bl":[{"rounded-bl":[a]}],"border-w":[{border:[s]}],"border-w-x":[{"border-x":[s]}],"border-w-y":[{"border-y":[s]}],"border-w-s":[{"border-s":[s]}],"border-w-e":[{"border-e":[s]}],"border-w-t":[{"border-t":[s]}],"border-w-r":[{"border-r":[s]}],"border-w-b":[{"border-b":[s]}],"border-w-l":[{"border-l":[s]}],"border-opacity":[{"border-opacity":[k]}],"border-style":[{border:[...He(),"hidden"]}],"divide-x":[{"divide-x":[s]}],"divide-x-reverse":["divide-x-reverse"],"divide-y":[{"divide-y":[s]}],"divide-y-reverse":["divide-y-reverse"],"divide-opacity":[{"divide-opacity":[k]}],"divide-style":[{divide:He()}],"border-color":[{border:[r]}],"border-color-x":[{"border-x":[r]}],"border-color-y":[{"border-y":[r]}],"border-color-s":[{"border-s":[r]}],"border-color-e":[{"border-e":[r]}],"border-color-t":[{"border-t":[r]}],"border-color-r":[{"border-r":[r]}],"border-color-b":[{"border-b":[r]}],"border-color-l":[{"border-l":[r]}],"divide-color":[{divide:[r]}],"outline-style":[{outline:["",...He()]}],"outline-offset":[{"outline-offset":[Vo,X]}],"outline-w":[{outline:[Vo,Qo]}],"outline-color":[{outline:[e]}],"ring-w":[{ring:oe()}],"ring-w-inset":["ring-inset"],"ring-color":[{ring:[e]}],"ring-opacity":[{"ring-opacity":[k]}],"ring-offset-w":[{"ring-offset":[Vo,Qo]}],"ring-offset-color":[{"ring-offset":[e]}],shadow:[{shadow:["","inner","none",Yo,qy]}],"shadow-color":[{shadow:[Yt]}],opacity:[{opacity:[k]}],"mix-blend":[{"mix-blend":[...po(),"plus-lighter","plus-darker"]}],"bg-blend":[{"bg-blend":po()}],filter:[{filter:["","none"]}],blur:[{blur:[n]}],brightness:[{brightness:[t]}],contrast:[{contrast:[c]}],"drop-shadow":[{"drop-shadow":["","none",Yo,X]}],grayscale:[{grayscale:[u]}],"hue-rotate":[{"hue-rotate":[d]}],invert:[{invert:[p]}],saturate:[{saturate:[b]}],sepia:[{sepia:[S]}],"backdrop-filter":[{"backdrop-filter":["","none"]}],"backdrop-blur":[{"backdrop-blur":[n]}],"backdrop-brightness":[{"backdrop-brightness":[t]}],"backdrop-contrast":[{"backdrop-contrast":[c]}],"backdrop-grayscale":[{"backdrop-grayscale":[u]}],"backdrop-hue-rotate":[{"backdrop-hue-rotate":[d]}],"backdrop-invert":[{"backdrop-invert":[p]}],"backdrop-opacity":[{"backdrop-opacity":[k]}],"backdrop-saturate":[{"backdrop-saturate":[b]}],"backdrop-sepia":[{"backdrop-sepia":[S]}],"border-collapse":[{border:["collapse","separate"]}],"border-spacing":[{"border-spacing":[i]}],"border-spacing-x":[{"border-spacing-x":[i]}],"border-spacing-y":[{"border-spacing-y":[i]}],"table-layout":[{table:["auto","fixed"]}],caption:[{caption:["top","bottom"]}],transition:[{transition:["none","all","","colors","opacity","shadow","transform",X]}],duration:[{duration:W()}],ease:[{ease:["linear","in","out","in-out",X]}],delay:[{delay:W()}],animate:[{animate:["none","spin","ping","pulse","bounce",X]}],transform:[{transform:["","gpu","none"]}],scale:[{scale:[N]}],"scale-x":[{"scale-x":[N]}],"scale-y":[{"scale-y":[N]}],rotate:[{rotate:[Qt,X]}],"translate-x":[{"translate-x":[C]}],"translate-y":[{"translate-y":[C]}],"skew-x":[{"skew-x":[A]}],"skew-y":[{"skew-y":[A]}],"transform-origin":[{origin:["center","top","top-right","right","bottom-right","bottom","bottom-left","left","top-left",X]}],accent:[{accent:["auto",e]}],appearance:[{appearance:["none","auto"]}],cursor:[{cursor:["auto","default","pointer","wait","text","move","help","not-allowed","none","context-menu","progress","cell","crosshair","vertical-text","alias","copy","no-drop","grab","grabbing","all-scroll","col-resize","row-resize","n-resize","e-resize","s-resize","w-resize","ne-resize","nw-resize","se-resize","sw-resize","ew-resize","ns-resize","nesw-resize","nwse-resize","zoom-in","zoom-out",X]}],"caret-color":[{caret:[e]}],"pointer-events":[{"pointer-events":["none","auto"]}],resize:[{resize:["none","y","x",""]}],"scroll-behavior":[{scroll:["auto","smooth"]}],"scroll-m":[{"scroll-m":B()}],"scroll-mx":[{"scroll-mx":B()}],"scroll-my":[{"scroll-my":B()}],"scroll-ms":[{"scroll-ms":B()}],"scroll-me":[{"scroll-me":B()}],"scroll-mt":[{"scroll-mt":B()}],"scroll-mr":[{"scroll-mr":B()}],"scroll-mb":[{"scroll-mb":B()}],"scroll-ml":[{"scroll-ml":B()}],"scroll-p":[{"scroll-p":B()}],"scroll-px":[{"scroll-px":B()}],"scroll-py":[{"scroll-py":B()}],"scroll-ps":[{"scroll-ps":B()}],"scroll-pe":[{"scroll-pe":B()}],"scroll-pt":[{"scroll-pt":B()}],"scroll-pr":[{"scroll-pr":B()}],"scroll-pb":[{"scroll-pb":B()}],"scroll-pl":[{"scroll-pl":B()}],"snap-align":[{snap:["start","end","center","align-none"]}],"snap-stop":[{snap:["normal","always"]}],"snap-type":[{snap:["none","x","y","both"]}],"snap-strictness":[{snap:["mandatory","proximity"]}],touch:[{touch:["auto","none","manipulation"]}],"touch-x":[{"touch-pan":["x","left","right"]}],"touch-y":[{"touch-pan":["y","up","down"]}],"touch-pz":["touch-pinch-zoom"],select:[{select:["none","text","all","auto"]}],"will-change":[{"will-change":["auto","scroll","contents","transform",X]}],fill:[{fill:[e,"none"]}],"stroke-w":[{stroke:[Vo,Qo,as]}],stroke:[{stroke:[e,"none"]}],sr:["sr-only","not-sr-only"],"forced-color-adjust":[{"forced-color-adjust":["auto","none"]}]},conflictingClassGroups:{overflow:["overflow-x","overflow-y"],overscroll:["overscroll-x","overscroll-y"],inset:["inset-x","inset-y","start","end","top","right","bottom","left"],"inset-x":["right","left"],"inset-y":["top","bottom"],flex:["basis","grow","shrink"],gap:["gap-x","gap-y"],p:["px","py","ps","pe","pt","pr","pb","pl"],px:["pr","pl"],py:["pt","pb"],m:["mx","my","ms","me","mt","mr","mb","ml"],mx:["mr","ml"],my:["mt","mb"],size:["w","h"],"font-size":["leading"],"fvn-normal":["fvn-ordinal","fvn-slashed-zero","fvn-figure","fvn-spacing","fvn-fraction"],"fvn-ordinal":["fvn-normal"],"fvn-slashed-zero":["fvn-normal"],"fvn-figure":["fvn-normal"],"fvn-spacing":["fvn-normal"],"fvn-fraction":["fvn-normal"],"line-clamp":["display","overflow"],rounded:["rounded-s","rounded-e","rounded-t","rounded-r","rounded-b","rounded-l","rounded-ss","rounded-se","rounded-ee","rounded-es","rounded-tl","rounded-tr","rounded-br","rounded-bl"],"rounded-s":["rounded-ss","rounded-es"],"rounded-e":["rounded-se","rounded-ee"],"rounded-t":["rounded-tl","rounded-tr"],"rounded-r":["rounded-tr","rounded-br"],"rounded-b":["rounded-br","rounded-bl"],"rounded-l":["rounded-tl","rounded-bl"],"border-spacing":["border-spacing-x","border-spacing-y"],"border-w":["border-w-s","border-w-e","border-w-t","border-w-r","border-w-b","border-w-l"],"border-w-x":["border-w-r","border-w-l"],"border-w-y":["border-w-t","border-w-b"],"border-color":["border-color-s","border-color-e","border-color-t","border-color-r","border-color-b","border-color-l"],"border-color-x":["border-color-r","border-color-l"],"border-color-y":["border-color-t","border-color-b"],"scroll-m":["scroll-mx","scroll-my","scroll-ms","scroll-me","scroll-mt","scroll-mr","scroll-mb","scroll-ml"],"scroll-mx":["scroll-mr","scroll-ml"],"scroll-my":["scroll-mt","scroll-mb"],"scroll-p":["scroll-px","scroll-py","scroll-ps","scroll-pe","scroll-pt","scroll-pr","scroll-pb","scroll-pl"],"scroll-px":["scroll-pr","scroll-pl"],"scroll-py":["scroll-pt","scroll-pb"],touch:["touch-x","touch-y","touch-pz"],"touch-x":["touch"],"touch-y":["touch"],"touch-pz":["touch"]},conflictingClassGroupModifiers:{"font-size":["leading"]}}},rz=Ly(tz);function Ao(...e){return rz(um(e))}function az(e){const o=[...e];for(let n=o.length-1;n>0;n--){const t=Math.floor(Math.random()*(n+1)),r=o[n];o[n]=o[t],o[t]=r}return o}function iz(e){return`${e}_${new Date().getTime()}`}const sz=xy("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",{variants:{variant:{default:"bg-primary text-primary-foreground hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground hover:bg-destructive/90",outline:"border border-input bg-background hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground hover:bg-secondary/80",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-10 px-4 py-2",sm:"h-9 rounded-md px-3",lg:"h-11 rounded-md px-8",icon:"h-10 w-10"}},defaultVariants:{variant:"default",size:"default"}}),zo=l.forwardRef(({className:e,variant:o,size:n,asChild:t=!1,...r},a)=>{const i=t?Hn:"button";return j.jsx(i,{className:Ao(sz({variant:o,size:n,className:e})),ref:a,...r})});zo.displayName="Button";/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const cz=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),km=(...e)=>e.filter((o,n,t)=>!!o&&t.indexOf(o)===n).join(" ");/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var uz={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lz=l.forwardRef(({color:e="currentColor",size:o=24,strokeWidth:n=2,absoluteStrokeWidth:t,className:r="",children:a,iconNode:i,...s},c)=>l.createElement("svg",{ref:c,...uz,width:o,height:o,stroke:e,strokeWidth:t?Number(n)*24/Number(o):n,className:km("lucide",r),...s},[...i.map(([u,d])=>l.createElement(u,d)),...Array.isArray(a)?a:[a]]));/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Pi=(e,o)=>{const n=l.forwardRef(({className:t,...r},a)=>l.createElement(lz,{ref:a,iconNode:o,className:km(`lucide-${cz(e)}`,t),...r}));return n.displayName=`${e}`,n};/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hm=Pi("Check",[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]]);/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rd=Pi("Github",[["path",{d:"M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4",key:"tonef"}],["path",{d:"M9 18c-4.51 2-5-2-7-2",key:"9comsn"}]]);/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const gt=Pi("Link",[["path",{d:"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",key:"1cjeqo"}],["path",{d:"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",key:"19qd67"}]]);/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const bm=Pi("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),dz=(e,o)=>j.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",width:800,height:800,fill:"none",viewBox:"0 0 24 24",ref:o,...e,children:j.jsx("path",{stroke:"currentColor",strokeLinejoin:"round",d:"M18.894 4.344A17.409 17.409 0 0 0 14.532 3c-.192.33-.406.779-.555 1.13a16.677 16.677 0 0 0-4.833 0c-.15-.351-.373-.8-.555-1.13a17.162 17.162 0 0 0-4.363 1.344C1.463 8.419.716 12.397 1.09 16.323A17.782 17.782 0 0 0 6.435 19a13 13 0 0 0 1.14-1.845 11.182 11.182 0 0 1-1.802-.864c.15-.107.299-.224.438-.342 3.477 1.59 7.243 1.59 10.678 0 .15.118.288.235.437.342a11.18 11.18 0 0 1-1.802.864A13 13 0 0 0 16.665 19a17.684 17.684 0 0 0 5.345-2.677c.459-4.544-.726-8.491-3.116-11.979ZM8.056 13.901c-1.045 0-1.899-.949-1.899-2.112 0-1.162.832-2.112 1.899-2.112 1.056 0 1.92.95 1.899 2.112 0 1.163-.843 2.112-1.9 2.112Zm7.009 0c-1.045 0-1.9-.949-1.9-2.112 0-1.162.833-2.112 1.9-2.112 1.056 0 1.92.95 1.899 2.112 0 1.163-.832 2.112-1.899 2.112Z"})}),ym=l.forwardRef(dz);ym.displayName="Discord";/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function se(){return se=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},se.apply(this,arguments)}var he;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(he||(he={}));const ad="popstate";function pz(e){e===void 0&&(e={});function o(r,a){let{pathname:i="/",search:s="",hash:c=""}=Ho(r.location.hash.substr(1));return!i.startsWith("/")&&!i.startsWith(".")&&(i="/"+i),Or("",{pathname:i,search:s,hash:c},a.state&&a.state.usr||null,a.state&&a.state.key||"default")}function n(r,a){let i=r.document.querySelector("base"),s="";if(i&&i.getAttribute("href")){let c=r.location.href,u=c.indexOf("#");s=u===-1?c:c.slice(0,u)}return s+"#"+(typeof a=="string"?a:Ln(a))}function t(r,a){Un(r.pathname.charAt(0)==="/","relative pathnames are not supported in hash history.push("+JSON.stringify(a)+")")}return mz(o,n,t,e)}function G(e,o){if(e===!1||e===null||typeof e>"u")throw new Error(o)}function Un(e,o){if(!e){typeof console<"u"&&console.warn(o);try{throw new Error(o)}catch{}}}function vz(){return Math.random().toString(36).substr(2,8)}function id(e,o){return{usr:e.state,key:e.key,idx:o}}function Or(e,o,n,t){return n===void 0&&(n=null),se({pathname:typeof e=="string"?e:e.pathname,search:"",hash:""},typeof o=="string"?Ho(o):o,{state:n,key:o&&o.key||t||vz()})}function Ln(e){let{pathname:o="/",search:n="",hash:t=""}=e;return n&&n!=="?"&&(o+=n.charAt(0)==="?"?n:"?"+n),t&&t!=="#"&&(o+=t.charAt(0)==="#"?t:"#"+t),o}function Ho(e){let o={};if(e){let n=e.indexOf("#");n>=0&&(o.hash=e.substr(n),e=e.substr(0,n));let t=e.indexOf("?");t>=0&&(o.search=e.substr(t),e=e.substr(0,t)),e&&(o.pathname=e)}return o}function mz(e,o,n,t){t===void 0&&(t={});let{window:r=document.defaultView,v5Compat:a=!1}=t,i=r.history,s=he.Pop,c=null,u=d();u==null&&(u=0,i.replaceState(se({},i.state,{idx:u}),""));function d(){return(i.state||{idx:null}).idx}function p(){s=he.Pop;let T=d(),k=T==null?null:T-u;u=T,c&&c({action:s,location:h.location,delta:k})}function v(T,k){s=he.Push;let m=Or(h.location,T,k);n&&n(m,T),u=d()+1;let b=id(m,u),N=h.createHref(m);try{i.pushState(b,"",N)}catch(S){if(S instanceof DOMException&&S.name==="DataCloneError")throw S;r.location.assign(N)}a&&c&&c({action:s,location:h.location,delta:1})}function z(T,k){s=he.Replace;let m=Or(h.location,T,k);n&&n(m,T),u=d();let b=id(m,u),N=h.createHref(m);i.replaceState(b,"",N),a&&c&&c({action:s,location:h.location,delta:0})}function f(T){let k=r.location.origin!=="null"?r.location.origin:r.location.href,m=typeof T=="string"?T:Ln(T);return m=m.replace(/ $/,"%20"),G(k,"No window.location.(origin|href) available to create URL for href: "+m),new URL(m,k)}let h={get action(){return s},get location(){return e(r,i)},listen(T){if(c)throw new Error("A history only accepts one active listener");return r.addEventListener(ad,p),c=T,()=>{r.removeEventListener(ad,p),c=null}},createHref(T){return o(r,T)},createURL:f,encodeLocation(T){let k=f(T);return{pathname:k.pathname,search:k.search,hash:k.hash}},push:v,replace:z,go(T){return i.go(T)}};return h}var ce;(function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"})(ce||(ce={}));const kz=new Set(["lazy","caseSensitive","path","id","index","children"]);function hz(e){return e.index===!0}function vc(e,o,n,t){return n===void 0&&(n=[]),t===void 0&&(t={}),e.map((r,a)=>{let i=[...n,a],s=typeof r.id=="string"?r.id:i.join("-");if(G(r.index!==!0||!r.children,"Cannot specify children on an index route"),G(!t[s],'Found a route id collision on id "'+s+`".  Route id's must be globally unique within Data Router usages`),hz(r)){let c=se({},r,o(r),{id:s});return t[s]=c,c}else{let c=se({},r,o(r),{id:s,children:void 0});return t[s]=c,r.children&&(c.children=vc(r.children,o,i,t)),c}})}function vt(e,o,n){n===void 0&&(n="/");let t=typeof o=="string"?Ho(o):o,r=Et(t.pathname||"/",n);if(r==null)return null;let a=zm(e);yz(a);let i=null;for(let s=0;i==null&&s<a.length;++s){let c=Mz(r);i=Sz(a[s],c)}return i}function bz(e,o){let{route:n,pathname:t,params:r}=e;return{id:n.id,pathname:t,params:r,data:o[n.id],handle:n.handle}}function zm(e,o,n,t){o===void 0&&(o=[]),n===void 0&&(n=[]),t===void 0&&(t="");let r=(a,i,s)=>{let c={relativePath:s===void 0?a.path||"":s,caseSensitive:a.caseSensitive===!0,childrenIndex:i,route:a};c.relativePath.startsWith("/")&&(G(c.relativePath.startsWith(t),'Absolute route path "'+c.relativePath+'" nested under path '+('"'+t+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),c.relativePath=c.relativePath.slice(t.length));let u=Lo([t,c.relativePath]),d=n.concat(c);a.children&&a.children.length>0&&(G(a.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+u+'".')),zm(a.children,o,d,u)),!(a.path==null&&!a.index)&&o.push({path:u,score:Pz(u,a.index),routesMeta:d})};return e.forEach((a,i)=>{var s;if(a.path===""||!((s=a.path)!=null&&s.includes("?")))r(a,i);else for(let c of jm(a.path))r(a,i,c)}),o}function jm(e){let o=e.split("/");if(o.length===0)return[];let[n,...t]=o,r=n.endsWith("?"),a=n.replace(/\?$/,"");if(t.length===0)return r?[a,""]:[a];let i=jm(t.join("/")),s=[];return s.push(...i.map(c=>c===""?a:[a,c].join("/"))),r&&s.push(...i),s.map(c=>e.startsWith("/")&&c===""?"/":c)}function yz(e){e.sort((o,n)=>o.score!==n.score?n.score-o.score:xz(o.routesMeta.map(t=>t.childrenIndex),n.routesMeta.map(t=>t.childrenIndex)))}const zz=/^:[\w-]+$/,jz=3,fz=2,gz=1,Tz=10,Nz=-2,sd=e=>e==="*";function Pz(e,o){let n=e.split("/"),t=n.length;return n.some(sd)&&(t+=Nz),o&&(t+=fz),n.filter(r=>!sd(r)).reduce((r,a)=>r+(zz.test(a)?jz:a===""?gz:Tz),t)}function xz(e,o){return e.length===o.length&&e.slice(0,-1).every((t,r)=>t===o[r])?e[e.length-1]-o[o.length-1]:0}function Sz(e,o){let{routesMeta:n}=e,t={},r="/",a=[];for(let i=0;i<n.length;++i){let s=n[i],c=i===n.length-1,u=r==="/"?o:o.slice(r.length)||"/",d=wz({path:s.relativePath,caseSensitive:s.caseSensitive,end:c},u);if(!d)return null;Object.assign(t,d.params);let p=s.route;a.push({params:t,pathname:Lo([r,d.pathname]),pathnameBase:Vz(Lo([r,d.pathnameBase])),route:p}),d.pathnameBase!=="/"&&(r=Lo([r,d.pathnameBase]))}return a}function wz(e,o){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,t]=Cz(e.path,e.caseSensitive,e.end),r=o.match(n);if(!r)return null;let a=r[0],i=a.replace(/(.)\/+$/,"$1"),s=r.slice(1);return{params:t.reduce((u,d,p)=>{let{paramName:v,isOptional:z}=d;if(v==="*"){let h=s[p]||"";i=a.slice(0,a.length-h.length).replace(/(.)\/+$/,"$1")}const f=s[p];return z&&!f?u[v]=void 0:u[v]=(f||"").replace(/%2F/g,"/"),u},{}),pathname:a,pathnameBase:i,pattern:e}}function Cz(e,o,n){o===void 0&&(o=!1),n===void 0&&(n=!0),Un(e==="*"||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were '+('"'+e.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+e.replace(/\*$/,"/*")+'".'));let t=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,s,c)=>(t.push({paramName:s,isOptional:c!=null}),c?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(t.push({paramName:"*"}),r+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":e!==""&&e!=="/"&&(r+="(?:(?=\\/|$))"),[new RegExp(r,o?void 0:"i"),t]}function Mz(e){try{return e.split("/").map(o=>decodeURIComponent(o).replace(/\//g,"%2F")).join("/")}catch(o){return Un(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+o+").")),e}}function Et(e,o){if(o==="/")return e;if(!e.toLowerCase().startsWith(o.toLowerCase()))return null;let n=o.endsWith("/")?o.length-1:o.length,t=e.charAt(n);return t&&t!=="/"?null:e.slice(n)||"/"}function Iz(e,o){o===void 0&&(o="/");let{pathname:n,search:t="",hash:r=""}=typeof e=="string"?Ho(e):e;return{pathname:n?n.startsWith("/")?n:Az(n,o):o,search:Oz(t),hash:Ez(r)}}function Az(e,o){let n=o.replace(/\/+$/,"").split("/");return e.split("/").forEach(r=>{r===".."?n.length>1&&n.pop():r!=="."&&n.push(r)}),n.length>1?n.join("/"):"/"}function is(e,o,n,t){return"Cannot include a '"+e+"' character in a manually specified "+("`to."+o+"` field ["+JSON.stringify(t)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function fm(e){return e.filter((o,n)=>n===0||o.route.path&&o.route.path.length>0)}function bu(e,o){let n=fm(e);return o?n.map((t,r)=>r===e.length-1?t.pathname:t.pathnameBase):n.map(t=>t.pathnameBase)}function yu(e,o,n,t){t===void 0&&(t=!1);let r;typeof e=="string"?r=Ho(e):(r=se({},e),G(!r.pathname||!r.pathname.includes("?"),is("?","pathname","search",r)),G(!r.pathname||!r.pathname.includes("#"),is("#","pathname","hash",r)),G(!r.search||!r.search.includes("#"),is("#","search","hash",r)));let a=e===""||r.pathname==="",i=a?"/":r.pathname,s;if(i==null)s=n;else{let p=o.length-1;if(!t&&i.startsWith("..")){let v=i.split("/");for(;v[0]==="..";)v.shift(),p-=1;r.pathname=v.join("/")}s=p>=0?o[p]:"/"}let c=Iz(r,s),u=i&&i!=="/"&&i.endsWith("/"),d=(a||i===".")&&n.endsWith("/");return!c.pathname.endsWith("/")&&(u||d)&&(c.pathname+="/"),c}const Lo=e=>e.join("/").replace(/\/\/+/g,"/"),Vz=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),Oz=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,Ez=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e,Co=function(o,n){n===void 0&&(n=302);let t=n;typeof t=="number"?t={status:t}:typeof t.status>"u"&&(t.status=302);let r=new Headers(t.headers);return r.set("Location",o),new Response(null,se({},t,{headers:r}))};class zu{constructor(o,n,t,r){r===void 0&&(r=!1),this.status=o,this.statusText=n||"",this.internal=r,t instanceof Error?(this.data=t.toString(),this.error=t):this.data=t}}function ju(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}const gm=["post","put","patch","delete"],Rz=new Set(gm),Dz=["get",...gm],Uz=new Set(Dz),Lz=new Set([301,302,303,307,308]),Fz=new Set([307,308]),ss={state:"idle",location:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},Bz={state:"idle",data:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},qt={state:"unblocked",proceed:void 0,reset:void 0,location:void 0},fu=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,_z=e=>({hasErrorBoundary:!!e.hasErrorBoundary}),Tm="remix-router-transitions";function Kz(e){const o=e.window?e.window:typeof window<"u"?window:void 0,n=typeof o<"u"&&typeof o.document<"u"&&typeof o.document.createElement<"u",t=!n;G(e.routes.length>0,"You must provide a non-empty routes array to createRouter");let r;if(e.mapRouteProperties)r=e.mapRouteProperties;else if(e.detectErrorBoundary){let g=e.detectErrorBoundary;r=P=>({hasErrorBoundary:g(P)})}else r=_z;let a={},i=vc(e.routes,r,void 0,a),s,c=e.basename||"/",u=e.unstable_dataStrategy||Zz,d=se({v7_fetcherPersist:!1,v7_normalizeFormMethod:!1,v7_partialHydration:!1,v7_prependBasename:!1,v7_relativeSplatPath:!1,unstable_skipActionErrorRevalidation:!1},e.future),p=null,v=new Set,z=null,f=null,h=null,T=e.hydrationData!=null,k=vt(i,e.history.location,c),m=null;if(k==null){let g=to(404,{pathname:e.history.location.pathname}),{matches:P,route:x}=bd(i);k=P,m={[x.id]:g}}let b,N=k.some(g=>g.route.lazy),S=k.some(g=>g.route.loader);if(N)b=!1;else if(!S)b=!0;else if(d.v7_partialHydration){let g=e.hydrationData?e.hydrationData.loaderData:null,P=e.hydrationData?e.hydrationData.errors:null,x=I=>I.route.loader?typeof I.route.loader=="function"&&I.route.loader.hydrate===!0?!1:g&&g[I.route.id]!==void 0||P&&P[I.route.id]!==void 0:!0;if(P){let I=k.findIndex(E=>P[E.route.id]!==void 0);b=k.slice(0,I+1).every(x)}else b=k.every(x)}else b=e.hydrationData!=null;let A,y={historyAction:e.history.action,location:e.history.location,matches:k,initialized:b,navigation:ss,restoreScrollPosition:e.hydrationData!=null?!1:null,preventScrollReset:!1,revalidation:"idle",loaderData:e.hydrationData&&e.hydrationData.loaderData||{},actionData:e.hydrationData&&e.hydrationData.actionData||null,errors:e.hydrationData&&e.hydrationData.errors||m,fetchers:new Map,blockers:new Map},C=he.Pop,R=!1,V,Z=!1,B=new Map,oe=null,ve=!1,Le=!1,He=[],po=[],M=new Map,U=0,F=-1,W=new Map,ee=new Set,vo=new Map,Xe=new Map,Ze=new Set,Ve=new Map,oo=new Map,Mi=!1;function Ok(){if(p=e.history.listen(g=>{let{action:P,location:x,delta:I}=g;if(Mi){Mi=!1;return}Un(oo.size===0||I!=null,"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");let E=Fu({currentLocation:y.location,nextLocation:x,historyAction:P});if(E&&I!=null){Mi=!0,e.history.go(I*-1),Gr(E,{state:"blocked",location:x,proceed(){Gr(E,{state:"proceeding",proceed:void 0,reset:void 0,location:x}),e.history.go(I)},reset(){let $=new Map(y.blockers);$.set(E,qt),We({blockers:$})}});return}return gn(P,x)}),n){aj(o,B);let g=()=>ij(o,B);o.addEventListener("pagehide",g),oe=()=>o.removeEventListener("pagehide",g)}return y.initialized||gn(he.Pop,y.location,{initialHydration:!0}),A}function Ek(){p&&p(),oe&&oe(),v.clear(),V&&V.abort(),y.fetchers.forEach((g,P)=>Wr(P)),y.blockers.forEach((g,P)=>Lu(P))}function Rk(g){return v.add(g),()=>v.delete(g)}function We(g,P){P===void 0&&(P={}),y=se({},y,g);let x=[],I=[];d.v7_fetcherPersist&&y.fetchers.forEach((E,$)=>{E.state==="idle"&&(Ze.has($)?I.push($):x.push($))}),[...v].forEach(E=>E(y,{deletedFetchers:I,unstable_viewTransitionOpts:P.viewTransitionOpts,unstable_flushSync:P.flushSync===!0})),d.v7_fetcherPersist&&(x.forEach(E=>y.fetchers.delete(E)),I.forEach(E=>Wr(E)))}function Dt(g,P,x){var I,E;let{flushSync:$}=x===void 0?{}:x,L=y.actionData!=null&&y.navigation.formMethod!=null&&bo(y.navigation.formMethod)&&y.navigation.state==="loading"&&((I=g.state)==null?void 0:I._isRedirect)!==!0,D;P.actionData?Object.keys(P.actionData).length>0?D=P.actionData:D=null:L?D=y.actionData:D=null;let H=P.loaderData?kd(y.loaderData,P.loaderData,P.matches||[],P.errors):y.loaderData,K=y.blockers;K.size>0&&(K=new Map(K),K.forEach((_,ie)=>K.set(ie,qt)));let Te=R===!0||y.navigation.formMethod!=null&&bo(y.navigation.formMethod)&&((E=g.state)==null?void 0:E._isRedirect)!==!0;s&&(i=s,s=void 0),ve||C===he.Pop||(C===he.Push?e.history.push(g,g.state):C===he.Replace&&e.history.replace(g,g.state));let Ne;if(C===he.Pop){let _=B.get(y.location.pathname);_&&_.has(g.pathname)?Ne={currentLocation:y.location,nextLocation:g}:B.has(g.pathname)&&(Ne={currentLocation:g,nextLocation:y.location})}else if(Z){let _=B.get(y.location.pathname);_?_.add(g.pathname):(_=new Set([g.pathname]),B.set(y.location.pathname,_)),Ne={currentLocation:y.location,nextLocation:g}}We(se({},P,{actionData:D,loaderData:H,historyAction:C,location:g,initialized:!0,navigation:ss,revalidation:"idle",restoreScrollPosition:_u(g,P.matches||y.matches),preventScrollReset:Te,blockers:K}),{viewTransitionOpts:Ne,flushSync:$===!0}),C=he.Pop,R=!1,Z=!1,ve=!1,Le=!1,He=[],po=[]}async function Vu(g,P){if(typeof g=="number"){e.history.go(g);return}let x=mc(y.location,y.matches,c,d.v7_prependBasename,g,d.v7_relativeSplatPath,P==null?void 0:P.fromRouteId,P==null?void 0:P.relative),{path:I,submission:E,error:$}=cd(d.v7_normalizeFormMethod,!1,x,P),L=y.location,D=Or(y.location,I,P&&P.state);D=se({},D,e.history.encodeLocation(D));let H=P&&P.replace!=null?P.replace:void 0,K=he.Push;H===!0?K=he.Replace:H===!1||E!=null&&bo(E.formMethod)&&E.formAction===y.location.pathname+y.location.search&&(K=he.Replace);let Te=P&&"preventScrollReset"in P?P.preventScrollReset===!0:void 0,Ne=(P&&P.unstable_flushSync)===!0,_=Fu({currentLocation:L,nextLocation:D,historyAction:K});if(_){Gr(_,{state:"blocked",location:D,proceed(){Gr(_,{state:"proceeding",proceed:void 0,reset:void 0,location:D}),Vu(g,P)},reset(){let ie=new Map(y.blockers);ie.set(_,qt),We({blockers:ie})}});return}return await gn(K,D,{submission:E,pendingError:$,preventScrollReset:Te,replace:P&&P.replace,enableViewTransition:P&&P.unstable_viewTransition,flushSync:Ne})}function Dk(){if(Ii(),We({revalidation:"loading"}),y.navigation.state!=="submitting"){if(y.navigation.state==="idle"){gn(y.historyAction,y.location,{startUninterruptedRevalidation:!0});return}gn(C||y.historyAction,y.navigation.location,{overrideNavigation:y.navigation})}}async function gn(g,P,x){V&&V.abort(),V=null,C=g,ve=(x&&x.startUninterruptedRevalidation)===!0,Xk(y.location,y.matches),R=(x&&x.preventScrollReset)===!0,Z=(x&&x.enableViewTransition)===!0;let I=s||i,E=x&&x.overrideNavigation,$=vt(I,P,c),L=(x&&x.flushSync)===!0;if(!$){let _=to(404,{pathname:P.pathname}),{matches:ie,route:je}=bd(I);Ai(),Dt(P,{matches:ie,loaderData:{},errors:{[je.id]:_}},{flushSync:L});return}if(y.initialized&&!Le&&qz(y.location,P)&&!(x&&x.submission&&bo(x.submission.formMethod))){Dt(P,{matches:$},{flushSync:L});return}V=new AbortController;let D=Qn(e.history,P,V.signal,x&&x.submission),H;if(x&&x.pendingError)H=[kr($).route.id,{type:ce.error,error:x.pendingError}];else if(x&&x.submission&&bo(x.submission.formMethod)){let _=await Uk(D,P,x.submission,$,{replace:x.replace,flushSync:L});if(_.shortCircuited)return;H=_.pendingActionResult,E=cs(P,x.submission),L=!1,D=Qn(e.history,D.url,D.signal)}let{shortCircuited:K,loaderData:Te,errors:Ne}=await Lk(D,P,$,E,x&&x.submission,x&&x.fetcherSubmission,x&&x.replace,x&&x.initialHydration===!0,L,H);K||(V=null,Dt(P,se({matches:$},hd(H),{loaderData:Te,errors:Ne})))}async function Uk(g,P,x,I,E){E===void 0&&(E={}),Ii();let $=tj(P,x);We({navigation:$},{flushSync:E.flushSync===!0});let L,D=hc(I,P);if(!D.route.action&&!D.route.lazy)L={type:ce.error,error:to(405,{method:g.method,pathname:P.pathname,routeId:D.route.id})};else if(L=(await Lt("action",g,[D],I))[0],g.signal.aborted)return{shortCircuited:!0};if(Cn(L)){let H;return E&&E.replace!=null?H=E.replace:H=pd(L.response.headers.get("Location"),new URL(g.url),c)===y.location.pathname+y.location.search,await Ut(g,L,{submission:x,replace:H}),{shortCircuited:!0}}if(wn(L))throw to(400,{type:"defer-action"});if(io(L)){let H=kr(I,D.route.id);return(E&&E.replace)!==!0&&(C=he.Push),{pendingActionResult:[H.route.id,L]}}return{pendingActionResult:[D.route.id,L]}}async function Lk(g,P,x,I,E,$,L,D,H,K){let Te=I||cs(P,E),Ne=E||$||jd(Te),_=s||i,[ie,je]=ud(e.history,y,x,Ne,P,d.v7_partialHydration&&D===!0,d.unstable_skipActionErrorRevalidation,Le,He,po,Ze,vo,ee,_,c,K);if(Ai(Q=>!(x&&x.some(Oe=>Oe.route.id===Q))||ie&&ie.some(Oe=>Oe.route.id===Q)),F=++U,ie.length===0&&je.length===0){let Q=Du();return Dt(P,se({matches:x,loaderData:{},errors:K&&io(K[1])?{[K[0]]:K[1].error}:null},hd(K),Q?{fetchers:new Map(y.fetchers)}:{}),{flushSync:H}),{shortCircuited:!0}}if(!ve&&(!d.v7_partialHydration||!D)){je.forEach(Oe=>{let no=y.fetchers.get(Oe.key),Pe=er(void 0,no?no.data:void 0);y.fetchers.set(Oe.key,Pe)});let Q;K&&!io(K[1])?Q={[K[0]]:K[1].data}:y.actionData&&(Object.keys(y.actionData).length===0?Q=null:Q=y.actionData),We(se({navigation:Te},Q!==void 0?{actionData:Q}:{},je.length>0?{fetchers:new Map(y.fetchers)}:{}),{flushSync:H})}je.forEach(Q=>{M.has(Q.key)&&Wo(Q.key),Q.controller&&M.set(Q.key,Q.controller)});let Bt=()=>je.forEach(Q=>Wo(Q.key));V&&V.signal.addEventListener("abort",Bt);let{loaderResults:Go,fetcherResults:Zn}=await Ou(y.matches,x,ie,je,g);if(g.signal.aborted)return{shortCircuited:!0};V&&V.signal.removeEventListener("abort",Bt),je.forEach(Q=>M.delete(Q.key));let Wn=yd([...Go,...Zn]);if(Wn){if(Wn.idx>=ie.length){let Q=je[Wn.idx-ie.length].key;ee.add(Q)}return await Ut(g,Wn.result,{replace:L}),{shortCircuited:!0}}let{loaderData:Gn,errors:No}=md(y,x,ie,Go,K,je,Zn,Ve);Ve.forEach((Q,Oe)=>{Q.subscribe(no=>{(no||Q.done)&&Ve.delete(Oe)})}),d.v7_partialHydration&&D&&y.errors&&Object.entries(y.errors).filter(Q=>{let[Oe]=Q;return!ie.some(no=>no.route.id===Oe)}).forEach(Q=>{let[Oe,no]=Q;No=Object.assign(No||{},{[Oe]:no})});let Jr=Du(),Qr=Uu(F),Yr=Jr||Qr||je.length>0;return se({loaderData:Gn,errors:No},Yr?{fetchers:new Map(y.fetchers)}:{})}function Fk(g,P,x,I){if(t)throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");M.has(g)&&Wo(g);let E=(I&&I.unstable_flushSync)===!0,$=s||i,L=mc(y.location,y.matches,c,d.v7_prependBasename,x,d.v7_relativeSplatPath,P,I==null?void 0:I.relative),D=vt($,L,c);if(!D){Ft(g,P,to(404,{pathname:L}),{flushSync:E});return}let{path:H,submission:K,error:Te}=cd(d.v7_normalizeFormMethod,!0,L,I);if(Te){Ft(g,P,Te,{flushSync:E});return}let Ne=hc(D,H);if(R=(I&&I.preventScrollReset)===!0,K&&bo(K.formMethod)){Bk(g,P,H,Ne,D,E,K);return}vo.set(g,{routeId:P,path:H}),_k(g,P,H,Ne,D,E,K)}async function Bk(g,P,x,I,E,$,L){if(Ii(),vo.delete(g),!I.route.action&&!I.route.lazy){let Pe=to(405,{method:L.formMethod,pathname:x,routeId:P});Ft(g,P,Pe,{flushSync:$});return}let D=y.fetchers.get(g);Zo(g,rj(L,D),{flushSync:$});let H=new AbortController,K=Qn(e.history,x,H.signal,L);M.set(g,H);let Te=U,_=(await Lt("action",K,[I],E))[0];if(K.signal.aborted){M.get(g)===H&&M.delete(g);return}if(d.v7_fetcherPersist&&Ze.has(g)){if(Cn(_)||io(_)){Zo(g,qo(void 0));return}}else{if(Cn(_))if(M.delete(g),F>Te){Zo(g,qo(void 0));return}else return ee.add(g),Zo(g,er(L)),Ut(K,_,{fetcherSubmission:L});if(io(_)){Ft(g,P,_.error);return}}if(wn(_))throw to(400,{type:"defer-action"});let ie=y.navigation.location||y.location,je=Qn(e.history,ie,H.signal),Bt=s||i,Go=y.navigation.state!=="idle"?vt(Bt,y.navigation.location,c):y.matches;G(Go,"Didn't find any matches after fetcher action");let Zn=++U;W.set(g,Zn);let Wn=er(L,_.data);y.fetchers.set(g,Wn);let[Gn,No]=ud(e.history,y,Go,L,ie,!1,d.unstable_skipActionErrorRevalidation,Le,He,po,Ze,vo,ee,Bt,c,[I.route.id,_]);No.filter(Pe=>Pe.key!==g).forEach(Pe=>{let _t=Pe.key,Ku=y.fetchers.get(_t),Wk=er(void 0,Ku?Ku.data:void 0);y.fetchers.set(_t,Wk),M.has(_t)&&Wo(_t),Pe.controller&&M.set(_t,Pe.controller)}),We({fetchers:new Map(y.fetchers)});let Jr=()=>No.forEach(Pe=>Wo(Pe.key));H.signal.addEventListener("abort",Jr);let{loaderResults:Qr,fetcherResults:Yr}=await Ou(y.matches,Go,Gn,No,je);if(H.signal.aborted)return;H.signal.removeEventListener("abort",Jr),W.delete(g),M.delete(g),No.forEach(Pe=>M.delete(Pe.key));let Q=yd([...Qr,...Yr]);if(Q){if(Q.idx>=Gn.length){let Pe=No[Q.idx-Gn.length].key;ee.add(Pe)}return Ut(je,Q.result)}let{loaderData:Oe,errors:no}=md(y,y.matches,Gn,Qr,void 0,No,Yr,Ve);if(y.fetchers.has(g)){let Pe=qo(_.data);y.fetchers.set(g,Pe)}Uu(Zn),y.navigation.state==="loading"&&Zn>F?(G(C,"Expected pending action"),V&&V.abort(),Dt(y.navigation.location,{matches:Go,loaderData:Oe,errors:no,fetchers:new Map(y.fetchers)})):(We({errors:no,loaderData:kd(y.loaderData,Oe,Go,no),fetchers:new Map(y.fetchers)}),Le=!1)}async function _k(g,P,x,I,E,$,L){let D=y.fetchers.get(g);Zo(g,er(L,D?D.data:void 0),{flushSync:$});let H=new AbortController,K=Qn(e.history,x,H.signal);M.set(g,H);let Te=U,_=(await Lt("loader",K,[I],E))[0];if(wn(_)&&(_=await Sm(_,K.signal,!0)||_),M.get(g)===H&&M.delete(g),!K.signal.aborted){if(Ze.has(g)){Zo(g,qo(void 0));return}if(Cn(_))if(F>Te){Zo(g,qo(void 0));return}else{ee.add(g),await Ut(K,_);return}if(io(_)){Ft(g,P,_.error);return}G(!wn(_),"Unhandled fetcher deferred data"),Zo(g,qo(_.data))}}async function Ut(g,P,x){let{submission:I,fetcherSubmission:E,replace:$}=x===void 0?{}:x;P.response.headers.has("X-Remix-Revalidate")&&(Le=!0);let L=P.response.headers.get("Location");G(L,"Expected a Location header on the redirect Response"),L=pd(L,new URL(g.url),c);let D=Or(y.location,L,{_isRedirect:!0});if(n){let ie=!1;if(P.response.headers.has("X-Remix-Reload-Document"))ie=!0;else if(fu.test(L)){const je=e.history.createURL(L);ie=je.origin!==o.location.origin||Et(je.pathname,c)==null}if(ie){$?o.location.replace(L):o.location.assign(L);return}}V=null;let H=$===!0?he.Replace:he.Push,{formMethod:K,formAction:Te,formEncType:Ne}=y.navigation;!I&&!E&&K&&Te&&Ne&&(I=jd(y.navigation));let _=I||E;if(Fz.has(P.response.status)&&_&&bo(_.formMethod))await gn(H,D,{submission:se({},_,{formAction:L}),preventScrollReset:R});else{let ie=cs(D,I);await gn(H,D,{overrideNavigation:ie,fetcherSubmission:E,preventScrollReset:R})}}async function Lt(g,P,x,I){try{let E=await Wz(u,g,P,x,I,a,r);return await Promise.all(E.map(($,L)=>{if(ej($)){let D=$.result;return{type:ce.redirect,response:Qz(D,P,x[L].route.id,I,c,d.v7_relativeSplatPath)}}return Jz($)}))}catch(E){return x.map(()=>({type:ce.error,error:E}))}}async function Ou(g,P,x,I,E){let[$,...L]=await Promise.all([x.length?Lt("loader",E,x,P):[],...I.map(D=>{if(D.matches&&D.match&&D.controller){let H=Qn(e.history,D.path,D.controller.signal);return Lt("loader",H,[D.match],D.matches).then(K=>K[0])}else return Promise.resolve({type:ce.error,error:to(404,{pathname:D.path})})})]);return await Promise.all([zd(g,x,$,$.map(()=>E.signal),!1,y.loaderData),zd(g,I.map(D=>D.match),L,I.map(D=>D.controller?D.controller.signal:null),!0)]),{loaderResults:$,fetcherResults:L}}function Ii(){Le=!0,He.push(...Ai()),vo.forEach((g,P)=>{M.has(P)&&(po.push(P),Wo(P))})}function Zo(g,P,x){x===void 0&&(x={}),y.fetchers.set(g,P),We({fetchers:new Map(y.fetchers)},{flushSync:(x&&x.flushSync)===!0})}function Ft(g,P,x,I){I===void 0&&(I={});let E=kr(y.matches,P);Wr(g),We({errors:{[E.route.id]:x},fetchers:new Map(y.fetchers)},{flushSync:(I&&I.flushSync)===!0})}function Eu(g){return d.v7_fetcherPersist&&(Xe.set(g,(Xe.get(g)||0)+1),Ze.has(g)&&Ze.delete(g)),y.fetchers.get(g)||Bz}function Wr(g){let P=y.fetchers.get(g);M.has(g)&&!(P&&P.state==="loading"&&W.has(g))&&Wo(g),vo.delete(g),W.delete(g),ee.delete(g),Ze.delete(g),y.fetchers.delete(g)}function Kk(g){if(d.v7_fetcherPersist){let P=(Xe.get(g)||0)-1;P<=0?(Xe.delete(g),Ze.add(g)):Xe.set(g,P)}else Wr(g);We({fetchers:new Map(y.fetchers)})}function Wo(g){let P=M.get(g);G(P,"Expected fetch controller: "+g),P.abort(),M.delete(g)}function Ru(g){for(let P of g){let x=Eu(P),I=qo(x.data);y.fetchers.set(P,I)}}function Du(){let g=[],P=!1;for(let x of ee){let I=y.fetchers.get(x);G(I,"Expected fetcher: "+x),I.state==="loading"&&(ee.delete(x),g.push(x),P=!0)}return Ru(g),P}function Uu(g){let P=[];for(let[x,I]of W)if(I<g){let E=y.fetchers.get(x);G(E,"Expected fetcher: "+x),E.state==="loading"&&(Wo(x),W.delete(x),P.push(x))}return Ru(P),P.length>0}function $k(g,P){let x=y.blockers.get(g)||qt;return oo.get(g)!==P&&oo.set(g,P),x}function Lu(g){y.blockers.delete(g),oo.delete(g)}function Gr(g,P){let x=y.blockers.get(g)||qt;G(x.state==="unblocked"&&P.state==="blocked"||x.state==="blocked"&&P.state==="blocked"||x.state==="blocked"&&P.state==="proceeding"||x.state==="blocked"&&P.state==="unblocked"||x.state==="proceeding"&&P.state==="unblocked","Invalid blocker state transition: "+x.state+" -> "+P.state);let I=new Map(y.blockers);I.set(g,P),We({blockers:I})}function Fu(g){let{currentLocation:P,nextLocation:x,historyAction:I}=g;if(oo.size===0)return;oo.size>1&&Un(!1,"A router only supports one blocker at a time");let E=Array.from(oo.entries()),[$,L]=E[E.length-1],D=y.blockers.get($);if(!(D&&D.state==="proceeding")&&L({currentLocation:P,nextLocation:x,historyAction:I}))return $}function Ai(g){let P=[];return Ve.forEach((x,I)=>{(!g||g(I))&&(x.cancel(),P.push(I),Ve.delete(I))}),P}function Hk(g,P,x){if(z=g,h=P,f=x||null,!T&&y.navigation===ss){T=!0;let I=_u(y.location,y.matches);I!=null&&We({restoreScrollPosition:I})}return()=>{z=null,h=null,f=null}}function Bu(g,P){return f&&f(g,P.map(I=>bz(I,y.loaderData)))||g.key}function Xk(g,P){if(z&&h){let x=Bu(g,P);z[x]=h()}}function _u(g,P){if(z){let x=Bu(g,P),I=z[x];if(typeof I=="number")return I}return null}function Zk(g){a={},s=vc(g,r,void 0,a)}return A={get basename(){return c},get future(){return d},get state(){return y},get routes(){return i},get window(){return o},initialize:Ok,subscribe:Rk,enableScrollRestoration:Hk,navigate:Vu,fetch:Fk,revalidate:Dk,createHref:g=>e.history.createHref(g),encodeLocation:g=>e.history.encodeLocation(g),getFetcher:Eu,deleteFetcher:Kk,dispose:Ek,getBlocker:$k,deleteBlocker:Lu,_internalFetchControllers:M,_internalActiveDeferreds:Ve,_internalSetRoutes:Zk},A}function $z(e){return e!=null&&("formData"in e&&e.formData!=null||"body"in e&&e.body!==void 0)}function mc(e,o,n,t,r,a,i,s){let c,u;if(i){c=[];for(let p of o)if(c.push(p),p.route.id===i){u=p;break}}else c=o,u=o[o.length-1];let d=yu(r||".",bu(c,a),Et(e.pathname,n)||e.pathname,s==="path");return r==null&&(d.search=e.search,d.hash=e.hash),(r==null||r===""||r===".")&&u&&u.route.index&&!gu(d.search)&&(d.search=d.search?d.search.replace(/^\?/,"?index&"):"?index"),t&&n!=="/"&&(d.pathname=d.pathname==="/"?n:Lo([n,d.pathname])),Ln(d)}function cd(e,o,n,t){if(!t||!$z(t))return{path:n};if(t.formMethod&&!nj(t.formMethod))return{path:n,error:to(405,{method:t.formMethod})};let r=()=>({path:n,error:to(400,{type:"invalid-body"})}),a=t.formMethod||"get",i=e?a.toUpperCase():a.toLowerCase(),s=Pm(n);if(t.body!==void 0){if(t.formEncType==="text/plain"){if(!bo(i))return r();let v=typeof t.body=="string"?t.body:t.body instanceof FormData||t.body instanceof URLSearchParams?Array.from(t.body.entries()).reduce((z,f)=>{let[h,T]=f;return""+z+h+"="+T+`
`},""):String(t.body);return{path:n,submission:{formMethod:i,formAction:s,formEncType:t.formEncType,formData:void 0,json:void 0,text:v}}}else if(t.formEncType==="application/json"){if(!bo(i))return r();try{let v=typeof t.body=="string"?JSON.parse(t.body):t.body;return{path:n,submission:{formMethod:i,formAction:s,formEncType:t.formEncType,formData:void 0,json:v,text:void 0}}}catch{return r()}}}G(typeof FormData=="function","FormData is not available in this environment");let c,u;if(t.formData)c=kc(t.formData),u=t.formData;else if(t.body instanceof FormData)c=kc(t.body),u=t.body;else if(t.body instanceof URLSearchParams)c=t.body,u=vd(c);else if(t.body==null)c=new URLSearchParams,u=new FormData;else try{c=new URLSearchParams(t.body),u=vd(c)}catch{return r()}let d={formMethod:i,formAction:s,formEncType:t&&t.formEncType||"application/x-www-form-urlencoded",formData:u,json:void 0,text:void 0};if(bo(d.formMethod))return{path:n,submission:d};let p=Ho(n);return o&&p.search&&gu(p.search)&&c.append("index",""),p.search="?"+c,{path:Ln(p),submission:d}}function Hz(e,o){let n=e;if(o){let t=e.findIndex(r=>r.route.id===o);t>=0&&(n=e.slice(0,t))}return n}function ud(e,o,n,t,r,a,i,s,c,u,d,p,v,z,f,h){let T=h?io(h[1])?h[1].error:h[1].data:void 0,k=e.createURL(o.location),m=e.createURL(r),b=h&&io(h[1])?h[0]:void 0,N=b?Hz(n,b):n,S=h?h[1].statusCode:void 0,A=i&&S&&S>=400,y=N.filter((R,V)=>{let{route:Z}=R;if(Z.lazy)return!0;if(Z.loader==null)return!1;if(a)return typeof Z.loader!="function"||Z.loader.hydrate?!0:o.loaderData[Z.id]===void 0&&(!o.errors||o.errors[Z.id]===void 0);if(Xz(o.loaderData,o.matches[V],R)||c.some(ve=>ve===R.route.id))return!0;let B=o.matches[V],oe=R;return ld(R,se({currentUrl:k,currentParams:B.params,nextUrl:m,nextParams:oe.params},t,{actionResult:T,unstable_actionStatus:S,defaultShouldRevalidate:A?!1:s||k.pathname+k.search===m.pathname+m.search||k.search!==m.search||Nm(B,oe)}))}),C=[];return p.forEach((R,V)=>{if(a||!n.some(Le=>Le.route.id===R.routeId)||d.has(V))return;let Z=vt(z,R.path,f);if(!Z){C.push({key:V,routeId:R.routeId,path:R.path,matches:null,match:null,controller:null});return}let B=o.fetchers.get(V),oe=hc(Z,R.path),ve=!1;v.has(V)?ve=!1:u.includes(V)?ve=!0:B&&B.state!=="idle"&&B.data===void 0?ve=s:ve=ld(oe,se({currentUrl:k,currentParams:o.matches[o.matches.length-1].params,nextUrl:m,nextParams:n[n.length-1].params},t,{actionResult:T,unstable_actionStatus:S,defaultShouldRevalidate:A?!1:s})),ve&&C.push({key:V,routeId:R.routeId,path:R.path,matches:Z,match:oe,controller:new AbortController})}),[y,C]}function Xz(e,o,n){let t=!o||n.route.id!==o.route.id,r=e[n.route.id]===void 0;return t||r}function Nm(e,o){let n=e.route.path;return e.pathname!==o.pathname||n!=null&&n.endsWith("*")&&e.params["*"]!==o.params["*"]}function ld(e,o){if(e.route.shouldRevalidate){let n=e.route.shouldRevalidate(o);if(typeof n=="boolean")return n}return o.defaultShouldRevalidate}async function dd(e,o,n){if(!e.lazy)return;let t=await e.lazy();if(!e.lazy)return;let r=n[e.id];G(r,"No route found in manifest");let a={};for(let i in t){let c=r[i]!==void 0&&i!=="hasErrorBoundary";Un(!c,'Route "'+r.id+'" has a static property "'+i+'" defined but its lazy function is also returning a value for this property. '+('The lazy route property "'+i+'" will be ignored.')),!c&&!kz.has(i)&&(a[i]=t[i])}Object.assign(r,a),Object.assign(r,se({},o(r),{lazy:void 0}))}function Zz(e){return Promise.all(e.matches.map(o=>o.resolve()))}async function Wz(e,o,n,t,r,a,i,s){let c=t.reduce((p,v)=>p.add(v.route.id),new Set),u=new Set,d=await e({matches:r.map(p=>{let v=c.has(p.route.id);return se({},p,{shouldLoad:v,resolve:f=>(u.add(p.route.id),v?Gz(o,n,p,a,i,f,s):Promise.resolve({type:ce.data,result:void 0}))})}),request:n,params:r[0].params,context:s});return r.forEach(p=>G(u.has(p.route.id),'`match.resolve()` was not called for route id "'+p.route.id+'". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.')),d.filter((p,v)=>c.has(r[v].route.id))}async function Gz(e,o,n,t,r,a,i){let s,c,u=d=>{let p,v=new Promise((h,T)=>p=T);c=()=>p(),o.signal.addEventListener("abort",c);let z=h=>typeof d!="function"?Promise.reject(new Error("You cannot call the handler for a route which defines a boolean "+('"'+e+'" [routeId: '+n.route.id+"]"))):d({request:o,params:n.params,context:i},...h!==void 0?[h]:[]),f;return a?f=a(h=>z(h)):f=(async()=>{try{return{type:"data",result:await z()}}catch(h){return{type:"error",result:h}}})(),Promise.race([f,v])};try{let d=n.route[e];if(n.route.lazy)if(d){let p,[v]=await Promise.all([u(d).catch(z=>{p=z}),dd(n.route,r,t)]);if(p!==void 0)throw p;s=v}else if(await dd(n.route,r,t),d=n.route[e],d)s=await u(d);else if(e==="action"){let p=new URL(o.url),v=p.pathname+p.search;throw to(405,{method:o.method,pathname:v,routeId:n.route.id})}else return{type:ce.data,result:void 0};else if(d)s=await u(d);else{let p=new URL(o.url),v=p.pathname+p.search;throw to(404,{pathname:v})}G(s.result!==void 0,"You defined "+(e==="action"?"an action":"a loader")+" for route "+('"'+n.route.id+"\" but didn't return anything from your `"+e+"` ")+"function. Please return a value or `null`.")}catch(d){return{type:ce.error,result:d}}finally{c&&o.signal.removeEventListener("abort",c)}return s}async function Jz(e){let{result:o,type:n,status:t}=e;if(xm(o)){let i;try{let s=o.headers.get("Content-Type");s&&/\bapplication\/json\b/.test(s)?o.body==null?i=null:i=await o.json():i=await o.text()}catch(s){return{type:ce.error,error:s}}return n===ce.error?{type:ce.error,error:new zu(o.status,o.statusText,i),statusCode:o.status,headers:o.headers}:{type:ce.data,data:i,statusCode:o.status,headers:o.headers}}if(n===ce.error)return{type:ce.error,error:o,statusCode:ju(o)?o.status:t};if(oj(o)){var r,a;return{type:ce.deferred,deferredData:o,statusCode:(r=o.init)==null?void 0:r.status,headers:((a=o.init)==null?void 0:a.headers)&&new Headers(o.init.headers)}}return{type:ce.data,data:o,statusCode:t}}function Qz(e,o,n,t,r,a){let i=e.headers.get("Location");if(G(i,"Redirects returned/thrown from loaders/actions must have a Location header"),!fu.test(i)){let s=t.slice(0,t.findIndex(c=>c.route.id===n)+1);i=mc(new URL(o.url),s,r,!0,i,a),e.headers.set("Location",i)}return e}function pd(e,o,n){if(fu.test(e)){let t=e,r=t.startsWith("//")?new URL(o.protocol+t):new URL(t),a=Et(r.pathname,n)!=null;if(r.origin===o.origin&&a)return r.pathname+r.search+r.hash}return e}function Qn(e,o,n,t){let r=e.createURL(Pm(o)).toString(),a={signal:n};if(t&&bo(t.formMethod)){let{formMethod:i,formEncType:s}=t;a.method=i.toUpperCase(),s==="application/json"?(a.headers=new Headers({"Content-Type":s}),a.body=JSON.stringify(t.json)):s==="text/plain"?a.body=t.text:s==="application/x-www-form-urlencoded"&&t.formData?a.body=kc(t.formData):a.body=t.formData}return new Request(r,a)}function kc(e){let o=new URLSearchParams;for(let[n,t]of e.entries())o.append(n,typeof t=="string"?t:t.name);return o}function vd(e){let o=new FormData;for(let[n,t]of e.entries())o.append(n,t);return o}function Yz(e,o,n,t,r,a){let i={},s=null,c,u=!1,d={},p=t&&io(t[1])?t[1].error:void 0;return n.forEach((v,z)=>{let f=o[z].route.id;if(G(!Cn(v),"Cannot handle redirect results in processLoaderData"),io(v)){let h=v.error;p!==void 0&&(h=p,p=void 0),s=s||{};{let T=kr(e,f);s[T.route.id]==null&&(s[T.route.id]=h)}i[f]=void 0,u||(u=!0,c=ju(v.error)?v.error.status:500),v.headers&&(d[f]=v.headers)}else wn(v)?(r.set(f,v.deferredData),i[f]=v.deferredData.data,v.statusCode!=null&&v.statusCode!==200&&!u&&(c=v.statusCode),v.headers&&(d[f]=v.headers)):(i[f]=v.data,v.statusCode&&v.statusCode!==200&&!u&&(c=v.statusCode),v.headers&&(d[f]=v.headers))}),p!==void 0&&t&&(s={[t[0]]:p},i[t[0]]=void 0),{loaderData:i,errors:s,statusCode:c||200,loaderHeaders:d}}function md(e,o,n,t,r,a,i,s){let{loaderData:c,errors:u}=Yz(o,n,t,r,s);for(let d=0;d<a.length;d++){let{key:p,match:v,controller:z}=a[d];G(i!==void 0&&i[d]!==void 0,"Did not find corresponding fetcher result");let f=i[d];if(!(z&&z.signal.aborted))if(io(f)){let h=kr(e.matches,v==null?void 0:v.route.id);u&&u[h.route.id]||(u=se({},u,{[h.route.id]:f.error})),e.fetchers.delete(p)}else if(Cn(f))G(!1,"Unhandled fetcher revalidation redirect");else if(wn(f))G(!1,"Unhandled fetcher deferred data");else{let h=qo(f.data);e.fetchers.set(p,h)}}return{loaderData:c,errors:u}}function kd(e,o,n,t){let r=se({},o);for(let a of n){let i=a.route.id;if(o.hasOwnProperty(i)?o[i]!==void 0&&(r[i]=o[i]):e[i]!==void 0&&a.route.loader&&(r[i]=e[i]),t&&t.hasOwnProperty(i))break}return r}function hd(e){return e?io(e[1])?{actionData:{}}:{actionData:{[e[0]]:e[1].data}}:{}}function kr(e,o){return(o?e.slice(0,e.findIndex(t=>t.route.id===o)+1):[...e]).reverse().find(t=>t.route.hasErrorBoundary===!0)||e[0]}function bd(e){let o=e.length===1?e[0]:e.find(n=>n.index||!n.path||n.path==="/")||{id:"__shim-error-route__"};return{matches:[{params:{},pathname:"",pathnameBase:"",route:o}],route:o}}function to(e,o){let{pathname:n,routeId:t,method:r,type:a}=o===void 0?{}:o,i="Unknown Server Error",s="Unknown @remix-run/router error";return e===400?(i="Bad Request",r&&n&&t?s="You made a "+r+' request to "'+n+'" but '+('did not provide a `loader` for route "'+t+'", ')+"so there is no way to handle the request.":a==="defer-action"?s="defer() is not supported in actions":a==="invalid-body"&&(s="Unable to encode submission body")):e===403?(i="Forbidden",s='Route "'+t+'" does not match URL "'+n+'"'):e===404?(i="Not Found",s='No route matches URL "'+n+'"'):e===405&&(i="Method Not Allowed",r&&n&&t?s="You made a "+r.toUpperCase()+' request to "'+n+'" but '+('did not provide an `action` for route "'+t+'", ')+"so there is no way to handle the request.":r&&(s='Invalid request method "'+r.toUpperCase()+'"')),new zu(e||500,i,new Error(s),!0)}function yd(e){for(let o=e.length-1;o>=0;o--){let n=e[o];if(Cn(n))return{result:n,idx:o}}}function Pm(e){let o=typeof e=="string"?Ho(e):e;return Ln(se({},o,{hash:""}))}function qz(e,o){return e.pathname!==o.pathname||e.search!==o.search?!1:e.hash===""?o.hash!=="":e.hash===o.hash?!0:o.hash!==""}function ej(e){return xm(e.result)&&Lz.has(e.result.status)}function wn(e){return e.type===ce.deferred}function io(e){return e.type===ce.error}function Cn(e){return(e&&e.type)===ce.redirect}function oj(e){let o=e;return o&&typeof o=="object"&&typeof o.data=="object"&&typeof o.subscribe=="function"&&typeof o.cancel=="function"&&typeof o.resolveData=="function"}function xm(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.headers=="object"&&typeof e.body<"u"}function nj(e){return Uz.has(e.toLowerCase())}function bo(e){return Rz.has(e.toLowerCase())}async function zd(e,o,n,t,r,a){for(let i=0;i<n.length;i++){let s=n[i],c=o[i];if(!c)continue;let u=e.find(p=>p.route.id===c.route.id),d=u!=null&&!Nm(u,c)&&(a&&a[c.route.id])!==void 0;if(wn(s)&&(r||d)){let p=t[i];G(p,"Expected an AbortSignal for revalidating fetcher deferred result"),await Sm(s,p,r).then(v=>{v&&(n[i]=v||n[i])})}}}async function Sm(e,o,n){if(n===void 0&&(n=!1),!await e.deferredData.resolveData(o)){if(n)try{return{type:ce.data,data:e.deferredData.unwrappedData}}catch(r){return{type:ce.error,error:r}}return{type:ce.data,data:e.deferredData.data}}}function gu(e){return new URLSearchParams(e).getAll("index").some(o=>o==="")}function hc(e,o){let n=typeof o=="string"?Ho(o).search:o.search;if(e[e.length-1].route.index&&gu(n||""))return e[e.length-1];let t=fm(e);return t[t.length-1]}function jd(e){let{formMethod:o,formAction:n,formEncType:t,text:r,formData:a,json:i}=e;if(!(!o||!n||!t)){if(r!=null)return{formMethod:o,formAction:n,formEncType:t,formData:void 0,json:void 0,text:r};if(a!=null)return{formMethod:o,formAction:n,formEncType:t,formData:a,json:void 0,text:void 0};if(i!==void 0)return{formMethod:o,formAction:n,formEncType:t,formData:void 0,json:i,text:void 0}}}function cs(e,o){return o?{state:"loading",location:e,formMethod:o.formMethod,formAction:o.formAction,formEncType:o.formEncType,formData:o.formData,json:o.json,text:o.text}:{state:"loading",location:e,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0}}function tj(e,o){return{state:"submitting",location:e,formMethod:o.formMethod,formAction:o.formAction,formEncType:o.formEncType,formData:o.formData,json:o.json,text:o.text}}function er(e,o){return e?{state:"loading",formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text,data:o}:{state:"loading",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:o}}function rj(e,o){return{state:"submitting",formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text,data:o?o.data:void 0}}function qo(e){return{state:"idle",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:e}}function aj(e,o){try{let n=e.sessionStorage.getItem(Tm);if(n){let t=JSON.parse(n);for(let[r,a]of Object.entries(t||{}))a&&Array.isArray(a)&&o.set(r,new Set(a||[]))}}catch{}}function ij(e,o){if(o.size>0){let n={};for(let[t,r]of o)n[t]=[...r];try{e.sessionStorage.setItem(Tm,JSON.stringify(n))}catch(t){Un(!1,"Failed to save applied view transitions in sessionStorage ("+t+").")}}}/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function ii(){return ii=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},ii.apply(this,arguments)}const xi=l.createContext(null),wm=l.createContext(null),Xn=l.createContext(null),Tu=l.createContext(null),Xo=l.createContext({outlet:null,matches:[],isDataRoute:!1}),Cm=l.createContext(null);function sj(e,o){let{relative:n}=o===void 0?{}:o;$r()||G(!1);let{basename:t,navigator:r}=l.useContext(Xn),{hash:a,pathname:i,search:s}=Am(e,{relative:n}),c=i;return t!=="/"&&(c=i==="/"?t:Lo([t,i])),r.createHref({pathname:c,search:s,hash:a})}function $r(){return l.useContext(Tu)!=null}function Hr(){return $r()||G(!1),l.useContext(Tu).location}function Mm(e){l.useContext(Xn).static||l.useLayoutEffect(e)}function Xr(){let{isDataRoute:e}=l.useContext(Xo);return e?fj():cj()}function cj(){$r()||G(!1);let e=l.useContext(xi),{basename:o,future:n,navigator:t}=l.useContext(Xn),{matches:r}=l.useContext(Xo),{pathname:a}=Hr(),i=JSON.stringify(bu(r,n.v7_relativeSplatPath)),s=l.useRef(!1);return Mm(()=>{s.current=!0}),l.useCallback(function(u,d){if(d===void 0&&(d={}),!s.current)return;if(typeof u=="number"){t.go(u);return}let p=yu(u,JSON.parse(i),a,d.relative==="path");e==null&&o!=="/"&&(p.pathname=p.pathname==="/"?o:Lo([o,p.pathname])),(d.replace?t.replace:t.push)(p,d.state,d)},[o,t,i,a,e])}const uj=l.createContext(null);function lj(e){let o=l.useContext(Xo).outlet;return o&&l.createElement(uj.Provider,{value:e},o)}function Im(){let{matches:e}=l.useContext(Xo),o=e[e.length-1];return o?o.params:{}}function Am(e,o){let{relative:n}=o===void 0?{}:o,{future:t}=l.useContext(Xn),{matches:r}=l.useContext(Xo),{pathname:a}=Hr(),i=JSON.stringify(bu(r,t.v7_relativeSplatPath));return l.useMemo(()=>yu(e,JSON.parse(i),a,n==="path"),[e,i,a,n])}function dj(e,o,n,t){$r()||G(!1);let{navigator:r}=l.useContext(Xn),{matches:a}=l.useContext(Xo),i=a[a.length-1],s=i?i.params:{};i&&i.pathname;let c=i?i.pathnameBase:"/";i&&i.route;let u=Hr(),d;d=u;let p=d.pathname||"/",v=p;if(c!=="/"){let h=c.replace(/^\//,"").split("/");v="/"+p.replace(/^\//,"").split("/").slice(h.length).join("/")}let z=vt(e,{pathname:v});return hj(z&&z.map(h=>Object.assign({},h,{params:Object.assign({},s,h.params),pathname:Lo([c,r.encodeLocation?r.encodeLocation(h.pathname).pathname:h.pathname]),pathnameBase:h.pathnameBase==="/"?c:Lo([c,r.encodeLocation?r.encodeLocation(h.pathnameBase).pathname:h.pathnameBase])})),a,n,t)}function pj(){let e=jj(),o=ju(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return l.createElement(l.Fragment,null,l.createElement("h2",null,"Unexpected Application Error!"),l.createElement("h3",{style:{fontStyle:"italic"}},o),n?l.createElement("pre",{style:r},n):null,null)}const vj=l.createElement(pj,null);class mj extends l.Component{constructor(o){super(o),this.state={location:o.location,revalidation:o.revalidation,error:o.error}}static getDerivedStateFromError(o){return{error:o}}static getDerivedStateFromProps(o,n){return n.location!==o.location||n.revalidation!=="idle"&&o.revalidation==="idle"?{error:o.error,location:o.location,revalidation:o.revalidation}:{error:o.error!==void 0?o.error:n.error,location:n.location,revalidation:o.revalidation||n.revalidation}}componentDidCatch(o,n){console.error("React Router caught the following error during render",o,n)}render(){return this.state.error!==void 0?l.createElement(Xo.Provider,{value:this.props.routeContext},l.createElement(Cm.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function kj(e){let{routeContext:o,match:n,children:t}=e,r=l.useContext(xi);return r&&r.static&&r.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=n.route.id),l.createElement(Xo.Provider,{value:o},t)}function hj(e,o,n,t){var r;if(o===void 0&&(o=[]),n===void 0&&(n=null),t===void 0&&(t=null),e==null){var a;if((a=n)!=null&&a.errors)e=n.matches;else return null}let i=e,s=(r=n)==null?void 0:r.errors;if(s!=null){let d=i.findIndex(p=>p.route.id&&(s==null?void 0:s[p.route.id])!==void 0);d>=0||G(!1),i=i.slice(0,Math.min(i.length,d+1))}let c=!1,u=-1;if(n&&t&&t.v7_partialHydration)for(let d=0;d<i.length;d++){let p=i[d];if((p.route.HydrateFallback||p.route.hydrateFallbackElement)&&(u=d),p.route.id){let{loaderData:v,errors:z}=n,f=p.route.loader&&v[p.route.id]===void 0&&(!z||z[p.route.id]===void 0);if(p.route.lazy||f){c=!0,u>=0?i=i.slice(0,u+1):i=[i[0]];break}}}return i.reduceRight((d,p,v)=>{let z,f=!1,h=null,T=null;n&&(z=s&&p.route.id?s[p.route.id]:void 0,h=p.route.errorElement||vj,c&&(u<0&&v===0?(gj("route-fallback"),f=!0,T=null):u===v&&(f=!0,T=p.route.hydrateFallbackElement||null)));let k=o.concat(i.slice(0,v+1)),m=()=>{let b;return z?b=h:f?b=T:p.route.Component?b=l.createElement(p.route.Component,null):p.route.element?b=p.route.element:b=d,l.createElement(kj,{match:p,routeContext:{outlet:d,matches:k,isDataRoute:n!=null},children:b})};return n&&(p.route.ErrorBoundary||p.route.errorElement||v===0)?l.createElement(mj,{location:n.location,revalidation:n.revalidation,component:h,error:z,children:m(),routeContext:{outlet:null,matches:k,isDataRoute:!0}}):m()},null)}var Vm=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(Vm||{}),si=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(si||{});function bj(e){let o=l.useContext(xi);return o||G(!1),o}function yj(e){let o=l.useContext(wm);return o||G(!1),o}function zj(e){let o=l.useContext(Xo);return o||G(!1),o}function Om(e){let o=zj(),n=o.matches[o.matches.length-1];return n.route.id||G(!1),n.route.id}function jj(){var e;let o=l.useContext(Cm),n=yj(si.UseRouteError),t=Om(si.UseRouteError);return o!==void 0?o:(e=n.errors)==null?void 0:e[t]}function fj(){let{router:e}=bj(Vm.UseNavigateStable),o=Om(si.UseNavigateStable),n=l.useRef(!1);return Mm(()=>{n.current=!0}),l.useCallback(function(r,a){a===void 0&&(a={}),n.current&&(typeof r=="number"?e.navigate(r):e.navigate(r,ii({fromRouteId:o},a)))},[e,o])}const fd={};function gj(e,o,n){fd[e]||(fd[e]=!0)}function Tj(e){return lj(e.context)}function Nj(e){let{basename:o="/",children:n=null,location:t,navigationType:r=he.Pop,navigator:a,static:i=!1,future:s}=e;$r()&&G(!1);let c=o.replace(/^\/*/,"/"),u=l.useMemo(()=>({basename:c,navigator:a,static:i,future:ii({v7_relativeSplatPath:!1},s)}),[c,s,a,i]);typeof t=="string"&&(t=Ho(t));let{pathname:d="/",search:p="",hash:v="",state:z=null,key:f="default"}=t,h=l.useMemo(()=>{let T=Et(d,c);return T==null?null:{location:{pathname:T,search:p,hash:v,state:z,key:f},navigationType:r}},[c,d,p,v,z,f,r]);return h==null?null:l.createElement(Xn.Provider,{value:u},l.createElement(Tu.Provider,{children:n,value:h}))}new Promise(()=>{});function Pj(e){let o={hasErrorBoundary:e.ErrorBoundary!=null||e.errorElement!=null};return e.Component&&Object.assign(o,{element:l.createElement(e.Component),Component:void 0}),e.HydrateFallback&&Object.assign(o,{hydrateFallbackElement:l.createElement(e.HydrateFallback),HydrateFallback:void 0}),e.ErrorBoundary&&Object.assign(o,{errorElement:l.createElement(e.ErrorBoundary),ErrorBoundary:void 0}),o}/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Er(){return Er=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},Er.apply(this,arguments)}function xj(e,o){if(e==null)return{};var n={},t=Object.keys(e),r,a;for(a=0;a<t.length;a++)r=t[a],!(o.indexOf(r)>=0)&&(n[r]=e[r]);return n}function Sj(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function wj(e,o){return e.button===0&&(!o||o==="_self")&&!Sj(e)}function bc(e){return e===void 0&&(e=""),new URLSearchParams(typeof e=="string"||Array.isArray(e)||e instanceof URLSearchParams?e:Object.keys(e).reduce((o,n)=>{let t=e[n];return o.concat(Array.isArray(t)?t.map(r=>[n,r]):[[n,t]])},[]))}function Cj(e,o){let n=bc(e);return o&&o.forEach((t,r)=>{n.has(r)||o.getAll(r).forEach(a=>{n.append(r,a)})}),n}const Mj=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"],Ij="6";try{window.__reactRouterVersion=Ij}catch{}function Aj(e,o){return Kz({basename:o==null?void 0:o.basename,future:Er({},o==null?void 0:o.future,{v7_prependBasename:!0}),history:pz({window:o==null?void 0:o.window}),hydrationData:(o==null?void 0:o.hydrationData)||Vj(),routes:e,mapRouteProperties:Pj,unstable_dataStrategy:o==null?void 0:o.unstable_dataStrategy,window:o==null?void 0:o.window}).initialize()}function Vj(){var e;let o=(e=window)==null?void 0:e.__staticRouterHydrationData;return o&&o.errors&&(o=Er({},o,{errors:Oj(o.errors)})),o}function Oj(e){if(!e)return null;let o=Object.entries(e),n={};for(let[t,r]of o)if(r&&r.__type==="RouteErrorResponse")n[t]=new zu(r.status,r.statusText,r.data,r.internal===!0);else if(r&&r.__type==="Error"){if(r.__subType){let a=window[r.__subType];if(typeof a=="function")try{let i=new a(r.message);i.stack="",n[t]=i}catch{}}if(n[t]==null){let a=new Error(r.message);a.stack="",n[t]=a}}else n[t]=r;return n}const Ej=l.createContext({isTransitioning:!1}),Rj=l.createContext(new Map),Dj="startTransition",gd=rp[Dj],Uj="flushSync",Td=jy[Uj];function Lj(e){gd?gd(e):e()}function or(e){Td?Td(e):e()}class Fj{constructor(){this.status="pending",this.promise=new Promise((o,n)=>{this.resolve=t=>{this.status==="pending"&&(this.status="resolved",o(t))},this.reject=t=>{this.status==="pending"&&(this.status="rejected",n(t))}})}}function Bj(e){let{fallbackElement:o,router:n,future:t}=e,[r,a]=l.useState(n.state),[i,s]=l.useState(),[c,u]=l.useState({isTransitioning:!1}),[d,p]=l.useState(),[v,z]=l.useState(),[f,h]=l.useState(),T=l.useRef(new Map),{v7_startTransition:k}=t||{},m=l.useCallback(y=>{k?Lj(y):y()},[k]),b=l.useCallback((y,C)=>{let{deletedFetchers:R,unstable_flushSync:V,unstable_viewTransitionOpts:Z}=C;R.forEach(oe=>T.current.delete(oe)),y.fetchers.forEach((oe,ve)=>{oe.data!==void 0&&T.current.set(ve,oe.data)});let B=n.window==null||n.window.document==null||typeof n.window.document.startViewTransition!="function";if(!Z||B){V?or(()=>a(y)):m(()=>a(y));return}if(V){or(()=>{v&&(d&&d.resolve(),v.skipTransition()),u({isTransitioning:!0,flushSync:!0,currentLocation:Z.currentLocation,nextLocation:Z.nextLocation})});let oe=n.window.document.startViewTransition(()=>{or(()=>a(y))});oe.finished.finally(()=>{or(()=>{p(void 0),z(void 0),s(void 0),u({isTransitioning:!1})})}),or(()=>z(oe));return}v?(d&&d.resolve(),v.skipTransition(),h({state:y,currentLocation:Z.currentLocation,nextLocation:Z.nextLocation})):(s(y),u({isTransitioning:!0,flushSync:!1,currentLocation:Z.currentLocation,nextLocation:Z.nextLocation}))},[n.window,v,d,T,m]);l.useLayoutEffect(()=>n.subscribe(b),[n,b]),l.useEffect(()=>{c.isTransitioning&&!c.flushSync&&p(new Fj)},[c]),l.useEffect(()=>{if(d&&i&&n.window){let y=i,C=d.promise,R=n.window.document.startViewTransition(async()=>{m(()=>a(y)),await C});R.finished.finally(()=>{p(void 0),z(void 0),s(void 0),u({isTransitioning:!1})}),z(R)}},[m,i,d,n.window]),l.useEffect(()=>{d&&i&&r.location.key===i.location.key&&d.resolve()},[d,v,r.location,i]),l.useEffect(()=>{!c.isTransitioning&&f&&(s(f.state),u({isTransitioning:!0,flushSync:!1,currentLocation:f.currentLocation,nextLocation:f.nextLocation}),h(void 0))},[c.isTransitioning,f]),l.useEffect(()=>{},[]);let N=l.useMemo(()=>({createHref:n.createHref,encodeLocation:n.encodeLocation,go:y=>n.navigate(y),push:(y,C,R)=>n.navigate(y,{state:C,preventScrollReset:R==null?void 0:R.preventScrollReset}),replace:(y,C,R)=>n.navigate(y,{replace:!0,state:C,preventScrollReset:R==null?void 0:R.preventScrollReset})}),[n]),S=n.basename||"/",A=l.useMemo(()=>({router:n,navigator:N,static:!1,basename:S}),[n,N,S]);return l.createElement(l.Fragment,null,l.createElement(xi.Provider,{value:A},l.createElement(wm.Provider,{value:r},l.createElement(Rj.Provider,{value:T.current},l.createElement(Ej.Provider,{value:c},l.createElement(Nj,{basename:S,location:r.location,navigationType:r.historyAction,navigator:N,future:{v7_relativeSplatPath:n.future.v7_relativeSplatPath}},r.initialized||n.future.v7_partialHydration?l.createElement(_j,{routes:n.routes,future:n.future,state:r}):o))))),null)}function _j(e){let{routes:o,future:n,state:t}=e;return dj(o,void 0,t,n)}const Kj=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",$j=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,mt=l.forwardRef(function(o,n){let{onClick:t,relative:r,reloadDocument:a,replace:i,state:s,target:c,to:u,preventScrollReset:d,unstable_viewTransition:p}=o,v=xj(o,Mj),{basename:z}=l.useContext(Xn),f,h=!1;if(typeof u=="string"&&$j.test(u)&&(f=u,Kj))try{let b=new URL(window.location.href),N=u.startsWith("//")?new URL(b.protocol+u):new URL(u),S=Et(N.pathname,z);N.origin===b.origin&&S!=null?u=S+N.search+N.hash:h=!0}catch{}let T=sj(u,{relative:r}),k=Hj(u,{replace:i,state:s,target:c,preventScrollReset:d,relative:r,unstable_viewTransition:p});function m(b){t&&t(b),b.defaultPrevented||k(b)}return l.createElement("a",Er({},v,{href:f||T,onClick:h||a?t:m,ref:n,target:c}))});var Nd;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(Nd||(Nd={}));var Pd;(function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"})(Pd||(Pd={}));function Hj(e,o){let{target:n,replace:t,state:r,preventScrollReset:a,relative:i,unstable_viewTransition:s}=o===void 0?{}:o,c=Xr(),u=Hr(),d=Am(e,{relative:i});return l.useCallback(p=>{if(wj(p,n)){p.preventDefault();let v=t!==void 0?t:Ln(u)===Ln(d);c(e,{replace:v,state:r,preventScrollReset:a,relative:i,unstable_viewTransition:s})}},[u,c,d,t,r,n,e,a,i,s])}function Em(e){let o=l.useRef(bc(e)),n=l.useRef(!1),t=Hr(),r=l.useMemo(()=>Cj(t.search,n.current?null:o.current),[t.search]),a=Xr(),i=l.useCallback((s,c)=>{const u=bc(typeof s=="function"?s(r):s);n.current=!0,a("?"+u,c)},[a,r]);return[r,i]}function Xj(){return j.jsxs(j.Fragment,{children:[j.jsxs("header",{className:"px-4 py-1 flex justify-between items-center",children:[j.jsx(mt,{to:"/",children:j.jsxs("h1",{className:"text-3xl font-bold",children:["PB152",j.jsx("span",{className:"text-xl font-light",children:"drill"})]})}),j.jsxs("div",{className:"flex gap-1 items-center",children:[j.jsx(mt,{to:"/about",children:j.jsx(zo,{variant:"ghost",children:"O nás"})}),j.jsx("div",{className:"h-6 w-[0.1rem] bg-border rounded-full"}),j.jsx("a",{href:"https://github.com/tomz197/os-drill",target:"_blank",children:j.jsx(zo,{variant:"ghost",size:"icon",children:j.jsx(rd,{})})})]})]}),j.jsx("div",{className:"h-[0.1rem] w-full bg-border rounded-full"}),j.jsx("main",{className:"p-4 f slex flex-1 flex-col gap-2",children:j.jsx(Tj,{})}),j.jsx("div",{className:"h-[0.1rem] w-full bg-border rounded-full"}),j.jsxs("footer",{className:"p-4 flex justify-center gap-2",children:[j.jsxs("a",{href:"https://github.com/tomz197/os-drill",target:"_blank",className:"text-grey-400 hover:text-blue-500 flex items-center gap-1",children:["Github",j.jsx(rd,{className:"w-5 h-5 inline"})]}),j.jsx("div",{className:"h-6 w-[0.1rem] bg-border rounded-full"}),j.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"text-grey-400 hover:text-blue-500 flex items-center gap-1",target:"_blank",children:["Discord",j.jsx(ym,{className:"w-6 h-6 stroke-[1.5] inline"})]})]})]})}function yn(){return yn=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)({}).hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},yn.apply(null,arguments)}function Zj(e,o){typeof e=="function"?e(o):e!=null&&(e.current=o)}function Rm(...e){return o=>e.forEach(n=>Zj(n,o))}function Dm(...e){return l.useCallback(Rm(...e),e)}function Wj(e,o=[]){let n=[];function t(a,i){const s=l.createContext(i),c=n.length;n=[...n,i];function u(p){const{scope:v,children:z,...f}=p,h=(v==null?void 0:v[e][c])||s,T=l.useMemo(()=>f,Object.values(f));return l.createElement(h.Provider,{value:T},z)}function d(p,v){const z=(v==null?void 0:v[e][c])||s,f=l.useContext(z);if(f)return f;if(i!==void 0)return i;throw new Error(`\`${p}\` must be used within \`${a}\``)}return u.displayName=a+"Provider",[u,d]}const r=()=>{const a=n.map(i=>l.createContext(i));return function(s){const c=(s==null?void 0:s[e])||a;return l.useMemo(()=>({[`__scope${e}`]:{...s,[e]:c}}),[s,c])}};return r.scopeName=e,[t,Gj(r,...o)]}function Gj(...e){const o=e[0];if(e.length===1)return o;const n=()=>{const t=e.map(r=>({useScope:r(),scopeName:r.scopeName}));return function(a){const i=t.reduce((s,{useScope:c,scopeName:u})=>{const p=c(a)[`__scope${u}`];return{...s,...p}},{});return l.useMemo(()=>({[`__scope${o.scopeName}`]:i}),[i])}};return n.scopeName=o.scopeName,n}function xd(e,o,{checkForDefaultPrevented:n=!0}={}){return function(r){if(e==null||e(r),n===!1||!r.defaultPrevented)return o==null?void 0:o(r)}}function Um(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)===null||t===void 0?void 0:t.call(o,...n)},[])}function Jj({prop:e,defaultProp:o,onChange:n=()=>{}}){const[t,r]=Qj({defaultProp:o,onChange:n}),a=e!==void 0,i=a?e:t,s=Um(n),c=l.useCallback(u=>{if(a){const p=typeof u=="function"?u(e):u;p!==e&&s(p)}else r(u)},[a,e,r,s]);return[i,c]}function Qj({defaultProp:e,onChange:o}){const n=l.useState(e),[t]=n,r=l.useRef(t),a=Um(o);return l.useEffect(()=>{r.current!==t&&(a(t),r.current=t)},[t,r,a]),n}function Yj(e){const o=l.useRef({value:e,previous:e});return l.useMemo(()=>(o.current.value!==e&&(o.current.previous=o.current.value,o.current.value=e),o.current.previous),[e])}const yc=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{};function qj(e){const[o,n]=l.useState(void 0);return yc(()=>{if(e){n({width:e.offsetWidth,height:e.offsetHeight});const t=new ResizeObserver(r=>{if(!Array.isArray(r)||!r.length)return;const a=r[0];let i,s;if("borderBoxSize"in a){const c=a.borderBoxSize,u=Array.isArray(c)?c[0]:c;i=u.inlineSize,s=u.blockSize}else i=e.offsetWidth,s=e.offsetHeight;n({width:i,height:s})});return t.observe(e,{box:"border-box"}),()=>t.unobserve(e)}else n(void 0)},[e]),o}function ef(e,o){return l.useReducer((n,t)=>{const r=o[n][t];return r??n},e)}const Lm=e=>{const{present:o,children:n}=e,t=of(o),r=typeof n=="function"?n({present:t.isPresent}):l.Children.only(n),a=Dm(t.ref,r.ref);return typeof n=="function"||t.isPresent?l.cloneElement(r,{ref:a}):null};Lm.displayName="Presence";function of(e){const[o,n]=l.useState(),t=l.useRef({}),r=l.useRef(e),a=l.useRef("none"),i=e?"mounted":"unmounted",[s,c]=ef(i,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return l.useEffect(()=>{const u=ha(t.current);a.current=s==="mounted"?u:"none"},[s]),yc(()=>{const u=t.current,d=r.current;if(d!==e){const v=a.current,z=ha(u);e?c("MOUNT"):z==="none"||(u==null?void 0:u.display)==="none"?c("UNMOUNT"):c(d&&v!==z?"ANIMATION_OUT":"UNMOUNT"),r.current=e}},[e,c]),yc(()=>{if(o){const u=p=>{const z=ha(t.current).includes(p.animationName);p.target===o&&z&&Kr.flushSync(()=>c("ANIMATION_END"))},d=p=>{p.target===o&&(a.current=ha(t.current))};return o.addEventListener("animationstart",d),o.addEventListener("animationcancel",u),o.addEventListener("animationend",u),()=>{o.removeEventListener("animationstart",d),o.removeEventListener("animationcancel",u),o.removeEventListener("animationend",u)}}else c("ANIMATION_END")},[o,c]),{isPresent:["mounted","unmountSuspended"].includes(s),ref:l.useCallback(u=>{u&&(t.current=getComputedStyle(u)),n(u)},[])}}function ha(e){return(e==null?void 0:e.animationName)||"none"}const Fm=l.forwardRef((e,o)=>{const{children:n,...t}=e,r=l.Children.toArray(n),a=r.find(tf);if(a){const i=a.props.children,s=r.map(c=>c===a?l.Children.count(i)>1?l.Children.only(null):l.isValidElement(i)?i.props.children:null:c);return l.createElement(zc,yn({},t,{ref:o}),l.isValidElement(i)?l.cloneElement(i,void 0,s):null)}return l.createElement(zc,yn({},t,{ref:o}),n)});Fm.displayName="Slot";const zc=l.forwardRef((e,o)=>{const{children:n,...t}=e;return l.isValidElement(n)?l.cloneElement(n,{...rf(t,n.props),ref:o?Rm(o,n.ref):n.ref}):l.Children.count(n)>1?l.Children.only(null):null});zc.displayName="SlotClone";const nf=({children:e})=>l.createElement(l.Fragment,null,e);function tf(e){return l.isValidElement(e)&&e.type===nf}function rf(e,o){const n={...o};for(const t in o){const r=e[t],a=o[t];/^on[A-Z]/.test(t)?r&&a?n[t]=(...s)=>{a(...s),r(...s)}:r&&(n[t]=r):t==="style"?n[t]={...r,...a}:t==="className"&&(n[t]=[r,a].filter(Boolean).join(" "))}return{...e,...n}}const af=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Bm=af.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,s=a?Fm:o;return l.useEffect(()=>{window[Symbol.for("radix-ui")]=!0},[]),l.createElement(s,yn({},i,{ref:r}))});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{}),_m="Checkbox",[sf,g4]=Wj(_m),[cf,uf]=sf(_m),lf=l.forwardRef((e,o)=>{const{__scopeCheckbox:n,name:t,checked:r,defaultChecked:a,required:i,disabled:s,value:c="on",onCheckedChange:u,...d}=e,[p,v]=l.useState(null),z=Dm(o,b=>v(b)),f=l.useRef(!1),h=p?!!p.closest("form"):!0,[T=!1,k]=Jj({prop:r,defaultProp:a,onChange:u}),m=l.useRef(T);return l.useEffect(()=>{const b=p==null?void 0:p.form;if(b){const N=()=>k(m.current);return b.addEventListener("reset",N),()=>b.removeEventListener("reset",N)}},[p,k]),l.createElement(cf,{scope:n,state:T,disabled:s},l.createElement(Bm.button,yn({type:"button",role:"checkbox","aria-checked":An(T)?"mixed":T,"aria-required":i,"data-state":Km(T),"data-disabled":s?"":void 0,disabled:s,value:c},d,{ref:z,onKeyDown:xd(e.onKeyDown,b=>{b.key==="Enter"&&b.preventDefault()}),onClick:xd(e.onClick,b=>{k(N=>An(N)?!0:!N),h&&(f.current=b.isPropagationStopped(),f.current||b.stopPropagation())})})),h&&l.createElement(vf,{control:p,bubbles:!f.current,name:t,value:c,checked:T,required:i,disabled:s,style:{transform:"translateX(-100%)"}}))}),df="CheckboxIndicator",pf=l.forwardRef((e,o)=>{const{__scopeCheckbox:n,forceMount:t,...r}=e,a=uf(df,n);return l.createElement(Lm,{present:t||An(a.state)||a.state===!0},l.createElement(Bm.span,yn({"data-state":Km(a.state),"data-disabled":a.disabled?"":void 0},r,{ref:o,style:{pointerEvents:"none",...e.style}})))}),vf=e=>{const{control:o,checked:n,bubbles:t=!0,...r}=e,a=l.useRef(null),i=Yj(n),s=qj(o);return l.useEffect(()=>{const c=a.current,u=window.HTMLInputElement.prototype,p=Object.getOwnPropertyDescriptor(u,"checked").set;if(i!==n&&p){const v=new Event("click",{bubbles:t});c.indeterminate=An(n),p.call(c,An(n)?!1:n),c.dispatchEvent(v)}},[i,n,t]),l.createElement("input",yn({type:"checkbox","aria-hidden":!0,defaultChecked:An(n)?!1:n},r,{tabIndex:-1,ref:a,style:{...e.style,...s,position:"absolute",pointerEvents:"none",opacity:0,margin:0}}))};function An(e){return e==="indeterminate"}function Km(e){return An(e)?"indeterminate":e?"checked":"unchecked"}const $m=lf,mf=pf,Nu=l.forwardRef(({className:e,...o},n)=>j.jsx($m,{ref:n,className:Ao("peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",e),...o,children:j.jsx(mf,{className:Ao("flex items-center justify-center text-current"),children:j.jsx(hm,{className:"h-4 w-4"})})}));Nu.displayName=$m.displayName;function hr(e,o,{checkForDefaultPrevented:n=!0}={}){return function(r){if(e==null||e(r),n===!1||!r.defaultPrevented)return o==null?void 0:o(r)}}function Sd(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function kf(...e){return o=>{let n=!1;const t=e.map(r=>{const a=Sd(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():Sd(e[r],null)}}}}function Si(...e){return l.useCallback(kf(...e),e)}function hf(e,o){const n=l.createContext(o),t=a=>{const{children:i,...s}=a,c=l.useMemo(()=>s,Object.values(s));return j.jsx(n.Provider,{value:c,children:i})};t.displayName=e+"Provider";function r(a){const i=l.useContext(n);if(i)return i;if(o!==void 0)return o;throw new Error(`\`${a}\` must be used within \`${e}\``)}return[t,r]}function bf(e,o=[]){let n=[];function t(a,i){const s=l.createContext(i),c=n.length;n=[...n,i];const u=p=>{var k;const{scope:v,children:z,...f}=p,h=((k=v==null?void 0:v[e])==null?void 0:k[c])||s,T=l.useMemo(()=>f,Object.values(f));return j.jsx(h.Provider,{value:T,children:z})};u.displayName=a+"Provider";function d(p,v){var h;const z=((h=v==null?void 0:v[e])==null?void 0:h[c])||s,f=l.useContext(z);if(f)return f;if(i!==void 0)return i;throw new Error(`\`${p}\` must be used within \`${a}\``)}return[u,d]}const r=()=>{const a=n.map(i=>l.createContext(i));return function(s){const c=(s==null?void 0:s[e])||a;return l.useMemo(()=>({[`__scope${e}`]:{...s,[e]:c}}),[s,c])}};return r.scopeName=e,[t,yf(r,...o)]}function yf(...e){const o=e[0];if(e.length===1)return o;const n=()=>{const t=e.map(r=>({useScope:r(),scopeName:r.scopeName}));return function(a){const i=t.reduce((s,{useScope:c,scopeName:u})=>{const p=c(a)[`__scope${u}`];return{...s,...p}},{});return l.useMemo(()=>({[`__scope${o.scopeName}`]:i}),[i])}};return n.scopeName=o.scopeName,n}var zf=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{},jf=rp.useId||(()=>{}),ff=0;function us(e){const[o,n]=l.useState(jf());return zf(()=>{e||n(t=>t??String(ff++))},[e]),e||(o?`radix-${o}`:"")}function Hm(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}function gf({prop:e,defaultProp:o,onChange:n=()=>{}}){const[t,r]=Tf({defaultProp:o,onChange:n}),a=e!==void 0,i=a?e:t,s=Hm(n),c=l.useCallback(u=>{if(a){const p=typeof u=="function"?u(e):u;p!==e&&s(p)}else r(u)},[a,e,r,s]);return[i,c]}function Tf({defaultProp:e,onChange:o}){const n=l.useState(e),[t]=n,r=l.useRef(t),a=Hm(o);return l.useEffect(()=>{r.current!==t&&(a(t),r.current=t)},[t,r,a]),n}function ls(e,o,{checkForDefaultPrevented:n=!0}={}){return function(r){if(e==null||e(r),n===!1||!r.defaultPrevented)return o==null?void 0:o(r)}}var Nf=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Xm=Nf.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,s=a?Hn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),j.jsx(s,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{});function Pf(e,o){e&&Kr.flushSync(()=>e.dispatchEvent(o))}function wd(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function xf(...e){return o=>{let n=!1;const t=e.map(r=>{const a=wd(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():wd(e[r],null)}}}}function Zm(...e){return l.useCallback(xf(...e),e)}function Wm(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}function Sf(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}function wf(e,o=globalThis==null?void 0:globalThis.document){const n=Sf(e);l.useEffect(()=>{const t=r=>{r.key==="Escape"&&n(r)};return o.addEventListener("keydown",t,{capture:!0}),()=>o.removeEventListener("keydown",t,{capture:!0})},[n,o])}var Cf="DismissableLayer",jc="dismissableLayer.update",Mf="dismissableLayer.pointerDownOutside",If="dismissableLayer.focusOutside",Cd,Gm=l.createContext({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),Jm=l.forwardRef((e,o)=>{const{disableOutsidePointerEvents:n=!1,onEscapeKeyDown:t,onPointerDownOutside:r,onFocusOutside:a,onInteractOutside:i,onDismiss:s,...c}=e,u=l.useContext(Gm),[d,p]=l.useState(null),v=(d==null?void 0:d.ownerDocument)??(globalThis==null?void 0:globalThis.document),[,z]=l.useState({}),f=Zm(o,y=>p(y)),h=Array.from(u.layers),[T]=[...u.layersWithOutsidePointerEventsDisabled].slice(-1),k=h.indexOf(T),m=d?h.indexOf(d):-1,b=u.layersWithOutsidePointerEventsDisabled.size>0,N=m>=k,S=Of(y=>{const C=y.target,R=[...u.branches].some(V=>V.contains(C));!N||R||(r==null||r(y),i==null||i(y),y.defaultPrevented||s==null||s())},v),A=Ef(y=>{const C=y.target;[...u.branches].some(V=>V.contains(C))||(a==null||a(y),i==null||i(y),y.defaultPrevented||s==null||s())},v);return wf(y=>{m===u.layers.size-1&&(t==null||t(y),!y.defaultPrevented&&s&&(y.preventDefault(),s()))},v),l.useEffect(()=>{if(d)return n&&(u.layersWithOutsidePointerEventsDisabled.size===0&&(Cd=v.body.style.pointerEvents,v.body.style.pointerEvents="none"),u.layersWithOutsidePointerEventsDisabled.add(d)),u.layers.add(d),Md(),()=>{n&&u.layersWithOutsidePointerEventsDisabled.size===1&&(v.body.style.pointerEvents=Cd)}},[d,v,n,u]),l.useEffect(()=>()=>{d&&(u.layers.delete(d),u.layersWithOutsidePointerEventsDisabled.delete(d),Md())},[d,u]),l.useEffect(()=>{const y=()=>z({});return document.addEventListener(jc,y),()=>document.removeEventListener(jc,y)},[]),j.jsx(Xm.div,{...c,ref:f,style:{pointerEvents:b?N?"auto":"none":void 0,...e.style},onFocusCapture:ls(e.onFocusCapture,A.onFocusCapture),onBlurCapture:ls(e.onBlurCapture,A.onBlurCapture),onPointerDownCapture:ls(e.onPointerDownCapture,S.onPointerDownCapture)})});Jm.displayName=Cf;var Af="DismissableLayerBranch",Vf=l.forwardRef((e,o)=>{const n=l.useContext(Gm),t=l.useRef(null),r=Zm(o,t);return l.useEffect(()=>{const a=t.current;if(a)return n.branches.add(a),()=>{n.branches.delete(a)}},[n.branches]),j.jsx(Xm.div,{...e,ref:r})});Vf.displayName=Af;function Of(e,o=globalThis==null?void 0:globalThis.document){const n=Wm(e),t=l.useRef(!1),r=l.useRef(()=>{});return l.useEffect(()=>{const a=s=>{if(s.target&&!t.current){let c=function(){Qm(Mf,n,u,{discrete:!0})};const u={originalEvent:s};s.pointerType==="touch"?(o.removeEventListener("click",r.current),r.current=c,o.addEventListener("click",r.current,{once:!0})):c()}else o.removeEventListener("click",r.current);t.current=!1},i=window.setTimeout(()=>{o.addEventListener("pointerdown",a)},0);return()=>{window.clearTimeout(i),o.removeEventListener("pointerdown",a),o.removeEventListener("click",r.current)}},[o,n]),{onPointerDownCapture:()=>t.current=!0}}function Ef(e,o=globalThis==null?void 0:globalThis.document){const n=Wm(e),t=l.useRef(!1);return l.useEffect(()=>{const r=a=>{a.target&&!t.current&&Qm(If,n,{originalEvent:a},{discrete:!1})};return o.addEventListener("focusin",r),()=>o.removeEventListener("focusin",r)},[o,n]),{onFocusCapture:()=>t.current=!0,onBlurCapture:()=>t.current=!1}}function Md(){const e=new CustomEvent(jc);document.dispatchEvent(e)}function Qm(e,o,n,{discrete:t}){const r=n.originalEvent.target,a=new CustomEvent(e,{bubbles:!1,cancelable:!0,detail:n});o&&r.addEventListener(e,o,{once:!0}),t?Pf(r,a):r.dispatchEvent(a)}function Id(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function Rf(...e){return o=>{let n=!1;const t=e.map(r=>{const a=Id(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():Id(e[r],null)}}}}function Df(...e){return l.useCallback(Rf(...e),e)}var Uf=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Lf=Uf.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,s=a?Hn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),j.jsx(s,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{});function Ad(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}var ds="focusScope.autoFocusOnMount",ps="focusScope.autoFocusOnUnmount",Vd={bubbles:!1,cancelable:!0},Ff="FocusScope",Ym=l.forwardRef((e,o)=>{const{loop:n=!1,trapped:t=!1,onMountAutoFocus:r,onUnmountAutoFocus:a,...i}=e,[s,c]=l.useState(null),u=Ad(r),d=Ad(a),p=l.useRef(null),v=Df(o,h=>c(h)),z=l.useRef({paused:!1,pause(){this.paused=!0},resume(){this.paused=!1}}).current;l.useEffect(()=>{if(t){let h=function(b){if(z.paused||!s)return;const N=b.target;s.contains(N)?p.current=N:en(p.current,{select:!0})},T=function(b){if(z.paused||!s)return;const N=b.relatedTarget;N!==null&&(s.contains(N)||en(p.current,{select:!0}))},k=function(b){if(document.activeElement===document.body)for(const S of b)S.removedNodes.length>0&&en(s)};document.addEventListener("focusin",h),document.addEventListener("focusout",T);const m=new MutationObserver(k);return s&&m.observe(s,{childList:!0,subtree:!0}),()=>{document.removeEventListener("focusin",h),document.removeEventListener("focusout",T),m.disconnect()}}},[t,s,z.paused]),l.useEffect(()=>{if(s){Ed.add(z);const h=document.activeElement;if(!s.contains(h)){const k=new CustomEvent(ds,Vd);s.addEventListener(ds,u),s.dispatchEvent(k),k.defaultPrevented||(Bf(Xf(qm(s)),{select:!0}),document.activeElement===h&&en(s))}return()=>{s.removeEventListener(ds,u),setTimeout(()=>{const k=new CustomEvent(ps,Vd);s.addEventListener(ps,d),s.dispatchEvent(k),k.defaultPrevented||en(h??document.body,{select:!0}),s.removeEventListener(ps,d),Ed.remove(z)},0)}}},[s,u,d,z]);const f=l.useCallback(h=>{if(!n&&!t||z.paused)return;const T=h.key==="Tab"&&!h.altKey&&!h.ctrlKey&&!h.metaKey,k=document.activeElement;if(T&&k){const m=h.currentTarget,[b,N]=_f(m);b&&N?!h.shiftKey&&k===N?(h.preventDefault(),n&&en(b,{select:!0})):h.shiftKey&&k===b&&(h.preventDefault(),n&&en(N,{select:!0})):k===m&&h.preventDefault()}},[n,t,z.paused]);return j.jsx(Lf.div,{tabIndex:-1,...i,ref:v,onKeyDown:f})});Ym.displayName=Ff;function Bf(e,{select:o=!1}={}){const n=document.activeElement;for(const t of e)if(en(t,{select:o}),document.activeElement!==n)return}function _f(e){const o=qm(e),n=Od(o,e),t=Od(o.reverse(),e);return[n,t]}function qm(e){const o=[],n=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,{acceptNode:t=>{const r=t.tagName==="INPUT"&&t.type==="hidden";return t.disabled||t.hidden||r?NodeFilter.FILTER_SKIP:t.tabIndex>=0?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP}});for(;n.nextNode();)o.push(n.currentNode);return o}function Od(e,o){for(const n of e)if(!Kf(n,{upTo:o}))return n}function Kf(e,{upTo:o}){if(getComputedStyle(e).visibility==="hidden")return!0;for(;e;){if(o!==void 0&&e===o)return!1;if(getComputedStyle(e).display==="none")return!0;e=e.parentElement}return!1}function $f(e){return e instanceof HTMLInputElement&&"select"in e}function en(e,{select:o=!1}={}){if(e&&e.focus){const n=document.activeElement;e.focus({preventScroll:!0}),e!==n&&$f(e)&&o&&e.select()}}var Ed=Hf();function Hf(){let e=[];return{add(o){const n=e[0];o!==n&&(n==null||n.pause()),e=Rd(e,o),e.unshift(o)},remove(o){var n;e=Rd(e,o),(n=e[0])==null||n.resume()}}}function Rd(e,o){const n=[...e],t=n.indexOf(o);return t!==-1&&n.splice(t,1),n}function Xf(e){return e.filter(o=>o.tagName!=="A")}var Zf=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Wf=Zf.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,s=a?Hn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),j.jsx(s,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{}),Gf=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{},Jf="Portal",ek=l.forwardRef((e,o)=>{var s;const{container:n,...t}=e,[r,a]=l.useState(!1);Gf(()=>a(!0),[]);const i=n||r&&((s=globalThis==null?void 0:globalThis.document)==null?void 0:s.body);return i?sm.createPortal(j.jsx(Wf.div,{...t,ref:o}),i):null});ek.displayName=Jf;var Dd=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{};function Qf(e,o){return l.useReducer((n,t)=>o[n][t]??n,e)}var wi=e=>{const{present:o,children:n}=e,t=Yf(o),r=typeof n=="function"?n({present:t.isPresent}):l.Children.only(n),a=Si(t.ref,qf(r));return typeof n=="function"||t.isPresent?l.cloneElement(r,{ref:a}):null};wi.displayName="Presence";function Yf(e){const[o,n]=l.useState(),t=l.useRef({}),r=l.useRef(e),a=l.useRef("none"),i=e?"mounted":"unmounted",[s,c]=Qf(i,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return l.useEffect(()=>{const u=ba(t.current);a.current=s==="mounted"?u:"none"},[s]),Dd(()=>{const u=t.current,d=r.current;if(d!==e){const v=a.current,z=ba(u);e?c("MOUNT"):z==="none"||(u==null?void 0:u.display)==="none"?c("UNMOUNT"):c(d&&v!==z?"ANIMATION_OUT":"UNMOUNT"),r.current=e}},[e,c]),Dd(()=>{if(o){let u;const d=o.ownerDocument.defaultView??window,p=z=>{const h=ba(t.current).includes(z.animationName);if(z.target===o&&h&&(c("ANIMATION_END"),!r.current)){const T=o.style.animationFillMode;o.style.animationFillMode="forwards",u=d.setTimeout(()=>{o.style.animationFillMode==="forwards"&&(o.style.animationFillMode=T)})}},v=z=>{z.target===o&&(a.current=ba(t.current))};return o.addEventListener("animationstart",v),o.addEventListener("animationcancel",p),o.addEventListener("animationend",p),()=>{d.clearTimeout(u),o.removeEventListener("animationstart",v),o.removeEventListener("animationcancel",p),o.removeEventListener("animationend",p)}}else c("ANIMATION_END")},[o,c]),{isPresent:["mounted","unmountSuspended"].includes(s),ref:l.useCallback(u=>{u&&(t.current=getComputedStyle(u)),n(u)},[])}}function ba(e){return(e==null?void 0:e.animationName)||"none"}function qf(e){var t,r;let o=(t=Object.getOwnPropertyDescriptor(e.props,"ref"))==null?void 0:t.get,n=o&&"isReactWarning"in o&&o.isReactWarning;return n?e.ref:(o=(r=Object.getOwnPropertyDescriptor(e,"ref"))==null?void 0:r.get,n=o&&"isReactWarning"in o&&o.isReactWarning,n?e.props.ref:e.props.ref||e.ref)}var e1=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Zr=e1.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,s=a?Hn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),j.jsx(s,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{}),vs=0;function o1(){l.useEffect(()=>{const e=document.querySelectorAll("[data-radix-focus-guard]");return document.body.insertAdjacentElement("afterbegin",e[0]??Ud()),document.body.insertAdjacentElement("beforeend",e[1]??Ud()),vs++,()=>{vs===1&&document.querySelectorAll("[data-radix-focus-guard]").forEach(o=>o.remove()),vs--}},[])}function Ud(){const e=document.createElement("span");return e.setAttribute("data-radix-focus-guard",""),e.tabIndex=0,e.style.outline="none",e.style.opacity="0",e.style.position="fixed",e.style.pointerEvents="none",e}var wo=function(){return wo=Object.assign||function(o){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(o[a]=n[a])}return o},wo.apply(this,arguments)};function ok(e,o){var n={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&o.indexOf(t)<0&&(n[t]=e[t]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,t=Object.getOwnPropertySymbols(e);r<t.length;r++)o.indexOf(t[r])<0&&Object.prototype.propertyIsEnumerable.call(e,t[r])&&(n[t[r]]=e[t[r]]);return n}function n1(e,o,n){if(n||arguments.length===2)for(var t=0,r=o.length,a;t<r;t++)(a||!(t in o))&&(a||(a=Array.prototype.slice.call(o,0,t)),a[t]=o[t]);return e.concat(a||Array.prototype.slice.call(o))}var Oa="right-scroll-bar-position",Ea="width-before-scroll-bar",t1="with-scroll-bars-hidden",r1="--removed-body-scroll-bar-size";function ms(e,o){return typeof e=="function"?e(o):e&&(e.current=o),e}function a1(e,o){var n=l.useState(function(){return{value:e,callback:o,facade:{get current(){return n.value},set current(t){var r=n.value;r!==t&&(n.value=t,n.callback(t,r))}}}})[0];return n.callback=o,n.facade}var i1=typeof window<"u"?l.useLayoutEffect:l.useEffect,Ld=new WeakMap;function s1(e,o){var n=a1(null,function(t){return e.forEach(function(r){return ms(r,t)})});return i1(function(){var t=Ld.get(n);if(t){var r=new Set(t),a=new Set(e),i=n.current;r.forEach(function(s){a.has(s)||ms(s,null)}),a.forEach(function(s){r.has(s)||ms(s,i)})}Ld.set(n,e)},[e]),n}function c1(e){return e}function u1(e,o){o===void 0&&(o=c1);var n=[],t=!1,r={read:function(){if(t)throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");return n.length?n[n.length-1]:e},useMedium:function(a){var i=o(a,t);return n.push(i),function(){n=n.filter(function(s){return s!==i})}},assignSyncMedium:function(a){for(t=!0;n.length;){var i=n;n=[],i.forEach(a)}n={push:function(s){return a(s)},filter:function(){return n}}},assignMedium:function(a){t=!0;var i=[];if(n.length){var s=n;n=[],s.forEach(a),i=n}var c=function(){var d=i;i=[],d.forEach(a)},u=function(){return Promise.resolve().then(c)};u(),n={push:function(d){i.push(d),u()},filter:function(d){return i=i.filter(d),n}}}};return r}function l1(e){e===void 0&&(e={});var o=u1(null);return o.options=wo({async:!0,ssr:!1},e),o}var nk=function(e){var o=e.sideCar,n=ok(e,["sideCar"]);if(!o)throw new Error("Sidecar: please provide `sideCar` property to import the right car");var t=o.read();if(!t)throw new Error("Sidecar medium not found");return l.createElement(t,wo({},n))};nk.isSideCarExport=!0;function d1(e,o){return e.useMedium(o),nk}var tk=l1(),ks=function(){},Ci=l.forwardRef(function(e,o){var n=l.useRef(null),t=l.useState({onScrollCapture:ks,onWheelCapture:ks,onTouchMoveCapture:ks}),r=t[0],a=t[1],i=e.forwardProps,s=e.children,c=e.className,u=e.removeScrollBar,d=e.enabled,p=e.shards,v=e.sideCar,z=e.noIsolation,f=e.inert,h=e.allowPinchZoom,T=e.as,k=T===void 0?"div":T,m=e.gapMode,b=ok(e,["forwardProps","children","className","removeScrollBar","enabled","shards","sideCar","noIsolation","inert","allowPinchZoom","as","gapMode"]),N=v,S=s1([n,o]),A=wo(wo({},b),r);return l.createElement(l.Fragment,null,d&&l.createElement(N,{sideCar:tk,removeScrollBar:u,shards:p,noIsolation:z,inert:f,setCallbacks:a,allowPinchZoom:!!h,lockRef:n,gapMode:m}),i?l.cloneElement(l.Children.only(s),wo(wo({},A),{ref:S})):l.createElement(k,wo({},A,{className:c,ref:S}),s))});Ci.defaultProps={enabled:!0,removeScrollBar:!0,inert:!1};Ci.classNames={fullWidth:Ea,zeroRight:Oa};var p1=function(){if(typeof __webpack_nonce__<"u")return __webpack_nonce__};function v1(){if(!document)return null;var e=document.createElement("style");e.type="text/css";var o=p1();return o&&e.setAttribute("nonce",o),e}function m1(e,o){e.styleSheet?e.styleSheet.cssText=o:e.appendChild(document.createTextNode(o))}function k1(e){var o=document.head||document.getElementsByTagName("head")[0];o.appendChild(e)}var h1=function(){var e=0,o=null;return{add:function(n){e==0&&(o=v1())&&(m1(o,n),k1(o)),e++},remove:function(){e--,!e&&o&&(o.parentNode&&o.parentNode.removeChild(o),o=null)}}},b1=function(){var e=h1();return function(o,n){l.useEffect(function(){return e.add(o),function(){e.remove()}},[o&&n])}},rk=function(){var e=b1(),o=function(n){var t=n.styles,r=n.dynamic;return e(t,r),null};return o},y1={left:0,top:0,right:0,gap:0},hs=function(e){return parseInt(e||"",10)||0},z1=function(e){var o=window.getComputedStyle(document.body),n=o[e==="padding"?"paddingLeft":"marginLeft"],t=o[e==="padding"?"paddingTop":"marginTop"],r=o[e==="padding"?"paddingRight":"marginRight"];return[hs(n),hs(t),hs(r)]},j1=function(e){if(e===void 0&&(e="margin"),typeof window>"u")return y1;var o=z1(e),n=document.documentElement.clientWidth,t=window.innerWidth;return{left:o[0],top:o[1],right:o[2],gap:Math.max(0,t-n+o[2]-o[0])}},f1=rk(),Tt="data-scroll-locked",g1=function(e,o,n,t){var r=e.left,a=e.top,i=e.right,s=e.gap;return n===void 0&&(n="margin"),`
  .`.concat(t1,` {
   overflow: hidden `).concat(t,`;
   padding-right: `).concat(s,"px ").concat(t,`;
  }
  body[`).concat(Tt,`] {
    overflow: hidden `).concat(t,`;
    overscroll-behavior: contain;
    `).concat([o&&"position: relative ".concat(t,";"),n==="margin"&&`
    padding-left: `.concat(r,`px;
    padding-top: `).concat(a,`px;
    padding-right: `).concat(i,`px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s,"px ").concat(t,`;
    `),n==="padding"&&"padding-right: ".concat(s,"px ").concat(t,";")].filter(Boolean).join(""),`
  }
  
  .`).concat(Oa,` {
    right: `).concat(s,"px ").concat(t,`;
  }
  
  .`).concat(Ea,` {
    margin-right: `).concat(s,"px ").concat(t,`;
  }
  
  .`).concat(Oa," .").concat(Oa,` {
    right: 0 `).concat(t,`;
  }
  
  .`).concat(Ea," .").concat(Ea,` {
    margin-right: 0 `).concat(t,`;
  }
  
  body[`).concat(Tt,`] {
    `).concat(r1,": ").concat(s,`px;
  }
`)},Fd=function(){var e=parseInt(document.body.getAttribute(Tt)||"0",10);return isFinite(e)?e:0},T1=function(){l.useEffect(function(){return document.body.setAttribute(Tt,(Fd()+1).toString()),function(){var e=Fd()-1;e<=0?document.body.removeAttribute(Tt):document.body.setAttribute(Tt,e.toString())}},[])},N1=function(e){var o=e.noRelative,n=e.noImportant,t=e.gapMode,r=t===void 0?"margin":t;T1();var a=l.useMemo(function(){return j1(r)},[r]);return l.createElement(f1,{styles:g1(a,!o,r,n?"":"!important")})},fc=!1;if(typeof window<"u")try{var ya=Object.defineProperty({},"passive",{get:function(){return fc=!0,!0}});window.addEventListener("test",ya,ya),window.removeEventListener("test",ya,ya)}catch{fc=!1}var Yn=fc?{passive:!1}:!1,P1=function(e){return e.tagName==="TEXTAREA"},ak=function(e,o){if(!(e instanceof Element))return!1;var n=window.getComputedStyle(e);return n[o]!=="hidden"&&!(n.overflowY===n.overflowX&&!P1(e)&&n[o]==="visible")},x1=function(e){return ak(e,"overflowY")},S1=function(e){return ak(e,"overflowX")},Bd=function(e,o){var n=o.ownerDocument,t=o;do{typeof ShadowRoot<"u"&&t instanceof ShadowRoot&&(t=t.host);var r=ik(e,t);if(r){var a=sk(e,t),i=a[1],s=a[2];if(i>s)return!0}t=t.parentNode}while(t&&t!==n.body);return!1},w1=function(e){var o=e.scrollTop,n=e.scrollHeight,t=e.clientHeight;return[o,n,t]},C1=function(e){var o=e.scrollLeft,n=e.scrollWidth,t=e.clientWidth;return[o,n,t]},ik=function(e,o){return e==="v"?x1(o):S1(o)},sk=function(e,o){return e==="v"?w1(o):C1(o)},M1=function(e,o){return e==="h"&&o==="rtl"?-1:1},I1=function(e,o,n,t,r){var a=M1(e,window.getComputedStyle(o).direction),i=a*t,s=n.target,c=o.contains(s),u=!1,d=i>0,p=0,v=0;do{var z=sk(e,s),f=z[0],h=z[1],T=z[2],k=h-T-a*f;(f||k)&&ik(e,s)&&(p+=k,v+=f),s instanceof ShadowRoot?s=s.host:s=s.parentNode}while(!c&&s!==document.body||c&&(o.contains(s)||o===s));return(d&&(Math.abs(p)<1||!r)||!d&&(Math.abs(v)<1||!r))&&(u=!0),u},za=function(e){return"changedTouches"in e?[e.changedTouches[0].clientX,e.changedTouches[0].clientY]:[0,0]},_d=function(e){return[e.deltaX,e.deltaY]},Kd=function(e){return e&&"current"in e?e.current:e},A1=function(e,o){return e[0]===o[0]&&e[1]===o[1]},V1=function(e){return`
  .block-interactivity-`.concat(e,` {pointer-events: none;}
  .allow-interactivity-`).concat(e,` {pointer-events: all;}
`)},O1=0,qn=[];function E1(e){var o=l.useRef([]),n=l.useRef([0,0]),t=l.useRef(),r=l.useState(O1++)[0],a=l.useState(rk)[0],i=l.useRef(e);l.useEffect(function(){i.current=e},[e]),l.useEffect(function(){if(e.inert){document.body.classList.add("block-interactivity-".concat(r));var h=n1([e.lockRef.current],(e.shards||[]).map(Kd),!0).filter(Boolean);return h.forEach(function(T){return T.classList.add("allow-interactivity-".concat(r))}),function(){document.body.classList.remove("block-interactivity-".concat(r)),h.forEach(function(T){return T.classList.remove("allow-interactivity-".concat(r))})}}},[e.inert,e.lockRef.current,e.shards]);var s=l.useCallback(function(h,T){if("touches"in h&&h.touches.length===2||h.type==="wheel"&&h.ctrlKey)return!i.current.allowPinchZoom;var k=za(h),m=n.current,b="deltaX"in h?h.deltaX:m[0]-k[0],N="deltaY"in h?h.deltaY:m[1]-k[1],S,A=h.target,y=Math.abs(b)>Math.abs(N)?"h":"v";if("touches"in h&&y==="h"&&A.type==="range")return!1;var C=Bd(y,A);if(!C)return!0;if(C?S=y:(S=y==="v"?"h":"v",C=Bd(y,A)),!C)return!1;if(!t.current&&"changedTouches"in h&&(b||N)&&(t.current=S),!S)return!0;var R=t.current||S;return I1(R,T,h,R==="h"?b:N,!0)},[]),c=l.useCallback(function(h){var T=h;if(!(!qn.length||qn[qn.length-1]!==a)){var k="deltaY"in T?_d(T):za(T),m=o.current.filter(function(S){return S.name===T.type&&(S.target===T.target||T.target===S.shadowParent)&&A1(S.delta,k)})[0];if(m&&m.should){T.cancelable&&T.preventDefault();return}if(!m){var b=(i.current.shards||[]).map(Kd).filter(Boolean).filter(function(S){return S.contains(T.target)}),N=b.length>0?s(T,b[0]):!i.current.noIsolation;N&&T.cancelable&&T.preventDefault()}}},[]),u=l.useCallback(function(h,T,k,m){var b={name:h,delta:T,target:k,should:m,shadowParent:R1(k)};o.current.push(b),setTimeout(function(){o.current=o.current.filter(function(N){return N!==b})},1)},[]),d=l.useCallback(function(h){n.current=za(h),t.current=void 0},[]),p=l.useCallback(function(h){u(h.type,_d(h),h.target,s(h,e.lockRef.current))},[]),v=l.useCallback(function(h){u(h.type,za(h),h.target,s(h,e.lockRef.current))},[]);l.useEffect(function(){return qn.push(a),e.setCallbacks({onScrollCapture:p,onWheelCapture:p,onTouchMoveCapture:v}),document.addEventListener("wheel",c,Yn),document.addEventListener("touchmove",c,Yn),document.addEventListener("touchstart",d,Yn),function(){qn=qn.filter(function(h){return h!==a}),document.removeEventListener("wheel",c,Yn),document.removeEventListener("touchmove",c,Yn),document.removeEventListener("touchstart",d,Yn)}},[]);var z=e.removeScrollBar,f=e.inert;return l.createElement(l.Fragment,null,f?l.createElement(a,{styles:V1(r)}):null,z?l.createElement(N1,{gapMode:e.gapMode}):null)}function R1(e){for(var o=null;e!==null;)e instanceof ShadowRoot&&(o=e.host,e=e.host),e=e.parentNode;return o}const D1=d1(tk,E1);var ck=l.forwardRef(function(e,o){return l.createElement(Ci,wo({},e,{ref:o,sideCar:D1}))});ck.classNames=Ci.classNames;var U1=function(e){if(typeof document>"u")return null;var o=Array.isArray(e)?e[0]:e;return o.ownerDocument.body},et=new WeakMap,ja=new WeakMap,fa={},bs=0,uk=function(e){return e&&(e.host||uk(e.parentNode))},L1=function(e,o){return o.map(function(n){if(e.contains(n))return n;var t=uk(n);return t&&e.contains(t)?t:(console.error("aria-hidden",n,"in not contained inside",e,". Doing nothing"),null)}).filter(function(n){return!!n})},F1=function(e,o,n,t){var r=L1(o,Array.isArray(e)?e:[e]);fa[n]||(fa[n]=new WeakMap);var a=fa[n],i=[],s=new Set,c=new Set(r),u=function(p){!p||s.has(p)||(s.add(p),u(p.parentNode))};r.forEach(u);var d=function(p){!p||c.has(p)||Array.prototype.forEach.call(p.children,function(v){if(s.has(v))d(v);else try{var z=v.getAttribute(t),f=z!==null&&z!=="false",h=(et.get(v)||0)+1,T=(a.get(v)||0)+1;et.set(v,h),a.set(v,T),i.push(v),h===1&&f&&ja.set(v,!0),T===1&&v.setAttribute(n,"true"),f||v.setAttribute(t,"true")}catch(k){console.error("aria-hidden: cannot operate on ",v,k)}})};return d(o),s.clear(),bs++,function(){i.forEach(function(p){var v=et.get(p)-1,z=a.get(p)-1;et.set(p,v),a.set(p,z),v||(ja.has(p)||p.removeAttribute(t),ja.delete(p)),z||p.removeAttribute(n)}),bs--,bs||(et=new WeakMap,et=new WeakMap,ja=new WeakMap,fa={})}},B1=function(e,o,n){n===void 0&&(n="data-aria-hidden");var t=Array.from(Array.isArray(e)?e:[e]),r=U1(e);return r?(t.push.apply(t,Array.from(r.querySelectorAll("[aria-live]"))),F1(t,r,n,"aria-hidden")):function(){return null}},Pu="Dialog",[lk,T4]=bf(Pu),[_1,To]=lk(Pu),dk=e=>{const{__scopeDialog:o,children:n,open:t,defaultOpen:r,onOpenChange:a,modal:i=!0}=e,s=l.useRef(null),c=l.useRef(null),[u=!1,d]=gf({prop:t,defaultProp:r,onChange:a});return j.jsx(_1,{scope:o,triggerRef:s,contentRef:c,contentId:us(),titleId:us(),descriptionId:us(),open:u,onOpenChange:d,onOpenToggle:l.useCallback(()=>d(p=>!p),[d]),modal:i,children:n})};dk.displayName=Pu;var pk="DialogTrigger",vk=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=To(pk,n),a=Si(o,r.triggerRef);return j.jsx(Zr.button,{type:"button","aria-haspopup":"dialog","aria-expanded":r.open,"aria-controls":r.contentId,"data-state":wu(r.open),...t,ref:a,onClick:hr(e.onClick,r.onOpenToggle)})});vk.displayName=pk;var xu="DialogPortal",[K1,mk]=lk(xu,{forceMount:void 0}),kk=e=>{const{__scopeDialog:o,forceMount:n,children:t,container:r}=e,a=To(xu,o);return j.jsx(K1,{scope:o,forceMount:n,children:l.Children.map(t,i=>j.jsx(wi,{present:n||a.open,children:j.jsx(ek,{asChild:!0,container:r,children:i})}))})};kk.displayName=xu;var ci="DialogOverlay",hk=l.forwardRef((e,o)=>{const n=mk(ci,e.__scopeDialog),{forceMount:t=n.forceMount,...r}=e,a=To(ci,e.__scopeDialog);return a.modal?j.jsx(wi,{present:t||a.open,children:j.jsx($1,{...r,ref:o})}):null});hk.displayName=ci;var $1=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=To(ci,n);return j.jsx(ck,{as:Hn,allowPinchZoom:!0,shards:[r.contentRef],children:j.jsx(Zr.div,{"data-state":wu(r.open),...t,ref:o,style:{pointerEvents:"auto",...t.style}})})}),Fn="DialogContent",bk=l.forwardRef((e,o)=>{const n=mk(Fn,e.__scopeDialog),{forceMount:t=n.forceMount,...r}=e,a=To(Fn,e.__scopeDialog);return j.jsx(wi,{present:t||a.open,children:a.modal?j.jsx(H1,{...r,ref:o}):j.jsx(X1,{...r,ref:o})})});bk.displayName=Fn;var H1=l.forwardRef((e,o)=>{const n=To(Fn,e.__scopeDialog),t=l.useRef(null),r=Si(o,n.contentRef,t);return l.useEffect(()=>{const a=t.current;if(a)return B1(a)},[]),j.jsx(yk,{...e,ref:r,trapFocus:n.open,disableOutsidePointerEvents:!0,onCloseAutoFocus:hr(e.onCloseAutoFocus,a=>{var i;a.preventDefault(),(i=n.triggerRef.current)==null||i.focus()}),onPointerDownOutside:hr(e.onPointerDownOutside,a=>{const i=a.detail.originalEvent,s=i.button===0&&i.ctrlKey===!0;(i.button===2||s)&&a.preventDefault()}),onFocusOutside:hr(e.onFocusOutside,a=>a.preventDefault())})}),X1=l.forwardRef((e,o)=>{const n=To(Fn,e.__scopeDialog),t=l.useRef(!1),r=l.useRef(!1);return j.jsx(yk,{...e,ref:o,trapFocus:!1,disableOutsidePointerEvents:!1,onCloseAutoFocus:a=>{var i,s;(i=e.onCloseAutoFocus)==null||i.call(e,a),a.defaultPrevented||(t.current||(s=n.triggerRef.current)==null||s.focus(),a.preventDefault()),t.current=!1,r.current=!1},onInteractOutside:a=>{var c,u;(c=e.onInteractOutside)==null||c.call(e,a),a.defaultPrevented||(t.current=!0,a.detail.originalEvent.type==="pointerdown"&&(r.current=!0));const i=a.target;((u=n.triggerRef.current)==null?void 0:u.contains(i))&&a.preventDefault(),a.detail.originalEvent.type==="focusin"&&r.current&&a.preventDefault()}})}),yk=l.forwardRef((e,o)=>{const{__scopeDialog:n,trapFocus:t,onOpenAutoFocus:r,onCloseAutoFocus:a,...i}=e,s=To(Fn,n),c=l.useRef(null),u=Si(o,c);return o1(),j.jsxs(j.Fragment,{children:[j.jsx(Ym,{asChild:!0,loop:!0,trapped:t,onMountAutoFocus:r,onUnmountAutoFocus:a,children:j.jsx(Jm,{role:"dialog",id:s.contentId,"aria-describedby":s.descriptionId,"aria-labelledby":s.titleId,"data-state":wu(s.open),...i,ref:u,onDismiss:()=>s.onOpenChange(!1)})}),j.jsxs(j.Fragment,{children:[j.jsx(Z1,{titleId:s.titleId}),j.jsx(G1,{contentRef:c,descriptionId:s.descriptionId})]})]})}),Su="DialogTitle",zk=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=To(Su,n);return j.jsx(Zr.h2,{id:r.titleId,...t,ref:o})});zk.displayName=Su;var jk="DialogDescription",fk=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=To(jk,n);return j.jsx(Zr.p,{id:r.descriptionId,...t,ref:o})});fk.displayName=jk;var gk="DialogClose",Tk=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=To(gk,n);return j.jsx(Zr.button,{type:"button",...t,ref:o,onClick:hr(e.onClick,()=>r.onOpenChange(!1))})});Tk.displayName=gk;function wu(e){return e?"open":"closed"}var Nk="DialogTitleWarning",[N4,Pk]=hf(Nk,{contentName:Fn,titleName:Su,docsSlug:"dialog"}),Z1=({titleId:e})=>{const o=Pk(Nk),n=`\`${o.contentName}\` requires a \`${o.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${o.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${o.docsSlug}`;return l.useEffect(()=>{e&&(document.getElementById(e)||console.error(n))},[n,e]),null},W1="DialogDescriptionWarning",G1=({contentRef:e,descriptionId:o})=>{const t=`Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${Pk(W1).contentName}}.`;return l.useEffect(()=>{var a;const r=(a=e.current)==null?void 0:a.getAttribute("aria-describedby");o&&r&&(document.getElementById(o)||console.warn(t))},[t,e,o]),null},J1=dk,Q1=vk,Y1=kk,xk=hk,Sk=bk,wk=zk,Ck=fk,q1=Tk;const Mk=J1,Ik=Q1,e4=Y1,Ak=l.forwardRef(({className:e,...o},n)=>j.jsx(xk,{ref:n,className:Ao("fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",e),...o}));Ak.displayName=xk.displayName;const Cu=l.forwardRef(({className:e,children:o,...n},t)=>j.jsxs(e4,{children:[j.jsx(Ak,{}),j.jsxs(Sk,{ref:t,className:Ao("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",e),...n,children:[o,j.jsxs(q1,{className:"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",children:[j.jsx(bm,{className:"h-4 w-4"}),j.jsx("span",{className:"sr-only",children:"Close"})]})]})]}));Cu.displayName=Sk.displayName;const Mu=({className:e,...o})=>j.jsx("div",{className:Ao("flex flex-col space-y-1.5 text-center sm:text-left",e),...o});Mu.displayName="DialogHeader";const Vk=({className:e,...o})=>j.jsx("div",{className:Ao("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",e),...o});Vk.displayName="DialogFooter";const Iu=l.forwardRef(({className:e,...o},n)=>j.jsx(wk,{ref:n,className:Ao("text-lg font-semibold leading-none tracking-tight",e),...o}));Iu.displayName=wk.displayName;const Au=l.forwardRef(({className:e,...o},n)=>j.jsx(Ck,{ref:n,className:Ao("text-sm text-muted-foreground",e),...o}));Au.displayName=Ck.displayName;const Bn=[{uuid:"95bb68e1-4510-4a5e-9c7f-ae982661c1f8",sectionNumber:"B",sectionTitle:"Základní pojmy a definice",statements:[{uuid:"956b03dc-986f-4604-87e2-0e987af3b4ca",correct:"Abstrakce v operačních systémech umožňuje stavět rozsáhlé systémy skrytím implementačních detailů.",incorrect:"Abstrakce v operačních systémech vyžaduje znalost všech implementačních detailů pro stavbu rozsáhlých systémů.",sectionNumber:"0.1.1",sectionTitle:"Co je abstrakce?"},{uuid:"37a4399d-c091-49ac-b34d-e77743e8063f",correct:"Pro abstrakci je klíčové znát vnější chování systému, zatímco vnitřní struktura může zůstat skryta.",incorrect:"Pro abstrakci je klíčové znát vnější i vnitřní chování a strukturu systému detailně.",sectionNumber:"0.1.1",sectionTitle:"Co je abstrakce?"},{uuid:"77fe023f-570c-42ff-ba5b-767ff80f6d9e",correct:"Modul je základní jednotkou abstrakce v software, oddělující rozhraní od implementace.",incorrect:"Modul je základní jednotkou implementace v software, oddělující rozhraní od abstrakce.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"cfbba433-a623-453a-ae1b-c741b89c8624",correct:"Modularita systému umožňuje výměnu modulu za jiný se stejným vnějším chováním.",incorrect:"Modularita systému vyžaduje výměnu modulu za jiný s odlišným vnějším chováním.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"0830ecab-2480-48a9-a67d-671b90118e43",correct:'Abstrakce modulu "propouští", když se vnitřní detaily projevují navenek.',incorrect:'Abstrakce modulu nikdy "nepropouští" a vnitřní detaily se nikdy neprojevují navenek.',sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"3159fe5a-c613-4266-882a-2da2e556e1b1",correct:"Při porušení modularity, výměna modulu vyžaduje úpravu dalších modulů.",incorrect:"Při porušení modularity, výměna modulu nevyžaduje úpravu žádných dalších modulů.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"8654feed-9fd7-4dda-a2e6-b8ba91383288",correct:"Von Neumannova architektura popisuje počítač s jednotným vnějším chováním, nezávisle na výrobci komponent.",incorrect:"Von Neumannova architektura popisuje počítač s proměnlivým vnějším chováním, v závislosti na výrobci komponent.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"c3f5999d-680c-40af-90f2-3797059264ca",correct:"Výpočetní jednotka, procesor, vykonává instrukce, které jsou uloženy v operační paměti.",incorrect:"Výpočetní jednotka, procesor, vykonává instrukce, které jsou uloženy ve vyrovnávací paměti.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"3d9c7d51-626a-4d7a-b59b-c65e7f3c612b",correct:"Operační paměť ve von Neumannově architektuře je adresovatelná a skládá se z očíslovaných buněk.",incorrect:"Operační paměť ve von Neumannově architektuře není adresovatelná a skládá se z neuspořádaných buněk.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"60b2b654-199f-4312-9fac-66650001c2bf",correct:"Každá buňka v operační paměti von Neumannovy architektury typicky uchovává jeden byte dat.",incorrect:"Každá buňka v operační paměti von Neumannovy architektury typicky uchovává jeden bit dat.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"f13f9d46-c538-4be8-a1e9-96ea6fd70101",correct:"Instrukce mohou vyžádat načtení dat z libovolně vypočtené adresy, což odlišuje paměť od registrů.",incorrect:"Instrukce mohou vyžádat načtení dat pouze z pevných adres, což odlišuje paměť od registrů.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"f28299a6-fe2b-4ac8-91e3-7908ce8401ab",correct:"Registry se odlišují od operační paměti tím, že mají pevná jména, nikoliv adresy.",incorrect:"Registry se odlišují od operační paměti tím, že mají proměnlivá jména, podobně jako proměnné.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"6fa471c7-9988-4462-ac21-b4b859df57e4",correct:"Pro zjednodušení se v kontextu von Neumannova modelu program považuje za neměnný.",incorrect:"Pro zjednodušení se v kontextu von Neumannova modelu program považuje za dynamicky modifikovatelný.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"60f28404-7d12-44e4-92d8-74b541e9bb54",correct:"Periferie slouží k příjmu a odesílání dat, která jsou reprezentována jako sekvence čísel.",incorrect:"Periferie slouží pouze k odesílání dat, která jsou reprezentována jako slova.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"c4769bbe-9361-4208-b250-01db23e1dcc8",correct:"Data pro periferie jsou výsledkem výpočtu, zatímco data z periferií jsou vstupem pro výpočet.",incorrect:"Data pro periferie i data z periferií jsou vždy výsledkem výpočtu.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"9ac086be-94e3-4388-a8ad-577f28b221df",correct:"Veškerá činnost programu sestává z manipulace s čísly, což je v podstatě výpočet.",incorrect:"Některé činnosti programu, jako kreslení obrázků, nejsou považovány za výpočet.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"1fff4f0d-0d58-4229-adc8-eed82f9084d8",correct:"Program je abstrakce, která popisuje sekvenci instrukcí pro výpočet a zahrnuje synchronizaci s periferiemi.",incorrect:"Program je abstrakce, která popisuje pouze sekvenci instrukcí pro výpočet a nezahrnuje synchronizaci s periferiemi.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"1d2f23cb-6eb0-44bb-8c13-815408e9c4a1",correct:"Operační systém a hardware společně realizují virtualizaci výpočetních zdrojů.",incorrect:"Pouze operační systém realizuje virtualizaci výpočetních zdrojů, hardware se na ní nepodílí.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"05ade31c-019c-4b8a-af17-a43c66daef0e",correct:"Virtualizace umožňuje, aby programy pracovaly, jako kdyby měly svůj vlastní počítač.",incorrect:"Virtualizace nutí programy pracovat sdíleně na jednom virtuálním počítači.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"e7c03c66-95f3-4390-99fd-b96910cdbdc5",correct:"Úkolem virtualizace je vytvořit několik nezávislých virtuálních kopií jednoho fyzického zařízení.",incorrect:"Úkolem virtualizace je sdílet jeden fyzický počítač mezi více programy.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"b9352630-77b0-426e-96b2-5a202eb711fd",correct:"Události, které nejsou uspořádané relací předcházení, jsou považovány za souběžné.",incorrect:"Události, které jsou uspořádané relací předcházení, jsou považovány za souběžné.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"7e0c57b2-30df-44b8-a71d-4e1448122dcc",correct:"Relace předcházení definuje chronologické uspořádání událostí, popisující, která událost nastala dříve.",incorrect:"Relace předcházení definuje časové trvání událostí, popisující, jak dlouho událost trvala.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"c27c6d93-86fd-4596-b298-16876e925ccd",correct:"Pokud událost A nepředchází událost B a událost B nepředchází událost A, pak jsou události A a B souběžné.",incorrect:"Pokud událost A předchází událost B a událost B předchází událost A, pak jsou události A a B souběžné.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"db1f5212-6c38-4248-8138-bb34ba7f012e",correct:"V množině událostí U = {A, B, X, Y} s relací předcházení P = {(A, X), (X, B), (A, Y), (Y, B)} jsou události X a Y souběžné.",incorrect:"V množině událostí U = {A, B, X, Y} s relací předcházení P = {(A, X), (X, B), (A, Y), (Y, B)} jsou události X a B souběžné.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"6d75d5f7-9b29-48ba-9275-88c7bf095176",correct:"Vnější chování modulu v operačním systému závisí na relaci předcházení událostí, nikoliv na přesném časování.",incorrect:"Vnější chování modulu v operačním systému závisí na přesném časovém rozložení jednotlivých událostí.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"4ae0eb2a-aaab-43ff-92b3-c6f42eaf93e9",correct:"Časový sled událostí představuje lineární uspořádání událostí, kde pro každou dvojici událostí platí, že jedna předchází druhou.",incorrect:"Časový sled událostí představuje nelineární uspořádání událostí, kde pro každou dvojici událostí platí, že jedna předchází druhou.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"d3d5ef7b-6259-4c59-898f-8fdb8d696774",correct:"Časový sled událostí lze chápat jako přidělení časových razítek událostem tak, že žádné dvě události nenastanou ve stejný okamžik.",incorrect:"Časový sled událostí nelze chápat jako přidělení časových razítek událostem tak, že žádné dvě události nenastanou ve stejný okamžik.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"c066cb52-2599-48b5-af79-85a29d67635b",correct:"Hazard souběhu nastává, pokud se vnější chování systému liší v různých časových sledech, které jsou konzistentní s relací předcházení.",incorrect:"Hazard souběhu nastává, pokud se vnější chování systému neliší v různých časových sledech, které jsou konzistentní s relací předcházení.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"e6008e07-13e8-4c7f-bb0b-967007da14c0",correct:"Pojem hazard souběhu označuje situaci, kdy různé platné časové sledy, kompatibilní s relací předcházení, vedou k rozdílným výsledkům.",incorrect:"Pojem hazard souběhu označuje situaci, kdy různé platné časové sledy, nekompatibilní s relací předcházení, vedou k rozdílným výsledkům.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"c8a07608-6c2a-4f8b-aaab-32ef78e69205",correct:"Operační systém zprostředkovává aplikacím přístup k hardwarovým i softwarovým zdrojům počítače.",incorrect:"Operační systém zprostředkovává aplikacím přístup pouze k hardwarovým zdrojům a nikoliv softwarovým.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"33d55748-603d-4e55-b7a6-7ba2cf21ad3d",correct:"Víceúlohový operační systém umožňuje současný běh několika uživatelských programů na jednom počítači.",incorrect:"Víceúlohový operační systém neumožňuje běh více uživatelských programů současně.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"851fabb5-edcf-4c44-8aa8-faf9370ae7be",correct:"Operační systém poskytuje izolaci běžících programů, aby se vzájemně nemohly narušovat.",incorrect:"Operační systém nezajišťuje izolaci běžících programů, které se tak mohou vzájemně ovlivňovat.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"c4e249b9-36e7-4088-b46c-a9f6bee2d297",correct:"POSIX je standardizované rozhraní pro víceúlohové a víceuživatelské operační systémy.",incorrect:"POSIX je standardizované rozhraní pouze pro jednoúlohové operační systémy.",sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"3ccd5b03-2624-4791-a9f3-f73821e02849",correct:"Standard POSIX popisuje aplikační programovací rozhraní (API) v jazyce C.",incorrect:"Standard POSIX popisuje aplikační programovací rozhraní (API) v jazyce Java.",sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"66b2e7db-1746-4cfe-93d6-612712a4c451",correct:"Standardizaci POSIX provedla organizace The Open Group.",incorrect:"Standardizaci POSIX provedla organizace IEEE.",sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"6552e5a9-3169-41e2-a911-1deb06fe4dc7",correct:"Běžný návrh operačního systému se skládá z jádra a uživatelského prostoru.",incorrect:"Běžný návrh operačního systému se skládá pouze z uživatelského prostoru.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"39953053-12c9-4aad-af09-fab92fb94039",correct:"Jádro operačního systému má privilegovaný přístup k hardwarovým zdrojům, zejména k procesoru.",incorrect:"Uživatelský prostor operačního systému má privilegovaný přístup k hardwarovým zdrojům.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"7e6cd78d-60ab-450f-8727-e750df78cdd0",correct:"Jádro operačního systému řídí virtualizaci zdrojů, jako je přidělování paměti a procesoru.",incorrect:"Uživatelské programy řídí virtualizaci hardwarových zdrojů operačního systému.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"bf056675-3f43-4e39-a5e5-349738830de6",correct:"Jádro operačního systému funguje jako strážce integrity systému tím, že kontroluje přístup uživatelských procesů.",incorrect:"Uživatelské procesy fungují jako strážce integrity systému, nezávisle na jádru operačního systému.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"5526b55a-8efa-425a-84fa-2d0e171fa3c3",correct:"Operační systémy bez jádra jsou v současnosti považovány za vzácné a okrajové v kontextu výuky.",incorrect:"Operační systémy bez jádra jsou v současnosti běžnější než systémy s jádrem v praxi.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"494270d5-bc91-4dcc-8804-e4d22353ddf7",correct:"Virtualizace operačního systému umožňuje provozovat více instancí operačního systému na jednom fyzickém počítači.",incorrect:"Virtualizace operačního systému omezuje provozování více instancí operačního systému na jednom fyzickém počítači.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"139c34b4-1d34-4516-a0b3-0e356ffd0c2b",correct:"Virtualizace operačního systému poskytuje silnější izolaci mezi úlohami než standardní procesy sdílející stejný operační systém.",incorrect:"Virtualizace operačního systému poskytuje slabší izolaci mezi úlohami než standardní procesy sdílející stejný operační systém.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"6be3ed3b-23d2-4ac4-ade3-52306ed0da4e",correct:"Jedním z hlavních důvodů virtualizace operačních systémů je zjednodušení správy a organizace počítačových systémů.",incorrect:"Zjednodušení správy a organizace počítačových systémů není považováno za důvod pro virtualizaci operačních systémů.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"b08b50d2-3cc4-43de-a856-b9692c6510f8",correct:"Díky virtualizaci operačních systémů je možná migrace, včetně živé migrace běžícího operačního systému na jiný hardware.",incorrect:"Virtualizace operačních systémů neumožňuje migraci, ani živou migraci běžícího operačního systému na jiný hardware.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"1d79d84b-bde6-46d2-8e73-2f77dcf2f95f",correct:"Abstrakce hardwaru a modularita systému usnadňují přenos operačního systému na jiný hardware.",incorrect:"Abstrakce hardwaru nemá vliv na přenositelnost operačního systému mezi různými hardwarovými platformami.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"},{uuid:"46693132-5d2c-4f32-b427-80711045abe5",correct:"Pro aplikační software operační systém vytváří abstrakční rozhraní, které podporuje jeho přenositelnost mezi systémy.",incorrect:"Aplikační software je přenositelný mezi operačními systémy i bez abstrakčního rozhraní poskytovaného operačním systémem.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"},{uuid:"05f269b4-2e2a-4685-9129-d6f4db80bbb7",correct:"Přenositelnost aplikačního software je omezena využitím vlastností specifických pro daný operační systém.",incorrect:"Přenositelnost aplikačního software mezi operačními systémy není ovlivněna využitím specifických vlastností operačního systému.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"}]},{uuid:"73c45141-9794-451f-b11d-8b36598420f5",sectionNumber:"1",sectionTitle:"Virtualizace paměti",statements:[{uuid:"41a737a1-037a-4d2d-af1e-1942f509bacc",correct:"Program interaguje s pamětí použitím instrukcí ld a st.",incorrect:"Program interaguje s pamětí výhradně instrukcí ld.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"4a56642c-8857-4e72-9bb9-259a1a1d0026",correct:"Instrukce ld načítá data z paměti určené adresou v registru do cílového registru.",incorrect:"Instrukce ld načítá data přímo z registru do paměti.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"a07ff963-d10b-4c83-b6e4-8d958df65ebc",correct:"Adresa paměti pro instrukce ld a st je číselná hodnota uložená v registru.",incorrect:"Adresa paměti pro ld a st je symbolický název.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"c4486a58-4f7f-406b-99fe-7db5a0c18d24",correct:"Složitější instrukce procesoru lze vždy rozdělit na sekvenci instrukcí ld, výpočetních a st.",incorrect:"Některé instrukce procesoru nelze rozdělit na ld, výpočetní a st instrukce.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"66a204ef-d78a-4fa2-a49c-c690678723f3",correct:"Adresní prostor se obvykle skládá ze souvislých bloků adres.",incorrect:"Adresní prostor se nikdy neskládá ze souvislých bloků adres.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"4fa8af70-62f9-4b50-a42e-30dfb0c39f3c",correct:"Každá adresa v typickém adresním prostoru odpovídá právě jednomu bajtu dat.",incorrect:"Každá adresa v typickém adresním prostoru odpovídá právě dvěma bajtům dat.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"49abd2d1-f845-4bf4-8b07-54e802d02562",correct:"Ne každé číslo reprezentuje platnou adresu v adresním prostoru.",incorrect:"Každé číslo reprezentuje platnou adresu v adresním prostoru.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"4206b23d-4857-48cf-813f-c2f1873f1b0d",correct:"Pro uložení většího objektu je potřeba několik sousedních adres.",incorrect:"Pro uložení většího objektu stačí pouze jedna adresa.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"54ff93f4-777b-42f6-afb5-a1afb45c568f",correct:"Adresa 0x010030 je platná adresa v uvedeném příkladu adresního prostoru.",incorrect:"Adresa 0x000050 je platná adresa v uvedeném příkladu adresního prostoru.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"a6ac0fed-cbe3-4d7b-a86e-e8d0985a120c",correct:"Čtyřbajtové slovo lze uložit na adresu 0x010030 v uvedeném adresním prostoru.",incorrect:"Čtyřbajtové slovo nelze uložit na adresu 0x01fffd v uvedeném adresním prostoru.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"20aeff10-b2a4-4814-af7f-f25d2e3b712b",correct:"Adresní prostor programu obvykle zahrnuje sekce pro kód, data a zásobník.",incorrect:"Adresní prostor programu obvykle zahrnuje pouze sekce pro kód a dočasná data.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"5aea504c-dc94-4797-9abe-f6a213b4c369",correct:"Zásobník v adresním prostoru slouží k ukládání informací o aktivních podprogramech.",incorrect:"Zásobník v adresním prostoru slouží výhradně k ukládání statických dat programu.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"19778e88-1ecc-4bc1-8830-39495fc00a05",correct:"Adresní prostor procesu může být dynamický a umožňovat změny velikosti za běhu programu.",incorrect:"Adresní prostor procesu je statický a jeho velikost je pevně daná při spuštění programu.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"6bd80b68-f1d5-4533-b619-8649c0474161",correct:"Fyzické adresy přímo pojmenovávají fyzické paměťové buňky hardwarových zařízení, zejména RAM.",incorrect:"Fyzické adresy nepřímo pojmenovávají logické paměťové buňky softwarových zařízení, zejména ROM.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"4da1da6b-98a2-4ad0-8ba3-2d5bc8b4d9c7",correct:"Většina fyzických adres v typickém počítači odpovídá buňkám operační paměti RAM.",incorrect:"Většina fyzických adres v typickém počítači odpovídá buňkám permanentní paměti ROM.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"4be1a9b2-7b44-4e84-9d11-22d703e2a0c8",correct:"Některé fyzické adresy mohou patřit periferiím, jako jsou grafické nebo síťové karty.",incorrect:"Fyzické adresy mohou patřit pouze operační paměti RAM, nikdy ne periferiím.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"88b8cbaa-19a8-418c-8f4e-4e054a0d4b00",correct:"Bloky fyzických adres, které nepatří RAM, obvykle nelze používat pro pracovní data výpočtů.",incorrect:"Bloky fyzických adres, které nepatří RAM, se běžně používají pro ukládání pracovních dat programů.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"9fec3f7f-b9dc-4a10-9629-cb9913f6053c",correct:"Operační paměť RAM slouží především k ukládání pracovních dat programů v klasickém smyslu.",incorrect:"Operační paměť RAM slouží především k ukládání instrukcí operačního systému a metadat.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"773d5293-ba31-44ae-a86f-c34b6bf61b5d",correct:"V principu je možné, aby programy pracovaly s pamětí přímo s fyzickými adresami.",incorrect:"V principu není možné, aby programy pracovaly s pamětí přímo s fyzickými adresami.",sectionNumber:"1.2.1",sectionTitle:"Motivace"},{uuid:"e63741d3-9e6a-4a25-9f11-d277cca08119",correct:"Spuštění více programů současně vyžaduje koordinaci fyzických adres kvůli potenciálním konfliktům.",incorrect:"Spuštění více programů současně nevyžaduje koordinaci fyzických adres a nezpůsobuje konflikty.",sectionNumber:"1.2.1",sectionTitle:"Motivace"},{uuid:"42efd9d1-f816-441c-b905-2c80979f21a9",correct:"Virtuální adresní prostory jsou pro programy odděleny od fyzických adresních prostorů.",incorrect:"Virtuální adresní prostory jsou pro programy totožné s fyzickými adresními prostory.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"078a1566-857b-46b3-9667-ed7551481807",correct:"Fyzický adresní prostor je pro běžné uživatelské programy zcela nepřístupný.",incorrect:"Fyzický adresní prostor je pro běžné uživatelské programy plně přístupný.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"e2ea115c-9cab-4775-a0f3-14fc07a326b1",correct:"Virtuálních adresních prostorů může existovat v počítači rovnou několik.",incorrect:"V počítači existuje vždy pouze jeden virtuální adresní prostor.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"f527fbaf-81b6-4603-b88e-0017de944e30",correct:"Adresa 0x0100 ve dvou různých virtuálních prostorech jsou považovány za různé virtuální adresy.",incorrect:"Adresa 0x0100 ve dvou různých virtuálních prostorech jsou považovány za stejné virtuální adresy.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"a6dcc6b9-8eb8-480e-8301-82b0743c789b",correct:"Fyzická buňka má právě jednu fyzickou adresu, ale může mít více virtuálních adres.",incorrect:"Fyzická buňka má vždy právě jednu fyzickou adresu a může mít pouze jednu virtuální adresu.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"2bfe562b-10db-460a-9e00-1f0df26920e6",correct:"Virtuální adresní prostory umožňují oddělit programy tak, aby nesdílely stejné fyzické buňky.",incorrect:"Virtuální adresní prostory jsou primárně určeny pro zvýšení rychlosti přístupu k fyzické paměti.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"dfe6d25a-e941-41e7-a5bd-7d0685ab539d",correct:"Jedna fyzická paměťová buňka může být mapována do více virtuálních adres v různých adresních prostorech.",incorrect:"Jedna fyzická paměťová buňka může být mapována pouze do jedné virtuální adresy, a to bez ohledu na adresní prostor.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"3a59bc28-b760-4cab-a6cc-e5a567546e0c",correct:"Překlad adres musí být rychlý a je realizován specializovaným hardwarem v CPU.",incorrect:"Překlad adres může být pomalý a je realizován softwarem v operačním systému.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"6605fcc6-4ac1-43fa-9a41-a3ebd375f993",correct:"Jednotka správy paměti je programovatelná překladovými tabulkami a řízena jádrem OS.",incorrect:"Jednotka správy paměti není programovatelná a není řízena jádrem OS.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"b26d5a92-5fd1-4f8a-aeb0-1340cf25bb58",correct:"Virtuální adresa musí být přeložena na fyzickou adresu před přístupem do paměti.",incorrect:"Fyzická adresa musí být přeložena na virtuální adresu před přístupem do paměti.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"cb01b040-f7f8-48b0-8727-12149c5024db",correct:"Stránky virtuální paměti představují bloky virtuálních adres o pevné velikosti.",incorrect:"Stránky virtuální paměti představují bloky virtuálních adres s proměnlivou velikostí.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"0fe00cda-ec91-48a0-a88d-4b40fb9a1b3e",correct:"Velikost stránky virtuální paměti je typicky mocninou dvou.",incorrect:"Velikost stránky virtuální paměti nemusí být mocninou dvou.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"474c0854-471e-4d4c-811d-e1ac3ee7b74b",correct:"V rámci stránkování se spodních n bitů virtuální adresy mapuje přímo na fyzickou adresu.",incorrect:"V rámci stránkování se spodních n bitů virtuální adresy nikdy nemapuje přímo na fyzickou adresu.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"ff0d6143-b8e6-4f81-90f5-04a3fda55fb9",correct:"Použitím stránek se dosahuje zmenšení velikosti překladových tabulek oproti mapování každé adresy.",incorrect:"Použitím stránek se velikost překladových tabulek nemění oproti mapování každé adresy.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"9e80d110-408a-4a6a-a27e-0e13da4c8752",correct:"Počáteční adresa každé stránky virtuální paměti je vždy dělitelná velikostí stránky.",incorrect:"Počáteční adresa každé stránky virtuální paměti nemusí být dělitelná velikostí stránky.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"e41373bf-f5f2-41a2-ad81-d9414ab744ea",correct:"Stránkové tabulky jsou uloženy v operační paměti RAM a slouží k překladu virtuálních adres na fyzické.",incorrect:"Stránkové tabulky jsou uloženy v cache procesoru a slouží k urychlení výpočtů.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"47b93a5d-7177-47bb-9243-78a47fc31a17",correct:"Pro velké adresní prostory se používají víceúrovňové překladové tabulky z důvodu efektivity paměti.",incorrect:"Pro velké adresní prostory se používají jednoúrovňové překladové tabulky z důvodu rychlosti.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"576b8be0-dd3c-485d-924e-062d444cc4f1",correct:"Řídká stránková tabulka efektivně šetří paměť, protože nemusí mapovat všechny virtuální adresy.",incorrect:"Řídká stránková tabulka plýtvá pamětí, protože musí mapovat všechny virtuální adresy.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"1c347f2b-6bbd-4712-8f3f-db018aafdca7",correct:"Segment virtuální adresy se používá jako index pro výběr řádku v příslušné úrovni překladové tabulky.",incorrect:"Segment virtuální adresy se přímo používá jako offset v operační paměti pro přístup k datům.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"e7d2fc3e-eb15-4e95-b716-970aa2b74f8d",correct:"TLB (Translation Lookaside Buffer) je rychlá asociativní paměť pro ukládání nedávno přeložených adres.",incorrect:"TLB (Translation Lookaside Buffer) je pomalá sekvenční paměť pro ukládání všech přeložených adres.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"adadedc0-57ca-445a-8094-a3fb5958488a",correct:"Formálněji proces označuje virtuální adresní prostor, který obsahuje kód programu a pracovní data.",incorrect:"Formálněji proces označuje pouze kód programu, ale neobsahuje pracovní data.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"013040dd-ccaf-42f7-abd5-caf342b279b4",correct:"Operační systém vede záznam o každém procesu a proces může vlastnit různé systémové zdroje.",incorrect:"Operační systém nevede záznam o procesech a proces nemůže vlastnit žádné systémové zdroje.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"09a970d1-60e4-4f60-acaa-6bc76adfba31",correct:"K jednomu procesu se může vázat libovolný počet vláken, což umožňuje paralelní provádění úloh.",incorrect:"K jednomu procesu se může vázat maximálně jedno vlákno, čímž se omezuje paralelismus.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"2f281585-014a-48ae-995b-f19e81f359c9",correct:"V abstrakci počítače proces odpovídá virtuální operační paměti, zatímco vlákno výpočetní jednotce.",incorrect:"V abstrakci počítače proces odpovídá virtuální výpočetní jednotce, a vlákno operační paměti.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"007e8a81-eb5c-45e9-baf5-8f67f1634a09",correct:"Adresní prostory procesů jsou v operačním systému převážně oddělené.",incorrect:"Adresní prostory procesů jsou v operačním systému vždy plně sdílené.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"7548e6e6-549a-421b-9777-bf5ab92fcc50",correct:"Standardně procesy nemají přímý přístup k paměti jiných procesů.",incorrect:"Standardně procesy mají plný přístup k paměti všech procesů v systému.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"9e8f7ef3-7ff3-4aaf-ad46-fc353e9004f6",correct:"Operační systémy umožňují sdílení kódu mezi procesy pouze pro čtení.",incorrect:"Operační systémy běžně sdílejí kód mezi procesy s plným přístupem pro zápis.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"475238a6-5280-4003-beb2-af2a0d08d18b",correct:"Sdílená paměť s možností zápisu slouží jako komunikační mechanismus procesů.",incorrect:"Sdílená paměť s zápisem slouží k izolaci procesů a omezení komunikace.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"d5190114-b6fc-464c-83b9-e87a0348c7f2",correct:"Virtuální adresy sdílené paměti nemusí být v různých procesech nutně stejné.",incorrect:"Virtuální adresy sdílené paměti musí být vždy identické ve všech procesech.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"f96e23dd-2c3b-46d1-9347-17acdc23c32c",correct:"Fyzická adresa stránkovací tabulky první úrovně je uložena v registru procesoru.",incorrect:"Virtuální adresa stránkovací tabulky první úrovně je uložena v registru procesoru.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"e4a1debc-8f3a-46a5-8021-2dfdbe1d39b2",correct:"Nastavení adresy stránkovací tabulky první úrovně je privilegovaná instrukce.",incorrect:"Nastavení adresy stránkovací tabulky první úrovně může provést i běžný program.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"48a6f3d5-7a48-438e-a6bb-e1f9883f5888",correct:"Přepnutí procesu zahrnuje změnu aktivní stránkovací tabulky.",incorrect:"Přepnutí procesu nezahrnuje změnu aktivní stránkovací tabulky.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"78ffd594-2980-457b-8727-384c1f02a3aa",correct:"Přepnutí vlákna souvisí s výměnou hodnot výpočetních registrů.",incorrect:"Přepnutí procesu souvisí s výměnou hodnot výpočetních registrů.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"7c5e270d-7d56-4fda-89b5-1489c25624ce",correct:"Virtuální výpočetní jednotku představuje vlákno, nikoliv proces.",incorrect:"Virtuální výpočetní jednotku představuje proces, nikoliv vlákno.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"6883baf5-1be4-48c3-b097-4ce501a5daab",correct:"Proces se vytváří duplikací, v POSIX systémech operací fork.",incorrect:"Proces se vytváří klonováním, v POSIX systémech operací clone.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"17fdd2da-3715-4421-bcfe-1f3dbc49f033",correct:"Copy-on-write duplikuje adresní prostor, ale fyzická data sdílí do prvního zápisu.",incorrect:"Copy-on-write duplikuje adresní prostor i fyzická data okamžitě při fork.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"2853ca5d-7eab-4fe3-81b9-46a6b2862856",correct:"Stránky v copy-on-write jsou zpočátku jen pro čtení a kopírují se až při pokusu o zápis.",incorrect:"Stránky v copy-on-write jsou zpočátku pro čtení i zápis a kopírují se ihned.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"51e3e18a-dfd3-4681-92ab-e489e38904c7",correct:"Mechanismus copy-on-write vytváří iluzi oddělených adresních prostorů procesů.",incorrect:"Mechanismus copy-on-write vytváří skutečně oddělené adresní prostory procesů od začátku.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"8aafc3d6-e42b-452f-a810-86a276669a25",correct:"Operace fork s copy-on-write je obvykle rychlejší než plná kopie paměti procesu.",incorrect:"Operace fork s copy-on-write je vždy pomalejší než plná kopie paměti procesu.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"bbd990d9-a4bc-43a7-a13b-94f544cee0fe",correct:"Při zápisu do copy-on-write stránky vyvolá proces výjimku ochrany paměti.",incorrect:"Při zápisu do copy-on-write stránky se data rovnou zapíší bez výjimky.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"9aceae88-dfa7-4ffa-8c33-a43c0e8b3e87",correct:"Neplatná virtuální adresa způsobí výjimku, kterou následně řeší jádro operačního systému.",incorrect:"Neplatná virtuální adresa nezpůsobí výjimku a jádro operačního systému ji neřeší.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"c996603f-0eba-42e6-8995-12d646a96a83",correct:"Při pokusu o zápis na virtuální adresu s příznakem „jen pro čtení“ dojde k výjimce ochrany paměti.",incorrect:"Při pokusu o zápis na virtuální adresu s příznakem „jen pro čtení“ nedojde k výjimce ochrany paměti.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"83deb08b-9934-48a0-8f1a-8f3da8223a79",correct:"Operační systém může využít prázdný řádek stránkovací tabulky pro vlastní potřeby.",incorrect:"Operační systém nemůže využít prázdný řádek stránkovací tabulky pro vlastní potřeby.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"321b1e7e-af6f-49f9-9225-21b25ea3e90d",correct:"Operační systém může přesunout stránky z operační paměti na externí úložiště.",incorrect:"Operační systém nemůže přesunout stránky z operační paměti na externí úložiště.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"edb9545f-e78e-415e-b10f-09f4ca9f43cf",correct:"V stránkové tabulce operační systém označí adresu za neplatnou, když je stránka přesunuta z RAM.",incorrect:"V stránkové tabulce operační systém vymaže adresu, když je stránka přesunuta z RAM.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"803f0b7b-edf9-4b1e-9f49-b1e994dc9aca",correct:"Virtuální paměť umožňuje přidělit programům více paměti, než je fyzicky dostupné v operační paměti.",incorrect:"Virtuální paměť omezuje přidělení paměti programům na množství fyzické operační paměti.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"2cc9393f-bf10-47ba-b12a-90c13b096295",correct:"Přístup ke stránkám na externím úložišti je pomalejší než přístup ke stránkám v operační paměti.",incorrect:"Přístup ke stránkám na externím úložišti je rychlejší než přístup ke stránkám v operační paměti.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"03c10304-71f9-463c-a81a-2ccc45a47268",correct:"Stránka označuje rozsah virtuálních adres.",incorrect:"Stránka označuje rozsah fyzických adres.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"afbbc4b3-b0e2-47ff-acfd-276096de01f7",correct:"Rámec označuje rozsah fyzických adres.",incorrect:"Rámec označuje rozsah virtuálních adres.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"10e87cbd-1603-40cd-aec1-24019ed5c44c",correct:"Stránka je uložena v rámci.",incorrect:"Rámec je uložen ve stránce.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"50568d08-cfce-4808-b697-2fbda578a144",correct:"Líné načítání spustitelného souboru využívá stránkovací tabulky k načítání stránek z disku dle potřeby.",incorrect:"Líné načítání spustitelného souboru nevyužívá stránkovací tabulky a načítá celý soubor najednou.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"7d2688f5-fff5-4723-81ef-46de239a0aa7",correct:"Při líném načítání spustitelného souboru není nutné nahrávat ihned celý obsah souboru do operační paměti.",incorrect:"Při líném načítání spustitelného souboru je nezbytné nahrát kompletní obsah souboru do operační paměti před spuštěním.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"05831b3b-77ec-4ecf-9aea-8da1f2e168b1",correct:"Mechanismus líného načítání je podobný externímu stránkování, avšak odpadá nutnost hledat oběť pro výměnu stránek.",incorrect:"Mechanismus líného načítání se zásadně liší od externího stránkování a vyžaduje složitější algoritmy pro výběr oběti.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"983fc2b0-28a7-416a-9f38-2c54bc0672c6",correct:"Líné načítání lze efektivně kombinovat s klasickým externím stránkováním pro optimalizaci správy operační paměti.",incorrect:"Líné načítání a klasické externí stránkování jsou neslučitelné metody a nemohou být kombinovány.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"7d49eaed-f598-4e50-88a1-8587bf0a408b",correct:"Mapování datových souborů do paměti je nejdůležitější využití externího stránkování v praxi.",incorrect:"Mapování datových souborů do paměti se používá pro správu paměti procesu, nikoliv pro přístup k souborům.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"},{uuid:"2529caf0-e62b-4628-8e21-758811d9bdfb",correct:"Při mapování souboru do paměti program přistupuje k souboru jako k místu v operační paměti.",incorrect:"Při mapování souboru do paměti program musí používat standardní systémová volání pro čtení a zápis.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"},{uuid:"4d478b54-2317-454f-9098-b3e5e0ab10ea",correct:"Externí stránkování umožňuje uložit stránky mapovaného souboru do běžného datového souboru.",incorrect:"Externí stránkování pro mapování souborů vyžaduje speciální diskový oddíl, nikoliv běžný soubor.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"}]},{uuid:"dc119fde-5b9a-4b1d-ab0a-b4e5d1b2fb77",sectionNumber:"2",sectionTitle:"Virtualizace procesoru",statements:[{uuid:"bf8b2927-4e17-418d-a080-43532e0ed1f2",correct:"Aritmetické a logické instrukce procesoru zahrnují sčítání, bitové posuvy a relační operátory.",incorrect:"Aritmetické a logické instrukce procesoru zahrnují pouze sčítání a odčítání celých čísel.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"9e54cd6a-118f-46c0-9d59-5f038db7094b",correct:"Instrukce pro přístup do paměti, označené jako ld a st, umožňují procesoru pracovat s daty uloženými v paměti.",incorrect:"Instrukce ld a st slouží výhradně k provádění aritmetických operací s daty v registrech procesoru.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"ccf49522-96e3-4898-903a-e8511e267b0b",correct:"Mezi instrukce řízení toku patří podmíněné skoky a nepřímé skoky, které ovlivňují pořadí provádění instrukcí.",incorrect:"Instrukce řízení toku se používají pouze pro manipulaci s daty v paměti a nemají vliv na pořadí provádění instrukcí.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"761f2e50-8748-44fe-b47b-a7e6c95a4db6",correct:"Realizace podprogramů pomocí specializovaných instrukcí zjednodušuje abstrakci, ale není pro funkčnost procesoru nezbytná.",incorrect:"Pro implementaci podprogramů jsou specializované instrukce procesoru naprosto nezbytné a nelze je nahradit jednoduššími instrukcemi.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"473c1123-bea5-4855-8cfc-fb013fa66ec6",correct:"Registry procesoru ukládají čísla reprezentovaná jako celá slova, nikoliv jednotlivé bajty.",incorrect:"Registry procesoru ukládají čísla reprezentovaná jako jednotlivé bajty, nikoliv celá slova.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"6b5e059f-98fa-4549-ab9a-85f839b8904f",correct:"Programový čítač obsahuje virtuální adresu instrukce, která se má aktuálně provést.",incorrect:"Programový čítač obsahuje fyzickou adresu instrukce, která se má aktuálně provést.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"a8e9f62e-a60d-43f2-bcf1-795b0b2908a9",correct:"Paměťové adresy lze indexovat a vypočítat, registry se v instrukcích používají přímo.",incorrect:"Registry lze indexovat a vypočítat, paměťové adresy se v instrukcích používají přímo.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"cb32d73c-4f9a-4bdc-926f-6f5e884b5854",correct:"Hodnotu programového čítače lze měnit instrukcemi řízení toku programu, nikoliv aritmetickými instrukcemi.",incorrect:"Hodnotu programového čítače lze měnit aritmetickými instrukcemi, nikoliv instrukcemi řízení toku programu.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"7e16c838-308d-4a14-aa32-c9f373b736a8",correct:"Instrukce je elementární příkaz strojového kódu, což představuje nejmenší jednotku činnosti procesoru.",incorrect:"Instrukce je složitý příkaz vyššího programovacího jazyka, který procesor vykonává přímo.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"7b716660-c27d-49e7-85f2-0e8aba7e8160",correct:"Procesor zná pouze konečný počet instrukcí strojového kódu, což umožňuje jejich jednoznačné očíslování.",incorrect:"Procesor je schopen vykonat nekonečný počet různých instrukcí strojového kódu bez omezení.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"213afe79-ba33-442f-9d33-8901c827c1cc",correct:"Instrukce strojového kódu lze logicky sdružovat do rodin podle prováděných operací, například sčítání.",incorrect:"Instrukce strojového kódu jsou zcela nesourodé a nelze je smysluplně kategorizovat podle operací.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"2064730c-1120-49a8-8c08-9d47c944073d",correct:"Mnemonický zápis instrukcí je určen pro čitelnost programátory a není totožný s jazykem symbolických adres.",incorrect:"Mnemonický zápis instrukcí je formální jazyk symbolických adres přímo interpretovaný procesorem.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"48ff1706-8caa-4b41-9a4b-d7ded63bb745",correct:"Operace, kterou má instrukce provést, je obvykle určena operačním kódem v rámci číselného kódování instrukce.",incorrect:"Operace instrukce není nikdy explicitně kódována, ale je odvozena pouze z kontextu a operandů.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"e4c8bf3e-ac6a-4565-a2ee-e2f09643426f",correct:"Každá instrukce operačního systému má za následek změnu stavu procesoru.",incorrect:"Některé instrukce operačního systému nemají žádný vliv na stav procesoru.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"9eba04a3-f219-4ad1-b93c-2725a9829f07",correct:"Výpočet programu je definován jako posloupnost elementárních změn stavu systému.",incorrect:"Výpočet programu je jednorázová operace bez posloupnosti změn stavu.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"e31a9b05-7b98-4ebc-b097-dfd48ce27976",correct:"Efekt instrukce je elementární změna stavu, což je základní stavební kámen výpočtu.",incorrect:"Efekt instrukce je komplexní transformace stavu, nikoliv elementární změna.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"eb05d003-832f-4279-8c81-2727e78f7468",correct:"Programy manipulují se stavem procesoru, paměti a periferií pro dosažení výstupů ze vstupů.",incorrect:"Programy ignorují stav systému a přímo generují výstupy nezávisle na vstupech.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"fb4e17ef-7b95-49ca-93a1-ad6f2b7f66f4",correct:"Vstupy a výstupy programu jsou integrální součástí celkového stavu výpočetního systému.",incorrect:"Vstupy a výstupy programu existují mimo kontext stavu výpočetního systému.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"7ff47499-d48b-4633-ae62-477f4deb1010",correct:"Instrukce typu `add op1 op2 -> result` typicky sečte hodnoty registrů op1 a op2.",incorrect:"Instrukce typu `add op1 op2 -> result` obvykle provádí bitový posun hodnot registrů.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"6fcc9b66-d7cc-4ebf-95bd-936b868407a3",correct:"Po provedení instrukce `add op1 op2 -> result` se programový čítač posune na další instrukci.",incorrect:"Po provedení instrukce `add op1 op2 -> result` programový čítač zůstává nezměněn.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"a30f59f2-69c1-4c23-ad67-beb097341e2a",correct:"Program je tvořen instrukcemi uloženými v paměti.",incorrect:"Program je tvořen daty uloženými v registech procesoru.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"9bb77e9b-d246-4ac4-bd9e-e73ee5c00629",correct:"Většina programu je prováděna v pořadí od nižších k vyšším virtuálním adresám.",incorrect:"Většina programu je prováděna v náhodném pořadí adres v paměti.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"2dff8de0-804b-403e-b6ac-74d5651911b2",correct:"Instrukce skoku mohou způsobit návrat k dříve vykonané instrukci, například u cyklů.",incorrect:"Instrukce skoku nikdy nemohou způsobit návrat k dříve vykonané instrukci.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"eacead6c-ddc5-4536-acfb-c790ea8d7597",correct:"Podmíněné příkazy obvykle posouvají programový čítač dopředu v adresovém prostoru.",incorrect:"Podmíněné příkazy obvykle posouvají programový čítač dozadu v adresovém prostoru.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"fcbadfd9-3a83-4cf6-aa3f-03ec557a9282",correct:"Podprogram je pomocný blok instrukcí, který se může opakovaně volat z různých částí programu.",incorrect:"Podprogram je hlavní program, který se volá pouze jednou na začátku výpočtu.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"c8d0cf24-5630-42d9-8804-ea0f33b47211",correct:"Aktivace podprogramu zahrnuje uložení části stavu procesoru a vyhrazení místa pro lokální proměnné.",incorrect:"Aktivace podprogramu nevyžaduje uložení stavu procesoru, pouze skok na začátek podprogramu.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"9bd17c43-bc04-46f9-9f5b-0d5142a23087",correct:"Zásobník je spojitá oblast virtuálního adresního prostoru, která se používá pro realizaci podprogramů.",incorrect:"Zásobník je diskrétní oblast fyzické paměti, která se používá pro ukládání globálních proměnných.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"854edbe6-7a40-4c55-bdb3-6f1f5f3ffa4d",correct:"Návrat z podprogramu je realizován skokem zpět na instrukci následující po aktivaci podprogramu.",incorrect:"Návrat z podprogramu je realizován ukončením procesu a uvolněním všech zdrojů.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"d596bc0b-40dd-47a2-bb4d-f1b20d379d2e",correct:"Pro realizaci podprogramů se běžně používá hardwarový zásobník.",incorrect:"Pro realizaci podprogramů se běžně používá fronta.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"5ab28e8c-74ab-499d-b677-beea5cc5d139",correct:"Zásobník typického programu je tvořen sekvencí aktivačních záznamů, známých jako rámce.",incorrect:"Zásobník typického programu je tvořen sekvencí instrukcí procesoru, známých jako rámce.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"4e54333c-a4d5-4fdd-bbf6-8352a4270c0a",correct:"Každý aktivační záznam v zásobníku odpovídá jedné dosud neskončené aktivaci podprogramu.",incorrect:"Každý aktivační záznam v zásobníku odpovídá každému volání podprogramu, i skončenému.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"5fc76e23-a971-4d4b-8984-9494df6d4f53",correct:"Zásobník funguje na principu LIFO, což znamená, že poslední zavolaný podprogram končí první.",incorrect:"Zásobník funguje na principu FIFO, kde první zavolaný podprogram končí první.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"d6ee4141-b009-4769-996f-64abef06e800",correct:"Pro správnou funkci zásobníku musí podprogram skončit až po skončení všech jím aktivovaných podprogramů.",incorrect:"Pro správnou funkci zásobníku může podprogram skončit i před skončením jím aktivovaných podprogramů.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"3f30fc17-41ad-45ca-9805-e3c3c6c3ca32",correct:"Některé procesory používají zásobníky, které rostou směrem k nižším paměťovým adresám.",incorrect:"Všechny procesory používají zásobníky, které rostou směrem k vyšším paměťovým adresám.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"00c17def-2079-42b8-8ef3-2e69a56dcb32",correct:"Aktivační záznam obvykle obsahuje lokální proměnné a uložené registry pro obnovení stavu po návratu.",incorrect:"Aktivační záznam obvykle obsahuje pouze globální proměnné a žádné registry procesoru.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"4b39e58f-a48b-4701-a116-f162a9a1fbf9",correct:"Stav procesoru pro účely výpočtu zahrnuje registry, programový čítač a ukazatel zásobníku.",incorrect:"Stav procesoru pro účely výpočtu zahrnuje pouze aritmetické registry a stav paměti.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"098b44bb-71fe-45d0-b847-f99b2334eee8",correct:"Izolovaný výpočet je deterministický, což znamená, že je jednoznačně určen počátečním stavem a programem.",incorrect:"Izolovaný výpočet je deterministický bez ohledu na počáteční stav procesoru a prováděný program.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"b262b4cc-54a9-4815-8aa5-f3c955638f89",correct:"Determinismus výpočtu může být narušen, pokud program interaguje s periferiemi mapovanými do paměti.",incorrect:"Interakce programu s periferiemi mapovanými do paměti nemá vliv na determinismus výpočtu.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"3534b101-99bc-42db-8a1a-f7b3ae74a645",correct:"Pro deterministický výpočet je klíčové, aby program neměl přístup do paměti mimo vyhrazený adresní prostor.",incorrect:"Deterministický výpočet je možný i v případě, že program má neomezený přístup do paměti.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"2bd449f4-f01e-4f62-8ceb-595bcfbba5b7",correct:"Výpočet procesoru lze chápat jako sekvenci postupných změn stavu procesoru.",incorrect:"Výpočet procesoru je statický a neměnný, bez postupných změn stavu.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"fb272868-65c4-450b-a5c7-d221be708944",correct:"V neizolovaném výpočtu může externí entita změnit hodnotu v paměti programu a ovlivnit tak jeho běh.",incorrect:"V izolovaném výpočtu může externí entita změnit hodnotu v paměti programu a ovlivnit tak jeho běh.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"21460bcf-79c4-43b7-8531-250240ea9058",correct:"Synchronizace v operačních systémech popisuje interakci výpočtů, kdy externí událost ovlivní průběh programu.",incorrect:"Synchronizace v operačních systémech popisuje izolovaný výpočet, kdy externí událost neovlivní průběh programu.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"070237a2-72b5-437e-9c70-641ada9f91cc",correct:"Virtuální adresa 0x1000 v programu nemusí odpovídat fyzické adrese 0x1000 v paměti systému.",incorrect:"Virtuální adresa 0x1000 v programu vždy odpovídá fyzické adrese 0x1000 v paměti systému.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"61d8738d-bf2a-4d1c-9aab-4bf54a29c848",correct:"Stav procesoru je určen výlučně programem, jak je definováno v tomto kontextu.",incorrect:"Stav procesoru není určen výlučně programem, ale i vnějšími vlivy.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"def175b9-652f-4756-a931-96a82b07f595",correct:"Zásobník v kontextu vláken operačního systému patří výhradně vláknu.",incorrect:"Zásobník v kontextu vláken operačního systému patří procesu, nikoliv vláknu.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"d3f7fcca-97bb-4aff-9ccb-43aa303d476c",correct:"Výpočet vlákna není jednoznačně určen, protože výpočet není izolován od vnějších událostí.",incorrect:"Výpočet vlákna je jednoznačně určen, protože výpočet je plně izolován od vnějších událostí.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"3ca6388a-5805-4fbc-895f-9fd9c9d9f66f",correct:"Vlákno může iniciovat synchronizaci s jinými vlákny zápisem do sdílené paměti.",incorrect:"Vlákno nemůže iniciovat synchronizaci s jinými vlákny zápisem do sdílené paměti.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"354d7aa0-a132-4d48-8ae7-964a95ce2bb2",correct:"Vlákno pozoruje vnější události operačního systému prostřednictvím čtení paměti.",incorrect:"Vlákno pozoruje vnější události operačního systému prostřednictvím zápisu do paměti.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"7ad7c784-5d4c-431d-963e-530db91f5e21",correct:"Stav logického procesoru je definován výhradně hodnotami registrů procesoru.",incorrect:"Stav logického procesoru je definován obsahem operační paměti.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"2c413012-620a-4e32-8e16-938e44bf3213",correct:"Změna stavu logického procesoru nastává pouze vykonáváním instrukcí.",incorrect:"Změna stavu logického procesoru může nastat i bez vykonávání instrukcí.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"ad82e302-dccb-4bc5-99f7-5abef9575c8e",correct:"Virtualizace procesoru umožňuje provozovat více logických procesorů na jednom fyzickém procesoru.",incorrect:"Virtualizace procesoru omezuje počet logických procesorů na maximálně jeden na fyzický procesor.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"66767e71-25be-45ac-bfad-e88e3432f0a6",correct:"Operační systém dokáže uložit a obnovit stav logického procesoru pro účely virtualizace.",incorrect:"Operační systém nemůže uložit ani obnovit stav logického procesoru.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"e6860944-4369-448a-8404-6d6e982b084e",correct:"Přerušení je vnější událost, která umožňuje operačnímu systému převzít kontrolu nad fyzickým procesorem.",incorrect:"Přerušení je událost vyvolaná vláknem, která umožňuje operačnímu systému převzít kontrolu.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"54cb05c9-fc03-49fe-bc5b-eb719ec6e854",correct:"Díky uložení a obnově registrů se vlákno může jevit jako samostatný logický procesor.",incorrect:"Vlákno funguje zcela nezávisle na uložení a obnově registrů fyzického procesoru.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"3772cd6d-c3b6-4f33-b317-16f412c263f4",correct:"Pro správnou funkčnost vláken je nezbytná hardwarová podpora procesoru pro uložení a obnovu jeho stavu.",incorrect:"Softwarová emulace plně postačuje pro uložení a obnovu stavu procesoru pro běh vláken bez hardwarové podpory.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"c1640fda-c909-40dd-83e5-39c4bb58f55c",correct:"Obsluha přerušení, která vyžaduje uložení části stavu, poskytuje základ pro mechanismy vláken.",incorrect:"Obsluha přerušení nemá žádný vliv na mechanismy uložení stavu, které se používají pro vlákna.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"afc7438e-f2d3-4a07-95a0-2c12aafd3c3e",correct:"Programový čítač představuje největší komplikaci při implementaci uložení a obnovení kontextu vláken.",incorrect:"Uložení a obnovení programového čítače je triviální operací v kontextu správy vláken.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"25533738-63e2-4301-8303-47ec867898e9",correct:"Střídavé provádění více vláken na jednom procesoru je umožněno mechanismy uložení a obnovy registrů.",incorrect:"Paralelní provádění více vláken na jednom procesoru je přímo umožněno mechanismy uložení a obnovy registrů.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"fbc59b48-693d-40e2-9adc-8751e58807bd",correct:"Plánovač vláken se spouští pravidelně přerušením časovače na každém fyzickém procesorovém jádře.",incorrect:"Plánovač vláken se spouští asynchronně, pouze pokud běžící vlákno explicitně uvolní procesor.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"bf04861e-e0fb-47a8-90c9-c7fc6f1c5c65",correct:"Hlavním úkolem plánovače vláken je rozhodnout, zda má být aktivní vlákno přerušeno a které má běžet dále.",incorrect:"Hlavním úkolem plánovače vláken je pouze optimalizovat využití procesoru bez ohledu na spuštěná vlákna.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"6987faf8-18c3-49a9-994f-fbb5173561b6",correct:"Díky preemptivnímu plánování může operační systém odebrat vláknu procesor i bez jeho aktivního souhlasu.",incorrect:"Preemptivní plánování vyžaduje, aby vlákno aktivně signalizovalo operačnímu systému, že může být přerušeno.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"fd0c49ef-778b-4197-ae58-41ba9d407a3a",correct:"Termín plánovač procesů se historicky používá jako synonymum pro modernější plánovač vláken.",incorrect:"Termíny plánovač procesů a plánovač vláken označují různé komponenty operačního systému s odlišnými funkcemi.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"b4aa0d80-845b-4545-9b24-3c894c136a9f",correct:"Pro aktivaci plánovače vláken se používá programovatelný časovač, který může pracovat v periodickém režimu.",incorrect:"Pro aktivaci plánovače vláken se používá výhradně jednorázový časovač, který je nutné po každém spuštění znovu aktivovat.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"a0662570-cd8a-4509-ab96-5d29c5076b64",correct:"Maximalizace propustnosti plánovače operačního systému se zaměřuje na maximalizaci práce vykonané za jednotku času.",incorrect:"Maximalizace propustnosti plánovače operačního systému se zaměřuje na minimalizaci reakční doby systému.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"59abb30b-7332-47e6-a323-491837d571f6",correct:"Minimalizace latence v plánování operačního systému je klíčová pro interaktivní programy a síťové služby.",incorrect:"Minimalizace latence v plánování operačního systému je klíčová pro výpočetně náročné programy.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"17eec286-bac2-43bf-9a2c-4718f0e1650c",correct:"Spravedlivost v plánování operačního systému zajišťuje, že všechna vlákna obdrží přibližně stejný díl procesorového času.",incorrect:"Spravedlivost v plánování operačního systému upřednostňuje vlákna s nejvyšší prioritou bez ohledu na ostatní vlákna.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"91d73888-f1b3-45c4-bf86-7a987b57c505",correct:"Požadavky na minimální latenci a maximální propustnost jsou v plánování operačního systému často protichůdné.",incorrect:"Požadavky na minimální latenci a maximální propustnost se v plánování operačního systému vzájemně doplňují a posilují.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"4541c5c5-1f68-4cc2-8857-facb4255e58b",correct:"Příliš časté střídání vláken může snížit propustnost systému kvůli režii spojené s přepínáním kontextu.",incorrect:"Příliš časté střídání vláken obvykle zvyšuje propustnost systému díky lepšímu využití procesoru.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"934e4899-d170-4f9c-84bd-22b1be4fb8a0",correct:"Vlákno se může nacházet ve stavech běžící, připravené nebo čekající na událost.",incorrect:"Vlákno se může nacházet ve stavech běžící, blokované, uspáno a čekající na událost.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"6b3707a0-0370-4076-a0d2-695755d01f12",correct:"Plánovač operačního systému rozhoduje o přechodu vlákna z běžícího stavu do stavu připraveno.",incorrect:"Samotné vlákno rozhoduje o svém přechodu z běžícího stavu do stavu připraveno.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"78e64b0c-f8de-4f9d-8d0c-36f0fd2bcc15",correct:"Přímý přechod vlákna ze stavu čekání na procesor do stavu čekání na událost není možný.",incorrect:"Přímý přechod vlákna ze stavu čekání na procesor do stavu čekání na událost je běžně prováděn.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"3d3a17c5-ab60-43b2-bd50-f5a711c13db2",correct:"Po nastání události a dostupnosti procesoru přechází vlákno z čekání na událost do stavu běžící.",incorrect:"Po nastání události vlákno z čekání na událost vždy okamžitě přechází do stavu běžící.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"5e6bc6a4-bcea-4360-b088-7e69be689a5e",correct:"Pokud po události není procesor dostupný, vlákno čekající na událost přejde do stavu připraveno.",incorrect:"Pokud po události není procesor dostupný, vlákno čekající na událost zůstane ve stavu čekání na událost.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"83ce430b-c57b-4fa0-9e15-7a294bd7c446",correct:"Běhové fronty úloh jsou klíčovým nástrojem plánovače operačního systému pro správu vláken čekajících na procesor.",incorrect:"Běhové fronty úloh se používají pro ukládání hotových procesů, nikoliv pro vlákna čekající na procesor.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"121e3adb-3e95-4ba5-b399-639eea2419fd",correct:"Plánovací algoritmy se liší zejména v chování běhových front úloh, které ovlivňují pořadí a prioritu vláken.",incorrect:"Plánovací algoritmy se liší pouze v rychlosti přepínání kontextu, nikoliv v chování běhových front úloh.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"ee0b661c-4aae-4152-8152-c129bdfebfaf",correct:"Globální fronta úloh je sdílená mezi všemi procesory, zatímco lokální fronta je specifická pro jeden procesor.",incorrect:"Globální fronta úloh je specifická pro jeden procesor, zatímco lokální fronta je sdílená mezi všemi procesory.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"0b8c5a84-f8f2-4fde-9db0-1d42e6fa9199",correct:"FIFO fronta zpracovává vlákna v pořadí, v jakém byla do fronty zařazena, bez ohledu na prioritu.",incorrect:"FIFO fronta zpracovává vlákna s nejvyšší prioritou jako první, bez ohledu na pořadí zařazení.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"3a42e3a9-c623-4e1e-bae0-aa47a401a4a4",correct:"Implementace fronty úloh, například monolitická nebo složená, má zásadní vliv na chování plánovače.",incorrect:"Implementace fronty úloh nemá žádný vliv na chování plánovače, protože plánovač je řízen pouze prioritami.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"6ea4c80e-dade-4968-b61b-6ce7f389f9d3",correct:"Prioritní fronty umožňují vláknům s vyšší prioritou předbíhat vlákna s nižší prioritou ve frontě úloh.",incorrect:"Prioritní fronty zajišťují, že všechna vlákna mají stejnou šanci na přidělení procesoru bez ohledu na prioritu.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"c8774ace-b221-4bfa-9a3d-328dd6349181",correct:"Plánovač s afinitou se snaží opakovaně plánovat vlákno na stejném fyzickém procesoru.",incorrect:"Plánovač s afinitou automaticky migruje vlákna mezi procesory pro lepší vyvážení zátěže.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"e1671a9e-8adb-4407-8f10-3dd447315a06",correct:"Migrace vlákna mezi procesory je drahá operace kvůli sdílení obsahu mezipaměti mezi nimi.",incorrect:"Migrace vlákna mezi procesory je levná operace, která zlepšuje výkon systému.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"2caef622-1484-4a89-b3a4-de36f53a8ef1",correct:'Kradení práce je mechanismus, kde procesor bez práce "ukradne" vlákno z jiné fronty.',incorrect:'Kradení práce je mechanismus, kde procesor s přebytkem práce "ukradne" vlákno z jiné fronty.',sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"8fb0531a-2c21-44dc-b14a-b7df7e1bab0d",correct:"Plánovač s globální frontou obvykle postrádá afinitu vláken k procesorům.",incorrect:"Plánovač s globální frontou aktivně podporuje afinitu vláken k procesorům.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"b3b3cd69-beda-4499-8b80-f85cb9dc39db",correct:"Plánovač s lokálními frontami a bez migrace zamezuje přesunu vláken mezi procesory.",incorrect:"Plánovač s lokálními frontami a bez migrace aktivně přesouvá vlákna mezi procesory.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"fb8e43ec-df95-4d8d-9fef-abdb2b25a07b",correct:"Interaktivní plánovače používají prioritní plánování, kde priorita ovlivňuje latenci vláken a celkový přidělený čas.",incorrect:"Interaktivní plánovače používají prioritní plánování, kde priorita neovlivňuje latenci vláken a celkový přidělený čas.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"2f6c30e4-ee97-43eb-870f-4eb29afea807",correct:"Statické priority vláken jsou určeny rozhodnutím uživatele a nemění se v závislosti na chování systému.",incorrect:"Statické priority vláken jsou určeny dynamicky systémem a mění se v závislosti na chování uživatele.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"46fb7afd-c9c3-4884-9a17-16bb3467c340",correct:"Klasické prioritní plánování s FIFO frontami vybírá vlákna z nejvyšší neprázdné fronty prioritních tříd.",incorrect:"Klasické prioritní plánování s FIFO frontami vybírá vlákna z nejnižší neprázdné fronty prioritních tříd.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"aa50a663-7660-437a-a071-877752e0b3eb",correct:"Dynamická úprava priority vláken snižováním priority za běh řeší problém blokování procesoru dlouhými vlákny.",incorrect:"Dynamická úprava priority vláken zvyšováním priority za běh řeší problém blokování procesoru dlouhými vlákny.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"24114977-fd24-4bd2-bc92-b968e952dd18",correct:"Férové plánování se podobá dynamickému prioritnímu plánování s prioritami v libovolném rozsahu.",incorrect:"Férové plánování je zcela odlišné od dynamického prioritního plánování a nepoužívá priority.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"6736f8fd-248a-4fb3-ad70-101ef709cb8e",correct:"Při plném vytížení systému mohou být dlouhodobě běžící interaktivní procesy férovým plánováním znevýhodněny.",incorrect:"Při plném vytížení systému jsou dlouhodobě běžící interaktivní procesy férovým plánováním vždy zvýhodněny.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"7be22771-4e8e-4660-8432-20710d222bb8",correct:"Priorita ve férovém plánování klesá s rostoucím využitým výpočetním časem vlákna.",incorrect:"Priorita ve férovém plánování roste s rostoucím využitým výpočetním časem vlákna.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"f9ef5773-313b-48da-9afd-46ded57a8be6",correct:"Rozhodnutí o odebrání procesoru zohledňuje dobu běhu aktuálního vlákna a srovnání s dalším vláknem ve frontě.",incorrect:"Rozhodnutí o odebrání procesoru je založeno výhradně na prioritě aktuálního vlákna bez ohledu na dobu jeho běhu.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"c66bc833-2dd1-4a6e-9689-de39c14a8842",correct:"Plánovací kvantum definuje minimální dobu, po kterou vlákno běží na procesoru, i když existuje vlákno s vyšší prioritou.",incorrect:"Plánovací kvantum zaručuje, že vlákno s vyšší prioritou vždy okamžitě získá procesor, i během kvanta běžícího vlákna.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"fe39c1ae-1860-447b-8b15-e30a00d1dbd5",correct:"Dlouhé plánovací kvantum obvykle zvyšuje propustnost systému, ale může negativně ovlivnit latenci a reakční dobu.",incorrect:"Dlouhé plánovací kvantum zlepšuje latenci systému a reakční dobu, ale snižuje celkovou propustnost systému.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"4e4d002d-eadf-4e1c-9838-82795bea8e02",correct:"V algoritmech FIFO a RR jsou vlákna s rovnocennou prioritou spravedlivě rotována po časových kvantech.",incorrect:"V algoritmech FIFO a RR jsou vlákna s rovnocennou prioritou rotována po časových úsecích, jejichž délka se dynamicky mění v závislosti na prioritě.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"629c9b58-3ea4-40a0-a826-d93b27955364",correct:"Dobrovolné propuštění procesoru je v moderních preemptivních systémech spíše výjimkou a nahrazuje se signalizací událostí.",incorrect:"Dobrovolné propuštění procesoru je klíčovým mechanismem moderních preemptivních systémů pro efektivní správu zdrojů.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"2aa3eed8-259f-41df-af8b-9054d1aa3fad",correct:"Při čekání na vyřízení požadavku je vlákno probuzeno komponentou, která daný požadavek vyřídila.",incorrect:"Při čekání na vyřízení požadavku je vlákno probuzeno plánovačem operačního systému ještě před vyřízením požadavku.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"},{uuid:"1ba29f46-60ab-4078-ac8c-0329ec012a5e",correct:"V situaci soutěže o zdroj se vlákna řadí do čekací fronty a po uvolnění zdroje se probudí jen první vlákno z fronty.",incorrect:"V situaci soutěže o zdroj se všechna čekající vlákna probudí současně po uvolnění daného zdroje.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"},{uuid:"07d72691-0064-405b-ba90-cb704f8a242d",correct:"Vlákno může být uspáno, pokud se pokusí vstoupit do kritické sekce, která je aktuálně zamčená jiným vláknem.",incorrect:"Vlákno se uspí, pokud úspěšně vstoupí do kritické sekce a začne v ní provádět operace.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"},{uuid:"664ea3ab-fac6-46a7-ae55-8f2d13b4b642",correct:"Čekání na vstup z klávesnice a čekání na data ze sítě jsou příklady událostí, které mohou vlákno uspat.",incorrect:"Čekání na tisk dokumentu a výpočet matematické operace jsou typické události, které uspí vlákno.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"}]},{uuid:"033995ad-e925-4494-ac23-ea2ca52f69c5",sectionNumber:"3",sectionTitle:"Souborové systémy",statements:[{uuid:"8d2f5a12-8090-439f-b7cc-6dc50b82c2d1",correct:"Perzistentní úložiště slouží k dlouhodobému uchování dat i po odpojení napájení.",incorrect:"Perzistentní úložiště slouží pouze k dočasnému uchování dat během běhu programu.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"97decc12-1ebd-42ec-8a9e-a3c9b493715b",correct:"Operace čtení a zápisu v perzistentním úložišti pracují s bloky dat o velikosti 512 bajtů a více.",incorrect:"Operace čtení a zápisu v perzistentním úložišti pracují s jednotlivými bajty, podobně jako operační paměť.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"50360a1b-e2e9-47f0-aa2d-7bb1abd3cc08",correct:"SSD, HDD a NVMe jsou příklady perzistentních úložišť, která se používají pro dlouhodobé ukládání dat.",incorrect:"Operační paměť RAM a cache procesoru jsou příklady perzistentních úložišť pro dlouhodobé uložení dat.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"c399abcc-9b1d-4b41-969b-045e6036dcfe",correct:"Magnetické pásky nejsou vhodné jako perzistentní blokové úložiště kvůli jejich sekvenčnímu přístupu k datům.",incorrect:"Magnetické pásky jsou ideální jako perzistentní blokové úložiště díky jejich rychlému náhodnému přístupu k datům.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"ec25b9dc-3efa-4811-89e8-2b02582dae86",correct:"Perzistentní úložiště je primárně určeno pro ukládání uživatelsky relevantních dat, jako jsou dokumenty a multimédia.",incorrect:"Perzistentní úložiště se primárně využívá pro ukládání dočasných mezivýsledků výpočtů a systémové cache.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"1ba26c2c-fd45-46ec-adfd-e65d20a26419",correct:"Adresa v blokově orientovaném zařízení odkazuje na celý blok dat, nikoliv na jednotlivé bajty.",incorrect:"Adresa v blokově orientovaném zařízení odkazuje na jednotlivé bajty dat, nikoliv na bloky.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"fdcd37a0-7276-4944-9ce7-d5913739f9b9",correct:"Komunikace s blokově orientovaným zařízením je asynchronní kvůli latenci spojené s přístupem k blokům.",incorrect:"Komunikace s blokově orientovaným zařízením je synchronní, a to i přes latenci přístupu k blokům.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"3a8d221f-41a1-42f7-9182-97145281fc18",correct:"Blokově orientovaná zařízení, na rozdíl od operační paměti, přenášejí data po větších blocích.",incorrect:"Blokově orientovaná zařízení přenášejí data po jednotlivých bajtech, stejně jako operační paměť.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"c55c1c54-3b5a-42b2-bfec-a4a2a97b8492",correct:"Struktura blokově orientovaných zařízení odpovídá jejich fyzickému uspořádání do bloků.",incorrect:"Struktura blokově orientovaných zařízení je abstraktní a neodpovídá fyzickému uspořádání.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"f17ec05d-c66c-43b4-a13c-054354e73943",correct:"Problém prodlevy mezi požadavkem a vyřízením nelze skrýt hardwarově a musí být řešen operačním systémem.",incorrect:"Problém prodlevy mezi požadavkem a vyřízením lze efektivně skrýt hardwarově bez zásahu operačního systému.",sectionNumber:"3.1.3",sectionTitle:"Latence"},{uuid:"592f27b0-c4e3-4249-b456-93a25ca4f619",correct:'Pro zajištění spolehlivého uložení dat, takzvané "durability" v ACID, je nutné v operačních systémech čekat na potvrzení zápisu kvůli prodlevě.',incorrect:'Pro zajištění spolehlivého uložení dat, takzvané "durability" v ACID, není nutné v operačních systémech čekat na potvrzení zápisu i přes prodlevu.',sectionNumber:"3.1.3",sectionTitle:"Latence"},{uuid:"b1159f0b-4418-426d-97b7-beaab0cf288c",correct:"Prodleva v kontextu operačních systémů označuje dobu, která uplyne mezi odesláním požadavku a obdržením odpovědi, a je příliš významná, než aby mohla být ignorována.",incorrect:"Prodleva v kontextu operačních systémů označuje dobu, která uplyne pouze při zpracování požadavku uvnitř hardwaru a operační systém ji může plně eliminovat.",sectionNumber:"3.1.3",sectionTitle:"Latence"},{uuid:"760e2546-84fa-43c2-bc49-3c52724fe92a",correct:"Mezipaměť v operačních systémech je navržena tak, aby skrývala latenci přístupu k datům.",incorrect:"Mezipaměť v operačních systémech primárně zvyšuje spolehlivost datových úložišť.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"1d36d03e-33ac-446a-8b14-b9c117512925",correct:"Politika mezipaměti operačního systému určuje, které nedávno čtené bloky dat zůstanou uloženy v RAM.",incorrect:"Politika mezipaměti operačního systému určuje, které nejméně často čtené bloky dat zůstanou uloženy v RAM.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"ef12571b-72e1-414e-b9fc-d1772271603b",correct:"Správu mezipaměti trvalých úložišť implementuje operační systém softwarově.",incorrect:"Správu mezipaměti trvalých úložišť implementuje výhradně hardware řadiče disku.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"c58514f6-0aca-4b5f-bfa1-9c83c655c7a6",correct:"Mezipaměť operačního systému nemá vliv na spolehlivost dat uložených v trvalém úložišti, pouze na rychlost přístupu.",incorrect:"Mezipaměť operačního systému je klíčová pro zajištění spolehlivosti dat uložených v trvalém úložišti.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"87c9af88-6fde-4176-ac07-56538350c89c",correct:"Hlavním účelem mezipaměti je zrychlení opakovaného přístupu ke stejným adresám v datovém úložišti.",incorrect:"Hlavním účelem mezipaměti je optimalizace sekvenčního přístupu k různým adresám v datovém úložišti.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"8257d804-2533-4036-8672-726bb0029b79",correct:"Operační systémy mohou využívat techniku prefetchingu pro načítání dat do mezipaměti s předstihem.",incorrect:"Operační systémy nikdy nevyužívají techniku prefetchingu kvůli neefektivnímu využití přenosové kapacity.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"2c0f64ef-4192-4427-92ee-e6ef0de37ab1",correct:"Při sekvenčním čtení souboru je efektivní načítat následující bloky do mezipaměti předem.",incorrect:"Při sekvenčním čtení souboru je neefektivní načítat následující bloky do mezipaměti předem.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"82a4a2a8-a164-412d-8c4b-59e00e348d9f",correct:"V kontextu trvalých úložišť je správa mezipaměti typicky realizována operačním systémem softwarově.",incorrect:"V kontextu trvalých úložišť je správa mezipaměti typicky realizována hardwarově řadičem paměti.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"14177550-b00e-42db-aa46-eeeab8ed4cc2",correct:"V mezipaměti trvalých úložišť operační paměť slouží jako rychlá mezipaměť a trvalé úložiště jako pomalá.",incorrect:"V mezipaměti trvalých úložišť trvalé úložiště slouží jako rychlá mezipaměť a operační paměť jako pomalá.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"3c2adf59-9c9a-4b80-b457-624b26bb100c",correct:"Vyrovnávací paměť slouží k vyrovnání rozdílu rychlostí mezi aplikací a trvalým úložištěm při zápisu dat.",incorrect:"Vyrovnávací paměť slouží k urychlení čtení dat z trvalého úložiště do aplikace.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"ecc030c3-bfd4-40fe-a78e-3434d2c1e59b",correct:"Data uložená ve vyrovnávací paměti se při výpadku napájení ztratí.",incorrect:"Data uložená ve vyrovnávací paměti jsou trvale uložena i po výpadku napájení.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"660efa26-e892-4c6a-b1b9-2235c919eae1",correct:"Oddělená vyrovnávací paměť uchovává požadavky na zápis i samotná data určená k zápisu.",incorrect:"Oddělená vyrovnávací paměť uchovává pouze požadavky na zápis, data jsou uložena v mezipaměti.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"835a4aa8-cc51-459f-9b40-78d47aa674d8",correct:"Sekvenční přístup k úložišti dat je obecně mnohem rychlejší než nahodilý přístup.",incorrect:"Nahodilý přístup k úložišti dat je obecně mnohem rychlejší než sekvenční přístup.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"b670418e-5631-4eb4-86c9-516e787c589f",correct:"Operace s trvalým úložištěm dat vykazují vysokou míru souběžnosti díky mnoha nezávislým požadavkům.",incorrect:"Operace s trvalým úložištěm dat obvykle nevykazují vysokou míru souběžnosti.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"8fc1bbcd-9156-43c0-bf1a-1a7674c96fbf",correct:"Přeuspořádání diskových operací, zejména zápisů, může vést k vyšší propustnosti systému.",incorrect:"Přeuspořádání diskových operací obvykle nevede k vyšší propustnosti systému.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"2c8488ee-a6fd-4bf5-994a-b0227d049ae5",correct:"Vyšší míra přeuspořádání zápisů může potenciálně zvýšit riziko nekonzistence dat při výpadku.",incorrect:"Vyšší míra přeuspořádání zápisů obvykle snižuje riziko nekonzistence dat při výpadku.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"3483bdf2-5ead-489d-be9e-2d69c2d6235d",correct:"Virtualizace trvalých úložišť se liší od virtualizace paměti a procesoru kvůli potřebě interakce uživatele s daty.",incorrect:"Virtualizace trvalých úložišť je stejná jako virtualizace paměti a procesoru, protože cílem je izolace.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"f4253f3f-c188-4807-af29-0bf76aac8739",correct:"Jedno z řešení virtualizace trvalých úložišť spočívá ve vyčlenění aplikace odpovědné za správu dat.",incorrect:"Všechny aplikace mají přímý a neomezený přístup k trvalému úložišti i při virtualizaci.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"c1dc43ac-716f-4ff0-855c-540f9cda8bfb",correct:"Operační systém může poskytnout abstrakci trvalého úložiště, čímž skryje fyzické zařízení před aplikacemi.",incorrect:"Operační systém vždy poskytuje přímý přístup k fyzickému trvalému úložišti bez abstrakce.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"4cb9d37f-82a9-415d-9318-a5621266eae6",correct:"V obou navržených řešeních virtualizace trvalých úložišť je přímý přístup omezen na jeden program.",incorrect:"V obou navržených řešeních virtualizace trvalých úložišť mají všechny programy přímý přístup.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"a95344cd-c5d0-4b3f-aee3-47d3d13b8e8e",correct:"Souborový systém je abstrakce poskytovaná operačním systémem pro řízený přístup k datům.",incorrect:"Souborový systém je abstrakce poskytovaná aplikacemi pro přímý přístup k datům.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"67d72dbd-2a4c-41e2-9d15-f7dea60f918c",correct:"Virtualizace na aplikační úrovni se typicky používá v databázových systémech pro správu dat.",incorrect:"Virtualizace na aplikační úrovni se typicky používá pro virtualizaci operační paměti.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"28581bad-3951-4fba-8f8f-5b8aeb6e6b9e",correct:"Izolovaná virtuální instance úložiště je užitečná zejména při virtualizaci operačních systémů.",incorrect:"Izolovaná virtuální instance úložiště je nejběžnější metodou virtualizace trvalých úložišť.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"15db155a-1e40-47f6-bf17-6fd3b4df76d5",correct:"Standardním řešením problémů se spolehlivostí paměti je v operačních systémech redundance.",incorrect:"Standardním řešením problémů se spolehlivostí paměti je v operačních systémech mezipaměť.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"35d8dd24-a89b-4b09-b7b8-f0dfa8ca8161",correct:"Technologie RAID spojuje několik fyzických úložišť do jednoho virtuálního diskového pole.",incorrect:"Technologie RAID rozděluje jedno fyzické úložiště na několik virtuálních diskových polí.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"c5d23acd-c284-47c3-90ca-5b4ef0ac7843",correct:"Softwarový RAID je implementován v blokové vrstvě operačního systému.",incorrect:"Softwarový RAID je implementován mimo blokovou vrstvu operačního systému.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"0043c964-9653-487f-b23b-ce960619e549",correct:"RAID 0 je jediná úroveň RAID, která neposkytuje žádnou redundanci dat.",incorrect:"RAID 0 je úroveň RAID, která poskytuje nejvyšší úroveň redundance dat.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"3cc32042-a59c-40d9-8e48-c2e8ee80c51b",correct:"Čtení z RAID pole je obvykle rychlejší díky paralelnímu přístupu k datům.",incorrect:"Čtení z RAID pole je obvykle pomalejší kvůli nutnosti skládat data z více disků.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"2bcbaa4c-26ad-40f7-a92c-7690b7ceecc6",correct:"Šifrování blokových zařízení typicky využívá symetrické šifrování pro zachování délky dat.",incorrect:"Šifrování blokových zařízení typicky využívá asymetrické šifrování pro zachování délky dat.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"7393195a-5401-4fd0-bb98-b47b8aecb023",correct:"Šifrování blokových zařízení je transparentní pro souborový systém a ten o něm nemusí vědět.",incorrect:"Souborový systém musí být speciálně navržen, aby mohl pracovat se šifrovanými blokovými zařízeními.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"0ecd422c-cb6b-40dc-b16c-0b17bd851bee",correct:"Šifrování blokových zařízení zachovává délku bloků, pokud se nepoužívá kontrola integrity dat.",incorrect:"Šifrování blokových zařízení vždy zachovává délku bloků dat, i když se používá kontrola integrity.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"dd60ac7f-2523-4ef7-96cb-53529b1f7725",correct:"Pro šifrování blokových zařízení se běžně používá hardwarově akcelerovaná šifra AES v módu CBC nebo XTS.",incorrect:"Pro šifrování blokových zařízení se běžně používá softwarově implementovaná šifra DES v módu ECB.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"4036c1df-2639-4f69-9ee8-459680655feb",correct:"Šifrování blokových zařízení chrání data v případě fyzického přístupu útočníka k pevnému disku.",incorrect:"Šifrování blokových zařízení chrání data pouze proti útokům vedeným přes počítačovou síť.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"7ef67309-da6a-4b27-bee9-26e84a1679eb",correct:"Soubor v operačním systému je abstrakce, která skrývá blokový charakter fyzického úložiště.",incorrect:"Soubor v operačním systému je fyzické blokové úložiště dat bez abstrakční vrstvy.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"6b475aa1-f92e-4c74-8926-276b263c8d6e",correct:"V POSIX systémech volání `read` a `write` umožňují čtení a zápis souborů po bajtech nebo blocích libovolné velikosti.",incorrect:"V POSIX systémech volání `read` a `write` umožňují čtení a zápis souborů pouze po blocích pevně dané velikosti.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"a4151833-4ab8-446f-be68-0f18119ee64d",correct:"Operační systém automaticky prodlouží soubor, pokud se zapisuje za aktuální konec souboru.",incorrect:"Operační systém nikdy automaticky neprodlužuje soubor, i když se zapisuje za jeho konec.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"808321ac-47ab-4a27-b077-108d5d6c3ac6",correct:"Soubory v operačním systému jsou obvykle perzistentní a existují nezávisle na běžících procesech.",incorrect:"Soubory v operačním systému jsou dočasné a existují pouze po dobu běhu procesu, který je vytvořil.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"569ca1ab-4cd2-4dae-8730-7d28ff64e9f7",correct:"Pro práci se souborem je ve většině systémů nutné jej nejprve otevřít, například pomocí volání `open` v POSIX.",incorrect:"Pro práci se souborem ve většině systémů není nutné jej otevírat, stačí znát jeho umístění v systému souborů.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"2fd4b7fb-019a-45aa-ae0e-225489992cac",correct:"Obyčejný soubor reprezentuje paměť a souborový systém neinterpretuje obsah obyčejných souborů.",incorrect:"Obyčejný soubor reprezentuje paměť a souborový systém interpretuje obsah obyčejných souborů.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"1595165b-66b0-469c-a5e9-ecda773a9a0f",correct:"Soubory nemají omezení na zarovnání, zatímco operace nad pevným úložištěm pracují po blocích s pevnou velikostí.",incorrect:"Soubory mají omezení na zarovnání, a operace nad pevným úložištěm nepracují po blocích s pevnou velikostí.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"d67fa53a-729c-41fe-9f45-533f05996fe6",correct:"Fyzické umístění dat souborů řeší operační systém a aplikace je od fyzického umístění odstíněna.",incorrect:"Fyzické umístění dat souborů řeší aplikace a operační systém se o fyzické umístění nestará.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"d36348e5-c140-42b4-9773-5709ee22b22b",correct:"Při prodlužování souboru souborový systém alokuje volné bloky a aktualizuje metadata souboru o nové bloky.",incorrect:"Při prodlužování souboru souborový systém nealokuje volné bloky, pouze aktualizuje metadata souboru.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"3ae61659-e12c-43ec-80b7-8625f2f3d5ad",correct:"Mapování souborů do paměti s líným načítáním zlepšuje efektivitu aplikací čtoucích data.",incorrect:"Mapování souborů do paměti s agresivním načítáním zlepšuje efektivitu aplikací čtoucích data.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"7e881440-4710-4579-bb86-70acd39cc971",correct:"Při mapování souborů do paměti mohou být externí stránky uloženy v běžném souboru na disku.",incorrect:"Při mapování souborů do paměti musí být externí stránky uloženy ve vyhrazené swapovací oblasti.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"1b828d87-bf6a-4dd9-a002-1a9f8d59a682",correct:"Mapování souborů do paměti umožňuje pracovat se soubory s menší režií než explicitní čtení a zápis.",incorrect:"Mapování souborů do paměti vyžaduje větší režii než explicitní čtení a zápis kvůli správě stránek.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"699f551a-a1d5-4271-a60e-e17f0c59a4c0",correct:"Operační systémy mohou optimalizovat čtení mapovaných souborů přemapováním stránek namísto kopírování dat, pokud jsou zarovnané.",incorrect:"Operační systémy vždy kopírují data při čtení mapovaných souborů, i když jsou operace zarovnané na stránky.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"79c73042-3244-4223-8429-8763861a9fc5",correct:"K souboru lze přistupovat z více vláken současně, pokud se jedná pouze o čtení.",incorrect:"K souboru lze přistupovat pouze z jednoho vlákna, i když se jedná pouze o čtení.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"76c9bd1e-a99d-4a4f-8367-6ecd9de6aa31",correct:"Při souběžném zápisu do souboru může dojít k hazardu souběhu, vyžadujícímu zamykání.",incorrect:"Při souběžném zápisu do souboru nikdy nedojde k hazardu souběhu, zamykání není nutné.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"603af444-98f3-46de-b1a9-722c904f80ff",correct:"Jmenný prostor souborového systému je sdílený mezi všemi procesy v operačním systému.",incorrect:"Jmenný prostor souborového systému je izolovaný pro každý proces v operačním systému.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"b1d43f04-ae07-4006-9931-82a0ab75cc2c",correct:"Operační systémy poskytují mechanismy zamykání souborů pro prevenci poškození dat při souběžném přístupu.",incorrect:"Operační systémy neposkytují mechanismy zamykání souborů, spoléhají se na programátory pro řešení souběžnosti.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"c2cbf28f-f1ae-43a6-9ff8-6f757c9c1640",correct:"Systémové volání `flock` v POSIX uzamkne pro proces celý soubor najednou.",incorrect:"Systémové volání `flock` v POSIX umožňuje zamknout pouze specifickou část souboru.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"8a2cb775-1ddd-416e-85b5-d3d574a4d60a",correct:"Systémové volání `fcntl` v POSIX umožňuje zamknout specifický rozsah bajtů v souboru.",incorrect:"Systémové volání `fcntl` v POSIX uzamkne vždy celý soubor, nikoliv jeho část.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"91636412-6a1e-4ca4-9d50-290ce73ae5fe",correct:"Spustitelné soubory obsahují počáteční obraz paměti, který se používá k inicializaci virtuálního adresního prostoru procesu.",incorrect:"Spustitelné soubory obsahují pouze instrukce programu a neobsahují data pro inicializaci paměti.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"c0141274-9f52-4242-be65-88bea26fcf26",correct:"Volání funkce exec v POSIX systémech inicializuje virtuální adresní prostor procesu z dat ve spustitelném souboru.",incorrect:"Volání funkce exec v POSIX systémech kopíruje data ze spustitelného souboru přímo do fyzické paměti.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"8f79db0d-e761-4978-b599-b0bc930ec277",correct:"Z hlediska souborového systému nejsou spustitelné soubory speciálním typem souborů.",incorrect:"Spustitelné soubory jsou v souborovém systému označeny jako speciální typ souborů.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"0403dccb-2263-4062-885b-d4fe2316a762",correct:"Data v rourách nejsou trvale uložena a po přečtení dat z roury zmizí.",incorrect:"Data v rourách se trvale ukládají na disk a zůstávají dostupná i po přečtení.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"14f3f70a-5c8c-49f7-880e-b51dfcbe5ca2",correct:"Roury využívají buffer v operační paměti pro dočasné uložení dat.",incorrect:"Roury pro ukládání dat využívají trvalé úložiště na pevném disku.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"3c416fe5-cf30-46da-b044-8dd1c64c1450",correct:"Pojmenované roury v POSIX mají jméno v souborovém systému, ale data nejsou trvale uložena.",incorrect:"Pojmenované roury v POSIX trvale ukládají data v souborovém systému pod svým jménem.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"b38d506e-1a5d-4bc5-aead-3391b7ab05c0",correct:"Anonymní roury jsou přístupné pouze skrze popisovače souborů a po uzavření zanikají.",incorrect:"Anonymní roury jsou trvale uloženy v souborovém systému a mají přidělené jméno.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"c04f4de2-f9e6-45d7-b205-3c15f9ad74ab",correct:"Znaková zařízení v operačních systémech se chovají podobně jako roury.",incorrect:"Znaková zařízení v operačních systémech se chovají podobně jako fronty.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"d3fc9ec8-ea05-4122-a646-7bc8a0a6b26b",correct:"Znaková zařízení reprezentují periferie jako soubory v operačním systému.",incorrect:"Znaková zařízení reprezentují periferie jako procesy v operačním systému.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"f3d4ec9a-e7bc-4f65-8369-3435c6e2ad67",correct:"Data zapsaná do znakového zařízení jsou odeslána do hardwarové periferie.",incorrect:"Data zapsaná do znakového zařízení jsou uložena do souboru na disku.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"00e972e0-1034-418f-ba1e-bffe79655c6b",correct:"Znaková zařízení umožňují čtení dat přicházejících z hardwarové periferie.",incorrect:"Znaková zařízení umožňují modifikaci dat přicházejících z hardwarové periferie.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"02894245-a3c5-40d2-9428-2ff1ee58178d",correct:"Tiskárna a skener jsou příklady znakových zařízení v operačním systému.",incorrect:"Tiskárna a monitor jsou příklady znakových zařízení v operačním systému.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"c09d0203-5957-4b5b-bb30-21c972567304",correct:"V cestách souborů se pro oddělení adresářů používá znak lomítko, avšak systémy Windows používají zpětné lomítko.",incorrect:"V cestách souborů se pro oddělení adresářů vždy používá znak zpětné lomítko, a to i v systémech typu POSIX.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"2ddc2654-8621-4316-98ae-6f7ab911877a",correct:"Cesty mohou být absolutní, začínající od kořenového adresáře, nebo relativní, vztažené k aktuálnímu pracovnímu adresáři.",incorrect:"Cesty jsou vždy absolutní a začínají od kořenového adresáře, relativní cesty v moderních operačních systémech neexistují.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"26ea8717-a7f3-42c8-bb66-f67a3fe6d9df",correct:"Kořenový adresář v souborovém systému POSIX je označen cestou s jedním dopředným lomítkem, tedy znakem '/'.",incorrect:"Kořenový adresář v souborovém systému je označen prázdnou cestou, která neobsahuje žádné znaky.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"5cebdc32-d69f-4c95-8e1f-a13ba395c6bd",correct:"Složka funguje jako slovník, kde klíčem je název souboru a hodnotou odkaz na i-uzel.",incorrect:"Složka funguje jako pole, kde indexem je pořadové číslo souboru a hodnotou obsah souboru.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"9be52149-6d36-4637-a205-6eeb68b33f7e",correct:"Složka obsahuje strukturovaná metadata, která mapují názvy souborů na odkazy, nikoliv obsah souborů.",incorrect:"Složka primárně obsahuje data souborů, a metadata slouží pouze pro organizaci zobrazení.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"362c5793-1d90-42fe-8120-fed62ad76427",correct:"Interakce uživatelských programů se složkami obvykle probíhá skrze cesty nebo iterací pro získání seznamu položek.",incorrect:"Uživatelské programy běžně interagují se složkami přímým čtením a zápisem datových struktur složky.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"302ba6d7-a3ef-42fd-8806-a7c4b9a608f3",correct:"V systémech POSIX se pro iteraci složek používají volání jako opendir, readdir a closedir.",incorrect:"V systémech POSIX se pro iteraci složek používají standardní volání read a write na souborovém deskriptoru.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"30d6e759-f291-4af2-804f-df02b39c3f17",correct:"Přidávání a odebírání položek ve složce se typicky provádí implicitně skrze operace s cestami, například vytvářením souborů.",incorrect:"Přidávání a odebírání položek ve složce vyžaduje přímou manipulaci s datovou strukturou složky pomocí speciálních systémových volání.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"4866e4ad-2edd-4c02-8db1-ca911cb98253",correct:"Stejný soubor může být odkazován z více adresářů pomocí tvrdých odkazů.",incorrect:"Stejný soubor může být odkazován pouze z jednoho adresáře pomocí tvrdých odkazů.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"61ce0d88-f59c-40e2-bab4-a6feb78f6506",correct:"Tvrdé odkazy umožňují, aby více adresářových položek odkazovalo na stejný i-uzel.",incorrect:"Tvrdé odkazy umožňují, aby pouze jedna adresářová položka odkazovala na stejný i-uzel.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"7f1f00cf-66b0-4e81-9d5d-a2682bf7936e",correct:"I-uzel souboru je zničen, až když počítadlo odkazů klesne na nulu.",incorrect:"I-uzel souboru je zničen ihned po odstranění posledního adresářového odkazu.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"2c7322ae-320f-41e8-88c4-3c0363f10c76",correct:"Odstranění adresářové položky nemusí vést ke smazání souboru kvůli tvrdým odkazům.",incorrect:"Odstranění adresářové položky vždy vede ke smazání souboru i při existenci tvrdých odkazů.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"58462193-9a73-469e-93c6-c9b5c84707ba",correct:"Se souborem lze pracovat i po odstranění všech adresářových odkazů, pokud existuje otevřený popisovač.",incorrect:"Se souborem nelze pracovat po odstranění všech adresářových odkazů, i když existuje otevřený popisovač.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"4ee31d72-a72f-4106-9851-7be68e51ad8b",correct:"Tvrdé odkazy nelze vytvářet mezi různými souborovými systémy.",incorrect:"Tvrdé odkazy lze vytvářet i mezi různými souborovými systémy.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"064fd70a-a4ec-4ecc-bddc-efb1f973d32f",correct:"Měkký odkaz je reprezentován samostatným i-uzlem v souborovém systému.",incorrect:"Měkký odkaz není reprezentován i-uzlem, ale přímo odkazuje na data souboru.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"94326c14-c987-4c25-a021-4674080395c0",correct:"Měkké odkazy mohou obsahovat cesty, které nemusí vést do stejného souborového systému.",incorrect:"Měkké odkazy musí vždy obsahovat cesty vedoucí do stejného souborového systému.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"27eb0462-298a-4a17-8d0b-652e974676ae",correct:"Operační systém při procházení měkkého odkazu čte cestu v něm obsaženou a pokračuje vyhledáváním.",incorrect:"Operační systém při procházení měkkého odkazu ignoruje cestu a pokračuje původní cestou.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"4ba544ff-4d83-4bdd-aa38-b7a810a43298",correct:"Cesta uložená v měkkém odkazu nemusí být platná a nemusí vést k existujícímu i-uzlu.",incorrect:"Cesta uložená v měkkém odkazu musí být vždy platná a vést k existujícímu i-uzlu.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"be139222-303b-4bd1-adf4-d5c2bc361990",correct:"Měkké odkazy umožňují vytvářet cykly v adresářové struktuře souborového systému.",incorrect:"Měkké odkazy jsou navrženy tak, aby nikdy nemohly vytvářet cykly v adresářové struktuře.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"4c8c038d-57e6-47ab-8a6a-8b89e68fb950",correct:"Adresářová struktura je sdílená mezi všemi procesy v systému.",incorrect:"Adresářová struktura je privátní a každý proces má svou vlastní.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"04a8b3a4-970f-4b4b-8b55-d42d98415295",correct:"Sdílená adresářová struktura může vést k problémům souběhu při manipulaci se soubory.",incorrect:"Sdílená adresářová struktura eliminuje problémy souběhu při práci se soubory.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"ffbbf3a7-a09b-4343-9914-fc40c00163bc",correct:"Globální adresářová struktura usnadňuje předávání souborů mezi různými programy.",incorrect:"Globální adresářová struktura komplikuje sdílení souborů mezi programy.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"5a33a3a5-c380-4dc0-8511-c4a79f6939f5",correct:"Uživatelé ocení globální adresářovou strukturu pro snazší orientaci a organizaci dat.",incorrect:"Globální adresářová struktura zhoršuje uživatelskou orientaci v systému.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"566950c1-4fc6-4bfd-bf53-54476f30f0a3",correct:"Sdílení adresářové struktury může představovat bezpečnostní riziko neautorizovaného přístupu.",incorrect:"Sdílení adresářové struktury zvyšuje bezpečnost a chrání před neautorizovaným přístupem.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"b7a17aa2-e84c-4268-9506-8069816d3858",correct:"Některé operační systémy částečně omezují sdílení adresářové struktury z důvodu bezpečnosti.",incorrect:"Operační systémy nikdy neomezují sdílení adresářové struktury, je vždy plně globální.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"c0d3dcf0-f255-42d2-a0db-06de0c382493",correct:"Datové struktury souborového systému musí minimalizovat počet bloků potřebných pro danou operaci.",incorrect:"Datové struktury souborového systému se primárně zaměřují na maximalizaci počtu bloků pro operaci.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"843aa1af-e6d7-41ea-8ccf-3b212f17e513",correct:"Robustnost vůči přerušení operací je klíčová vlastnost datových struktur souborového systému.",incorrect:"Pro datové struktury souborového systému není robustnost vůči přerušení operací důležitá.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"f68d87c3-1ff3-49ff-adf9-2c113561be2b",correct:"Klasické zřetězené seznamy nejsou vhodné pro souborové systémy kvůli mnoha navazujícím operacím s malým objemem dat.",incorrect:"Klasické zřetězené seznamy jsou ideální pro souborové systémy díky efektivnímu využití paměti.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"6faf312c-9805-453b-a03d-ab8c8a5c53c6",correct:"Vyvažování stromů rotacemi může být nevhodné pro souborové systémy kvůli riziku ztráty dat při přerušení.",incorrect:"Rotace pro vyvažování stromů jsou preferovanou metodou v souborových systémech pro zvýšení výkonu.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"53afcbfa-d539-4fd1-809c-cb27c35447bb",correct:"Bitmapa se v souborových systémech používá pro mapování volných a využitých datových bloků.",incorrect:"Bitmapa se v souborových systémech používá pro správu metadat souborů, nikoliv datových bloků.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"c6b827b4-d22d-4e56-890e-95db1c59e015",correct:"Každý bit v bitmapě reprezentuje stav jednoho datového bloku, typicky zda je blok volný nebo využitý.",incorrect:"Každý bit v bitmapě reprezentuje stav souboru a obsahuje informace o jeho oprávněních.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"a00ed7f7-5fed-47ef-963d-a3ae40ef93f1",correct:"Díky kompaktní reprezentaci bitmapy je možné rychle prohledávat velké diskové oblasti pro nalezení volného místa.",incorrect:"Kvůli nekompaktní reprezentaci bitmapy je prohledávání velkých diskových oblastí pomalé a neefektivní.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"d8b7ec4c-0eca-4fd5-8bef-677d91b84888",correct:"Zápis do bitmapy je považován za robustní, protože operace jsou jednoduché a bez složitých odkazů.",incorrect:"Zápis do bitmapy je náchylný k chybám kvůli složité struktuře odkazů mezi bity a datovými bloky.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"6c476412-5cc6-41be-b200-c770c55f8e09",correct:"Bitmapa umožňuje rychlé vyhledávání volných bloků i přesto, že asymptotická složitost vyhledávání je lineární.",incorrect:"Bitmapa je pomalá při vyhledávání volných bloků kvůli její logaritmické asymptotické složitosti.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"66e1682e-a826-4195-8c5c-a7c0aaddbc36",correct:"Tabulky v souborovém systému jsou souvislé oblasti paměti obsahující řádky fixní velikosti, obvykle navržené tak, aby se jich vešel celočíselný počet do bloku.",incorrect:"Tabulky v souborovém systému jsou souvislé oblasti paměti obsahující řádky fixní velikosti, jejichž velikost není závislá na velikosti bloku.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"425744f9-d4ac-402f-87c7-ea3cfec904fb",correct:"Pro alokaci řádků v tabulce se běžně používá bitmapa a pro odkazování na řádky stačí znát jejich index.",incorrect:"Pro alokaci řádků v tabulce se běžně používá spojový seznam a pro odkazování na řádky stačí znát jejich index.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"4db4754b-80c9-4c28-ae2a-49e4ca58e52f",correct:"Tabulky v souborovém systému jsou obvykle alokovány pevně při jeho vzniku, což může vést k neefektivnímu využití místa.",incorrect:"Tabulky v souborovém systému jsou obvykle alokovány dynamicky během běhu systému pro efektivnější využití místa.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"39d2f8b3-b080-44be-9f77-5c5990f7488f",correct:"B-stromy jsou samovyvažovací vyhledávací stromy s logaritmickou hloubkou a složitostí operací.",incorrect:"B-stromy nejsou samovyvažovací vyhledávací stromy s logaritmickou hloubkou a složitostí operací.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"03f26396-bbb9-4a3f-ac53-042aefe8c835",correct:"B-strom je n-ární strom, kde každý uzel může mít desítky až stovky potomků, což zmenšuje hloubku stromu.",incorrect:"B-strom je binární strom, kde každý uzel může mít desítky až stovky potomků, což zmenšuje hloubku stromu.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"775eeb55-07a3-4d05-9110-e966ddff4795",correct:"Optimalizace B-stromů pro blokové operace spočívá v nastavení velikosti uzlu na velikost diskového bloku.",incorrect:"Optimalizace B-stromů pro blokové operace nespočívá v nastavení velikosti uzlu na velikost diskového bloku.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"bbd9ee9c-56ca-483b-85e1-b5473a4a7eb5",correct:"B-stromy jsou univerzální datové struktury, které mohou reprezentovat adresáře a být základem souborových systémů.",incorrect:"B-stromy nejsou univerzální datové struktury, a nemohou reprezentovat adresáře ani být základem souborových systémů.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"6de774b6-3052-404f-b49e-fae8772b87d7",correct:"Kvůli složitosti implementace B-stromů může být obtížné zajistit konzistenci dat při operacích zápisu.",incorrect:"Kvůli jednoduchosti implementace B-stromů je snadné zajistit konzistenci dat při operacích zápisu.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"78ebd36e-decb-4efe-9eb5-917bacee5e4d",correct:"Konzistence metadat souborového systému může být narušena mezi daty a metadaty.",incorrect:"Konzistence metadat souborového systému může být narušena pouze v metadatech.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"951df37a-1ea9-4498-bf01-70f290cfbd42",correct:"Přerušení kritické operace, jako výpadek napájení, může způsobit nekonzistenci souborového systému.",incorrect:"Přerušení nekritické operace, jako restart aplikace, může způsobit nekonzistenci souborového systému.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"ed7076cc-5f4f-4727-baf9-9a5cd480f565",correct:"Narušení B-stromu, kdy uzel není platný, představuje porušení konzistence jednotlivé datové struktury.",incorrect:"Narušení B-stromu, kdy uzel není platný, představuje porušení konzistence mezi daty a metadaty.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"1c52c541-47f7-4320-90f1-2a758567057b",correct:"Konfliktní informace v bitmapě a metadatech tabulky je příkladem nekonzistence mezi strukturami.",incorrect:"Konfliktní informace uvnitř jedné bitmapy je příkladem nekonzistence mezi strukturami.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"441578eb-bc79-496d-8b32-b8bdd4e12618",correct:"Nesoulad mezi metadaty vlastníka souboru a daty uživatele v blocích je nekonzistence metadat a dat.",incorrect:"Nesoulad mezi metadaty vlastníka souboru a názvem souboru je nekonzistence metadat a dat.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"e283e896-453d-4d68-97d5-cfe06a9424a2",correct:"Žurnál souborového systému obsahuje sekvenci záznamů o akcích, které se mají provést, pro zajištění konzistence metadat.",incorrect:"Žurnál souborového systému obsahuje sekvenci záznamů o akcích, které se již provedly, pro urychlení zápisu metadat.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"5d100d7b-1bce-412c-9c8f-de8edab79991",correct:"Záznamy v žurnálu souborového systému jsou seskupeny do transakcí, které zaručují atomicitu operací s metadaty.",incorrect:"Záznamy v žurnálu souborového systému jsou seskupeny do transakcí, které primárně slouží k optimalizaci diskového prostoru.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"8e1c58c2-3b8b-4be1-9f52-de2dfbc8de64",correct:"Použití žurnálu v souborovém systému snižuje riziko poškození metadat a umožňuje rychlejší zotavení po havárii.",incorrect:"Použití žurnálu v souborovém systému zvyšuje riziko poškození metadat a zpomaluje zotavení po havárii.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"257dd988-b0bc-4213-8069-7d88e77920b9",correct:"Záznamy v žurnálu souborového systému musí být idempotentní, aby opakovaná aplikace záznamu nezpůsobila nekonzistenci.",incorrect:"Záznamy v žurnálu souborového systému nemusí být idempotentní, protože se nikdy neaplikují více než jednou.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"cc2d59e8-4b9c-453d-a054-b379b6b551f5",correct:"Souborový systém ext4 používá dvouúrovňový žurnál, kde JBD2 tvoří fyzickou vrstvu a fast commit logickou vrstvu.",incorrect:"Souborový systém ext4 používá pouze jedinou úroveň žurnálu, která kombinuje fyzické i logické aspekty operací.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"c983d92e-36af-494f-a9a0-58f356fab5e8",correct:"Při úpravě metadat se vytváří nová verze datové struktury namísto úpravy stávající.",incorrect:"Při úpravě metadat se datová struktura upravuje přímo na místě bez vytváření kopie.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"15e2271e-0243-4774-87aa-9260d9c0459f",correct:"Tento přístup je vhodný pro stromové datové struktury, jako jsou B-stromy v souborových systémech.",incorrect:"Tento přístup je nejvhodnější pro lineární datové struktury, jako jsou spojové seznamy.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"85a288ad-168a-47dc-bb66-4fe20c8799c7",correct:"Synchronizace zápisu nového kořene stromu zajišťuje konzistenci metadat.",incorrect:"Konzistence metadat je zajištěna i bez synchronizace zápisu nového kořene stromu.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"acdcc724-da35-42c4-970a-59bae12d7ec7",correct:"Cílem správy volných bloků je rychlé nalezení volného místa a minimalizace externí fragmentace.",incorrect:"Cílem správy volných bloků je pomalé nalezení volného místa a maximalizace externí fragmentace.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"67cccae3-203f-4d20-badd-9eef5589e410",correct:"Pro organizaci volných bloků se často používají bitmapy nebo B-stromy.",incorrect:"Pro organizaci volných bloků se často používají spojové seznamy nebo kruhové fronty.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"cc5195e6-b5e6-431d-aff0-2c471c27c93c",correct:"V B-stromě pro správu volných bloků může být klíčem adresa prvního bloku volné skupiny.",incorrect:"V B-stromě pro správu volných bloků musí být klíčem velikost volné skupiny.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"30b399d4-74fc-4ea6-add1-6ae75b64c938",correct:"Některé B-stromy pro volné bloky používají velikost volné oblasti jako hlavní klíč a adresu jako vedlejší.",incorrect:"Všechny B-stromy pro volné bloky používají velikost volné oblasti jako hlavní klíč.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"e55c8567-589b-41d7-adda-b70b1e427503",correct:"Některé souborové systémy rozdělují disk na alokační skupiny s vlastními bitmapami a i-uzly.",incorrect:"Všechny souborové systémy rozdělují disk na alokační skupiny s vlastními bitmapami a i-uzly.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"6b59a164-1c28-4b98-9cae-ae1bb317a709",correct:"Externí fragmentace nastává, když volné místo na disku není souvislé, například po smazání starých souborů.",incorrect:"Externí fragmentace popisuje situaci, kdy jsou data jednoho souboru uložena v nesouvislých blocích.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"740299c0-7f69-4cdd-958a-7f39d5b58ab6",correct:"Datová fragmentace souborů zhoršuje efektivitu čtení dat z disku kvůli nutnosti přeskakování mezi fragmenty.",incorrect:"Datová fragmentace zlepšuje efektivitu čtení souborů, protože data jsou lépe uspořádána.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"ccba3b3e-8896-4743-8d98-d196b77d5816",correct:"Fragmentace souborového systému vede ke zvětšení metadat potřebných pro správu souborů a jejich umístění.",incorrect:"Fragmentace souborového systému snižuje objem metadat nutných pro správu souborů na disku.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"f15b2938-46fc-4792-8ac7-b298115436e7",correct:"Extenty pro reprezentaci datových bloků souboru mohou být úspornější a efektivnější než tradiční tabulky přímých a nepřímých odkazů.",incorrect:"Extenty pro reprezentaci datových bloků souboru jsou vždy méně úsporné a méně efektivní než tradiční tabulky přímých a nepřímých odkazů.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"eefcae1f-b72d-49c0-8e23-7b7c72b2f391",correct:"Vyhledávání datového bloku podle offsetu v metadatech s extenty může být lineární v závislosti na délce tabulky extentů.",incorrect:"Vyhledávání datového bloku podle offsetu v metadatech s extenty je vždy konstantní bez ohledu na délku tabulky extentů.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"40622c0c-709b-4339-8fae-5e6cbbf7d842",correct:"Rozsahy (extenty) datových bloků lze kombinovat s tabulkami i B-stromy pro správu metadat souborů.",incorrect:"Rozsahy (extenty) datových bloků lze kombinovat pouze s B-stromy, nikoliv s tabulkami pro správu metadat souborů.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"70b8da5d-b87f-48f1-986e-be2508688710",correct:"Při čtení celého souboru je celková složitost přístupu k datům s extenty asymptoticky stejná, ale prakticky lepší než u tabulek jednotlivých bloků.",incorrect:"Při čtení celého souboru je celková složitost přístupu k datům s extenty asymptoticky horší a prakticky horší než u tabulek jednotlivých bloků.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"d757b1fc-6c3a-4145-9f2f-22cb7a63dab0",correct:"Vnitřní fragmentace vzniká, protože soubory se ukládají v blocích pevné velikosti.",incorrect:"Vnitřní fragmentace nevzniká, protože soubory se ukládají v blocích pevné velikosti.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"a020500e-11ea-4f67-b09f-a70175b78f19",correct:"Zarovnání souborů na hranice bloků může vést k vnitřní fragmentaci paměti.",incorrect:"Zarovnání souborů na hranice bloků vždy zabraňuje vnitřní fragmentaci paměti.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"dfbd0f22-436b-47f8-b008-25987272d2d8",correct:"Vnitřní fragmentace představuje nevyužité místo uvnitř alokovaných bloků souboru.",incorrect:"Vnitřní fragmentace představuje nevyužité místo mezi alokovanými bloky souboru.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"9e9f636e-a105-46ae-8618-7e3de0b23772",correct:"Klasické reprezentace složek mají lineární složitost vyhledávání, což je neefektivní pro velké adresáře.",incorrect:"Klasické reprezentace složek mají konstantní složitost vyhledávání, což je efektivní i pro velké adresáře.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"510f5a04-1d5f-40e6-8da5-923b8f250ef0",correct:"Hašované složky ukládají položky do hašovací tabulky, iterace vrací položky v náhodném pořadí.",incorrect:"Hašované složky ukládají položky seřazené podle jména, iterace vrací položky v uspořádaném pořadí.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"3164a9bb-9316-498a-a649-bd7bb7c59437",correct:"Stromové složky využívají B-stromy v metadatech, operace mají logaritmickou časovou složitost.",incorrect:"Stromové složky využívají hašovací tabulky v datových blocích, operace mají konstantní časovou složitost.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"f64407c0-5b10-4dc2-9b2a-9a1492088c1c",correct:"Pro malé složky může být klasická reprezentace dostačující, ale pro velké se stává nepraktickou.",incorrect:"Pro malé složky je stromová reprezentace nejefektivnější, zatímco klasická je vždy nepraktická.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"6e6431c7-7ea0-4a4d-96a2-dfc621e14210",correct:"Stromové složky zaručují logaritmickou složitost všech operací a vrací položky seřazené podle jména.",incorrect:"Stromové složky zaručují konstantní složitost všech operací a vrací položky v náhodném pořadí.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"}]},{uuid:"1ad5b698-0291-4fa7-8feb-bbbc27c26bfd",sectionNumber:"4",sectionTitle:"Virtualizace periferií",statements:[{uuid:"c442e1b1-24b2-4fd4-8752-107218aefeb8",correct:"Řadiče sběrnic jsou považovány za pomocná vnitřní zařízení počítače.",incorrect:"Řadiče sběrnic jsou považovány za perzistentní úložiště dat.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"54e5ec88-217d-44bc-8038-39ca23e0692a",correct:"Perzistentní úložiště slouží k dlouhodobému uchování dat i po vypnutí napájení.",incorrect:"Perzistentní úložiště slouží pouze k dočasnému uchování dat během běhu programu.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"20fea280-a7a7-4b12-968a-a3b4518bdf8f",correct:"Síťová rozhraní umožňují počítačům komunikovat a vyměňovat si data v síti.",incorrect:"Síťová rozhraní slouží výhradně pro komunikaci s vnitřními komponentami počítače.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"ef17f393-6b0b-46a3-a842-1f51c66c27ab",correct:"Terminál zahrnuje obrazovku, klávesnici a další periferie pro interakci uživatele s počítačem.",incorrect:"Terminál se skládá pouze z centrální procesorové jednotky a operační paměti.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"2a05b7e4-f2bd-4bc4-92c0-43503205885c",correct:"Mezi součásti terminálu patří vstupní zařízení jako klávesnice a myš.",incorrect:"Mezi součásti terminálu patří výhradně výstupní zařízení jako tiskárny a skenery.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"516b3315-6735-4f3f-9206-ae40781f98ef",correct:"Mapování registrů zařízení na fyzické adresy se typicky používá pro komunikaci s malým objemem dat.",incorrect:"Mapování registrů zařízení na fyzické adresy se typicky používá pro komunikaci s velkým objemem dat.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"e916a8c7-65da-4149-98f6-3d99d0e2f3b4",correct:"Registry zařízení se liší od registrů procesoru a představují paměťové buňky s pevnou funkcí.",incorrect:"Registry zařízení jsou identické s registry procesoru a nemají pevnou funkci.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"d81f6da8-c88c-4a1f-9d63-7c6fbbf3c4b9",correct:"Hodnoty v registrech zařízení se mohou měnit samovolně bez přímého zásahu hlavního procesoru.",incorrect:"Hodnoty v registrech zařízení se mohou měnit pouze přímým zásahem hlavního procesoru.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"87014756-1f09-43dd-b78a-61642118b612",correct:"Princip FIFO u paměti zařízení znamená, že nejstarší data jsou přepsána novými po zaplnění.",incorrect:"Princip FIFO u paměti zařízení znamená, že nejnovější data jsou přepsána starými po zaplnění.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"4144d03c-9c1b-4a29-90b4-c37809aeac16",correct:"Programované I/O vyžaduje aktivní účast procesoru v pravidelných časových intervalech.",incorrect:"Programované I/O nevyžaduje aktivní účast procesoru v pravidelných časových intervalech.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"b5969363-4b22-4309-9d3d-8973a18c2ae6",correct:"Programované I/O je vhodné pro občasné přenosy nebo přenosy s malou šířkou pásma.",incorrect:"Programované I/O je vhodné pro velké objemy dat a kontinuální přenosy s vysokou šířkou pásma.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"b3c51b53-856f-47c8-920c-3e25bfdb6a79",correct:"Při velkých objemech dat vede programované I/O k vysoké režii.",incorrect:"Při velkých objemech dat vede programované I/O k nízké režii.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"9226b603-b4a2-432b-b2cb-3c1fcfa29a51",correct:"DMA přenosy umožňují periferiím asynchronně zapisovat data přímo do operační paměti bez přímé účasti CPU při samotném přenosu.",incorrect:"DMA přenosy vyžadují aktivní účast hlavního procesoru při každém přenosu dat mezi periferií a operační pamětí.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"d7494bef-eb96-4f2a-a749-3a7267ae4174",correct:"V moderních počítačových systémech je běžnější, že DMA přenosy jsou řízeny přímo periferií, což zvyšuje efektivitu.",incorrect:"Dedikovaný pomocný procesor je v moderních systémech běžnější metodou pro řízení DMA přenosů než přímé řízení periferií.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"1bb1bca3-0650-46b5-a490-b1d85c57b8b3",correct:"DMA se často využívá pro periferie jako SSD disky a grafické karty, kde jsou vyžadovány časté a velké přenosy dat.",incorrect:"DMA se obvykle nepoužívá pro SSD disky a grafické karty, protože tyto periferie obvykle nevyžadují rychlé přenosy dat.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"c2a7599f-4ec1-48f3-99d7-cbd5ac522725",correct:"Při DMA přenosu na sdílené sběrnici se periferie dočasně stává řídícím zařízením sběrnice pro provedení přenosu.",incorrect:"Při DMA přenosu na sdílené sběrnici zůstává procesor vždy řídícím zařízením sběrnice a periferie nemůže převzít kontrolu.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"d1b5dede-9f4e-4224-bf15-74b9a4eb3aab",correct:"Rozdíl mezi DMA a mapováním paměti zařízení spočívá v tom, že DMA obchází procesor při komunikaci s pamětí.",incorrect:"DMA a mapování paměti zařízení jsou v podstatě totožné mechanismy pro přímý přístup procesoru k periferiím.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"d24d99a4-927a-4036-8b26-7ff1fea11037",correct:"Klasická implementace DMA představuje bezpečnostní riziko kvůli neomezenému přístupu periferií do fyzické paměti.",incorrect:"Klasická implementace DMA je zcela bezpečná, protože operační systém plně kontroluje přístup periferií do paměti.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"aa1f9096-ed6b-4af8-8022-e33aedaf54cc",correct:"IO-MMU řeší bezpečnostní rizika DMA tím, že zavádí překlad adres pro periferie, podobně jako MMU pro software.",incorrect:"IO-MMU primárně zvyšuje výkon DMA operací, nikoliv řeší bezpečnostní rizika spojená s přímým přístupem do paměti.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"a8f885ff-21f6-4955-abf0-50def37cf24e",correct:"IO-MMU je programovatelná výhradně operačním systémem, což zajišťuje kontrolu nad přístupem periferií do paměti.",incorrect:"IO-MMU mohou programovat i ovladače periferií, což umožňuje flexibilnější správu paměťových přístupů.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"f6716fa2-41d8-4f50-8af9-0035d02a885d",correct:"Sběrnice se skládá z fyzické a logické vrstvy, kde logická vrstva řeší adresaci a konfiguraci zařízení.",incorrect:"Sběrnice se skládá pouze z fyzické vrstvy, která se stará o veškerou komunikaci a konfiguraci zařízení.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"3cb3b012-1fcd-47b7-8a7b-cbd5267a5697",correct:"Řadič sběrnice je typ periferie, s nímž procesor komunikuje a který rozděluje adresní prostor.",incorrect:"Řadič sběrnice není periferie, ale pouze pasivní prvek propojující různé typy sběrnic.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"e0c2664f-310e-4efb-91c3-1cdb0b34ec97",correct:"Hlavním úkolem sběrnice je přenos dat a signalizace událostí, přičemž události se mohou projevit jako přerušení.",incorrect:"Hlavním úkolem sběrnice je pouze konfigurace připojených periferií a nikoliv přenos dat mezi nimi.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"7092f638-5262-4323-bf3e-017b7aef0bab",correct:"Procesory Intel Skylake propojují jádra, GPU a cache pomocí sběrnice Ring Bus.",incorrect:"Procesory Intel Skylake propojují jádra a paměť pomocí sběrnice PCIe.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"daa2b10a-fa06-447f-b4d3-7ceab3173eee",correct:"Na sběrnici PCIe mohou být připojeny NVMe úložiště, síťová rozhraní a řadiče USB.",incorrect:"Na sběrnici PCIe jsou připojeny výhradně paměťové moduly RAM a žádná jiná zařízení.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"9df852a8-d2f9-4f6f-a73a-d5d770422409",correct:"Enumerace sběrnice umožňuje operačnímu systému zjistit připojené periferie automaticky.",incorrect:"Enumerace sběrnice vyžaduje manuální konfiguraci uživatelem pro zjištění připojených periferií.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"a0e81b81-1b8e-4c8f-8689-8892540e2a1e",correct:"Moderní sběrnice poskytují unikátní identifikátory zařízení pro automatickou konfiguraci ovladačů.",incorrect:"Unikátní identifikátory zařízení nejsou poskytovány moderními sběrnicemi pro konfiguraci ovladačů.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"3829e707-1950-47e4-bfaa-d64d3b66bf97",correct:"Historická sběrnice ISA nepodporovala enumeraci, vyžadovala konfiguraci adres uživatelem.",incorrect:"Historická sběrnice ISA podporovala enumeraci periferií automaticky bez zásahu uživatele.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"c0894816-a2ff-4286-b44b-a248bf6c8814",correct:"Enumerace sběrnice zahrnuje vyjmenování periferií a jejich základních parametrů pro OS.",incorrect:"Enumerace sběrnice se omezuje pouze na zjištění přítomnosti periferií bez parametrů.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"b35c90ec-d7fe-441e-ac5f-bf30e0fc8215",correct:"Ovladač zařízení je program, který poskytuje softwarovou abstrakci dané třídy zařízení operačnímu systému.",incorrect:"Ovladač zařízení je hardware, který obsluhuje periferie a je zcela nezávislý na operačním systému.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"33c3185f-9c59-4025-9d5d-cb80bbe56379",correct:"Hlavním úkolem ovladače je převod dat mezi formou, kterou poskytuje zařízení, a formou, kterou vyžaduje operační systém.",incorrect:"Hlavním úkolem ovladače je pouze zajistit fyzický přenos dat mezi zařízením a operační pamětí bez nutnosti konverze dat.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"2ab06248-83d9-4011-9e84-1c9e68c8a275",correct:"Ovladače sběrnic jsou využívány ovladači periferií pro komunikaci se zařízeními, která jsou připojena přes danou sběrnici.",incorrect:"Ovladače periferií obcházejí ovladače sběrnic a komunikují přímo s hardwarem sběrnice pro zvýšení výkonu.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"31cfcd1a-d19d-4226-8434-6f2782a757bf",correct:"Komunikace s periferiemi skrze ovladače zahrnuje čtení a zápis dat, což představuje výpočetní operace pro zpracování datových formátů.",incorrect:"Komunikace s periferiemi je čistě hardwarová záležitost, která se obejde bez jakýchkoliv výpočetních operací na straně ovladače.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"cde8819f-a382-4af1-9bfc-f1cd8dae03d9",correct:"Ovladače zpracovávají nejen užitná data, ale i řídící data, která konfigurují chování zařízení a aktivují specifické funkce.",incorrect:"Ovladače se starají výhradně o přenos užitných dat, řízení a konfigurace zařízení je plně v kompetenci operačního systému.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"6d66ee01-6710-43a7-9ec1-0a603666ca96",correct:"Fyzický terminál se skládá z výstupní i vstupní části, jako je obrazovka a klávesnice.",incorrect:"Fyzický terminál se skládá pouze z výstupní části, jako je například obrazovka.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"d8a85e66-fe73-45b4-bf71-8d45dd9ceeda",correct:"Virtualizace terminálů umožňuje vytvořit více virtuálních terminálů, než je fyzických zařízení.",incorrect:"Virtualizace terminálů omezuje počet virtuálních terminálů na počet fyzických zařízení.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"d12bdde1-fe4a-4f3a-b578-f88e8d350886",correct:"Pro virtualizaci textového terminálu je nezbytné zapamatovat si obsah obrazovky v operační paměti.",incorrect:"Pro virtualizaci textového terminálu není nutné ukládat obsah obrazovky do operační paměti.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"4117834d-e0d1-457a-adae-e4c0bf89e145",correct:"Aktivace virtuálního terminálu způsobí, že se obsah fyzické obrazovky přepíše uloženým obsahem.",incorrect:"Aktivace virtuálního terminálu nemá vliv na obsah fyzické obrazovky a její zobrazení.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"ecfb6fe2-1437-428e-b40d-52ec356a68d0",correct:"Připojení a odpojení fyzické klávesnice od virtuálního terminálu neovlivní běžící program.",incorrect:"Odpojení fyzické klávesnice od virtuálního terminálu vždy způsobí pád běžícího programu.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"cb41fa33-7682-4bd0-9b03-e1d98aa16747",correct:"Synchronizace přepojování klávesnice a obrazovky zajišťuje, že obrazovka zobrazuje terminál s připojenou klávesnicí.",incorrect:"Přepojování klávesnice a obrazovky u virtuálních terminálů probíhá zcela nezávisle na sobě.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"15a1e831-80a2-43ef-89fa-968d6d465610",correct:"Na virtuálním terminálu je vždy aktivní právě jeden program, který ovládá terminál a zobrazuje výstup.",incorrect:"Na virtuálním terminálu může být aktivních více programů současně, které sdílí ovládání terminálu.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"4880efd2-11df-4737-a8f6-8e68525c3941",correct:"V řádkovém režimu terminálu se text vypisuje pouze do jednoho řádku, přičemž scrollování posouvá starší řádky pryč.",incorrect:"V řádkovém režimu terminálu se text vypisuje do více řádků současně bez scrollování.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"abcf776b-81d6-4247-8897-5a9ca5946d92",correct:"Obrazovkový režim terminálu umožňuje programům cíleně měnit obsah libovolného políčka na obrazovce.",incorrect:"Obrazovkový režim terminálu omezuje programy pouze na změnu aktuálního řádku.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"a89b33da-82f5-4e2c-be91-b86031bad4a0",correct:"Virtuální terminál může být emulován grafickou aplikací, čímž není nutná fyzická přítomnost terminálu.",incorrect:"Virtuální terminál vyžaduje fyzické zařízení a nemůže být emulován softwarovou aplikací.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"632acf0e-a403-433e-99de-6f611dcc3abf",correct:"Přes síťové spojení, například pomocí ssh, může být virtuální terminál zobrazen na vzdáleném počítači.",incorrect:"Virtuální terminál je vždy zobrazen pouze na lokálním počítači a nemůže být sdílen přes síť.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"8a8efd6e-9157-44c1-96c8-7e443b24b1f5",correct:"Virtuální klávesnice buď přeposílá data z fyzické klávesnice, nebo je nulová.",incorrect:"Virtuální klávesnice vždy aktivně zpracovává data a nikdy není nulová.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"5b5f2597-a5e9-4f51-a2bc-4c589f87c767",correct:"K fyzické klávesnici je obvykle připojena jedna virtuální klávesnice.",incorrect:"K fyzické klávesnici může být připojeno více virtuálních klávesnic současně.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"4b51febc-a2f9-44bf-beab-bf3842c88bd6",correct:"Programy v neaktivních virtuálních terminálech jsou typicky připojeny k nulové klávesnici.",incorrect:"Programy v neaktivních virtuálních terminálech jsou aktivně obsluhovány fyzickou klávesnicí.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"41d1da81-2b23-4a33-924c-639ddb30ae25",correct:"Virtuální klávesnice může být řízena programem, například u vzdáleného terminálu.",incorrect:"Virtuální klávesnice je vždy řízena fyzickým uživatelem, nikoliv programem.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"2afcdef8-64e1-4356-bc22-76f66b154eae",correct:"V grafickém režimu jsou buňky s písmeny nahrazeny pixely, což umožňuje flexibilnější zobrazení.",incorrect:"V grafickém režimu jsou pixely nahrazeny buňkami s písmeny, což zachovává omezení textového terminálu.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"9f7a8349-0c21-424e-99c6-6329176349fc",correct:"Virtualizace vstupu v grafickém režimu má podobná omezení jako virtualizace vstupu v textovém režimu.",incorrect:"Virtualizace vstupu v grafickém režimu je výrazně flexibilnější než virtualizace vstupu v textovém režimu.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"27972471-d3ab-4c64-9e1d-876b487ed8f9",correct:"Grafická obrazovka nabízí flexibilnější metody virtualizace výstupu oproti textové obrazovce.",incorrect:"Textová obrazovka nabízí flexibilnější metody virtualizace výstupu oproti grafické obrazovce.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"97f42306-3d95-4ffb-bbda-556c3e683ee5",correct:"Každá aplikace v okenním systému obdrží svou vlastní virtuální obrazovku.",incorrect:"Pouze některé aplikace v okenním systému obdrží svou vlastní virtuální obrazovku.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"e6322595-e3ac-4d22-96a4-18482518c9db",correct:"Virtuální obrazovky aplikací jsou zobrazeny jako okna, s nimiž může uživatel manipulovat.",incorrect:"Virtuální obrazovky aplikací jsou zobrazeny jako okna, s nimiž uživatel nemůže manipulovat.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"fea0681f-a210-4c76-a285-d19300046b80",correct:"Chování oken, včetně jejich zobrazení a ovládání, se může lišit v závislosti na konkrétním okenním systému.",incorrect:"Chování oken, včetně jejich zobrazení a ovládání, je jednotné napříč všemi okenními systémy.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"22d3bf83-7569-4382-a9b6-419d5369325a",correct:"Okenní systém virtualizuje klávesnici a události ukazovacích zařízení pro aktivní okno.",incorrect:"Okenní systém virtualizuje pouze klávesnici, ale ne události ukazovacích zařízení.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"953070d9-6925-4105-b71f-4aff7b2dce40",correct:"Rozhraní mobilních telefonů, umožňující přepínání mezi aplikacemi, lze považovat za formu okenního systému.",incorrect:"Rozhraní mobilních telefonů, umožňující přepínání mezi aplikacemi, nelze považovat za formu okenního systému.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"dcf24305-d985-484f-96ca-6f0cd01e2c55",correct:"Rasterizace, neboli výpočet barev pixelů, je výpočetně náročný proces, jehož náročnost roste s počtem pixelů a složitostí scény.",incorrect:"Rasterizace, neboli výpočet barev pixelů, je výpočetně nenáročný proces, jehož náročnost klesá s počtem pixelů a složitostí scény.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"e2326424-9d4a-412b-902d-235ba0cf2330",correct:"Moderní GPU využívají virtualizaci s hardwarovými kontexty pro efektivní sdílení mezi více aplikacemi.",incorrect:"Moderní GPU nepodporují virtualizaci a nemohou být efektivně sdíleny mezi více aplikacemi.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"94ce95d9-11c9-480c-9761-0c37ab8de0b1",correct:"Výpočet pixelů pomocí GPU typicky zahrnuje uložení vypočtených pixelů do paměti.",incorrect:"Výpočet pixelů pomocí GPU se obejde bez nutnosti ukládat vypočtené pixely do paměti.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"cad0b46f-df05-43f4-9629-f2bfb10f079c",correct:"Specializovaný hardware GPU urychluje rasterizaci mimo jiné díky efektivní virtualizaci přepínáním kontextů.",incorrect:"Specializovaný hardware GPU urychluje rasterizaci, ale virtualizace přepínáním kontextů s tím nesouvisí.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"5aa360ec-34d3-4f43-bd56-31f6d531b5ec",correct:"Přístup CPU do paměti je nákladný, obzvláště pokud vyžaduje načítání dat pro výpočet barvy pixelu.",incorrect:"Přístup CPU do paměti je rychlý a nenákladný, a to i při načítání dat pro výpočet barvy pixelu.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"e0e58789-62c8-4abe-bc91-1d3a45416c45",correct:"Výstupní část okenního systému, kompozitor, skládá obrázky aplikací do jednoho snímku.",incorrect:"Vstupní část okenního systému, kompozitor, skládá obrázky aplikací do jednoho snímku.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"0125d2a4-3559-47c6-bc1c-bacbb9fcec58",correct:"Pro výpočet snímku kompozitor obvykle využívá GPU, čímž šetří operační paměť.",incorrect:"Pro výpočet snímku kompozitor obvykle využívá CPU, čímž šetří operační paměť.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"98e4d2ac-42f3-4ac8-a963-1cbe65af21c4",correct:"Kompozitor musí spolupracovat se vstupní částí systému kvůli správnému zpracování souřadnic událostí.",incorrect:"Kompozitor nemusí spolupracovat se vstupní částí systému, protože souřadnice událostí jsou irelevantní.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"300bfcd3-4f37-4f98-8e74-fa136b707300",correct:"V okenním systému s kompozitorem je každá aplikace odpovědná za vykreslování vlastních pixelů.",incorrect:"V okenním systému s kompozitorem je kompozitor odpovědný za vykreslování pixelů všech aplikací.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"90c82156-bebd-4611-a073-6fe2c25a0be4",correct:"Grafický server je alternativní metoda virtualizace grafického podsystému.",incorrect:"Grafický server je primární metoda virtualizace grafického podsystému.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"f03b45ca-e63d-4533-a44a-ae3504dea905",correct:"Grafický server přijímá příkazy vyšší úrovně pro vykreslování 2D a 3D objektů.",incorrect:"Grafický server přijímá příkazy na úrovni jednotlivých pixelů pro vykreslování.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"5c84ea94-0299-434a-aa36-d40e9f9839cc",correct:"Grafický server má plnou kontrolu nad obsahem obrazovky.",incorrect:"Grafický server nemá žádnou kontrolu nad obsahem obrazovky.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"892dcef4-075e-47e7-8ee0-a63bd8517a38",correct:"Použitím grafického serveru se může objem přenášených dat zmenšit oproti rastrové reprezentaci.",incorrect:"Použitím grafického serveru se objem přenášených dat zvětší oproti rastrové reprezentaci.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"96f0d698-4f24-4d15-ac68-cfd965db5095",correct:"Grafický server usnadňuje vzdálené vykreslování díky menšímu objemu přenášených dat.",incorrect:"Grafický server znesnadňuje vzdálené vykreslování kvůli většímu objemu přenášených dat.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"b911b290-ce6a-4920-bc9c-90832459ff0b",correct:"Grafický server může pro rasterizaci využívat hardware.",incorrect:"Grafický server nikdy pro rasterizaci nevyužívá hardware.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"bbe200ad-eeb2-4b5f-8cf1-97f70659fc13",correct:"Výstup zvukového rozhraní lze virtualizovat mixováním několika zvukových proudů do jednoho.",incorrect:"Výstup zvukového rozhraní lze virtualizovat pouze přepínáním zvukových proudů, nikoliv mixováním.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"be8a2c25-769e-40b9-9167-096aaac58b7e",correct:"Vstup zvukového rozhraní, například mikrofon, lze v operačním systému pouze přepínat, nikoliv mixovat.",incorrect:"Vstup zvukového rozhraní, například mikrofon, lze v operačním systému mixovat i přepínat současně.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"22a740b9-0fd4-4d4d-b416-5e5288e766f9",correct:"Větší vyrovnávací paměť zvukového subsystému snižuje pravděpodobnost výpadku zvuku, ale zvyšuje latenci.",incorrect:"Větší vyrovnávací paměť zvukového subsystému zvyšuje pravděpodobnost výpadku zvuku a snižuje latenci.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"10fbe5ce-d8cb-4ec6-a2d3-98d8f2d2dc75",correct:"Zvuková rozhraní, podobně jako grafické zobrazení, jsou v operačních systémech citlivá na latenci a nepřerušenost datového proudu.",incorrect:"Zvuková rozhraní, na rozdíl od grafického zobrazení, nejsou v operačních systémech citlivá na latenci a nepřerušenost datového proudu.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"c1523ff2-46f4-457c-8f5a-cf5247784ca8",correct:"Tiskárny jsou z pohledu operačního systému charakteristické dávkovým zpracováním úloh.",incorrect:"Tiskárny jsou z pohledu operačního systému charakteristické interaktivním zpracováním úloh.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"c0855a42-b3ef-4d13-b69c-2d8ad625d97a",correct:"Virtualizace tiskáren je řešena frontou úloh, což je analogické k plánování úloh v dávkových systémech.",incorrect:"Virtualizace tiskáren je řešena interaktivním plánováním úloh, na rozdíl od dávkových systémů.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"0ef94a64-ba76-4a6b-8274-612865e159d2",correct:"Abstrakce tiskáren v operačním systému má za cíl skrýt rozdíly mezi různými modely tiskáren pro aplikace.",incorrect:"Abstrakce tiskáren v operačním systému má za cíl zdůraznit rozdíly mezi různými modely tiskáren pro aplikace.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"30340687-0308-47de-9855-7bb60bce5dfc",correct:"PDF a PostScript slouží jako formáty pro popis dokumentů, které mají zahladit rozdíly mezi tiskárnami.",incorrect:"PDF a PostScript slouží jako formáty pro popis dokumentů, které jsou specifické pro konkrétní tiskárny.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"cf73bc7b-46e9-481a-944d-768853fc3da4",correct:"Některé síťové tiskárny mohou obsahovat interní frontu úloh, čímž virtualizaci řeší i mezi počítači.",incorrect:"Síťové tiskárny nikdy neobsahují interní frontu úloh, virtualizaci vždy plně řeší operační systém.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"e1adf9c7-8ec3-417e-909c-9a497e8dfe25",correct:"Základní funkcí počítačové sítě je umožnit komunikaci a přenos dat mezi počítači.",incorrect:"Základní funkcí počítačové sítě je pouze fyzicky propojit počítače, nikoliv přenášet data.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"1e192443-1499-4e96-8ac2-abd137378460",correct:"Pro připojení k síti počítače využívají síťová rozhraní a propojovací média, která mohou být drátová.",incorrect:"Pro připojení k síti počítače využívají pouze síťová rozhraní, propojovací média nejsou nutná.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"1dfeb48c-6f92-4ac2-9aa7-58d8e8abe5e3",correct:"Síťové rozhraní se připojuje k počítači sběrnicí a k síti přenosovým médiem, podobně jako řadič sběrnice.",incorrect:"Síťové rozhraní se připojuje k počítači přímo, bez sběrnice, a k síti přenosovým médiem.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"56087fc0-e7ac-4835-9137-635c3d26f325",correct:"Architektura počítačové sítě se liší od sběrnice absencí význačného centrálního prvku.",incorrect:"Architektura počítačové sítě je identická se sběrnicí, včetně centrálního prvku.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"cc4ff1e0-f837-49d6-8f19-cb23a62c3432",correct:"Fyzická vrstva ISO/OSI modelu je primárně záležitostí hardwaru.",incorrect:"Fyzická vrstva ISO/OSI modelu je primárně záležitostí operačního systému.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"ebd98871-5672-4e32-aca9-91940aba2576",correct:"Linková vrstva ISO/OSI modelu tvoří rozhraní mezi hardwarem a operačním systémem.",incorrect:"Linková vrstva ISO/OSI modelu je primárně aplikační vrstvou.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"ea4b089d-cbf3-4c2c-842a-da2409821079",correct:"Síťová vrstva ISO/OSI modelu zajišťuje komunikaci mezi koncovými uzly.",incorrect:"Síťová vrstva ISO/OSI modelu se zabývá doručováním dat mezi aplikacemi.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"4f2681de-6f21-45c7-81a2-b4a38956cb87",correct:"Virtualizace se v ISO/OSI modelu typicky uplatňuje mezi transportní a aplikační vrstvou.",incorrect:"Virtualizace se v ISO/OSI modelu typicky uplatňuje mezi linkovou a síťovou vrstvou.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"606b02d4-3c45-442c-895b-cceb6bc2eef7",correct:"Vrstvy 1 a 2 ISO/OSI modelu jsou převážně hardwarové, vrstvy 3 a 4 převážně softwarové.",incorrect:"Vrstvy 1 a 2 ISO/OSI modelu jsou převážně softwarové, vrstvy 3 a 4 převážně hardwarové.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"b492a33c-349f-4bbd-906c-01102edfd6b7",correct:"Abstrakce pro potřeby operačního systému se nachází mezi druhou a třetí vrstvou.",incorrect:"Abstrakce pro potřeby operačního systému se nachází mezi čtvrtou a pátou vrstvou.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"65510fb6-54b1-4d07-92bb-8e6836720976",correct:"Virtualizace síťové komunikace je hlavně založena na multiplexingu paketů.",incorrect:"Virtualizace síťové komunikace není založena na principu multiplexingu paketů.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"c207fd6e-3876-4f3a-9c9b-71e360902944",correct:"Adresa aplikace v síti se skládá z adresy uzlu a čísla portu.",incorrect:"Adresa aplikace v síti se skládá pouze z adresy uzlu, bez portu.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"274494fe-069a-4eb5-ae75-50fcc1f2c31d",correct:"Pro aplikační potřeby se virtualizace i abstrakce nachází mezi čtvrtou a pátou vrstvou.",incorrect:"Pro aplikační potřeby se virtualizace i abstrakce nachází mezi druhou a třetí vrstvou.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"7c8ede80-8a49-46b8-a9d4-9dc27f9d7992",correct:"Čtvrtá vrstva síťového modelu přidává virtuální koncové body aplikací pomocí portů.",incorrect:"Třetí vrstva síťového modelu přidává virtuální koncové body aplikací pomocí portů.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"879e8a1d-1102-4f59-81bf-c77829ada6f4",correct:"Operační systém přímo komunikuje pouze s částí MAC ethernetového rozhraní.",incorrect:"Operační systém přímo komunikuje s fyzickou i MAC vrstvou ethernetového rozhraní.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"a7d7accf-f799-445a-a8fc-d98345646aa6",correct:"Ethernetový rámec obsahuje preambuli, která slouží k synchronizaci přijímače.",incorrect:"Ethernetový rámec obsahuje preambuli, která slouží k adresování cílového zařízení.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"1fdb217e-238a-4e58-9a37-a264ecbe17f6",correct:"V moderním Ethernetu se propojování point-to-point realizuje pomocí aktivních přepínačů.",incorrect:"V moderním Ethernetu se propojování point-to-point realizuje pomocí pasivních hubů.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"b88139f8-d8d1-4544-bee0-619518342e79",correct:"Maximální velikost užitných dat v ethernetovém rámci je patnáct set bajtů.",incorrect:"Maximální velikost užitných dat v ethernetovém rámci je šestnáct set bajtů.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"b899da8c-5a65-40a4-87e9-78a4dd10c8c2",correct:"Adresace na ethernetové úrovni funguje pouze lokálně v rámci segmentu.",incorrect:"Adresace na ethernetové úrovni funguje globálně napříč sítěmi.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"92ea230d-d3b8-4335-aa82-e71abdd5bc9d",correct:"Každé ethernetové rozhraní má přidělenu tovární MAC adresu pro identifikaci.",incorrect:"MAC adresa ethernetového rozhraní je přidělena operačním systémem.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"5f0b95e2-61b3-4235-9778-7714f3d9b0ea",correct:"Přepínače v ethernetové síti mapují MAC adresy na porty pro přeposílání rámců.",incorrect:"Přepínače v ethernetové síti mapují IP adresy na porty pro přeposílání rámců.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"c84561c2-4304-4b3f-a440-8d6b9366f858",correct:"Pro doručení paketu třetí vrstvy je nutné získat odpovídající adresu druhé vrstvy.",incorrect:"Pro doručení paketu třetí vrstvy se adresa druhé vrstvy nevyužívá.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"78cb4bfe-0925-4df3-b277-cba5147e527c",correct:"V sítích IP/Ethernet se překlad adres zajišťuje protokolem ARP.",incorrect:"V sítích IP/Ethernet se překlad adres zajišťuje protokolem DHCP.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"d8e98629-275e-48d9-af74-6b0bd02d4c18",correct:"Síťové rozhraní autonomně čte rámce z odchozí fronty pomocí DMA a odesílá je do sítě.",incorrect:"Síťové rozhraní autonomně čte rámce z odchozí fronty pomocí CPU a odesílá je do sítě.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"afedf95b-f056-49bb-b05c-286c390f712e",correct:"Odchozí fronta je implementována jako kruhová fronta pevné velikosti uložená v operační paměti.",incorrect:"Odchozí fronta je implementována jako lineární fronta proměnné velikosti uložená v operační paměti.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"6ee7a8ec-baf9-4ddd-b230-57ec74a8e2ea",correct:"Pro odeslání rámce operační systém upravuje koncový ukazatel odchozí fronty po zápisu dat.",incorrect:"Pro odeslání rámce operační systém upravuje hlavový ukazatel odchozí fronty před zápisem dat.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"69355fb6-fc2d-4210-aa62-81ddfec85e24",correct:"Ukazatele hlavový a koncový dělí kruhovou odchozí frontu na část pro operační systém a síťové rozhraní.",incorrect:"Ukazatele hlavový a koncový dělí kruhovou odchozí frontu na část pouze pro operační systém.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"4086f9ed-bbe1-4272-beff-d1ab803d0d75",correct:"Síťové rozhraní signalizuje události související se zpracováním odchozí fronty pomocí přerušení.",incorrect:"Síťové rozhraní signalizuje události související se zpracováním odchozí fronty pomocí pollingu.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"27e0aacc-fdf7-4c21-9dcf-a0f78e90e8c6",correct:"Síťové rozhraní signalizuje příchod nových dat do fronty pomocí přerušení.",incorrect:"Síťové rozhraní signalizuje příchod nových dat do fronty pomocí dotazování.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"a4084662-33fd-4e32-85c6-12b32f57c098",correct:"Pokud je příjmová fronta plná a přichází další rámce, dojde ke ztrátě dat.",incorrect:"Pokud je příjmová fronta plná a přichází další rámce, rámce se uloží do vyrovnávací paměti.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"addfb8b1-86c2-465b-a00d-327cc5b7dfba",correct:"Operační systém alokuje paměť pro rámce v příjmové frontě.",incorrect:"Síťové rozhraní alokuje paměť pro rámce v příjmové frontě.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"81c6feb2-e170-433d-b290-cc626b927e5c",correct:"Události signalizující nová data v příjmové frontě mohou být sdružovány pro více rámců.",incorrect:"Události signalizující nová data v příjmové frontě nemohou být sdružovány a jsou generovány pro každý rámec zvlášť.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"66d6324d-c550-4d4f-b9a6-de988de2fbcf",correct:"Operační systém dává najevo síťovému rozhraní, že paměť může být přepsána, přesunutím položky do kruhové fronty.",incorrect:"Síťové rozhraní dává najevo operačnímu systému, že paměť může být přepsána, přesunutím položky do kruhové fronty.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"cd6bcea2-4127-4a57-88ce-e7235d9a1aab",correct:"Moderní síťové adaptéry mohou dosáhnout takové rychlosti, že jedno procesorové jádro nemusí stačit na jejich plné využití.",incorrect:"Moderní síťové adaptéry jsou navrženy tak, aby jedno procesorové jádro vždy dokázalo plně saturovat jejich výkon.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"cce0ee3d-c551-4d58-b3a7-6dd142606232",correct:"Rozhraní s více frontami umožňují operačnímu systému rozdělit zátěž zpracování síťového provozu mezi různá procesorová jádra.",incorrect:"Rozhraní s více frontami jsou navržena pro zvýšení výkonu jediného procesorového jádra při zpracování síťového provozu.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"d8ca55b8-ae4f-48ef-9027-38a81f11366f",correct:"Operační systém typicky nastavuje pro každé procesorové jádro jednu vysílací a jednu přijímací frontu u moderních síťových karet.",incorrect:"Operační systém obvykle sdílí jednu vysílací a jednu přijímací frontu mezi všechna procesorová jádra pro snížení režie.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"39dca947-376e-4a66-be4a-0a6e49ad07b5",correct:"Při odesílání paketů operační systém rozhoduje o výběru vysílací fronty, kterou síťové rozhraní použije.",incorrect:"Při odesílání paketů síťové rozhraní automaticky vybírá vysílací frontu bez zásahu operačního systému.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"73f6743e-2538-4a91-8ddc-c9084f54cd61",correct:"Při příjmu paketů síťové rozhraní samo rozhoduje o zařazení rámců do front na základě filtrování nebo hashování.",incorrect:"Při příjmu paketů operační systém aktivně rozhoduje o zařazení každého rámce do konkrétní přijímací fronty.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"7b3840cf-079d-4170-8b36-0e1189e0c1e6",correct:"Cílem rozřazování rámců do front na síťovém rozhraní je zvýšit lokalitu zpracování a rovnoměrně zaplnit fronty.",incorrect:"Cílem rozřazování rámců do front je primárně minimalizovat latenci doručení paketů do aplikace bez ohledu na lokalitu.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"8613db6d-7a6f-42dc-8fd4-9beab13c8c33",correct:"Protokoly WiFi jsou implementovány částečně ve firmwaru a částečně v softwaru operačního systému.",incorrect:"Protokoly WiFi jsou implementovány výhradně v softwaru operačního systému.",sectionNumber:"4.3.9",sectionTitle:"WiFi"},{uuid:"b6dbb5fc-bee5-4e78-aa5f-fd00975d35e7",correct:"Šifrování je u bezdrátových sítí prakticky povinné kvůli snadnému odposlouchávání sdíleného média.",incorrect:"Šifrování u bezdrátových sítí je volitelné a není nutné kvůli obtížnému odposlouchávání.",sectionNumber:"4.3.9",sectionTitle:"WiFi"},{uuid:"c60358cf-b1c2-47ad-8d3a-332a9cdca1c8",correct:"Autentizace v WiFi sítích je nezbytná pro prevenci útoků typu man in the middle.",incorrect:"Autentizace v WiFi sítích není nutná pro prevenci útoků typu man in the middle.",sectionNumber:"4.3.9",sectionTitle:"WiFi"}]},{uuid:"f6afeeb0-aa47-4201-82b3-c1b185f65e50",sectionNumber:"5",sectionTitle:"Souběžnost a synchronizace",statements:[{uuid:"bc13ed0f-7024-45f3-b277-442a139c31bb",correct:"V grafu předcházení vrcholy reprezentují události a hrany reprezentují akce.",incorrect:"V grafu předcházení hrany reprezentují události a vrcholy reprezentují akce.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"51965a94-8a98-4bec-b66f-7a7dd791d684",correct:"Graf předcházení je tranzitivní redukcí relace uspořádání 'muselo se stát před'.",incorrect:"Graf předcházení je tranzitivním uzávěrem relace uspořádání 'muselo se stát před'.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"5b7ab34f-7d35-40f5-88f4-cc1faab84938",correct:"Akce v grafu předcházení nemohou přímo spojovat události, mezi kterými existuje cesta délky dva.",incorrect:"Akce v grafu předcházení mohou přímo spojovat události, mezi kterými existuje cesta délky dva.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"cfd01452-1939-4a98-8bd6-c30f648a9350",correct:"Souběžné události jsou takové, mezi kterými v grafu závislostí nevede cesta.",incorrect:"Souběžné události jsou takové, mezi kterými v grafu závislostí vždy vede cesta.",sectionNumber:"5.1.2",sectionTitle:"Souběžnost"},{uuid:"a5e1f9cd-5fce-454c-8e75-d852e7f7609a",correct:"Pokud událost A nepředchází události B a B nepředchází A, události A a B jsou souběžné.",incorrect:"Pokud událost A nepředchází události B a B nepředchází A, událost A musí předcházet události B.",sectionNumber:"5.1.2",sectionTitle:"Souběžnost"},{uuid:"1d83812e-e73b-401a-a0e6-1c2e31ee850a",correct:"Časový sled událostí je lineární uspořádání, kde pro každou dvojici událostí jedna předchází druhou.",incorrect:"Časový sled událostí je nelineární uspořádání, kde pro každou dvojici událostí jedna předchází druhou.",sectionNumber:"5.1.3",sectionTitle:"Časový sled"},{uuid:"aa67e4d5-f959-47c7-992b-8e23ccce4228",correct:"V časovém sledu událostí, reprezentovaném časovými razítky, nemohou dvě události nastat ve stejný okamžik.",incorrect:"V časovém sledu událostí, reprezentovaném časovými razítky, mohou dvě události nastat ve stejný okamžik.",sectionNumber:"5.1.3",sectionTitle:"Časový sled"},{uuid:"2540b410-8043-4424-9e93-331de40e38e1",correct:"Relace předcházení je abstrakce, která v operačních systémech popisuje vnější chování procesů.",incorrect:"Relace předcházení je konkrétní implementace, která v operačních systémech popisuje vnitřní chování procesů.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"c049f981-17af-420e-9b3f-22c9ea678e4a",correct:"Hazard souběhu nastává, pokud různé časové sledy událostí vedou k rozdílnému vnějšímu chování systému.",incorrect:"Hazard souběhu nastává, pokud stejné časové sledy událostí vedou k rozdílnému vnějšímu chování systému.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"27741294-9d19-4026-9f45-f8b1eb0cf30f",correct:"Porušení abstrakce relace předcházení, tedy hazard souběhu, je nežádoucí, i když nemusí být chybou.",incorrect:"Porušení abstrakce relace předcházení, tedy hazard souběhu, je žádoucí, protože zlepšuje výkon systému.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"c132ba29-dca0-438e-91e9-4081245231a0",correct:"Vnější chování systému závisí pouze na relaci předcházení, nikoliv na konkrétním časovém rozložení událostí.",incorrect:"Vnější chování systému závisí na relaci předcházení a také na konkrétním časovém rozložení událostí.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"4a30a4f4-40e2-48e4-84a9-4cd7aea265f0",correct:"Abstrakce relace předcházení se snaží skrýt vnitřní detaily procesů a jejich časové uspořádání v systému.",incorrect:"Abstrakce relace předcházení se snaží odhalit vnitřní detaily procesů a jejich časové uspořádání v systému.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"1581885d-6ab6-4634-a66a-e66962e02261",correct:"Akce v grafu předcházení jsou vždy prováděny hybatelem, typicky vláknem nebo periferií.",incorrect:"Akce v grafu předcházení jsou prováděny nezávisle na hybatelích, jako jsou vlákna a periferie.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"873903b1-afd2-461c-bfc6-966ab742fac0",correct:"V grafu předcházení můžeme hranám, reprezentujícím akce, přisoudit hybatele, například vlákno či periferii.",incorrect:"Hranám v grafu předcházení nelze přisoudit hybatele, protože hrany reprezentují pouze samotné akce.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"f4c0f57e-a8e1-42f0-8b8b-2b4d6cd3817d",correct:"Hybatele, jako vlákna nebo periferie, lze v grafu předcházení chápat jako pešky pohybující se po hranách své barvy.",incorrect:"Hybatele v grafu předcházení se nepovažují za pešky pohybující se po hranách, ale za pasivní prvky grafu.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"c5110ce6-27c1-450e-a21e-c7f4e45f829c",correct:"V příkladu jsou vlákna A a B, která provádějí prakticky stejný program s rozdílnými registry.",incorrect:"V příkladu vlákna A a B vykonávají zcela odlišné programy bez jakékoliv programové podobnosti.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"cd38a771-700a-41b7-ac61-541c7612ce68",correct:"Akce jsou souběžné právě tehdy, když jsou souběžné libovolné dvě události, kterých se tyto akce týkají.",incorrect:"Akce jsou souběžné pouze tehdy, když jsou souběžné všechny události, kterých se tyto akce týkají.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"43ccac0f-1bd1-4ab9-863f-fcb6202b9d87",correct:"Událost nemůže být souběžná sama se sebou, ani nemohou být souběžné události spojené akcí.",incorrect:"Událost může být souběžná sama se sebou, ale nemůže být souběžná s událostí spojenou akcí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"fd98f772-cc0b-495f-9bad-43c56feacd55",correct:"Nezávislé akce mohou proběhnout v libovolném pořadí, protože vedou do souběžných událostí.",incorrect:"Nezávislé akce musí proběhnout v předem daném pořadí, i když vedou do souběžných událostí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"36a81eba-3ec8-40c4-8b4b-43f56854d71c",correct:"Synchronizace akcí nastává, když se akce 'sejdou' ve společné události a musí proběhnout 'najednou'.",incorrect:"Synchronizace akcí nastává, když se akce 'sejdou' ve společné události a mohou proběhnout v libovolném pořadí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"c418330b-51ad-4c38-bcae-a2a2449b333a",correct:"Souběžné sledy jsou takové, které nesdílí žádnou událost, s výjimkou první a/nebo poslední události.",incorrect:"Souběžné sledy jsou takové, které sdílí alespoň jednu událost kromě první nebo poslední události.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"9790890a-abcf-4e98-a590-bf7e1d51a3d4",correct:"Akce v operačním systému propojují události a stavy systému.",incorrect:"Akce v operačním systému popisují pouze stavy, nikoli události.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"5d11a343-732f-4692-8e82-096b6e3790db",correct:"Výpočet je vnímán jako posloupnost stavů a akcí v operačním systému.",incorrect:"Výpočet je chápán pouze jako lineární posloupnost stavů bez akcí.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"91d47ccb-11f3-4f28-a3eb-f0880f489317",correct:"Stavový prostor je orientovaný graf, kde vrcholy jsou stavy a hrany akce.",incorrect:"Stavový prostor je neorientovaný graf stavů, kde hrany nereprezentují akce.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"eb5eb2ac-cd55-4623-ae99-83c78c51237f",correct:"Stav systému zahrnuje registry procesoru a obsah paměťových buněk.",incorrect:"Stav systému zahrnuje pouze registry procesoru, nikoli paměťové buňky.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"7d384cf5-4395-4735-9921-52e84576dd2e",correct:"Vstupní periferie mění svůj stav nezávisle na operačním systému.",incorrect:"Vstupní periferie mění svůj stav výhradně na základě řízení operačním systémem.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"7908140c-be17-44e8-a693-065f352cad21",correct:"Běh v stavovém prostoru je orientovaná cesta, která reprezentuje posloupnost stavů propojených akcemi.",incorrect:"Běh v stavovém prostoru je neorientovaná cesta, která reprezentuje posloupnost stavů propojených událostmi.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"3849cda1-8458-4531-8ad1-b9d38bac01bb",correct:"Sekvence akcí může být chápána jako běh i jako sled, pokud je určen počáteční stav.",incorrect:"Sekvence akcí může být chápána jako běh i jako sled, i když není určen počáteční stav.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"95409ff1-a978-4f53-a703-0a35dde88cf5",correct:"V situacích souběhu může vést odlišné pořadí akcí k rozdílným výsledným stavům systému.",incorrect:"V situacích souběhu vždy vede odlišné pořadí akcí ke stejným výsledným stavům systému.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"9a5ce9e7-11ab-48c9-8fcd-d61acc42e1eb",correct:"Časový sled událostí má jasnou korespondenci s během, který je posloupností stavů.",incorrect:"Časový sled událostí nemá žádnou korespondenci s během, který je posloupností stavů.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"c7fa9fb7-2f50-474d-8413-45cbdc060944",correct:"Pojem běhu v stavovém prostoru je zobecněním výpočtu, který zahrnuje posloupnost stavů a akcí.",incorrect:"Pojem běhu v stavovém prostoru je zúžením výpočtu, který zahrnuje pouze posloupnost stavů.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"2913d7e0-2c36-4f14-b745-54f1435c9442",correct:"Kritická sekce je běh, jehož přerušení jiným souběžným během může vést k chybě.",incorrect:"Kritická sekce je běh, jehož přerušení jiným souběžným během nikdy nevede k chybě.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"20632c90-3d58-4540-bb07-a37c9b4b10d0",correct:"Porušení atomicity kritické sekce je z definice považováno za chybu běhu.",incorrect:"Porušení atomicity kritické sekce není nikdy považováno za chybu běhu.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"2c2c4695-764d-4e3d-9a41-74165ca624b7",correct:"Kritická sekce se týká běhů, které jsou relativní vůči jiným souběžným běhům.",incorrect:"Kritická sekce se týká běhů, které jsou zcela nezávislé na jiných souběžných bězích.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"37758615-e2c3-40d3-a2e4-8cc7dccff000",correct:"V příkladu s inkrementací proměnné V, běh vlákna A může být kritickou sekcí vůči běhu vlákna B.",incorrect:"V příkladu s inkrementací proměnné V, běh vlákna A nikdy nemůže být kritickou sekcí vůči běhu vlákna B.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"07a87655-41f0-4687-acd2-6ca8ce85ef38",correct:"Chyba atomicity nastává, když souběžné běhy vedou k nežádoucímu uspořádání akcí.",incorrect:"Chyba atomicity nastává, když jednotlivé běhy samy o sobě, bez souběhu, vedou k chybě.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"03151cf8-9a7b-42a4-a1b8-08eb894aa84d",correct:"Kritická sekce je speciálním případem obecnějšího konceptu hazardu souběhu.",incorrect:"Kritická sekce je obecným případem a hazard souběhu je jejím speciálním případem.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"c49f9dbf-81a4-4f26-93f1-cbf0a848f620",correct:"Čtenáři v problému čtenářů a písařů nejsou vzájemně kritickou sekcí.",incorrect:"Čtenáři v problému čtenářů a písařů jsou vzájemně kritickou sekcí.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"ffbf1f9a-4373-468b-9783-d172d9b1c88d",correct:"Čtenář je v problému čtenářů a písařů kritickou sekcí vůči písaři.",incorrect:"Čtenář v problému čtenářů a písařů není kritickou sekcí vůči písaři.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"b2dcb296-5faf-4cd1-8763-5914d3851253",correct:"Písaři jsou v problému čtenářů a písařů vzájemně kritickou sekcí.",incorrect:"Písaři v problému čtenářů a písařů nejsou vzájemně kritickou sekcí.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"46e97811-e887-4ea1-b630-8a86621f7c68",correct:"Čtenáři v problému čtenářů a písařů sdílená data pouze čtou.",incorrect:"Čtenáři v problému čtenářů a písařů sdílená data čtou a modifikují.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"49709dbf-fa30-4d55-9e83-8151d0162b2b",correct:"Písaři v problému čtenářů a písařů sdílená data modifikují.",incorrect:"Písaři v problému čtenářů a písařů sdílená data pouze čtou.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"f408ca91-6879-4536-9392-c83bedf50213",correct:"Efektivní řešení problému čtenářů a písařů umožňují souběh čtenářů.",incorrect:"Efektivní řešení problému čtenářů a písařů zakazují souběh čtenářů.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"9806482c-3dbc-49e2-b6e6-15a7289795ed",correct:"Nejjednodušší řešení problému čtenářů a písařů je neefektivní.",incorrect:"Nejjednodušší řešení problému čtenářů a písařů je efektivní.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"4b06b700-9cba-45a9-b85e-e345f4d5d13a",correct:"Neustálá aktivita čtenářů může způsobit, že písaři budou trvale zablokováni v problému čtenářů a písařů.",incorrect:"Neustálá aktivita čtenářů nikdy nemůže způsobit trvalé zablokování písařů v problému čtenářů a písařů.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"905986a6-834a-4ffb-8cf2-5a6dbf1262d1",correct:"Hladovění je definováno jako situace, kdy vlákno nemůže pokračovat ve svém výpočtu a vykonávat užitečné akce.",incorrect:"Hladovění je definováno jako situace, kdy vlákno může nerušeně pokračovat ve svém výpočtu a vykonávat užitečné akce.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"08a5800a-c460-4a65-9e5b-5577167e9063",correct:"Uváznutí, kdy vlákna čekají v kruhu, je v operačních systémech považováno za běžnou příčinu hladovění.",incorrect:"Uváznutí, kdy vlákna čekají v kruhu, není v operačních systémech nikdy považováno za příčinu hladovění.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"b4c70a1c-4c8e-48b0-88d9-2e1498181fab",correct:"Synchronizace sama o sobě není řešením problému hladovění a může být dokonce jeho častou příčinou.",incorrect:"Synchronizace je vždy efektivním řešením problému hladovění v operačních systémech a nikdy není jeho příčinou.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"b5d429c6-f2e4-4531-acca-b998742d925c",correct:"Datová závislost vzniká, když akce čte data z paměti, do které předtím zapisovala jiná akce.",incorrect:"Datová závislost vzniká, když akce zapisuje data do paměti, ze které předtím četla jiná akce.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"b2154442-bf81-45b5-9136-d9d2ebddb7e9",correct:"Chyba pořadí se projevuje v souběžných systémech, kde existují datové závislosti mezi akcemi.",incorrect:"Chyba pořadí se projevuje pouze v sekvenčních systémech, kde neexistují datové závislosti.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"4fd45015-cbad-40da-99c8-66d0ab64f3ff",correct:"Datová závislost je specifický typ hazardu souběhu, odlišný od problémů kritické sekce.",incorrect:"Datová závislost je typ hazardu souběhu, který je totožný s problémy kritické sekce.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"c04c5112-a193-4d49-bda0-0fa8f53deec4",correct:"Odhalení chyb datové závislosti může být obtížné, zvláště pokud jsou některé akce časově nenáročné.",incorrect:"Odhalení chyb datové závislosti je snadné, i když jsou všechny souběžné akce časově nenáročné.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"226f64ca-ce6b-483b-b1ad-01a87baf4cf1",correct:"Příliš brzký pokus o použití dat v datové závislosti může způsobit běhovou chybu programu.",incorrect:"Příliš brzký pokus o použití dat v datové závislosti nikdy nezpůsobí běhovou chybu programu.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"0c1888d1-553f-4cee-9dc3-a7a88bc10a00",correct:"Producenti a konzumenti vláken pracují souběžně, což umožňuje distribuci úloh a urychlení celkového procesu.",incorrect:"Producenti a konzumenti vláken pracují sekvenčně, což zajišťuje snadnější synchronizaci, ale snižuje výkon systému.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"4e4d758f-b5c0-4d13-b974-dc9c022b041f",correct:"Při převaze produkce nad konzumací hrozí zahlcení paměti hromadícími se mezivýsledky, pokud není zavedena synchronizace.",incorrect:"Při převaze produkce nad konzumací dochází k efektivnějšímu využití procesoru a zrychlení zpracování dat bez nutnosti synchronizace.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"804706cf-5cea-49a2-a4b3-013bc86c7ac4",correct:"Synchronizace producentů a konzumentů je klíčová pro zamezení opakovaného zpracování stejných mezivýsledků a chyb.",incorrect:"Synchronizace producentů a konzumentů je zbytečná, protože operační systém automaticky zajišťuje správné pořadí zpracování.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"63b74db5-107a-4fac-b7fe-15c1098cb3b5",correct:"Ideální synchronizace producentů a konzumentů by měla omezit počet nezpracovaných mezivýsledků z důvodu paměťové efektivity.",incorrect:"Ideální synchronizace producentů a konzumentů by měla maximalizovat počet nezpracovaných mezivýsledků pro zvýšení propustnosti systému.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"c3391303-6ae8-48a3-823b-46aaaa05dad3",correct:"Jedním z rizik souběžné produkce a konzumace je přepsání mezivýsledku producentem dříve, než bude zpracován konzumentem.",incorrect:"Souběžná produkce a konzumace nikdy nezpůsobí přepsání mezivýsledku, protože producent vždy čeká na zpracování konzumentem.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"5bca3968-549b-4f58-89fb-3940e239eacf",correct:"Nedostatek souběžnosti v systému může vést k neefektivnímu využití hardwarových zdrojů, zejména jader procesoru.",incorrect:"Nedostatek souběžnosti v systému zefektivňuje využití hardwarových zdrojů, zejména jader procesoru.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"1eebad1b-19e8-4ffc-98fc-aaafb3b38347",correct:"Rozvětvení vláken může být řešením pro nedostatek souběžnosti, ale vyžaduje synchronizaci a čekání na dokončení všech větví.",incorrect:"Rozvětvení vláken řeší problém nadměrné souběžnosti a nevyžaduje synchronizaci ani čekání na dokončení všech větví.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"279ffd03-9751-42ad-bf4a-eb2e971449be",correct:"Akce, které nejsou souběžné, nelze provádět paralelně, což omezuje potenciální paralelizaci výpočtu.",incorrect:"Akce, které nejsou souběžné, lze provádět paralelně, což maximalizuje potenciální paralelizaci výpočtu.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"2f4164ef-6ffa-42d0-a702-9efa40ba36e9",correct:"Předčasné pokračování výpočtu před dokončením všech souběžných bloků může vést k výpočetním závislostem a chybám.",incorrect:"Předčasné pokračování výpočtu před dokončením některých souběžných bloků nikdy nevede k výpočetním závislostem.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"}]},{uuid:"41ff3bb9-a775-4b6f-8856-da38b718acc5",sectionNumber:"6",sectionTitle:"Synchronizace",statements:[{uuid:"996e4d1b-df67-4582-9635-6f338e55c678",correct:"Synchronizační zařízení slouží k omezení souběžnosti procesů nebo vláken.",incorrect:"Synchronizační zařízení slouží k úplnému odstranění souběžnosti procesů nebo vláken.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"b0e47a53-cfc8-44d5-84b3-434580669247",correct:"Synchronizační zařízení jsou datové struktury uzpůsobené k řešení specifických problémů souběžnosti.",incorrect:"Synchronizační zařízení jsou hardwarové komponenty uzpůsobené k řešení specifických problémů souběžnosti.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"1a289831-e7dd-49ef-9442-3d1b2dbfee4e",correct:"Instance synchronizačního zařízení spolu navzájem neinteragují a pracují nezávisle.",incorrect:"Instance synchronizačního zařízení spolu navzájem interagují a ovlivňují se.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"2ff046aa-9c53-4a4b-a3d8-4430bfd52558",correct:"Instance synchronizačního zařízení je ztotožněna s adresou, na které je uložen její stav.",incorrect:"Instance synchronizačního zařízení je ztotožněna s názvem proměnné, která na ni odkazuje.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"1519bdeb-9b8c-46a8-8aaf-b2f9a4793838",correct:"V prostředí více procesů může být synchronizační zařízení viditelné pod různými virtuálními adresami.",incorrect:"V prostředí více procesů je synchronizační zařízení vždy viditelné pod stejnou virtuální adresou.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"68c52c8c-0123-431d-b836-66c6936f431d",correct:"Mutex je synchronizační zařízení určené k ochraně kritické sekce před souběžným přístupem.",incorrect:"Mutex je synchronizační zařízení určené k ochraně všech sekcí kódu, nejen kritických sekcí.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"e0d5bade-47ae-45f1-bd97-433cadce2f67",correct:"Operace lock na mutexu může způsobit, že vlákno čeká, pokud je mutex již zamčený jiným vláknem.",incorrect:"Operace lock na mutexu nikdy nezpůsobí, že vlákno čeká, ale okamžitě získá zámek.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"f8d995ce-b03c-4462-858f-816531b48da5",correct:"Pro správnou ochranu kritické sekce je nutné chránit kritickou sekci a všechny běhy vůči ní kritické stejným mutexem.",incorrect:"Pro ochranu kritické sekce stačí chránit pouze kritickou sekci, běhy vůči ní kritické nemusí být chráněny.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"aa986ca6-10db-42fb-9488-f526e3cf0020",correct:"Klasický mutex, jak je popsán v textu, nedetekuje a nezabraňuje odemčení mutexu vláknem, které ho nevlastní.",incorrect:"Klasický mutex detekuje a zabrání pokusu o odemčení mutexu vláknem, které mutex nevlastní.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"617bd170-ff12-406a-9409-40059b7445f6",correct:"Mutex má dva základní abstraktní stavy: zamčený a odemčený, které určují jeho aktuální stav.",incorrect:"Mutex má tři abstraktní stavy: zamčený, odemčený a čekající, pro detailnější kontrolu synchronizace.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"d4e40463-2a43-430f-aab1-2eac18e40601",correct:"Nejjednodušší implementace spinlocku využívá aktivní čekání a stav je reprezentován jedním bitem.",incorrect:"Nejjednodušší implementace spinlocku nevyužívá aktivní čekání a stav je reprezentován bajtem.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"52df82c3-862d-40de-9966-f7988a6d0d52",correct:"Soutěž o spinlock na jednom CPU je neefektivní kvůli aktivnímu čekání, které plýtvá výpočetním časem.",incorrect:"Soutěž o spinlock na jednom CPU je efektivní, protože minimalizuje režii plánovače a zrychluje běh programu.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"5843e3c6-47b0-43f5-8d18-3a839431dcfc",correct:"V moderních systémech se spinlock implementuje pomocí atomické instrukce cmpxchg, která zajistí atomicitu operace lock.",incorrect:"V moderních systémech se spinlock implementuje pomocí Petersonova algoritmu, který je jednodušší než atomické instrukce.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"e53c4834-655b-4c2c-bf31-40b17cea8ba4",correct:"Instrukce cmpxchg atomicky porovná hodnotu na dané adrese s očekávanou hodnotou a v případě shody ji vymění za novou hodnotu.",incorrect:"Instrukce cmpxchg atomicky pouze porovná hodnotu na dané adrese s očekávanou hodnotou, ale hodnotu nikdy nevymění.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"815fe43f-18a1-4423-8133-19a702e99f1b",correct:"Operace unlock u spinlocku spočívá v atomickém zápisu hodnoty 0 na adresu paměti, která reprezentuje zámek.",incorrect:"Operace unlock u spinlocku spočívá v atomickém zápisu hodnoty 1 na adresu paměti, která reprezentuje zámek.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"400b9380-c1a3-4dc8-a57c-6f1082158a1c",correct:"Výhodou spinlocku je jeho jednoduchost implementace, paměťová nenáročnost a nízká latence v případě, že nedochází k soutěži.",incorrect:"Výhodou spinlocku je jeho složitá implementace, paměťová náročnost a vysoká latence i v případě, že nedochází k soutěži.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"35e0cefa-d5cd-4178-8700-0ad568c7ca77",correct:"Použití spinlocku v uživatelských programech může být nevhodné, pokud vlákna sdílejí procesorové jádro kvůli aktivnímu čekání.",incorrect:"Použití spinlocku v uživatelských programech je vždy vhodné, protože spinlock minimalizuje režii plánování procesů.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"61931a44-8051-4a10-8463-0d5f9b8fb23a",correct:"Spinlock je vhodný pro ochranu kritických sekcí s krátkou dobou trvání, aby se minimalizoval čas strávený aktivním čekáním.",incorrect:"Spinlock je vhodný pro ochranu kritických sekcí s dlouhou dobou trvání, protože efektivně využívá výpočetní čas procesoru.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"713fc67f-bcbd-4479-90e9-6cc8d421bd73",correct:"Operace ‹lock› uspávajícího mutexu je realizována jako systémové volání operačního systému.",incorrect:"Operace ‹lock› uspávajícího mutexu je realizována jako atomická instrukce procesoru.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"550e6187-d12c-402f-913b-1540654aded7",correct:"Pokud je uspávající mutex zamčený, jádro zařadí vlákno do fronty a nechá plánovač probudit jiné vlákno.",incorrect:"Pokud je uspávající mutex zamčený, jádro vlákno uspí bez interakce s plánovačem.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"4ead4002-07ba-45e0-a641-20c8f0c710df",correct:"Systémové volání uspávajícího mutexu má řádově stovky instrukcí režie oproti atomické instrukci.",incorrect:"Systémové volání uspávajícího mutexu má režii srovnatelnou s atomickou instrukcí.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"12d5fc7f-9013-41ad-91d0-f181d8f37ac4",correct:"Odemčení uspávajícího mutexu předá zámek prvnímu vláknu z fronty čekající na tento mutex.",incorrect:"Odemčení uspávajícího mutexu odemkne zámek bez ohledu na čekající vlákna.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"e37742df-61d3-4434-a582-08990fd48695",correct:"O zámku rozhoduje vlákno samo pomocí atomické instrukce, podobně jako spinlock.",incorrect:"O zámku rozhoduje operační systém výhradně pomocí systémového volání futex.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"d71cf699-3aff-4f2b-a6a5-2ad697cbddfc",correct:"Systémové volání futex se provádí jen když pokus o zamčení zámku selže v uživatelském prostoru.",incorrect:"Systémové volání futex se provádí vždy při každém pokusu o zamčení zámku.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"e87497c8-edaf-44ed-b544-601361074416",correct:"Uživatelská část stavu mutexu obsahuje počítadlo vláken, která se pokusila o zamčení.",incorrect:"Uživatelská část stavu mutexu obsahuje pouze jeden bit indikující, zda je zámek odemčen.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"c1550210-9a35-458a-ba44-cb8acdb52bc8",correct:"Systémová část futex obsahuje frontu uspaných vláken čekajících na odemčení mutexu.",incorrect:"Systémová část futex obsahuje počítadlo vláken a spinlock pro rychlé zamčení.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"56c00e08-78b7-449b-9e4b-a36c0dbf427e",correct:"Při odemykání mutexu se systémové volání pro probuzení volá jen pokud je počítadlo pokusů o zamčení větší než jedna.",incorrect:"Při odemykání mutexu se vždy volá systémové volání pro probuzení čekajícího vlákna.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"0c702fee-7acb-469c-8a13-d71c4a328310",correct:"Futexy jsou svázány s uživatelskými mutexy pomocí adres, což řeší problém virtuálních a fyzických adres při synchronizaci mezi procesy.",incorrect:"Futexy jsou svázány s uživatelskými mutexy pomocí fyzických adres, což zjednodušuje synchronizaci mezi procesy.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"57b960a1-158d-4393-bfd4-55ff440cda28",correct:"Naivní implementace mutexů zablokuje vlákno při pokusu o opětovné uzamčení stejným vláknem.",incorrect:"Naivní implementace mutexů nikdy nezablokuje vlákno při pokusu o opětovné uzamčení stejným vláknem.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"68b78fb1-5da1-4428-a41a-39f0cfc820f5",correct:"Reentrantní mutex vyžaduje identifikátor vlastníka a počítadlo zanoření pro správnou funkci opakovaného zamykání.",incorrect:"Reentrantní mutex nepotřebuje počítadlo zanoření, pouze identifikátor vlastníka pro opakované zamykání.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"5849dbdd-ca8f-4a22-8711-5ebfda83fc1b",correct:"Refaktorování programu může být v některých případech řešením problému s mutexy namísto reentrantního mutexu.",incorrect:"Refaktorování programu je vždy nutné řešení problému s mutexy a reentrantní mutex není nikdy potřeba.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"56cb547f-5d04-497a-9489-55c17ea5641b",correct:"Rozšířený mutex s počítadlem zanoření dokáže spolehlivě poznat pokus o odemčení zámku nesprávným vláknem.",incorrect:"Rozšířený mutex s počítadlem zanoření nedokáže poznat pokus o odemčení zámku nesprávným vláknem.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"ef12476c-f512-4279-8ade-6b5989b20305",correct:"Operace unlock u reentrantního mutexu sníží počítadlo zanoření a zámek odemkne až po dosažení nuly.",incorrect:"Operace unlock u reentrantního mutexu odemkne zámek okamžitě a nesnižuje počítadlo zanoření.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"b29f7a87-e754-4f57-80db-c98b86b79c7b",correct:"Rwlock je rozšíření mutexu o stavy pro čtení a zápis.",incorrect:"Rwlock je zjednodušená verze mutexu pro základní synchronizaci.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"1ae3035e-3dcd-42e2-b27f-7703396ec21f",correct:"Operace rdlock blokuje, pokud je rwlock ve stavu zápis.",incorrect:"Operace rdlock blokuje pouze, pokud je rwlock ve stavu čtení.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"5fc053ee-128a-41e7-a6c4-b26ed478078a",correct:"Operace wrlock uspěje jen když je rwlock ve stavu odemčeno.",incorrect:"Operace wrlock uspěje i když je rwlock ve stavu čtení.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"000be13a-dc99-4621-8877-57d220dbab38",correct:"Operace unlock ve stavu zápis změní stav rwlock na odemčeno.",incorrect:"Operace unlock ve stavu zápis změní stav rwlock na čtení.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"da998fd3-2f2f-47c8-a991-884ece77c71a",correct:"Rwlock má stavy odemčeno, čtení a zápis pro řízení přístupu.",incorrect:"Rwlock má pouze stavy odemčeno a zamčeno, podobně jako mutex.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"e0744c65-4d20-4e13-a533-f9dfb1d49861",correct:"Mechanismus RCU řeší problém čtenářů a písařů bez použití zámků a kritických sekcí.",incorrect:"Mechanismus RCU řeší problém čtenářů a písařů s použitím zámků a kritických sekcí.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"17234fd8-83be-48eb-82b3-2d19130731c1",correct:"Písař v RCU vytvoří kopii datové struktury a upraví ji mimo původní strukturu.",incorrect:"Písař v RCU upravuje datovou strukturu přímo na místě bez vytváření kopie.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"b6072488-a374-47f3-a3ed-7f05e2a675a3",correct:"Čtenáři v RCU vidí novou verzi dat až po přesměrování sdíleného ukazatele písařem.",incorrect:"Čtenáři v RCU vidí novou verzi dat ihned po zahájení úprav písařem.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"5d057a7e-9383-4a86-a6ed-60210bdef906",correct:"Stará verze dat v RCU se uvolní, když k ní nepřistupuje žádný čtenář, pomocí počítadla odkazů.",incorrect:"Stará verze dat v RCU se uvolní ihned po vytvoření nové verze písařem.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"d81c6974-887d-4987-bdec-c6bffff6873f",correct:"Při více písařích může RCU bez dalších mechanismů vést k hazardu souběhu písařů.",incorrect:"Při více písařích RCU vždy zaručuje atomické úpravy dat bez dalších mechanismů.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"adb4f7d0-3ee0-4ce3-97fe-4fb31ff10b28",correct:"Monitor je synchronizační koncept vyšší úrovně, nikoliv prostředek operačního systému.",incorrect:"Monitor je synchronizační prostředek poskytovaný operačním systémem na nízké úrovni.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"aaab54f3-6094-4f3c-844f-9869c643b357",correct:"Monitory jsou interně postaveny na vzájemném vyloučení, zajišťujícím vstup pouze jednoho vlákna.",incorrect:"Monitory umožňují souběžný vstup více vláken, čímž maximalizují paralelizaci bez omezení.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"3d43ef5f-af8e-4dff-aabe-44b63a7008e4",correct:"Implementace monitorů může využívat rekurzivní mutexy pro podporu vnořeného zamykání operací.",incorrect:"Implementace monitorů se striktně vyhýbá rekurzivním mutexům kvůli riziku deadlocku.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"004ecda2-e325-46f5-8d35-77f4cd1e5972",correct:"Monitor může snížit celkovou souběžnost programu výměnou za snazší prevenci chyb synchronizace.",incorrect:"Monitor vždy zvyšuje souběžnost programů a minimalizuje riziko chyb synchronizace zároveň.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"95fa5689-7011-420e-a2cd-bb1eb6d3551b",correct:"Monitor nezaručuje globální bezchybnost synchronizace, zejména u invariantů přesahujících jeho rozsah.",incorrect:"Monitor je univerzálním řešením, které zaručuje absolutní bezchybnost synchronizace v jakémkoliv programu.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"34659fab-85ad-4822-bf4f-3c4b1d4bed36",correct:"Podmínková proměnná se používá k řešení problému souběžné datové závislosti mezi vlákny.",incorrect:"Podmínková proměnná se používá výhradně k zamezení uváznutí systému v důsledku chybějících zdrojů.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"b36d7b48-c7a9-4332-a310-faa86e783444",correct:"Operace wait na podmínkové proměnné blokuje vlákno, dokud jiné vlákno nezavolá operaci signal.",incorrect:"Operace wait na podmínkové proměnné vlákno pouze uspí na pevně stanovený časový interval.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"e7d0c87a-a477-4a3e-810e-a285a4b012d7",correct:"Stav podmínkové proměnné může být reprezentován jako množina vláken čekajících na signál.",incorrect:"Stav podmínkové proměnné je vždy reprezentován jediným bitem indikujícím, zda je proměnná uzamčena.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"5e7b1e44-cc0f-411b-99e5-40ced39ff967",correct:"Implementace podmínkové proměnné s aktivním čekáním je méně efektivní v problémech datové závislosti.",incorrect:"Implementace podmínkové proměnné s aktivním čekáním je preferovanou metodou pro synchronizaci v reálném čase.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"fcc1b0f1-287f-474c-97fc-acde000031dc",correct:"Při použití operace signal na podmínkové proměnné se může probudit jedno nebo více čekajících vláken.",incorrect:"Operace signal na podmínkové proměnné vždy probudí všechna vlákna, která na ni čekají.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"43426891-1c9e-456b-9bc8-96d76367ec5f",correct:"Klasický semafor sám o sobě neřeší problém producentů a konzumentů lépe než mutex.",incorrect:"Klasický semafor sám o sobě řeší problém producentů a konzumentů lépe než mutex.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"5605729a-c8eb-448d-9727-23c4c9c8c01b",correct:"Symetrický semafor blokuje operaci post, pokud by došlo k překročení maximální hodnoty počítadla n.",incorrect:"Symetrický semafor nikdy neblokuje operaci post, a to ani při překročení maximální hodnoty počítadla n.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"b64dd9dc-6581-498e-875a-31c848e72443",correct:"V klasickém řešení producent-konzument semafor E reprezentuje počet volných míst ve frontě mezivýsledků.",incorrect:"V klasickém řešení producent-konzument semafor F reprezentuje počet volných míst ve frontě mezivýsledků.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"db7e4825-d8e5-4c15-ae03-8cd3fb3d52c4",correct:"Operace wait na semaforu blokuje proces, pokud je aktuální hodnota semaforu rovna nule.",incorrect:"Operace wait na semaforu blokuje proces, pokud je aktuální hodnota semaforu větší než nula.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"306ba28c-3762-45c8-b653-44d70ed02445",correct:"Problém producentů a konzumentů lze řešit kombinací dvou klasických, asymetrických semaforů.",incorrect:"Problém producentů a konzumentů nelze řešit kombinací dvou klasických, asymetrických semaforů.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"39fca68c-917c-447c-b118-c8696e87a064",correct:"Bariéra řeší problém rozvětvení a setkání vláken, zejména při synchronizaci většího počtu vláken.",incorrect:"Bariéra řeší problém pouze rozvětvení vláken, nikoliv setkání, a není určena pro synchronizaci více vláken.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"9c23f234-37e8-4da6-9a1d-82bb8504dcbb",correct:"Operace wait bariéry blokuje volající vlákno dokud operaci wait nezavolají všechna synchronizovaná vlákna.",incorrect:"Operace wait bariéry blokuje volající vlákno pouze do doby, než ji zavolá alespoň jedno další synchronizované vlákno.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"149e5ff8-f51d-4e69-9e4d-c085ce531752",correct:"Implementace bariéry s aktivním čekáním je vhodná pouze v situacích, kdy všechna vlákna dorazí přibližně ve stejnou dobu.",incorrect:"Implementace bariéry s aktivním čekáním je univerzálnější a efektivnější než implementace s podmínkovou proměnnou.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"24044a5c-7bf7-4943-b80f-b5506141aae8",correct:"Při implementaci bariéry s počítadlem operace init nastaví počítadlo na počet vláken, která se mají synchronizovat.",incorrect:"Při implementaci bariéry s počítadlem operace init nastaví počítadlo na nulu a operace wait ho inkrementuje.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"dba6a30a-4646-400e-8a9f-542a52e74ff3",correct:"Vlákna čekající na bariéře, implementované pomocí podmínkové proměnné, obvykle spí a nezatěžují procesor aktivním čekáním.",incorrect:"Vlákna čekající na bariéře, implementované pomocí podmínkové proměnné, aktivně čekají a neustále kontrolují stav bariéry.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"}]},{uuid:"9b09f7c6-79c5-43f7-ae95-751301b85594",sectionNumber:"7",sectionTitle:"Komunikace, uváznutí",statements:[{uuid:"5fdaf263-16da-4714-b696-e3609e4b6ae2",correct:"Každá komunikace je formou synchronizace, protože čtení informace musí být předcházeno zápisem.",incorrect:"Každá komunikace je formou produkce zpráv, nikoliv synchronizace mezi procesy.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"fb7816c7-260d-4571-a52e-3beb791e025d",correct:"Komunikační zařízení jsou často zároveň zařízeními synchronizačními kvůli nutné kauzalitě zápisu a čtení.",incorrect:"Komunikační zařízení jsou zřídka zařízeními synchronizačními, primárně slouží pouze k produkci zpráv.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"937e9372-f786-4040-b5ba-9d017d2bd0a0",correct:"Většina komunikace je zobecněnou verzí problému producentů a konzumentů, kde účastníci jsou producenty i konzumenty.",incorrect:"Většina komunikace je specifickou verzí problému producentů a konzumentů, kde účastníci jsou jen producenty nebo konzumenty.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"92d11021-ae0f-4e32-ac69-153188bd7f3c",correct:"Opačný vztah k implikaci komunikace → synchronizace neplatí, synchronizace neznamená vždy komunikaci.",incorrect:"Opačný vztah k implikaci komunikace → synchronizace platí, synchronizace vždy nutně znamená komunikaci.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"a3c178d4-1bd0-4f7d-a1c4-7df7e2dd2df8",correct:"Pro komunikaci lze použít libovolnou datovou strukturu, je-li chráněna mutexem.",incorrect:"Pro komunikaci lze použít pouze specializované datové struktury bez mutexu.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"10d48add-2aa6-4675-a1a6-e4e5d0d111fe",correct:"Soutěž o zámek mutexu může zpomalovat komunikaci při častém používání.",incorrect:"Soutěž o zámek mutexu nemá vliv na rychlost komunikace ani při častém používání.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"7910d167-8e91-449f-8d0a-fa3353d9bf89",correct:"Specializované fronty umožňují větší souběžnost než komunikace s mutexem při každém předání.",incorrect:"Mutexy při každém předání umožňují větší souběžnost než specializované komunikační fronty.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"c213f92a-0764-4aa3-b73c-f48188d90d1c",correct:"Pro občasnou komunikaci nepředstavuje použití mutexu zásadní problém z hlediska výkonu.",incorrect:"I pro občasnou komunikaci představuje použití mutexu zásadní problém z hlediska výkonu.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"a7e2de84-5e60-4aee-9557-f171e983f7ca",correct:"Kruhová fronta s pevnou velikostí využívá dva ukazatele, čtecí a zapisovací, pro řízení operací.",incorrect:"Kruhová fronta s pevnou velikostí využívá pouze jeden ukazatel pro řízení operací čtení a zápisu.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"1e0791a5-8f6b-40a8-b684-d2af7d8ce613",correct:"Fronta je považována za plnou, pokud by zápisovací ukazatel měl předběhnout ukazatel čtecí.",incorrect:"Fronta je považována za plnou, pokud by čtecí ukazatel měl předběhnout ukazatel zapisovací.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"fd1f819e-2b56-45a2-95cf-8e3edb2d8db8",correct:"V kruhové frontě každá strana modifikuje pouze jeden ukazatel, čímž se minimalizuje potřeba kritických sekcí.",incorrect:"V kruhové frontě obě strany modifikují oba ukazatele, což vyžaduje rozsáhlé kritické sekce pro synchronizaci.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"4c8a4185-1685-4f8d-8459-5247157069ed",correct:"V kruhové frontě s S buňkami je efektivně využitelná kapacita o jednu buňku menší než S.",incorrect:"V kruhové frontě s S buňkami je plně využitelná kapacita rovna počtu buněk S.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"3f8cc3e2-18ee-44d1-aec7-0f250cdd7d65",correct:"Pro implementaci fronty producent-konzument lze efektivně použít kruhovou frontu nebo frontu s mutexem.",incorrect:"Pro implementaci fronty producent-konzument je nezbytné použít pouze jednostranně zřetězený seznam.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"d23dfc8c-6d62-49b0-8e44-57bd25d2cc6e",correct:"Algoritmus odebrání z kruhové fronty nejprve kontroluje, zda je fronta prázdná, porovnáním ukazatelů.",incorrect:"Algoritmus odebrání z kruhové fronty zahajuje operaci čtení bez předchozí kontroly, zda fronta není prázdná.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"7510282f-81b1-49b0-a0cd-5b9d56408599",correct:"Roura je specializovaná fronta pracující s bajty, která se vyznačuje efektivními dávkovými operacemi.",incorrect:"Roura je specializovaná fronta pracující s bloky, která se vyznačuje neefektivními dávkovými operacemi.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"865d75f7-ce2f-4362-ab24-83aabd6d3b9b",correct:"Efektivní dávkové operace jsou klíčovou charakteristikou roury pro zápis a čtení většího množství bajtů najednou.",incorrect:"Jednotlivé operace s bajty jsou klíčovou charakteristikou roury pro zápis a čtení dat.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"7d9eceda-caf1-4dcb-a818-cacd41022bb3",correct:"Roura je obvykle poskytována operačním systémem a implementována jako omezená fronta.",incorrect:"Roura je obvykle poskytována uživatelskými knihovnami a implementována jako neomezená fronta.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"6a3cd7e0-d5af-48aa-9c95-3b21bdb3f6ae",correct:"Synchronizační chování roury, která je implementována jako omezená fronta, se podobá symetrickému semaforu.",incorrect:"Synchronizační chování roury, která je implementována jako neomezená fronta, se podobá binárnímu semaforu.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"994ba9a9-2dc5-4075-9100-520e08259dc5",correct:"Zobecněná komunikační fronta umožňuje vkládání a vybírání prvků více vlákny současně.",incorrect:"Zobecněná komunikační fronta umožňuje vkládání a vybírání prvků pouze jedním vláknem.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"12914746-430f-439f-b419-d31d3d41e256",correct:"Implementace zobecněné fronty bez zámků může být založena na zřetězeném seznamu.",incorrect:"Implementace zobecněné fronty bez zámků nemůže být založena na zřetězeném seznamu.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"f9d9eb4a-41ce-40dd-96b5-606fbeeb67a8",correct:"Zobecněná komunikační fronta se používá jako společný seznam úloh pro producenty a konzumenty.",incorrect:"Zobecněná komunikační fronta se nepoužívá jako společný seznam úloh pro producenty a konzumenty.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"ad3fb5b6-c63e-4f2f-9f1d-253737af8e85",correct:"Implementace množiny ukončených úloh typicky podporuje operace dotazování a vkládání nových úloh.",incorrect:"Implementace množiny ukončených úloh typicky podporuje operace mazání a aktualizace existujících úloh.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"24c351e1-6cbb-4928-af35-c4b069cd93c0",correct:"Read-copy-update je jednou z možných implementací množiny ukončených úloh.",incorrect:"Read-copy-update není vhodná implementace pro množinu ukončených úloh.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"1fc371b2-1b79-42de-857a-9ff972ec6474",correct:"Pro implementaci množiny ukončených úloh lze použít hashovací tabulku kombinovanou se spinlockem v každé buňce.",incorrect:"Pro implementaci množiny ukončených úloh nelze použít hashovací tabulku kombinovanou se spinlockem v každé buňce.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"8c2b2575-bb04-44b1-83d6-160d714f3c59",correct:'Množina ukončených úloh se používá například pro správu "dirty" stránek v operačním systému.',incorrect:"Množina ukončených úloh se používá například pro plánování běhu procesů v operačním systému.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"250a9abf-1872-4729-80ed-4831d8ca3559",correct:"K synchronizaci operací nad množinou ukončených úloh lze využít atomické instrukce jako ‹cmpxchg›.",incorrect:"K synchronizaci operací nad množinou ukončených úloh nelze využít atomické instrukce jako ‹cmpxchg›.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"c97ca8d5-8d08-4765-8b6e-906f388b6766",correct:"Při předávání zpráv jsou metadata, zejména adresa, důležitější než samotný obsah zprávy.",incorrect:"Při předávání zpráv je obsah zprávy důležitější než metadata, která jsou k ní připojena.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"e32d421c-3eb4-4e93-9948-c73b014d98a7",correct:"Pro pevnou dvojici komunikujících vláken je předávání zpráv ekvivalentní dvojici komunikačních front.",incorrect:"Pro pevnou dvojici komunikujících vláken se předávání zpráv zásadně liší od dvojice komunikačních front.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"5b63d24e-6944-46d6-8510-182bbff641b1",correct:"Systém pro předávání zpráv obvykle interpretuje obsah zprávy jako neprůhledné bajty.",incorrect:"Systém pro předávání zpráv obvykle interpretuje obsah zprávy a analyzuje jeho strukturu.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"6a8f9d64-aba9-43ba-9c21-47f0a823c78a",correct:"Při rendezvous se odesílající a přijímající vlákno musí setkat, aby si mohly předat zprávu.",incorrect:"Při rendezvous se odesílající a přijímající vlákno nemusí setkat, aby si mohly předat zprávu.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"15f2129b-5ea2-4cc5-8ac9-dfc4c1b2c08b",correct:"Operace přijmi může blokovat, pokud není doručena žádná zpráva.",incorrect:"Operace přijmi nikdy neblokuje, i když není doručena žádná zpráva.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"1ff7ed48-4294-4b43-8686-6ee2ffb5aa3e",correct:"Asynchronní operace mohou snížit počet kopírování zpráv, ale komplikují správu paměti.",incorrect:"Asynchronní operace vždy vyžadují kopírování zpráv a zjednodušují správu paměti.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"676a5e04-958c-4b92-93df-9ed1f0691315",correct:"Operace odešli může blokovat kvůli omezené schopnosti systému pamatovat si odeslané zprávy.",incorrect:"Operace odešli nikdy neblokuje, protože systém má neomezenou schopnost pamatovat si zprávy.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"967fa638-0eb0-4ecf-888d-4cfdbfbe098d",correct:"Systém předávání zpráv může mít žádného, jednoho, nebo i více zprostředkovatelů.",incorrect:"Systém předávání zpráv musí mít vždy alespoň jednoho zprostředkovatele.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"53991ce7-010e-4e9f-b0b8-a30848a12d7c",correct:"Zprostředkovatel v systému zpráv přijímá zprávy od klientů a realizuje jejich doručení adresátovi.",incorrect:"Zprostředkovatel v systému zpráv pouze odesílá zprávy klientům, ale nepřijímá zprávy od klientů.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"4a3279f6-7ccf-46d6-b4a4-61dfeb42b66a",correct:"Pro předání zprávy mezi klientem a zprostředkovatelem je nutný komunikační kanál.",incorrect:"Pro předání zprávy mezi klientem a zprostředkovatelem není nutný komunikační kanál.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"f43c968a-263a-4a15-81a9-b11f1fe7fc08",correct:"Při synchronním odeslání a spolehlivém doručení je za zprávu odpovědný zprostředkovatel.",incorrect:"Při synchronním odeslání a spolehlivém doručení je za zprávu stále odpovědný odesílající klient.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"052219d2-e9eb-4eb8-9d70-a09bd8e62936",correct:"Při asynchronním odeslání musí klient uchovat zprávu, dokud zprostředkovatel nepotvrdí její převzetí.",incorrect:"Při asynchronním odeslání může klient zprávu smazat ihned po jejím odeslání zprostředkovateli.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"5035a9c4-d7ec-44d2-82c0-7c2e05c659fe",correct:"Při nespolehlivém doručení musí klient uchovat zprávu do potvrzení doručení příjemcem.",incorrect:"Při nespolehlivém doručení stačí, aby klient uchoval zprávu pouze do potvrzení od zprostředkovatele.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"09f37ed8-4e1a-41b9-bf13-61002b0a155a",correct:"Synchronní příjem zprávy znamená, že se příjemce aktivně dotazuje na existenci nové zprávy.",incorrect:"Synchronní příjem zprávy znamená, že zprostředkovatel aktivně oznamuje doručení nové zprávy příjemci.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"efcc209a-7d14-47a8-b999-e09cc45cf417",correct:"Asynchronní příjem umožňuje klientovi souběžně zpracovávat více zpráv na výzvu zprostředkovatele.",incorrect:"Asynchronní příjem nutí klienta zpracovávat zprávy sekvenčně, jednu po druhé, na výzvu zprostředkovatele.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"a906e282-548f-4f13-a1ca-c99bc02f36f4",correct:"Fibry jsou uživatelská vlákna s kooperativním plánováním a levnějším přepínáním kontextu.",incorrect:"Fibry jsou vlákna operačního systému s preemptivním plánováním a dražším přepínáním kontextu.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"ccd92a26-4f73-49f7-9fe2-20777c5a2295",correct:"Operace broadcast lze v principu realizovat pomocí point-to-point zpráv.",incorrect:"Operace broadcast nelze v principu realizovat pomocí point-to-point zpráv.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"06844704-d0e0-43d2-a3ef-44f656b67def",correct:"Centrální zprostředkovatel může zefektivnit operace jako scatter/gather.",incorrect:"Centrální zprostředkovatel nemůže zefektivnit operace jako scatter/gather.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"bd949331-0137-4635-a114-514ffdb6a97e",correct:"Synchronizační operace bariéra je efektivnější, pokud ji přímo podporuje zprostředkovatel.",incorrect:"Synchronizační operace bariéra není efektivnější, pokud ji přímo podporuje zprostředkovatel.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"94c73491-e065-4715-99e3-4c1f3a0af93b",correct:"V mikrojádrových systémech je předávání zpráv základním mechanismem meziprocesové komunikace.",incorrect:"V mikrojádrových systémech je sdílená paměť základním mechanismem meziprocesové komunikace.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"91764b56-fb21-4da2-b5d4-fb08090e1a83",correct:"Distribuované systémy běžně používají předávání zpráv jako metodu komunikace kvůli absenci sdílené paměti.",incorrect:"Distribuované systémy preferují sdílenou paměť jako metodu komunikace pro její výkonnost.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"57c7b906-633d-45de-86f0-4f45b1ee542d",correct:"Pro systémy s důrazem na bezpečnost je izolace komponent klíčová a předávání zpráv ji podporuje.",incorrect:"Izolace komponent nemá vliv na bezpečnost systémů a předávání zpráv se pro ni nehodí.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"4fa1d926-bfe2-4e13-8556-51050e3e0071",correct:"Mikrojádro v mikrojádrových systémech často funguje jako zprostředkovatel pro předávání zpráv.",incorrect:"Mikrojádro v mikrojádrových systémech nikdy nefunguje jako zprostředkovatel pro předávání zpráv.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"481cf175-a6db-4966-9cc4-355488e7f8de",correct:"Distribuované vědecké výpočty na superpočítačích často využívají efektivní předávání zpráv pro komunikaci.",incorrect:"Distribuované vědecké výpočty se obvykle vyhýbají předávání zpráv kvůli jeho neefektivitě na superpočítačích.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"8f1a25e3-293a-4394-818d-28925889e44f",correct:"Operační systém pracuje s konečným množstvím hardwarových zdrojů.",incorrect:"Operační systém má k dispozici neomezené množství hardwarových zdrojů díky virtualizaci.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"1a038973-e5de-4793-ade7-4eafc8fb8262",correct:"Virtualizace umožňuje sdílení hardwarových zdrojů, ale nepřekonává jejich fyzickou konečnost.",incorrect:"Virtualizace hardwarových zdrojů operačního systému dokáže eliminovat fyzické limity hardware.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"eddb5d39-2099-4e6a-bb28-441c2e5e3018",correct:"Některé periferie, kvůli svým specifickým vlastnostem, nelze efektivně virtualizovat.",incorrect:"Díky pokročilým technikám virtualizace lze virtualizovat naprosto všechny typy hardwarových periferií.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"1d3c38de-d73b-4f95-b7ba-65c03dfc2f73",correct:"Virtualizace zdrojů je nejúčinnější, pokud procesy využívají pouze část kapacity zdroje.",incorrect:"Virtualizace zdrojů je nejúčinnější, i když všechny procesy vyžadují plnou kapacitu daného zdroje.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"e3e525c1-6bb6-470b-ab45-99041449c43b",correct:"Rezervace zdrojů představuje alternativu k virtualizaci, zvláště u zařízení jako jsou páskové jednotky.",incorrect:"Rezervace zdrojů je vždy preferovanou metodou správy zdrojů oproti virtualizaci ve všech situacích.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"1cbd783c-1d6e-4d03-aefb-d3f2b291fc5f",correct:"Virtualizace a rezervace zdrojů se mohou doplňovat, kdy rezervace zajistí garantovanou kapacitu i ve virtualizovaném prostředí.",incorrect:"Virtualizace a rezervace zdrojů jsou vždy vzájemně výlučné metody správy systémových zdrojů v operačním systému.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"baa47025-7fe2-43db-a48b-7a17b4da02a4",correct:"Operační systémy umožňují procesům rezervovat fyzickou paměť, čímž zamezí stránkování rezervované paměti.",incorrect:"Operační systémy nikdy neumožňují procesům rezervovat fyzickou paměť pro výhradní použití procesem.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"d13d4d9f-5885-4b84-aa89-a665a37ef8dc",correct:"Rezervace zdroje zahrnuje dvě fáze: vyžádání zdroje pro výhradní použití a následné uvolnění zdroje.",incorrect:"Rezervace zdroje je jednofázový proces, zahrnující pouze vyžádání zdroje pro daný proces.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"ba268505-ad19-43d1-84a5-f77ba962548c",correct:"Při rezervaci zdroje může dojít k situaci, kdy zdroj není dostupný, což může vést k zamítnutí nebo čekání.",incorrect:"Při rezervaci zdroje, pokud není zdroj okamžitě dostupný, systém vždy rezervaci automaticky zamítne.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"525047fd-05fa-4d75-a62f-1685a1839601",correct:"Mutex lze chápat jako abstraktní zdroj, který se rezervuje zamčením a uvolňuje odemčením.",incorrect:"Mutex nelze chápat jako abstraktní zdroj, protože reprezentuje pouze kritickou sekci.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"d0c13ccb-a152-4f03-a72e-607bfb1634c8",correct:"Semafor je abstraktní zdroj, jehož instance lze přidělovat nezávisle.",incorrect:"Semafor je abstraktní zdroj, jehož instance nelze přidělovat nezávisle.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"a07f6de8-75ce-4901-b69c-cbef4aeb5ea1",correct:"Kritickou sekci lze v určitém smyslu také chápat jako abstraktní zdroj.",incorrect:"Kritickou sekci nelze chápat jako abstraktní zdroj, protože se jedná pouze o kód.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"9f43fd9f-2b73-4201-b178-2b5eef853153",correct:"Zdroje mohou existovat v několika zaměnitelných instancích, ale pouze v době rezervace.",incorrect:"Zdroje jsou vždy zaměnitelné, a to i po rezervaci instance zdroje.",sectionNumber:"7.3.4",sectionTitle:"Instance"},{uuid:"14247f46-f9c4-45b7-a075-e1dc293ab4e9",correct:"Jakmile je instance zdroje rezervována, nelze ji dodatečně vyměnit za jinou.",incorrect:"I po rezervaci instance zdroje je možné ji dodatečně vyměnit za jinou.",sectionNumber:"7.3.4",sectionTitle:"Instance"},{uuid:"a4c6a775-1f20-49fb-8959-2b7b8c4fc957",correct:"Komunikace mezi procesy může být považována za synchronizační mechanismus a abstraktní zdroj.",incorrect:"Komunikace mezi procesy není nikdy považována za synchronizační mechanismus.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"fa700980-3309-4a67-b528-be7d819d23a9",correct:"V kontextu komunikace, odeslání zprávy lze chápat jako rezervaci abstraktního zdroje.",incorrect:"V kontextu komunikace, odeslání zprávy se nikdy nechápe jako rezervace zdroje.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"8ffbc742-db67-4594-8067-71ef99361729",correct:"Přijetí zprávy v komunikačním kontextu odpovídá uvolnění dříve rezervovaného abstraktního zdroje.",incorrect:"Přijetí zprávy v komunikačním kontextu rezervuje abstraktní zdroj.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"3ed32274-badd-4573-ae3b-ea942059d291",correct:"Různá vlákna nebo procesy mohou provádět operace rezervace a uvolnění v rámci komunikace.",incorrect:"Pouze stejné vlákno může provádět rezervaci a uvolnění zdroje v komunikaci.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"e8684bf8-043d-4a8f-a180-c3b6a074e497",correct:"V problému producent-konzument je uložení mezivýsledku formou rezervace omezeného zdroje.",incorrect:"V problému producent-konzument uložení mezivýsledku není rezervací zdroje.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"9f766d0d-b0a5-4c79-8159-c4b506927bfe",correct:"Operační systém může asistovat při předávání zdrojů mezi programy a jejich následném uvolnění.",incorrect:"Operační systém nikdy neasistuje při předávání zdrojů mezi programy.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"d0cf1c03-515f-4167-8562-7a1702d7bd43",correct:"Implicitně se zdroje považují za neodnímatelné, což znamená, že uvolnění zdroje iniciuje vlastník.",incorrect:"Implicitně se zdroje považují za odnímatelné, což znamená, že uvolnění zdroje iniciuje operační systém.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"c397cc14-990a-4482-9ba7-d475e16e36df",correct:"U neodnímatelných zdrojů, jako je mutex, může násilné odebrání vést k problémům ve fungování programu.",incorrect:"U neodnímatelných zdrojů, jako je mutex, násilné odebrání nemá žádný vliv na fungování programu.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"40a6ffa6-d297-4098-9034-49f6f269ed2a",correct:"Virtualizované zdroje umožňují odebrání fyzického prostředku bez fatálních dopadů na běžící proces.",incorrect:"Virtualizované zdroje vyžadují, aby odebrání fyzického prostředku mělo vždy fatální dopady na běžící proces.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"8128f42b-b29e-4729-8273-0d14811ef538",correct:"Odnímatelnost zdroje se může měnit v závislosti na kontextu použití daného zdroje v systému.",incorrect:"Odnímatelnost zdroje je neměnná vlastnost, která nezávisí na kontextu použití v systému.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"eb12b2b2-beb5-4216-adfb-3c729cc8801a",correct:"Ztráta paketu v síti z důvodu plné vyrovnávací paměti je příkladem násilného odebrání zdroje.",incorrect:"Ztráta paketu v síti z důvodu plné vyrovnávací paměti není považována za odebrání zdroje.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"0f6d5cdd-c5dd-4c09-a570-c5fa217131b1",correct:"Uváznutí nastává, když vlákno P drží zdroj A a čeká na zdroj B, a vlákno Q drží zdroj B a čeká na zdroj A.",incorrect:"Uváznutí nastává, když vlákno P drží zdroj A a čeká na zdroj B, a vlákno Q drží zdroj A a čeká na zdroj B.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"1a380e55-adbe-45a6-abc2-a4e5887586c8",correct:"V situaci uváznutí nemohou vlákna P a Q pokračovat v činnosti bez vnějšího zásahu operačního systému.",incorrect:"V situaci uváznutí mohou vlákna P a Q pokračovat v činnosti bez vnějšího zásahu operačního systému.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"6fa766b5-6c78-4e94-8c3f-8e1c9395dad4",correct:"Podle textu, k uváznutí může dojít, i když souběžnost žádostí vláken P a Q není nutnou podmínkou.",incorrect:"Podle textu, k uváznutí může dojít, pouze pokud je souběžnost žádostí vláken P a Q nutnou podmínkou.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"2eb519ea-e0b0-43f5-9d6f-889b0142af6c",correct:"Uváznutí je stav, kdy vlákno čeká na zdroj, který drží jiné vlákno, a tím vzniká cyklická závislost čekání.",incorrect:"Uváznutí je stav, kdy vlákno čeká na zdroj, který není držen žádným jiným vláknem, což způsobuje jeho zablokování.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"200260f2-1626-4b0a-8da2-2d6ac9be481b",correct:"Vzájemné vyloučení je přímým důsledkem rezervace zdrojů v operačním systému.",incorrect:"Vzájemné vyloučení není důsledkem rezervace zdrojů v operačním systému.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"0a1a2194-ccc0-470b-86c3-712b09db7afd",correct:"Podmínka čekající vlastník uváznutí nastává, když vlákno drží jeden zdroj a čeká na další.",incorrect:"Podmínka čekající vlastník uváznutí nastává, jen když vlákno nedrží žádné zdroje.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"07c9dc36-93d5-4bd0-8c17-f25303fa81f7",correct:"Neodnímatelnost zdrojů znamená, že operační systém nemůže odebrat zdroj vláknu násilím.",incorrect:"Neodnímatelnost zdrojů znamená, že operační systém může odebrat zdroj vláknu násilím.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"cb6ba26f-f161-4be7-a9bf-b39166801e61",correct:"Kruhové čekání je stav, kdy existuje cyklická závislost mezi vlákny čekajícími na zdroje.",incorrect:"Kruhové čekání je stav, kdy neexistuje žádná závislost mezi vlákny a zdroji.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"3f8c3e67-f717-4be9-9238-91fd0000d0fc",correct:"Podmínky uváznutí jsou nutné, ale ne postačující pro vznik uváznutí v systému.",incorrect:"Podmínky uváznutí jsou nutné a postačující pro vznik uváznutí v systému.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"6e848669-049f-4038-a7fe-e42ff980df00",correct:"Uváznutí mohou být velmi vzácné, protože jsou často důsledkem hazardů souběhu.",incorrect:"Uváznutí jsou běžná a snadno se odhalují v moderních operačních systémech.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"6cc2dc9f-9df1-4fdc-9812-3303a720e4c8",correct:"Pštrosí algoritmus řeší uváznutí hrubou silou, například restartem systému.",incorrect:"Pštrosí algoritmus se snaží aktivně předcházet uváznutím sofistikovanými metodami.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"fcf39570-63ef-49a8-b3ab-db5e829bfbfa",correct:"Rozhodnutí, zda nastalo uváznutí, může být v některých případech ponecháno na uživateli.",incorrect:"Operační systém vždy automaticky a spolehlivě detekuje uváznutí bez zásahu uživatele.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"5a6a1181-7490-467d-823a-74f18a6f4899",correct:"Detekce uváznutí může být problematická, jak naznačuje text.",incorrect:"Detekce uváznutí je vždy jednoduchá a přímočará v operačních systémech.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"d086d9a7-830f-42e1-b5c1-d39b685b3c2e",correct:"Uváznutí lze detekovat pomocí grafu vlastnictví a čekání na zdroje.",incorrect:"Uváznutí lze detekovat pouze kontrolou kruhového čekání bez grafu zdrojů.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"aa6d0e5b-cb72-4a96-8c83-b57d22e24b72",correct:"Graf detekce uváznutí obsahuje dva typy uzlů: vlákna a zdroje, s hranami mezi nimi.",incorrect:"Graf detekce uváznutí obsahuje pouze jeden typ uzlů a hrany mezi uzly stejného typu.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"742c9753-ca28-45cd-9693-e5aa79a5ee97",correct:"Cyklická závislost v grafu vlastnictví a čekání indikuje uváznutí systému.",incorrect:"Cyklická závislost v grafu vlastnictví a čekání nikdy neindikuje uváznutí systému.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"00df0447-a746-4364-b06d-ec5604ce1ce8",correct:"Přístup detekce uváznutí pomocí grafu je primárně určen pro zdroje s jedinou instancí.",incorrect:"Přístup detekce uváznutí pomocí grafu je určen pro zdroje s více instancemi.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"a8afba46-71f1-4172-951e-b8678f273ae3",correct:"Mutexy, chránící kritické sekce, jsou považovány za zdroje s jedinou instancí v kontextu uváznutí.",incorrect:"Mutexy, chránící kritické sekce, jsou považovány za zdroje s více instancemi v kontextu uváznutí.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"16507fb7-9c6f-4668-baff-ddfbdaa263ae",correct:"Každý cyklus v grafu detekce uváznutí musí mít sudou délku a alespoň čtyři hrany.",incorrect:"Každý cyklus v grafu detekce uváznutí může mít lichou délku a alespoň tři hrany.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"9457dd1d-0b59-41a0-a50d-6b358bcfc4e5",correct:"Účastní-li se cyklického čekání odnímatelný zdroj, obvykle lze uváznutí vyřešit odebráním zdroje.",incorrect:"Účastní-li se cyklického čekání odnímatelný zdroj, nelze uváznutí vyřešit odebráním zdroje.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"260b0e27-b1b3-472d-b266-f8ac060d23c7",correct:"Pro zotavení z uváznutí s neodnímatelnými zdroji je možné násilně ukončit proces.",incorrect:"Pro zotavení z uváznutí s neodnímatelnými zdroji není možné násilně ukončit proces.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"ebe03cce-8b0c-4f3b-a149-034db7ec1836",correct:"Odnímatelnost zdroje umožňuje zotavení z uváznutí bez nutnosti násilného ukončování vláken.",incorrect:"Odnímatelnost zdroje neumožňuje zotavení z uváznutí bez nutnosti násilného ukončování vláken.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"5b9f51be-b015-42d5-9d8e-0ab0e0f6e352",correct:"Podle textu, striktní definice uváznutí vyžaduje účast pouze neodnímatelných zdrojů.",incorrect:"Podle textu, striktní definice uváznutí nevyžaduje účast pouze neodnímatelných zdrojů.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"ead47df6-98a9-49d4-afec-cf30a4c75480",correct:"Vyhýbání se uváznutí může zahrnovat zamítnutí některých požadavků na rezervaci zdrojů.",incorrect:"Vyhýbání se uváznutí spočívá pouze v přidělování zdrojů, pokud jsou všechny zdroje volné.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"601796ce-96e2-404c-8520-4dd575dba191",correct:"Bankéřův algoritmus vyžaduje znalost maximálních požadavků každého vlákna na zdroje.",incorrect:"Bankéřův algoritmus funguje i bez znalosti maximálních požadavků vláken.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"29e0816d-0d2a-44c4-8286-9ff73e670ba3",correct:"Technika vyhýbání se uváznutí využívá koncept bezpečných stavů systému.",incorrect:"Technika vyhýbání se uváznutí se obejde bez konceptu bezpečných stavů systému.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"1c116b67-62ae-4461-b0b5-0ae1fb0c2c1d",correct:"Bankéřův algoritmus počítá s nejhorším případem maximálních požadavků vláken na zdroje.",incorrect:"Bankéřův algoritmus se spoléhá na průměrné požadavky vláken, nikoli na maximální.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"ed95b63d-e666-4fb8-b63c-e1ce5113c057",correct:"Invariant bankéřova algoritmu zaručuje existenci vlákna, které může dokončit běh.",incorrect:"Invariant bankéřova algoritmu zaručuje, že všechna vlákna mohou souběžně dokončit běh.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"a51f8e9c-bfe7-431b-80e3-a20daa2cd080",correct:"Vyhýbání se uváznutí je často nepraktické kvůli omezenému počtu instancí zdrojů.",incorrect:"Vyhýbání se uváznutí je praktické ve většině situací díky bankéřovu algoritmu.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"522af1f6-7ce6-4cc7-8172-9b84197d2b45",correct:"Zamezení uváznutí spočívá v eliminaci alespoň jedné ze čtyř nutných podmínek uváznutí.",incorrect:"Zamezení uváznutí vyžaduje eliminaci všech čtyř nutných podmínek uváznutí současně.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"dbba97ee-d619-4553-a2ba-e0bcfb512a57",correct:"Podmínku vzájemného vyloučení lze zamezit virtualizací zdrojů.",incorrect:"Podmínku vzájemného vyloučení lze zamezit předrezervací zdrojů.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"83314669-7878-4279-be49-f8a6d8842653",correct:"Technika zotavení z uváznutí je vhodná pro systémy s odnímatelnými zdroji.",incorrect:"Technika zotavení z uváznutí je primárně určena pro systémy s výhradně nepřenosnými zdroji.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"44ac4454-c393-4147-9750-6f91baf6cf77",correct:"Předrezervace zdrojů se snaží zabránit čekání vlastníka zdroje na jiný zdroj.",incorrect:"Předrezervace zdrojů má za cíl umožnit čekání vlastníka zdroje na další zdroje.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"a294e72b-a300-48ec-b82f-3f3ea7a2d390",correct:"Dávková rezervace vyžaduje, aby vlákno rezervovalo všechny zdroje atomicky a najednou.",incorrect:"Dávková rezervace umožňuje vláknu rezervovat zdroje postupně, nikoliv atomicky.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"984a26d9-62d2-46de-9851-54299656f474",correct:"Vlákno musí uvolnit všechny držené zdroje před rezervací dalších zdrojů v systému s předrezervací.",incorrect:"Vlákno může držet zdroje a rezervovat další bez nutnosti uvolnění stávajících zdrojů v systému s předrezervací.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"74f2a2bb-bae6-455c-ab82-81b113c4add2",correct:"Pro rezervaci více zdrojů najednou předrezervace vyžaduje jedinou atomickou operaci.",incorrect:"Pro rezervaci více zdrojů najednou předrezervace umožňuje více postupných operací.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"3f8ce394-4388-47d0-bed7-3b07de2f5b59",correct:"Virtualizované zdroje nepoužívají výlučnou rezervaci, a proto nemohou přímo způsobit uváznutí.",incorrect:"Virtualizované zdroje používají výlučnou rezervaci, a proto mohou přímo způsobit uváznutí.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"b3da32d7-ce1f-4ef5-8721-e8d42849b303",correct:"Virtualizace tiskáren obvykle používá frontu pro správu tiskových úloh.",incorrect:"Virtualizace tiskáren obvykle nepoužívá frontu pro správu tiskových úloh.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"67ae12a7-1d66-4356-8fb9-29bd91851edf",correct:"Virtualizace napadá vzájemné vyloučení, aby umožnila více programům využívat zdroj.",incorrect:"Virtualizace posiluje vzájemné vyloučení, aby umožnila více programům využívat zdroj.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"fd3d31ef-0322-4a08-b04a-c80187facc4a",correct:"Zavedení globálního uspořádání zdrojů efektivně zamezuje vzniku kruhového čekání mezi vlákny.",incorrect:"Zavedení globálního uspořádání zdrojů nijak neovlivňuje vznik kruhového čekání mezi vlákny.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"},{uuid:"e98564b7-debf-4955-a67a-3758fd44662f",correct:"V systému s globálním uspořádáním musí vlákno rezervovat zdroje v pořadí určeném globálním uspořádáním.",incorrect:"V systému s globálním uspořádáním může vlákno rezervovat zdroje v libovolném pořadí.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"},{uuid:"d46e19b2-66c4-4722-858d-809489ac9a3e",correct:"Globální uspořádání zdrojů je praktické pro menší uzavřené systémy, ale pro rozsáhlý OS se příliš nehodí.",incorrect:"Globální uspořádání zdrojů je ideálním řešením pro zamezení uváznutí i v rozsáhlých operačních systémech.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"}]},{uuid:"42cce62a-c42a-4f86-8698-6b4e060af424",sectionNumber:"8",sectionTitle:"Přerušení a periferie",statements:[{uuid:"3d20a6e2-2708-424c-adc7-7f78bfe7a54d",correct:"Přerušení je synchronizační zařízení, které slouží k synchronizaci periferie a softwaru.",incorrect:"Přerušení je synchronizační zařízení, které slouží k synchronizaci dvou softwarových vláken.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"759179ce-a4d6-48fa-964c-3666308dbd8e",correct:"Asymetrie přerušení spočívá v tom, že přerušení je vždy signalizováno periferií, nikoliv operačním systémem.",incorrect:"Asymetrie přerušení spočívá v tom, že přerušení může být signalizováno jak periferií, tak operačním systémem.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"bbd7c91b-36e1-49f9-9e86-df061de70f71",correct:"Operační systém je pasivním účastníkem přerušení, protože přerušení je vždy aktivováno periferií.",incorrect:"Operační systém je aktivním účastníkem přerušení a může aktivně vyvolávat přerušení pro periferie.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"32ef6860-183e-4d8d-bc4a-4fcb25eeef41",correct:"Přerušení je hardwarový mechanismus, který operační systém využívá pro reakci na události.",incorrect:"Přerušení je softwarový mechanismus, který operační systém využívá pro plánování procesů.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"cdb8533b-e8f5-4652-bbce-ed19c41dc479",correct:"Operační systém je program, který musí být vykonáván procesorem, aby mohl řídit hardware.",incorrect:"Operační systém je program, který je vykonáván pamětí a nepotřebuje procesor k řízení hardware.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"c70a285f-d5b3-4fc6-aa27-3a1276c20675",correct:"Při preemptivním přerušení je aktuálně běžící program procesoru dočasně pozastaven a uložen do paměti.",incorrect:"Při preemptivním přerušení je aktuálně běžící program procesoru dokončen před zpracováním přerušení.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"f2f6bdb7-17db-49cb-8315-2a19cdfbe3e2",correct:"Obsluha přerušení je spuštěna procesorem až po uložení aktuálního stavu vlákna do operační paměti.",incorrect:"Obsluha přerušení je spuštěna procesorem ihned, bez ohledu na stav aktuálního vlákna.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"fd221119-b188-4425-b97f-cdbca6efc319",correct:"Počet instancí přerušení je omezen hardwarem a typicky nepřesahuje 256 instancí.",incorrect:"Počet instancí přerušení je omezen softwarem a typicky nepřesahuje 256 instancí.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"90daac39-e284-4e11-8db0-33792d600935",correct:"Každá instance přerušení má přidruženou vlastní obsluhu, která je realizována jako podprogram.",incorrect:"Více instancí přerušení může sdílet jednu obsluhu, která je realizována jako podprogram.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"5fbc2539-dfd1-48d8-8df3-426ff3b46c5e",correct:"Adresa obslužného podprogramu pro každé přerušení je uložena v tabulce obsluhy přerušení.",incorrect:"Adresa obslužného podprogramu pro všechna přerušení je uložena na jednom místě v paměti.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"8ae4b340-5d5c-4aee-bf0c-17c97e13fdd0",correct:"Instance přerušení jsou rozlišeny a identifikovány pomocí čísel.",incorrect:"Instance přerušení jsou rozlišeny a identifikovány pomocí názvů.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"3977cfda-397e-4230-bed4-619df243a724",correct:"Tabulka obsluhy přerušení obsahuje pro každou instanci přerušení jednu položku.",incorrect:"Tabulka obsluhy přerušení obsahuje jednu položku pro všechny instance přerušení dohromady.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"75eae350-9bca-4f37-bf83-7f45ce25e147",correct:"Obslužný podprogram přerušení se podobá běžnému podprogramu s výjimkou speciálního prologu a epilogu.",incorrect:"Obslužný podprogram přerušení je zcela odlišný od běžného podprogramu a nevyužívá zásobník.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"8b02e038-94ed-4c96-ad5d-a9efaa3e02b7",correct:"Během obsluhy přerušení dochází k přepnutí na vyhrazený zásobník, protože původní zásobník nemusí být dostatečný.",incorrect:"Během obsluhy přerušení nikdy nedochází k přepnutí zásobníku a vždy se používá původní zásobník procesu.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"e99fbdd6-dbe6-4e3a-963a-5d5e75538bf7",correct:"Obsluha přerušení se provádí v privilegovaném režimu jádra, což jí umožňuje plný přístup k hardwarovým zdrojům.",incorrect:"Obsluha přerušení se provádí v uživatelském režimu a má omezený přístup k hardwarovým zdrojům systému.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"07020ccc-8254-44cf-9f28-21aa4b2a2b9d",correct:"Pro synchronizaci mezi CPU jádry lze v obsluze přerušení použít spinlocky.",incorrect:"Pro synchronizaci mezi CPU jádry nelze v obsluze přerušení použít spinlocky.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"e79e8c3e-0500-4c30-9d0b-170d3c25bb3b",correct:"Pro synchronizaci na stejném CPU jádře nelze v obsluze přerušení použít spinlocky.",incorrect:"Pro synchronizaci na stejném CPU jádře lze v obsluze přerušení použít spinlocky.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"b261759a-80a0-4c96-ae9b-cfa321215513",correct:"Obslužný podprogram přerušení nemůže být uspán plánovačem operačního systému.",incorrect:"Obslužný podprogram přerušení může být uspán plánovačem operačního systému.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"143d12bf-cba4-4615-ba84-707e1e9ad5e7",correct:"Zákaz přerušení představuje formu vzájemného vyloučení specifickou pro obslužné podprogramy.",incorrect:"Zákaz přerušení není forma vzájemného vyloučení specifická pro obslužné podprogramy.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"a9d6df07-6f81-4e60-b986-4ca8b22e0881",correct:"Obsluha druhé úrovně se používá v případech, kdy obsluha přerušení potřebuje čekat na událost.",incorrect:"Obsluha druhé úrovně se používá i v případech, kdy obsluha přerušení nepotřebuje čekat.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"ebfdac16-3e60-4b32-a5ff-e2db74d69cd2",correct:"Zákaz přerušení je asymetrický mechanismus synchronizace, působící pouze směrem k obsluze přerušení.",incorrect:"Zákaz přerušení je symetrický mechanismus synchronizace, působící oběma směry, jak k obsluze, tak i k jádru.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"37d433c9-35f9-4097-8330-4707260b4ba4",correct:"Obsluha přerušení je na jednom CPU atomická z hlediska zbytku jádra díky zákazu přerušení.",incorrect:"Obsluha přerušení není na jednom CPU atomická z hlediska zbytku jádra, i když je zákaz přerušení aktivní.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"8732cfd8-35f5-4a57-bbeb-803b854bc6a4",correct:"Kritické sekce v operačním systému, zejména ty sdílené mezi jádrem a obsluhou přerušení, vyžadují ochranu.",incorrect:"Kritické sekce v operačním systému, i když jsou sdílené mezi jádrem a obsluhou přerušení, ochranu nevyžadují.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"dbe85709-765b-45f6-b6c6-fd6becc666e0",correct:"Zákaz přerušení by neměl být používán po příliš dlouhou dobu, aby se předešlo latenci systému.",incorrect:"Zákaz přerušení může být používán libovolně dlouho, bez negativního vlivu na latenci systému.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"3f835c75-384f-4c59-be9f-2ac8bed7a4e1",correct:"Jádro může využít zákaz přerušení pro synchronizaci i v jiných částech kódu, nejen v obsluze přerušení.",incorrect:"Jádro může využít zákaz přerušení pro synchronizaci výhradně jen v obsluze přerušení, nikoliv jinde.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"2c8588f1-8a93-4754-891d-74a323a5aa31",correct:"Vlákno je výpočet, který vznikne nepřerušenou činností procesoru řízeného programem.",incorrect:"Vlákno je proces, který vznikne přerušenou činností procesoru řízeného programem.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"0addde2d-e507-4e8d-bfcf-cb9ea5787248",correct:"Vlákno není vázáno na adresní prostor a jeden proces může obsahovat více vláken.",incorrect:"Vlákno je vázáno na adresní prostor a jeden proces může obsahovat jen jedno vlákno.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"2b088017-ab66-4369-97fd-bacdc066e121",correct:"Při aktivaci obsluhy přerušení se proces nepřepíná, protože se nemění mapování paměti.",incorrect:"Při aktivaci obsluhy přerušení se proces přepíná, protože se mění mapování paměti.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"879819cd-f20f-40bf-b073-46d2218b162e",correct:"Paměť obsluhy přerušení musí být dostupná ve všech virtuálních adresních prostorech na stejných adresách.",incorrect:"Paměť obsluhy přerušení musí být dostupná pouze v adresním prostoru aktuálního procesu.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"6cb82750-aa66-4b65-b670-506fb35952e5",correct:"Aktivace procesu je drahá operace, protože vyžaduje změnu mapování paměti.",incorrect:"Aktivace procesu je levná operace, protože nevyžaduje změnu mapování paměti.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"9abb82d4-754f-466d-b450-1c668db42470",correct:"Obsluha přerušení běží v provizorních podmínkách a blokuje přerušené vlákno.",incorrect:"Obsluha přerušení běží v běžných podmínkách a neblokuje přerušené vlákno.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"6a9359f9-b88d-4268-a634-8627b4ad8569",correct:"Běžnými synchronizačními prostředky nelze synchronizovat obsluhu přerušení s přerušeným vláknem.",incorrect:"Běžnými synchronizačními prostředky lze synchronizovat obsluhu přerušení s přerušeným vláknem.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"173ce717-73f8-4109-ade6-2ba2721b93e1",correct:"Adresy obsluhy přerušení jsou přístupné výhradně v privilegovaném režimu procesoru.",incorrect:"Adresy obsluhy přerušení jsou přístupné i v uživatelském režimu procesoru.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"52c4e5a4-b978-4ebc-ad3d-5a3c5a12ff4b",correct:"Při vstupu do obsluhy přerušení se obvykle zakazují další přerušení, minimálně stejného typu.",incorrect:"Při vstupu do obsluhy přerušení se nikdy nezakazují další přerušení, aby systém zůstal plně responzivní.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"a39b33e1-4e04-4a4d-a818-a4c8eca7d428",correct:"Obsluha přerušení vykonává minimální nutnou akci pro uvedení systému do provozuschopného stavu.",incorrect:"Obsluha přerušení vykonává kompletní obsluhu události, včetně všech souvisejících úkonů.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"3f8ce31f-2525-4c0a-a719-ed73d2dd8f46",correct:"Zbytek akcí obsluhy přerušení se plánuje na pozdější vykonání jinou částí jádra.",incorrect:"Veškeré akce obsluhy přerušení jsou vykonávány okamžitě a kompletně v rámci obsluhy přerušení.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"f6729b60-2c85-480d-91b9-378ba99e422b",correct:"Existují nemaskovatelná přerušení, která nelze zakázat a jsou určena pro závažné události.",incorrect:"Všechna přerušení v systému mohou být zakázána během obsluhy přerušení, včetně kritických událostí.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"1057d610-d7d9-4fee-8f14-fc3ea9ecd154",correct:"Přerušení typu notifikace, jako například vsync, jsou obvykle nezávazná a jejich zpoždění neohrozí systém.",incorrect:"Přerušení typu notifikace, jako například vsync, jsou kritická a jejich zpoždění vážně ohrozí systém.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"41d46de5-5b13-4522-a434-e9a187fa7bfa",correct:"U periferií s malou šířkou pásma, jako UART, se data obvykle čtou z registrů periferie v reakci na přerušení.",incorrect:"U periferií s velkou šířkou pásma, jako UART, se data obvykle čtou z registrů periferie v reakci na přerušení.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"ee0c6574-94b9-4e39-8953-6058e87fb546",correct:"Vsync přerušení informuje o výměně obrazu na displeji a obvykle není časově kritické pro operační systém.",incorrect:"Vsync přerušení informuje o výměně obrazu na displeji a je vysoce časově kritické pro operační systém.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"e9fd56d6-1825-47d7-a8a9-d7724505b298",correct:"UART zařízení s vyrovnávací pamětí 128 bitů a plným vytížením generuje přerušení s frekvencí do 900Hz.",incorrect:"UART zařízení s vyrovnávací pamětí 128 bitů a plným vytížením generuje přerušení s frekvencí nad 10kHz.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"7c2f0c73-8fcd-466e-8e8b-c3ee5543229d",correct:"Zařízení s větší šířkou pásma obvykle používají DMA pro souběžný přenos dat.",incorrect:"Zařízení s větší šířkou pásma obvykle používají přerušení pro souběžný přenos dat.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"d3de0537-5bfe-4ccb-8293-7a31188e0426",correct:"Synchronizace směrem k periferii u DMA se provádí zápisem do registru zařízení.",incorrect:"Synchronizace směrem k periferii u DMA se provádí pomocí přerušení od periferie.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"a97c72ad-dd34-45fc-9e70-623c55b1a354",correct:"Periferie využívající DMA signalizuje dokončení přenosu do systému pomocí přerušení.",incorrect:"Periferie využívající DMA signalizuje dokončení přenosu do systému zápisem do registru.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"c39ce50c-820a-4454-9e0b-db443aaabf75",correct:"Přenosy DMA vyžadují synchronizaci s operačním systémem prostřednictvím ovladače zařízení.",incorrect:"Přenosy DMA jsou zcela autonomní a nevyžadují synchronizaci s operačním systémem.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"21650403-13f7-4538-81f1-bdcbb3e638fa",correct:"Vysoká přenosová rychlost u DMA zvyšuje riziko přetečení dostupné operační paměti.",incorrect:"Vysoká přenosová rychlost u DMA snižuje riziko přetečení dostupné operační paměti.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"a5feb468-80a8-488a-8122-183308241e1a",correct:"Síťová rozhraní Intel E1000 podporují příjmové fronty s maximální délkou 256 rámců.",incorrect:"Síťová rozhraní Intel E1000 podporují příjmové fronty s maximální délkou 512 rámců.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"90cf6795-02e1-4945-9802-afb6d6552a39",correct:"Při 1Gb/s a 1kHz přerušení DMA je nutné zpracovat přibližně 1Mb dat na každé přerušení.",incorrect:"Při 1Gb/s a 1kHz přerušení DMA je nutné zpracovat přibližně 1Kb dat na každé přerušení.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"8723a78b-1c9a-40d0-a2fc-9a9a14240022",correct:"Přerušení časovače je složité kvůli interakci s plánovačem vláken a řízení pravidelných činností OS.",incorrect:"Přerušení časovače je jednoduché, protože se nezabývá plánováním vláken a řídí pouze nepravidelné činnosti OS.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"d41fc288-9f6a-4ae8-af63-70ae144426a6",correct:"Manipulace s frontami vláken v obsluze přerušení časovače musí probíhat v první úrovni obsluhy.",incorrect:"Manipulace s frontami vláken v obsluze přerušení časovače se může odložit do obsluhy druhé úrovně.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"6b034ef9-9cbd-444d-85d5-7ac44c9fc15d",correct:"Synchronizace při manipulaci s frontami vláken musí být chráněna spinlockem a zákazem přerušení.",incorrect:"Synchronizace při manipulaci s frontami vláken se může spoléhat pouze na spinlocky bez nutnosti zakazovat přerušení.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"56996f03-641d-4bbe-9a99-9226a9f4d794",correct:"Přepnutí kontextu mezi vlákny různých procesů vyžaduje přepnutí stránkovacích tabulek.",incorrect:"Přepnutí kontextu mezi vlákny různých procesů se obejde bez přepnutí stránkovacích tabulek.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"696cf28f-5470-40f3-9ebe-e3997680af8c",correct:"Každý procesor v systému obvykle disponuje vlastním časovačem pro řízení událostí.",incorrect:"V systému s více procesory se obvykle používá jeden sdílený časovač pro všechny procesory.",sectionNumber:"8.3.3",sectionTitle:"Časovač"}]},{uuid:"89a152f1-f487-4028-a450-1f5daa715b14",sectionNumber:"9",sectionTitle:"Interacting with the World",statements:[{uuid:"782627c8-2b0f-49cb-91a2-1175fe89a859",correct:"Shell skriptování se zaměřuje na interakci s operačním systémem.",incorrect:"Shell skriptování se primárně zaměřuje na vývoj grafického uživatelského rozhraní.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"1620b5cf-14b0-4f6b-9341-9e46a2f0a449",correct:"Shell skripty implementují základní řízení toku programu.",incorrect:"Shell skripty postrádají jakékoliv mechanismy pro řízení toku programu.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"85f9bd82-1194-49d7-bcca-61380588b563",correct:"Proměnné v shell skriptování slouží jako zástupné symboly v příkazech.",incorrect:"Proměnné v shell skriptování se používají výhradně pro matematické operace.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"7834efe5-5b75-45d7-932a-6754d0b3be21",correct:"Zpracování chyb v shell skriptech je tradičně považováno za nedostatečné.",incorrect:"Shell skripty se vyznačují sofistikovaným a detailním zpracováním chyb.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"6a4d535b-69c8-49b1-9a95-c0737e2b39f6",correct:"Shell skriptovací jazyky typicky nevyžadují explicitní deklaraci typů proměnných.",incorrect:"Shell skriptovací jazyky vyžadují striktní typovou kontrolu všech proměnných.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"61fb0a3a-79f0-4268-93ef-1350de7d1874",correct:"Většina shellů disponuje interaktivním režimem.",incorrect:"Jen málo shellů disponuje interaktivním režimem.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"ec8912b0-a448-41f1-a2a8-eec45a9a7685",correct:"V interaktivním režimu uživatel zadává jeden příkaz na klávesnici a řádek.",incorrect:"V interaktivním režimu uživatel zadává více příkazů najednou na klávesnici.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"6b3f0b8b-2de4-45b5-aac8-8ce41349fe68",correct:"Příkazy v interaktivním režimu se provedou okamžitě po potvrzení uživatelem.",incorrect:"Příkazy v interaktivním režimu se provedou až po delší prodlevě.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"2811d76d-e50a-4c34-ad52-0b0ab19d54a2",correct:"Rozhraní příkazového řádku jsou založena na principu interaktivního režimu.",incorrect:"Grafická uživatelská rozhraní jsou založena na principu interaktivního režimu.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"3fc320ab-7503-4acb-97be-f806b3def3b8",correct:"Mezi shell skripty a interaktivním příkazovým řádkem není syntaktický rozdíl.",incorrect:"Mezi shell skripty a interaktivním příkazovým řádkem existuje syntaktický rozdíl.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"3db4286e-1979-413a-ab30-060cb342120f",correct:"Interaktivní režim umožňuje psaní krátkých skriptů, takzvaných one-linerů, přímo v příkazovém řádku.",incorrect:"Interaktivní režim neumožňuje psaní krátkých skriptů, one-linerů, přímo v příkazovém řádku.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"22c9a85f-f650-4d13-b462-838cd930768d",correct:"Shell script je spustitelný soubor obsahující sekvenci příkazů.",incorrect:"Shell script je spustitelný soubor obsahující pouze jeden příkaz.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"5a915eb1-5397-4ad2-ab24-15d65d9f277e",correct:"Spuštění shell scriptu se podobá postupnému zadávání příkazů v terminálu.",incorrect:"Spuštění shell scriptu se zásadně liší od postupného zadávání příkazů v terminálu.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"b573ab70-28f5-443f-8f1f-9203e4639cc6",correct:"Shell scripty mohou využívat konstrukce strukturovaného programování pro řízení toku.",incorrect:"Shell scripty nemohou využívat konstrukce strukturovaného programování pro řízení toku.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"91ddf9ab-62bd-4857-8605-7fe1acebfe88",correct:"Proměnné v shell scriptu umožňují substituci částí příkazů mezi spuštěními.",incorrect:"Proměnné v shell scriptu se používají pouze pro interaktivní zadávání příkazů.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"77e904a5-9763-4099-a8fd-7c8f4d7c8d0c",correct:"Shell skripty jsou velmi snadné na psaní pro jednoduché automatizační úlohy.",incorrect:"Shell skripty jsou komplikované na psaní i pro základní automatizační úlohy.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"fdd30e26-f7df-41ec-b7bf-90f299423b19",correct:"Pro rozsáhlé programy se shell skripty obvykle nedoporučují kvůli jejich omezením.",incorrect:"Shell skripty jsou ideální pro vývoj rozsáhlých a komplexních programů.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"c7ea7025-6baf-48f5-bb5c-c2819e86fb78",correct:"Nedostatek typového systému v shell skriptech komplikuje údržbu větších projektů.",incorrect:"Typový systém v shell skriptech usnadňuje vývoj a údržbu rozsáhlých aplikací.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"3dcc6732-ff82-4205-b3ef-1b845c344c0a",correct:"Shell skripty jsou efektivní pro automatizaci opakovaných úkonů v operačním systému.",incorrect:"Shell skripty jsou nevhodné pro automatizaci opakovaných úkonů v operačním systému.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"0eeac9cd-b86e-427f-ba60-b654939d4ed8",correct:"Bourne shell, vytvořený v roce 1976, definoval duální povahu shellů jako interaktivních a programovatelných.",incorrect:"Bourne shell, vytvořený v roce 1986, definoval pouze interaktivní povahu shellů.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"564966b2-56e8-4b1b-a9d9-fe6c51648179",correct:"Bash, zkratka pro Bourne Again Shell, je široce známá implementace Bourne shellu.",incorrect:"Bash je jediná existující implementace shellu a nemá nic společného s Bourne shellem.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"1fb60dfc-950b-47f1-8f57-4b0bbe2531c8",correct:"Standard POSIX vyžaduje přítomnost shellu sh, obvykle umístěného v adresáři /bin.",incorrect:"Standard POSIX vyžaduje přítomnost shellu sh výhradně v adresáři /usr/bin.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"7486b51c-b317-48b2-a981-eecc63d61d21",correct:"C shell byl druhý známý UNIXový shell, vydaný v roce 1978.",incorrect:"C shell byl prvním známým UNIXovým shellem, vydaný v roce 1978.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"b89550d8-7272-4ada-a2af-54836f1cff53",correct:"C shell nabídl vylepšený interaktivní režim oproti shellu Bourne.",incorrect:"C shell nabídl horší interaktivní režim oproti shellu Bourne.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"bed26cdd-1830-475b-80b3-364ff6356c8a",correct:"Tcsh je variantou C shellu s dodatečnými funkcemi, udržovanou od 80. let.",incorrect:"Tcsh je starší verzí C shellu bez dodatečných funkcí a není udržována.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"a77da248-6669-4aba-a86c-818c6ed96b1b",correct:"Mezi interaktivní vylepšení C shellu patřila historie příkazů a aliasy.",incorrect:"Mezi interaktivní vylepšení C shellu patřilo pouze automatické dokončování souborů.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"05d23b8b-6ef5-47dc-a9d1-b91094b6f310",correct:"Korn shell, známý také jako ksh, byl poprvé vydán v roce 1983.",incorrect:"Korn shell, známý také jako ksh, byl poprvé vydán v roce 1973.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"8e374e78-7f57-456f-8943-8f30c3e625f3",correct:"Korn shell kombinuje prvky Bourne shell a C shell, přičemž syntaxe skriptů zůstává věrná sh.",incorrect:"Korn shell kombinuje prvky Bourne shell a C shell, přičemž syntaxe skriptů je převzata z csh.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"9f364017-2585-4a70-805f-6e112d3f51ff",correct:"Korn shell slouží jako vzor pro standard POSIX.2 pro shell /bin/sh.",incorrect:"Bourne shell slouží jako vzor pro standard POSIX.2 pro shell /bin/sh.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"fd4fcf4f-919a-4a1b-a458-af4e2ce80eff",correct:"Původní implementace Korn shell byla založena na zdrojovém kódu Bourne shell.",incorrect:"Původní implementace Korn shell byla založena na zdrojovém kódu C shell.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"a4ddc110-25be-4658-855e-a37f1827dc92",correct:"Korn shell je považován za kompromis mezi Bourne shell a C shell.",incorrect:"Korn shell je považován za přímého nástupce C shell.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"54b5bbed-f344-421c-b18f-812e1ef22101",correct:"Příkaz shellu je typicky jméno spustitelného souboru.",incorrect:"Příkaz shellu je vždy jméno interního příkazu shellu.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"f7c8049f-748a-4019-9857-068f3a0a7a94",correct:"Shell pro spuštění externího příkazu využívá systémová volání fork a exec.",incorrect:"Shell pro spuštění externího příkazu využívá pouze systémové volání exec.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"d0e2df99-7f6d-4bb0-a574-060ff5edbebd",correct:"Vytváření nových procesů pro každý příkaz může být relativně nákladné.",incorrect:"Vytváření nových procesů pro každý příkaz je velmi levná operace.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"b4675a5d-e3ab-45b4-a816-7faa29e8d02c",correct:"Shell nejprve kontroluje, zda zadaný příkaz není interní příkaz.",incorrect:"Shell nikdy nekontroluje, zda zadaný příkaz je interní příkaz.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"27c51927-9996-45af-8f47-35a0f7a2e939",correct:"Hlavní proces shellu čeká na ukončení spuštěného programu pomocí volání wait.",incorrect:"Hlavní proces shellu nikdy nečeká na ukončení spuštěného programu.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"44970c7e-ca8a-44de-b332-0b8bc2da452d",correct:"Příkaz `echo` je často implementován jako vestavěný příkaz shellu z důvodu optimalizace výkonu.",incorrect:"Příkaz `echo` je implementován jako vestavěný příkaz shellu primárně z funkčních důvodů, nikoli z optimalizace výkonu.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"aa1d9be8-e872-408f-bb9c-dc65f336edbc",correct:"Příkaz `cd` musí být vestavěný, protože změna pracovního adresáře ovlivňuje hlavní proces shellu.",incorrect:"Příkaz `cd` může být implementován jako externí příkaz spouštěný v novém procesu bez ovlivnění hlavního shellu.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"17cd473c-6f5b-46d8-8790-78bc337a03dd",correct:"Příkaz `exec` bez použití `fork` nahrazuje aktuální shell proces novým programem.",incorrect:"Příkaz `exec` bez použití `fork` vytváří nový proces shellu, zatímco původní shell proces pokračuje.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"6f8fd754-e81a-4bff-b51b-584cda868e8e",correct:"Vestavěné příkazy shellu se liší od externích příkazů tím, že nepoužívají proces `fork` a `exec`.",incorrect:"Vestavěné příkazy shellu se od externích příkazů liší tím, že vždy používají proces `fork` a `exec`, ale optimalizovaně.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"9fbc9bff-76f2-4441-af43-f7b34ef059b1",correct:"Příkaz `export` je vestavěný, protože modifikuje prostředí hlavního shell procesu.",incorrect:"Příkaz `export` může být externí, protože modifikace prostředí se snadno propagují do hlavního shell procesu.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"1c470eef-8bd9-4470-b057-b3516730216a",correct:"Názvy proměnných v shellu se skládají pouze z písmen a číslic.",incorrect:"Názvy proměnných v shellu mohou obsahovat i speciální znaky jako pomlčky a podtržítka.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"da10324e-99d3-4505-9849-183e0a6c2735",correct:"Pro získání hodnoty proměnné v shellu se používá znak dolaru '$' před jménem proměnné.",incorrect:"Pro získání hodnoty proměnné v shellu se používá znak dolaru '$' za jménem proměnné.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"da334124-84e9-47e9-bb58-318f0c497e74",correct:"Při nastavování hodnoty proměnné se znak dolaru '$' před jménem proměnné nepoužívá.",incorrect:"Při nastavování hodnoty proměnné je nutné uvést znak dolaru '$' před jménem proměnné.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"1ec5d137-dbe9-47d2-9965-d79fc16d135c",correct:"Bílé znaky okolo operátoru '=' při přiřazování hodnoty proměnné nejsou v shellu povoleny.",incorrect:"Bílé znaky okolo operátoru '=' při přiřazování hodnoty proměnné jsou v shellu ignorovány.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"80761a99-5e11-4c2f-9705-9ea2dbd65a68",correct:"Uvozovky nejsou nutné při definici proměnné, pokud její hodnota neobsahuje bílé znaky.",incorrect:"Uvozovky jsou vždy nutné při definici proměnné v shellu, bez ohledu na obsah hodnoty.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"ff5c2094-7294-4923-baf0-b42cdf6cbc84",correct:"Substituce proměnných v shellu probíhá výhradně textově, bez ohledu na kontext použití proměnné.",incorrect:"Substituce proměnných v shellu probíhá kontextově, přičemž se rozlišuje, zda je proměnná použita v aritmetickém výrazu.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"0833251a-a461-463d-8761-13fa70e20678",correct:"Pro provádění aritmetických operací v shellu je nezbytné použít konstrukci `$((výraz))`.",incorrect:"Pro provádění aritmetických operací v shellu je doporučeno, ale není nezbytné, použít konstrukci `$((výraz))`.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"11f5f682-8c50-4a67-b46e-bef2072edd31",correct:"V aritmetických výrazech `$((...))` není nutné uvádět znak dolaru před názvy proměnných pro jejich substituci.",incorrect:"V aritmetických výrazech `$((...))` je nutné uvádět znak dolaru před názvy proměnných pro jejich substituci, podobně jako mimo aritmetické výrazy.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"af57004b-0fdb-412f-90ef-99e06ab9500a",correct:"Substituce proměnných bez dolaru uvnitř `$((...))` jsou interpretovány jako uzavřené v závorkách pro účely aritmetického vyhodnocení.",incorrect:"Substituce proměnných bez dolaru uvnitř `$((...))` nejsou interpretovány jako uzavřené v závorkách a jsou vyhodnocovány lineárně.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"19666cf7-ac03-4b19-be0f-0df7538f2b57",correct:"Rozdíl v použití dolaru před proměnnou v `$((...))` ovlivňuje způsob substituce a výslednou hodnotu aritmetického výrazu.",incorrect:"Rozdíl v použití dolaru před proměnnou v `$((...))` nemá žádný vliv na způsob substituce ani výslednou hodnotu aritmetického výrazu.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"291582c6-a119-45f4-9c18-f1094bc80cc2",correct:"Příkazová substituce pomocí `$(command)` provede příkaz a nahradí výstup do původního příkazu.",incorrect:"Příkazová substituce pomocí `$(command)` pouze zachytí vstup příkazu a neprovede ho.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"a8364843-396f-4868-b1ba-4790feefcff5",correct:"V příkazové substituci `$(command)` je příkaz proveden jako shell příkaz, potenciálně zahrnující fork a exec.",incorrect:"V příkazové substituci `$(command)` je příkaz proveden přímo v aktuálním shell procesu bez fork nebo exec.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"3614c9d9-c1f0-401a-84f4-7cc495775710",correct:"Výstup příkazu v `$(command)` je zachycen jako standardní výstup a použit pro substituci.",incorrect:"Výstup příkazu v `$(command)` je zachycen jako standardní chybový výstup a použit pro substituci.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"611aea89-efa0-4b13-8477-3545ec1511e0",correct:"Příklad `cat $(ls)` nejprve provede `ls` pro výpis souborů, a poté použije `cat` pro zobrazení obsahu těchto souborů.",incorrect:"Příklad `cat $(ls)` nejprve provede `cat` pro zřetězení souborů, a poté použije `ls` pro výpis zřetězených souborů.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"08018da6-d103-4d9c-837a-c578d631af16",correct:"Mezera slouží jako oddělovač argumentů v shellu.",incorrect:"Mezera není považována za oddělovač argumentů v shellu.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"28682975-e37d-4059-85da-7e3767d1a58f",correct:"Víceslovné argumenty v shellu musí být obaleny uvozovkami.",incorrect:"Víceslovné argumenty v shellu mohou být použity bez uvozovek.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"5d0f348b-009e-4151-ad66-c546ffa732c4",correct:"Dvojité uvozovky v shellu umožňují substituci proměnných.",incorrect:"Dvojité uvozovky v shellu neumožňují substituci proměnných.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"929d0ea2-2928-40bf-9a1d-561cc06cdeca",correct:"Jednoduché uvozovky v shellu zabraňují substituci proměnných.",incorrect:"Jednoduché uvozovky v shellu umožňují substituci proměnných.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"17ea422a-f231-4e3d-ab7c-8a57f89dd41d",correct:"V shellu lze pro uvozování řetězců použít jednoduché i dvojité uvozovky.",incorrect:"V shellu lze pro uvozování řetězců použít pouze dvojité uvozovky.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"0ff13076-6d3e-4f4b-883b-f992537632c9",correct:"Substituce parametrů se provádí před rozdělením argumentů, což může vést k neočekávanému chování při práci s mezerami.",incorrect:"Rozdělení argumentů předchází substituci parametrů, takže mezery v proměnných nemají vliv na interpretaci argumentů.",sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"32a5c533-5df2-415c-8291-f51001a821cd",correct:'Použití uvozovek kolem proměnné v příkazu shellu, například "$foo", zajistí, že hodnota proměnné bude považována za jediný argument.',incorrect:"Uvozovky kolem proměnné v příkazu shellu, jako '$foo', nemají žádný vliv na to, zda je hodnota proměnné považována za jeden nebo více argumentů.",sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"e24c7beb-fddb-4ef0-a4f2-921d155394e9",correct:"Pokud proměnná obsahuje mezeru a není uzavřena v uvozovkách, interpretuje shell mezeru jako oddělovač argumentů.",incorrect:"Shell vždy interpretuje obsah proměnné jako jediný argument, i když proměnná obsahuje mezery a není v uvozovkách.",sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"5ae1b4ae-6553-4cb7-b78c-7b77c8d08f42",correct:"Příkaz `ls $foo`, kde `$foo` je 'hello world', se chová jinak než `ls \"$foo\"`, protože v prvním případě `ls` obdrží více argumentů.",incorrect:'Příkazy `ls $foo` a `ls "$foo"` se chovají identicky, i když proměnná `$foo` obsahuje mezery, protože shell je automaticky zpracuje.',sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"ecee10d0-f3ba-46d5-a680-398a94f35b5c",correct:"Speciální proměnná `$?` v shellu udává návratový kód posledního spuštěného příkazu.",incorrect:"Speciální proměnná `$?` v shellu udává PID aktuálního shellu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"7d68b6cf-fce6-4e2c-af97-8f64c8eb1d52",correct:"Proměnná `$$` v shellu obsahuje PID aktuálního shell procesu.",incorrect:"Proměnná `$$` v shellu obsahuje PID posledního procesu na pozadí.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"d349ea76-9224-4929-aa47-a9da6e10528b",correct:"Proměnné `$1` až `$9` v shell skriptu reprezentují poziční parametry.",incorrect:"Proměnné `$1` až `$9` v shell skriptu reprezentují speciální proměnné shellu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"fcd89922-0525-495b-af4e-55083dfaaec5",correct:"Speciální proměnná `$#` udává počet pozičních parametrů předaných shell skriptu.",incorrect:"Speciální proměnná `$#` udává počet speciálních proměnných shellu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"ff36a6c6-f995-4b28-a690-ade8a1ea0dbc",correct:"Proměnná `$0` obsahuje jméno shellu, které odpovídá `argv[0]` v jazyce C.",incorrect:"Proměnná `$0` obsahuje návratový kód posledního příkazu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"dc460987-cd40-4307-9d72-5f77f0fbc1a7",correct:"Proměnná `$@` expanduje do všech pozičních parametrů a chová se speciálně v dvojitých uvozovkách.",incorrect:"Proměnná `$@` expanduje pouze do prvního pozičního parametru, bez ohledu na uvozovky.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"e46b3985-4cc2-4b90-9699-c39c41fa79b1",correct:"Proměnná `$*` expanduje do všech pozičních parametrů bez speciálního chování v dvojitých uvozovkách.",incorrect:"Proměnná `$*` expanduje do všech pozičních parametrů se stejným chováním v dvojitých uvozovkách jako `$@`.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"5fe447f7-a641-45bb-82c8-bd4b3706f37c",correct:"Speciální proměnná `$!` obsahuje PID posledního procesu spuštěného na pozadí.",incorrect:"Speciální proměnná `$!` obsahuje PID aktuálního shell procesu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"c97e00e0-dc45-4e5a-b5e4-fe7346975914",correct:"Proměnná `$-` v shellu reprezentuje aktuální nastavení shell options.",incorrect:"Proměnná `$-` v shellu reprezentuje počet pozičních parametrů.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"1eb86b65-005b-47a5-8c3f-230a5691a628",correct:"Proměnné prostředí se předávají mezi procesy pomocí fork a exec.",incorrect:"Proměnné prostředí se předávají pouze novým procesům vytvořeným pomocí exec, nikoli fork.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"7c7861ee-c5fc-4330-9b2b-711fb24ea253",correct:"Změny proměnných prostředí se šíří pouze k potomkům procesu.",incorrect:"Změny proměnných prostředí se šíří i k rodičovskému procesu.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"0641f5d0-0a83-4326-af2c-ec4fb297397d",correct:"Potomkovský proces nemůže ovlivnit proměnné prostředí svého rodiče.",incorrect:"Potomkovský proces může přímo modifikovat proměnné prostředí svého rodiče.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"3df168e9-2a51-4a71-9d07-3af23c7be103",correct:"Shell interpretuje proměnné prostředí podobně jako své vlastní interní proměnné.",incorrect:"Shell interpretuje proměnné prostředí zcela odlišně od svých interních proměnných.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"8c2d2342-9d5f-4705-8b2b-310e35c25ef9",correct:"Proměnné prostředí POSIX jsou nezávislé na konkrétním shellu.",incorrect:"Proměnné prostředí POSIX jsou specifické pro shell, ve kterém byly nastaveny.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"4425f598-950c-486a-a396-3faaff594f14",correct:"Konvence pro pojmenování proměnných prostředí je používat výhradně velká písmena.",incorrect:"Konvence pro pojmenování proměnných prostředí je používat výhradně malá písmena.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"a938044d-2be8-4b94-963a-bfae4d51750b",correct:"Proměnná prostředí `$PATH` udává systému, kde má hledat spustitelné programy.",incorrect:"Proměnná prostředí `$PATH` udává systému, kde má hledat konfigurační soubory uživatelů.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"cc5e8a3f-b8fd-416d-b13c-16ee6a183f5a",correct:"Proměnná prostředí `$HOME` určuje domovský adresář aktuálního uživatele.",incorrect:"Proměnná prostředí `$HOME` určuje aktuální pracovní adresář.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"87354b4a-b712-40b9-a1b9-ca3f3fe50512",correct:"Proměnná prostředí `$PWD` je nastavena shellem.",incorrect:"Proměnná prostředí `$PWD` je nastavena systémovým administrátorem.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"8af0de9f-ef43-4503-b5bf-ca55095ea4a5",correct:"Proměnnou prostředí `$PATH` mohou uživatelé měnit, i když je obvykle konfigurována administrátorem.",incorrect:"Proměnnou prostředí `$PATH` uživatelé nemohou měnit, pouze systémový administrátor má tuto možnost.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"b8d42534-e090-4a6a-8a66-9250203bdd3f",correct:"Globbing v shellu slouží k rychlému vypisování více souborů pomocí vzorů.",incorrect:"Globbing v shellu slouží k úpravě obsahu souborů pomocí speciálních vzorů.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"e1f7d29e-104e-4a33-a101-2959da8e7a4f",correct:"V globbingu znak '*' odpovídá libovolnému počtu znaků v názvu souboru.",incorrect:"V globbingu znak '*' odpovídá právě jednomu znaku v názvu souboru.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"3d0e643c-429f-4432-9ad2-1c3123bf656b",correct:"Expanzi glob vzorů provádí samotný shell, nikoliv volaný program.",incorrect:"Expanzi glob vzorů provádí volaný program, nikoliv samotný shell.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"97abc6ad-d089-40ba-b60e-a69b0faeaca1",correct:"Jednoduché i dvojité uvozovky zabraňují expanzi glob vzorů v shellu.",incorrect:"Jednoduché i dvojité uvozovky umožňují expanzi glob vzorů v shellu.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"bc82f528-0142-4fa9-8c23-bcf8fafee768",correct:"Globbing je možné použít i v celých cestách, například 'ls src/*/*.c'.",incorrect:"Globbing je možné použít pouze v aktuálním adresáři, nikoliv v celých cestách.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"18b59486-fcc4-4f38-a591-0bdde3210927",correct:"Příkaz `cond` v konstrukci `if` je interpretován jako pravdivý, pokud skončí s návratovým kódem 0.",incorrect:"Příkaz `cond` v konstrukci `if` je interpretován jako pravdivý, pokud skončí s návratovým kódem 1.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"3579d729-9796-4bb7-a818-d789833cdbd3",correct:"V shellových skriptech, klíčové slovo `if` umožňuje provádět podmíněné spuštění příkazů.",incorrect:"V shellových skriptech, klíčové slovo `while` umožňuje provádět podmíněné spuštění příkazů.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"2fdca52a-8dbd-456e-b793-b35504ea6739",correct:"Konstrukce `if` v shellu používá návratový kód příkazu `cond` pro vyhodnocení podmínky.",incorrect:"Konstrukce `if` v shellu používá výstup příkazu `cond` pro vyhodnocení podmínky.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"6f85b84d-756e-4ae6-a8b3-58552db478eb",correct:"Klauzule `elif` a `else` jsou volitelné součásti konstrukce `if` v shellových skriptech.",incorrect:"Klauzule `elif` a `else` jsou povinné součásti konstrukce `if` v shellových skriptech.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"b16699a2-0522-4ed4-8f2a-d1213f458ab1",correct:"Příkaz `test` byl původně externí program, ale nyní je často zabudován do shellů.",incorrect:"Příkaz `test` je vždy externí program a nikdy není zabudován do shellů.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"4a771ff6-294b-419c-bac6-54f5bb706a89",correct:"Příkaz `test` slouží k obcházení nedostatku výrazů v shell skriptech a vrací logickou hodnotu.",incorrect:"Příkaz `test` slouží k definování nových výrazů v shell skriptech a vrací číselnou hodnotu.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"82b6afe1-8a1b-4b23-ba48-22dcd9bbbe79",correct:"Standard POSIX specifikuje příkaz `test` jako speciální program pro vyhodnocování podmínek.",incorrect:"Standard POSIX definuje, že příkaz `test` není speciální program, ale běžná součást shellu.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"c0efd6de-84fe-4dcc-932a-eb4e649de6f9",correct:"Příkaz `test` v shellu umožňuje kombinovat predikáty s substitucí proměnných.",incorrect:"Příkaz `test` v shellu nepodporuje kombinování predikátů s substitucí proměnných.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"5179b998-f329-4bae-834f-e77f1b779db3",correct:"Příkaz `test` poskytuje tři třídy predikátů: pro soubory, čísla a řetězce.",incorrect:"Příkaz `test` poskytuje pouze dvě třídy predikátů: pro čísla a řetězce.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"cc200b8c-c408-43b5-9c12-32dcfeba18af",correct:"Predikáty pro soubory v příkazu `test` usnadňují psaní skriptů závislých na existenci souborů.",incorrect:"Predikáty pro soubory v příkazu `test` jsou primárně určeny pro porovnávání číselných hodnot v souborech.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"74960d7b-3fdb-4414-84f4-7c5b3449b3df",correct:"Syntaxe pro porovnávání čísel a řetězců v příkazu `test` se liší od běžných programovacích jazyků.",incorrect:"Syntaxe pro porovnávání čísel a řetězců v příkazu `test` je identická s běžnými programovacími jazyky.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"27ae8435-6d42-4f1f-9a91-afb2f9b7d1c2",correct:"Příkaz `while` v shell skriptech opakuje cyklus dokud daný příkaz neuspěje.",incorrect:"Příkaz `while` v shell skriptech opakuje cyklus dokud daný příkaz uspěje.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"7f335984-c6a1-49bc-ae4f-264481d2dd77",correct:"Cyklus `for` v shellu umožňuje použití globů, například pro iteraci přes všechny `.c` soubory.",incorrect:"Cyklus `for` v shellu neumožňuje použití globů pro iteraci přes soubory.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"f7a8cf75-c35b-48b3-a076-d9372054d171",correct:"Příkazová substituce může být použita v cyklu `for` k dynamickému generování seznamu prvků.",incorrect:"Příkazová substituce nemůže být použita v cyklu `for`.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"a7954f14-4380-4a8a-8f03-647668695800",correct:"Utilita `seq` je v shell skriptech nestandardní nástroj pro generování číselných sekvencí.",incorrect:"Utilita `seq` je v shell skriptech standardní nástroj pro generování číselných sekvencí.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"f39fc374-af4e-4f22-97d2-f388bee99306",correct:"Příkaz `case` vybírá příkaz na základě porovnávání vzorů.",incorrect:"Příkaz `case` vybírá příkaz na základě glob expanze jmen souborů.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"1eae6965-50d9-4394-a3cb-bda80e41d858",correct:"V příkazu `case` se používají nevyvážené závorky.",incorrect:"V příkazu `case` se používají vyvážené závorky.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"e7200ec6-a66d-4b14-9ef0-6f33443cb6d1",correct:"`case analýza` umožňuje použití vzorů podobných glob na libovolné řetězce.",incorrect:"`case analýza` umožňuje použití pouze regulárních výrazů na libovolné řetězce.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"5ba02fac-2d4e-43a5-a781-2012d9fb68d0",correct:"Vzory v klauzuli `in` příkazu `case` nejsou glob expanzí jmen souborů.",incorrect:"Vzory v klauzuli `in` příkazu `case` jsou glob expanzí jmen souborů.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"2e070c2a-404d-4fb9-a20f-58df6440fbb1",correct:"Operátor středník (;) umožňuje sekvenční spuštění příkazů.",incorrect:"Operátor středník (;) umožňuje paralelní spuštění příkazů.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"4399c821-6733-4b06-9f32-ccd669e851b6",correct:"Operátor '&&' spustí druhý příkaz pouze pokud první příkaz uspěje.",incorrect:"Operátor '&&' spustí druhý příkaz i když první příkaz selže.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"513aecfb-1504-44fb-b439-2b15259fcfd4",correct:"Operátor '||' spustí druhý příkaz pouze pokud první příkaz selže.",incorrect:"Operátor '||' spustí druhý příkaz i když první příkaz uspěje.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"05648df6-90d0-4966-a665-9e79138a8c13",correct:"Operátory '&&' a '||' fungují jako booleovské kombinátory pro řízení toku příkazů.",incorrect:"Operátory '&&' a '||' primárně slouží k optimalizaci paměti, nikoliv k řízení toku.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"99580e7f-1682-4b4a-8c19-789988b96979",correct:"Operátor '&&' může snížit interakční latenci tím, že zastaví provádění příkazů při prvním neúspěchu.",incorrect:"Operátor '&&' zvyšuje interakční latenci tím, že vždy čeká na dokončení všech příkazů.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"e9f5a6ff-19a8-4aad-b9db-7ab0526edcd6",correct:"Příkazové interprety umožňují spouštění rour příkazů.",incorrect:"Příkazové interprety nepodporují spouštění rour příkazů.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"f30fc8a8-b44e-41a4-a8d7-1545add9aac7",correct:"Všechny příkazy v rouře jsou spouštěny paralelně.",incorrect:"Všechny příkazy v rouře jsou spouštěny sekvenčně.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"d0796529-546a-423e-b017-26a670237f11",correct:"Výstup prvního příkazu se stává vstupem druhého příkazu v rouře.",incorrect:"Výstup prvního příkazu je ignorován a nepředává se dál v rouře.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"799e34ea-5981-4d5f-a43c-0559e9409f56",correct:"Roury nabízejí flexibilní způsob, jak kombinovat více příkazů.",incorrect:"Roury omezují flexibilitu kombinování příkazů v systémech.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"18628be0-4b9b-4770-a6b9-b86125a29cc7",correct:"Standard POSIX specifikuje utility navržené pro práci v rourách.",incorrect:"Standard POSIX se nezabývá utilitami pro efektivní práci v rourách.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"7eb3921d-56a2-43ce-953c-0a62b6eb92bf",correct:"Shell funkce jsou odlehčenou alternativou k shell skriptům.",incorrect:"Shell funkce jsou těžkopádnou alternativou k shell skriptům.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"f36227b8-04f5-4ed0-b102-349026ccfafd",correct:"Shell funkce nevyžadují export proměnných, aby byly přístupné uvnitř funkce.",incorrect:"Shell funkce vyžadují export proměnných, aby byly přístupné uvnitř funkce.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"42cbd7da-db51-4464-88a8-068e491bbcc3",correct:"Shell funkce nemohou být volány programy, které nejsou shell skripty.",incorrect:"Shell funkce mohou být volány programy, které nejsou shell skripty.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"2f78b971-d2a1-44b2-b56e-a8277e8f64bc",correct:"Změny proměnných uvnitř shell funkce mohou ovlivnit rodičovský shell.",incorrect:"Změny proměnných uvnitř shell funkce neovlivní rodičovský shell.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"85b747b2-134d-4f51-888d-d4076fc8f006",correct:"Hostname je pro člověka čitelné jméno počítače v síti.",incorrect:"Hostname je strojově čitelné binární číslo reprezentující počítač v síti.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"568a66f2-91a6-46d0-9f72-64cb484dfd78",correct:"Plně kvalifikované jméno (FQDN) udává jméno počítače a sítě.",incorrect:"Plně kvalifikované jméno (FQDN) udává pouze jméno počítače bez sítě.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"8a22706d-9123-4478-8bf0-2eeebcb6fc82",correct:"U lokálních hostnamech může být lokální přípona sítě vynechána.",incorrect:"U lokálních hostnamech musí být lokální přípona sítě vždy uvedena.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"f521dee4-3c07-4d15-a14b-4b4bcb58fe34",correct:"IPv4 adresa se skládá ze čtyř oktetů, což je pro počítače srozumitelný numerický formát.",incorrect:"IPv4 adresa se skládá ze šesti oktetů, což je formát používaný pro Ethernet protokoly.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"629c815f-cf26-460b-834c-7819e8a3249d",correct:"IPv6 adresy využívají šestnáct oktetů pro adresování v moderních počítačových sítích.",incorrect:"IPv6 adresy využívají pouze čtyři oktety, podobně jako starší IPv4 adresy.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"6ce9b629-8e60-40d7-a550-7c881669663c",correct:"MAC adresy, typické pro Ethernet, mají délku šesti oktetů a slouží k identifikaci síťových rozhraní.",incorrect:"MAC adresy, typické pro IPv6, mají délku šestnáct oktetů a slouží k identifikaci síťových rozhraní.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"7a99872b-88d5-48cd-ab02-46377b2dda9f",correct:"Pro komunikaci v síti počítače používají numerické adresy, které jsou strojově čitelné, na rozdíl od lidsky čitelných jmen.",incorrect:"Pro komunikaci v síti počítače používají lidsky čitelné názvy, které jsou srozumitelnější než numerické adresy.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"0725766d-2acc-48dd-afff-a7a4cadba7fe",correct:"Oktety v IPv4 adrese jsou řazeny od nejvýznamnějšího bytu (MSB) jako první, což je označováno jako big endian.",incorrect:"Oktety v IPv4 adrese jsou řazeny od nejméně významného bytu (LSB) jako první, což je označováno jako little endian.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"754be9ec-2855-4ef3-9dc2-a53c9ca54e5d",correct:"Lokální sítě (LAN) obvykle pokrývají kanceláře, domácnosti nebo budovy a často tvoří jednu broadcastovou doménu.",incorrect:"Lokální sítě (LAN) obvykle pokrývají rozsáhlá území a vždy tvoří více broadcastových domén.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"7017085d-bfe0-4a24-a330-fb91861ed756",correct:"Mezi technologie používané v lokálních sítích (LAN) patří Ethernet a WiFi.",incorrect:"Mezi technologie používané výhradně v rozsáhlých sítích (WAN) patří Ethernet a WiFi.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"c5931aba-28ef-46fb-b660-79e43f106842",correct:"Ethernet, používaný v LAN sítích, dosahuje rychlosti 1 Gb/s nebo i 10 Gb/s.",incorrect:"Ethernet, používaný v LAN sítích, dosahuje rychlosti maximálně 100 Mb/s.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"07d61cc3-ca49-49de-aefa-9eec4d164d72",correct:"Rozsáhlé sítě (WAN) se často používají pro internet a sítě poskytovatelů internetových služeb (ISP).",incorrect:"Rozsáhlé sítě (WAN) se používají výhradně pro lokální sítě v rámci jedné budovy.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"9fffd132-0ef3-49f7-bfb9-9bdf2ecea999",correct:"WiFi, standard IEEE 802.11, je bezdrátová technologie používaná v lokálních sítích (LAN) s rychlostí do 1 Gb/s.",incorrect:"WiFi, standard IEEE 802.11, je výhradně kabelová technologie používaná v rozsáhlých sítích (WAN) s rychlostí nad 10 Gb/s.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"fb6e52d6-5446-4d5b-a1df-5062a38debc5",correct:"TCP/IP model síťové komunikace má čtyři vrstvy.",incorrect:"TCP/IP model síťové komunikace má sedm vrstev.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"303dd3fb-73a2-4f7f-b846-1403e3417a71",correct:"Linková vrstva TCP/IP modelu odpovídá fyzické a datové vrstvě OSI modelu.",incorrect:"Linková vrstva TCP/IP modelu odpovídá pouze fyzické vrstvě OSI modelu.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"552a7d29-cd0e-4055-9ed1-6fcd8575c5dc",correct:"Internetová vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 3.",incorrect:"Internetová vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 4.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"c139d1c0-295a-4ce5-b84d-038d5cd910cd",correct:"Transportní vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 4.",incorrect:"Transportní vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 3.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"bba60e2e-fbc4-4ac6-8ee8-9414a9d43473",correct:"Aplikační vrstva TCP/IP modelu zahrnuje v OSI modelu vrstvy 5 až 7.",incorrect:"Aplikační vrstva TCP/IP modelu zahrnuje v OSI modelu pouze vrstvu 7.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"0264c03e-05a7-4bf7-b24f-c57651e3dadd",correct:"Protokol IP je v OSI modelu definován jako protokol 3. vrstvy.",incorrect:"Protokol IP je v OSI modelu definován jako protokol 4. vrstvy.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"c535a064-5234-4645-9516-ee573eb26bfe",correct:"Protokol TCP je v OSI modelu definován jako protokol 4. vrstvy.",incorrect:"Protokol TCP je v OSI modelu definován jako protokol 3. vrstvy.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"b17649f2-cee8-4323-93b5-233dc4bfa40c",correct:"Číslování vrstev, na které se odkazuje text, odpovídá číslování OSI modelu.",incorrect:"Číslování vrstev, na které se odkazuje text, odpovídá číslování TCP/IP modelu.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"efbbb8fc-9af0-4086-9528-883129b59670",correct:"Síťové služby jsou standardní součástí operačních systémů posledních dvacet let.",incorrect:"Síťové služby se staly standardní součástí operačních systémů teprve nedávno.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"1081ae19-701e-46bf-a49f-5604cd70a6ec",correct:"V monolitických kernelech je významná část síťového stacku součástí jádra.",incorrect:"V monolitických kernelech je pouze malá část síťového stacku součástí jádra.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"3b2a5324-03d8-4428-9ea0-101673980bde",correct:"Rozhraní sockets API zpřístupňuje síťový stack uživatelským programům v monolitických kernelech.",incorrect:"Rozhraní sockets API se nepoužívá k zpřístupnění síťového stacku uživatelským programům.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"6f8bef01-d174-4abb-b1fb-39053ab326c9",correct:"Funkce aplikační vrstvy jako DNS a TLS jsou obvykle dostupné v systémových knihovnách.",incorrect:"Funkce aplikační vrstvy jako DNS a TLS jsou obvykle součástí jádra operačního systému.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"14f48799-3298-4ab3-bfdb-e52c41078698",correct:"TLS je technologie aplikační vrstvy, i když se jmenuje Transport Layer Security.",incorrect:"TLS je technologie transportní vrstvy, jak naznačuje její jméno Transport Layer Security.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"0948ad06-ac88-4eb5-986f-b244b9d075a9",correct:"Routování a filtrování paketů může být implementováno v jádře operačního systému.",incorrect:"Routování a filtrování paketů je vždy implementováno mimo jádro operačního systému.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"b0eb89a4-5831-44a3-a185-27bc530d80c5",correct:"Síťové souborové systémy mohou být implementovány v jádře operačního systému.",incorrect:"Síťové souborové systémy nemohou být implementovány v jádře operačního systému.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"96894be6-d118-41d8-89cd-ecef3bee6b69",correct:"Socket API zpřístupňuje klientskou i serverovou stranu TCP/IP.",incorrect:"Socket API zpřístupňuje pouze klientskou stranu TCP/IP.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"c8e790fb-44ef-4074-a38c-1dbcba93e853",correct:"Softwarové mosty a přepínače jsou zřídka praktické, ale operační systémy je implementují kvůli virtualizaci.",incorrect:"Softwarové mosty a přepínače jsou běžné a praktické řešení v operačních systémech.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"20151c94-6f36-4658-b84b-d9b1c57e70c7",correct:"Socket API je součástí systémových knihoven, ale v monolitických jádrech často mapuje 1:1 na systémová volání.",incorrect:"Socket API je výhradně doménou operačního systému a nikdy není součástí systémových knihoven.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"5c53b5ed-70b7-4a78-81aa-340000a317f5",correct:"V mikrokernelech se síťový stack dělí jinak a systémové knihovny pravděpodobně přebírají větší podíl práce s Socket API.",incorrect:"V mikrokernelech je Socket API vždy přímo implementováno v jádře operačního systému.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"5a3c735f-d986-46a0-91a1-bc6cd1f7fd35",correct:"Překlad hostnames na IP adresy, tedy DNS klient, obvykle spadá do kompetence systémových knihoven.",incorrect:"Překlad hostnames na IP adresy je typicky prováděn výhradně na straně serveru, nikoliv klientských systémových knihoven.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"6626904e-48f3-41bd-909e-871cec3c1a28",correct:"Většina moderních operačních systémů poskytuje SSL/TLS stack, který zahrnuje i správu a validaci certifikátů.",incorrect:"Správa certifikátů v rámci SSL/TLS stacku je obvykle ponechána na externích aplikacích, nikoliv na operačním systému.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"2ab9f359-054e-4f29-b638-008ab0c4d926",correct:"Konfigurační nástroje jako dhclient slouží k automatické konfiguraci síťových rozhraní.",incorrect:"Konfigurační nástroje jako dhclient slouží výhradně k manuální konfiguraci tiskáren.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"ceb42778-6623-44d2-80ab-842bd9244516",correct:"Správa směrování je klíčová pro systémy fungující jako softwarové směrovače.",incorrect:"Správa směrování je irelevantní pro systémy fungující jako softwarové směrovače.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"985ff976-296b-491f-9143-480fc3118194",correct:"Diagnostické nástroje jako ping a traceroute pomáhají při ověřování síťové konektivity.",incorrect:"Diagnostické nástroje jako ping a traceroute slouží k monitorování využití procesoru.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"d80db21a-2fa8-4776-a7af-1cf67898b7c4",correct:"Tcpdump umožňuje inspekci síťových paketů na úrovni rozhraní.",incorrect:"Tcpdump primárně slouží k nastavení firewallu operačního systému.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"503e89cd-b179-4f74-bdf6-d2697ad795d9",correct:"Síťové služby jako ntpd zajišťují synchronizaci systémového času.",incorrect:"Síťové služby jako ntpd slouží k správě uživatelských účtů v systému.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"d1ce154c-cb6b-43da-9339-3beaf5240692",correct:"Síťové protokoly se zabývají třemi hlavními aspekty komunikace: pakety, adresováním a doručením.",incorrect:"Síťové protokoly se zabývají pouze dvěma hlavními aspekty komunikace: adresováním a doručením.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"383ac0f1-84f4-4a44-9de3-ce746a2b947d",correct:"Paket je základní komunikační jednotka, která nese informace v síťových protokolech.",incorrect:"Paket je pouze pomocná datová struktura, která nenese informace v síťových protokolech.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"d9b1c339-58ae-4872-9d77-e8882045bd0f",correct:"Adresování v síťových protokolech slouží k identifikaci cílových počítačů nebo programů v síti.",incorrect:"Adresování v síťových protokolech slouží pouze k identifikaci fyzických síťových zařízení.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"96c3e22b-8635-4a4d-b608-089118218da0",correct:"Doručení paketů zahrnuje směrování a případný překlad adres mezi různými vrstvami sítě.",incorrect:"Doručení paketů se týká výhradně fyzického přenosu dat a nezahrnuje směrování.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"4818ddc8-95ab-4d78-add4-0f1bf7742986",correct:"Protokoly v síťovém stacku běží nad sebou, přičemž vyšší vrstvy využívají abstrakcí poskytovaných nižšími vrstvami.",incorrect:"Protokoly v síťovém stacku běží paralelně vedle sebe a nevyužívají abstrakcí poskytovaných jinými vrstvami.",sectionNumber:"9.2.10",sectionTitle:"Protocol Nesting"},{uuid:"c748069f-d2c2-42f7-a215-ffccf5910046",correct:"Síťový stack je struktura, kde protokoly vyšších úrovní, jako HTTP, využívají abstrakce nižších úrovní, jako TCP a IP.",incorrect:"Síťový stack je struktura, kde protokoly nižších úrovní, jako IP, poskytují abstrakce protokolům vyšších úrovní, jako HTTP a TCP.",sectionNumber:"9.2.10",sectionTitle:"Protocol Nesting"},{uuid:"37b09e7e-f3b0-48e1-8cb1-020dcecb3373",correct:"HTTP protokol využívá abstrakce poskytované protokolem TCP, což ilustruje vrstvenou povahu síťového stacku.",incorrect:"HTTP protokol poskytuje abstrakce pro protokol TCP, což ilustruje hierarchickou povahu síťového stacku.",sectionNumber:"9.2.10",sectionTitle:"Protocol Nesting"},{uuid:"eef93758-bb8a-45ae-8311-1c7fd9191b55",correct:"Ethernetový rámec obaluje IP paket, podobně jako matrjoška obaluje menší loutku.",incorrect:"IP paket obaluje Ethernetový rámec, podobně jako matrjoška obaluje menší loutku.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"0d9084cf-ea70-46b2-9274-2f1638cecf0f",correct:"Pro nižší vrstvy síťového modelu jsou pakety vyšších vrstev považovány za data.",incorrect:"Pro vyšší vrstvy síťového modelu jsou pakety nižších vrstev považovány za data.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"1c04f2ea-89e5-4fd3-b76b-91f7fb391fb5",correct:"TCP stream může přenášet HTTP request jako svůj obsah.",incorrect:"HTTP request může přenášet TCP stream jako svůj obsah.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"decc194b-64b3-48a3-ba26-4014fbd23229",correct:"Přidávání záhlaví k paketům je úkolem nižších vrstev při zapouzdření dat.",incorrect:"Přidávání záhlaví k paketům je úkolem vyšších vrstev při zapouzdření dat.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"d81f72b9-451a-4f46-9002-289dba31dad3",correct:"Abstraktní doručování je typu point-to-point.",incorrect:"Abstraktní doručování není typu point-to-point.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"6f4d270b-b812-4e8f-a7ac-ff4b90e12899",correct:"Routing je pro vyšší vrstvy převážně skryté.",incorrect:"Routing není pro vyšší vrstvy skryté.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"eae6ed57-e90f-4927-9435-2c860c9f5468",correct:"Vyšší vrstva požaduje doručení na adresu.",incorrect:"Vyšší vrstva požaduje doručení na jméno.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"aed9d97b-ad25-44e6-99c7-15aeae8e5435",correct:"Nižší vrstvy jsou obvykle orientované na pakety.",incorrect:"Nižší vrstvy nejsou orientované na pakety.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"a556e734-ae72-409c-b470-9219ab6fcb5b",correct:"Paket může překročit hranice domén nízké úrovně.",incorrect:"Paket nemůže překročit hranice domén nízké úrovně.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"c9b10436-faea-4061-94ec-159865ee2350",correct:"Doručování v internetové vrstvě má širší rozsah než v linkové vrstvě.",incorrect:"Doručování v linkové vrstvě má širší rozsah než v internetové vrstvě.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"dbd0fd8d-b76b-4f5c-9b63-93859464b3eb",correct:"IP paket běžně prochází několika linkovými doménami.",incorrect:"IP paket nikdy neprochází několika linkovými doménami.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"3fe8d9c9-56fe-4f7e-831b-40fe2d63a517",correct:"Pro překlad IP adres na MAC adresy se používá protokol ARP.",incorrect:"Pro překlad IP adres na MAC adresy se používá protokol DNS.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"08435a4e-e173-4f1a-b2da-61b3d58d54b6",correct:"Adresa TCP vrstvy typicky zahrnuje adresu IP vrstvy a číslo portu.",incorrect:"Adresa TCP vrstvy zahrnuje pouze číslo portu, nikoli adresu IP vrstvy.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"1b2aecb4-37fa-4a08-a292-375ed70c0aaa",correct:"Protokol DNS logicky patří do aplikační vrstvy, i když využívá adresy transportní vrstvy.",incorrect:"Protokol DNS logicky patří do transportní vrstvy a využívá adresy transportní vrstvy.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"fbe355d3-c1e7-49e1-bf04-9cd67904457d",correct:"Vyšší vrstvy musí poskytovat správné adresy nižším vrstvám pro doručení dat.",incorrect:"Nižší vrstvy musí poskytovat správné adresy vyšším vrstvám pro doručení dat.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"5c5512f2-37b6-4d2f-83bf-b296bb5882f6",correct:"ARP protokol slouží k nalezení MAC adresy odpovídající dané IP adrese v lokální síti.",incorrect:"ARP protokol slouží k nalezení IP adresy odpovídající dané MAC adrese v lokální síti.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"957ef112-25dc-49de-87b6-a42f9176b3ff",correct:"Pro doručení IP paketu linkovou vrstvou je nezbytné znát MAC adresu cílového zařízení.",incorrect:"Pro doručení IP paketu linkovou vrstvou není nutné znát MAC adresu cílového zařízení.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"4a26e58f-bde9-47b9-81ec-49002bf948c9",correct:"Operační systém buduje mapu překladů IP adres na MAC adresy pomocí ARP protokolu.",incorrect:"Operační systém buduje mapu překladů MAC adres na IP adresy pomocí ARP protokolu.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"9a94f2aa-bd61-4327-baab-29ff4d4373df",correct:"ARP protokol umožňuje internetové vrstvě doručovat pakety s využitím služeb linkové vrstvy.",incorrect:"ARP protokol umožňuje linkové vrstvě doručovat pakety s využitím služeb internetové vrstvy.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"fb7cb2b2-12a2-47b9-9fae-05835f5524d5",correct:"Routery v lokální síti používají ARP protokol pro zjištění MAC adresy cílových zařízení.",incorrect:"Routery v lokální síti nepoužívají ARP protokol pro zjištění MAC adresy cílových zařízení.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"6e85952d-0faf-4300-a4e0-a0b76e8deabc",correct:"Komunikační protokol linkové vrstvy je z velké části implementován hardwarově.",incorrect:"Komunikační protokol linkové vrstvy je implementován výhradně v softwaru operačního systému.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"d2824fc1-ea7c-4d42-b211-be49b25f5223",correct:"Operační systém používá pro příjem a odesílání ethernetových rámců unifikované rozhraní s MAC adresami.",incorrect:"Operační systém používá pro příjem a odesílání ethernetových rámců rozhraní s IP adresami.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"c16a2612-47cc-479c-920e-89f9c8c287c4",correct:"Ethernet je běžně používaný protokol linkové vrstvy.",incorrect:"Ethernet je protokol síťové vrstvy, který se stará o směrování paketů.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"afb381f0-b309-4570-8cc0-3b7262226c74",correct:"Ethernetové sítě s přepínači typicky využívají hvězdicovou topologii fyzických připojení.",incorrect:"Ethernetové sítě s přepínači typicky využívají sběrnicovou topologii fyzických připojení.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"0e04e7ec-221c-4433-bcb4-c8c6bee2ab5e",correct:"Funkce mostů v počítačových sítích se odehrává na linkové vrstvě.",incorrect:"Funkce mostů v počítačových sítích spadá do kompetence síťové vrstvy.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"3466b549-a34f-41ad-8f48-7367184b68d6",correct:"Přepínače se liší od mostů tím, že jsou optimalizovány pro větší počet portů s jednou MAC adresou na port.",incorrect:"Přepínače a mosty se liší pouze počtem portů, ale oba jsou optimalizovány pro mnoho MAC adres na port.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"43dfca3e-8029-4f16-a486-f71f300363eb",correct:"Kromě Ethernetu existuje mnoho dalších protokolů linkové vrstvy.",incorrect:"Ethernet je jediný protokol linkové vrstvy.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"bbbf0a03-1b9d-4cad-b60a-f463901cec15",correct:"PPP je zkratka pro Point-to-Point Protocol.",incorrect:"PPP je zkratka pro Protokol pro přenos paketů.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"7de61677-09f6-4218-84d7-8fcf14d10e53",correct:"WiFi lze považovat za bezdrátovou verzi Ethernetu.",incorrect:"WiFi je rychlejší a spolehlivější než Ethernet.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"2bcab80c-3d01-4577-a691-7b1488984ea4",correct:"Protokol PPP je určen pro sítě s dvěma uzly.",incorrect:"Protokol PPP je primárně určen pro rozsáhlé sítě LAN.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"046b62a6-acd9-4c1f-bd60-7091037e961e",correct:"WiFi vyžaduje šifrování z důvodu možné odposlouchávání komunikace.",incorrect:"WiFi nevyžaduje šifrování, protože je inherentně bezpečný.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"07564f88-98b0-4cb5-931f-0c6d18ebe307",correct:"Tunely jsou virtuální zařízení druhé nebo třetí vrstvy.",incorrect:"Tunely jsou fyzická zařízení druhé nebo třetí vrstvy.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"47e0b888-72a2-409a-aea3-87970cde8be3",correct:"Tunely zapouzdřují provoz v protokolu vyšší vrstvy.",incorrect:"Tunely zapouzdřují provoz v protokolu stejné vrstvy.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"634b11a7-0e74-47e3-b0a4-8a3887f5c846",correct:"Tunely se používají ve virtuálních privátních sítích.",incorrect:"Tunely se nepoužívají ve virtuálních privátních sítích.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"34b872ad-6501-4953-8fec-5dff6a8fe24e",correct:"Tunelování umožňuje vnoření provozu nižší vrstvy do aplikační vrstvy.",incorrect:"Tunelování umožňuje vnoření provozu aplikační vrstvy do linkové vrstvy.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"54018ced-766b-4671-9db0-28a59f41fba7",correct:"IP protokol je paketově orientovaný protokol s nízkou režií.",incorrect:"IP protokol je spojitě orientovaný protokol s nízkou režií.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"e142b421-ed15-4905-8e02-08ab4c2eaace",correct:"IP protokol negarantuje doručení paketů ani integritu dat.",incorrect:"IP protokol garantuje spolehlivé doručení paketů a integritu dat.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"0d41884e-adb4-4b00-a629-7211986cca26",correct:"V rámci jedné IP sítě se doručení paketů stará linková vrstva.",incorrect:"V rámci jedné IP sítě se o doručení paketů stará transportní vrstva.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"0989ed6d-5e63-4f28-9704-b231770e2fbc",correct:"Routery přeposílají pakety mezi sítěmi a pracují na třetí vrstvě.",incorrect:"Routery přeposílají pakety v rámci jedné sítě a pracují na druhé vrstvě.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"36f2b3a7-ab43-41da-8f71-402cc21d238b",correct:"Porty jsou 16bitová čísla, která identifikují služby běžící na počítači.",incorrect:"Porty jsou 32bitová čísla, která identifikují služby běžící na počítači.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"bf6e735c-0fab-4754-b3af-fb28677b4b18",correct:"ICMP protokol slouží pro diagnostiku, hlášení chyb a správu sítě.",incorrect:"ICMP protokol slouží výhradně pro diagnostiku aplikačních chyb.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"195d9b71-16b2-4e99-8fa7-c3fa2a85b29f",correct:"S příchodem IPv6 byla role ICMP rozšířena o automatickou konfiguraci sítě.",incorrect:"S příchodem IPv6 byla role ICMP omezena pouze na hlášení chyb.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"171e9f49-90e3-4820-871c-9c5b1ff8155c",correct:"ICMP protokol neposkytuje přímé služby aplikační vrstvě.",incorrect:"ICMP protokol poskytuje přímé služby aplikační vrstvě pro spolehlivý přenos dat.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"ea4d4caa-5a48-4130-96da-3ad89d6649dd",correct:"Příkaz ping využívá ICMP echo request a echo reply zprávy a v kombinaci s TTL je základem pro traceroute.",incorrect:"Příkaz ping využívá výhradně TCP protokol pro diagnostiku spojení a traceroute je založen na UDP.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"084a3f6c-8281-409c-9bca-94caa3449ba8",correct:"TCP je spojově orientovaný protokol, který zaručuje spolehlivé doručení dat.",incorrect:"TCP je bezespjojový protokol, který zaručuje spolehlivé doručení dat.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"85f51e02-5423-4b5a-9cd6-e80a1779caf2",correct:"Pro navázání spojení TCP využívá trojcestný handshake: SYN, SYN/ACK a ACK.",incorrect:"Pro navázání spojení TCP využívá čtyřcestný handshake: SYN, SYN/ACK, ACK a FIN.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"f5d7fe58-1bc8-4547-9ca3-b5906e594c29",correct:"TCP musí implementovat mechanismy pro rozdělení datového proudu na pakety pro IP vrstvu.",incorrect:"TCP nemusí implementovat mechanismy pro rozdělení datového proudu na pakety pro IP vrstvu, jelikož IP vrstva je proudově orientovaná.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"8e236c7a-35b1-43ba-8702-b5bc80b049cb",correct:"TCP spojení je obousměrné, umožňující obousměrný tok dat současně.",incorrect:"TCP spojení je jednosměrné, umožňující tok dat pouze v jednom směru.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"086711b4-4c4e-4a56-bdfd-4f65d2935169",correct:"TCP zajišťuje doručení dat ve správném pořadí a retransmisi ztracených paketů.",incorrect:"TCP nezajišťuje doručení dat ve správném pořadí a retransmisi ztracených paketů.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"2e025574-d2be-4ea2-95fb-bcb6055d4342",correct:"TCP pakety využívají sekvenční čísla k zajištění správného pořadí doručení dat.",incorrect:"TCP pakety nepoužívají sekvenční čísla, pořadí doručení dat není garantováno.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"87d2a062-153b-478a-8e60-0c633dc8768f",correct:"Sekvenční čísla v TCP umožňují příjemci znovu sestavit datový proud i při změně pořadí IP paketů.",incorrect:"Sekvenční čísla v TCP slouží pouze k šifrování dat, nikoliv k sestavení datového proudu.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"5b3bea46-305b-4f27-b05f-b09374a4fb79",correct:"Potvrzování příjmu (ACK) v TCP se provádí pomocí sekvenčních čísel, což umožňuje identifikaci přijatých paketů.",incorrect:"Potvrzování příjmu (ACK) v TCP se provádí bez použití sekvenčních čísel.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"948c73ff-49b6-49e1-b7f7-11f4e02b2d46",correct:"Ztráta paketů v TCP je detekována odesílatelem, pokud není včas obdrženo potvrzení (ACK).",incorrect:"Ztrátu paketů v TCP detekuje pouze příjemce na základě chybějících dat.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"6205b1ed-eae7-4870-b2aa-4baabea20460",correct:"Pokud odesílatel TCP neobdrží potvrzení (ACK) v dynamicky upraveném časovém limitu, paket je znovu odeslán.",incorrect:"Při ztrátě paketu v TCP se automaticky navýší rychlost odesílání dat.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"b5ec31b9-c234-4f09-ada3-376c3037ebfa",correct:"TCP protokol má významnou režii kvůli svým garancím spolehlivosti a doručení v pořadí.",incorrect:"TCP protokol má minimální režii, protože se jedná o jednoduchý protokol nad IP.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"b0c1bed2-018c-401e-a0ac-218f26c90d22",correct:"UDP je mnohem jednodušší protokol než TCP a představuje tenkou vrstvu nad IP.",incorrect:"UDP je složitější protokol než TCP a přidává komplexní mechanismy pro spolehlivost.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"e45b6d4f-666e-49a8-9d00-9f93dc9bb642",correct:"UDP přidává k IP minimální režii, v podstatě jen port a 16bitový kontrolní součet.",incorrect:"UDP přidává k IP významnou režii, včetně mechanismů pro spolehlivé doručení dat.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"343a221f-d6dc-4671-a19f-c9020715b68a",correct:"Hlavička UDP paketu je celkově dlouhá pouze 64 bitů a zahrnuje porty a kontrolní součet.",incorrect:"Hlavička UDP paketu je delší než 128 bitů a zahrnuje komplexní pole pro řízení toku.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"25868332-fadd-41a3-868a-4e68329a2904",correct:"Firewall odděluje sítě a působí jako jediný router mezi nimi, kontroluje pakety a blokuje škodlivé pokusy o přístup.",incorrect:"Firewall odděluje sítě, ale nikdy nepůsobí jako router a nekontroluje pakety, pouze slepě propouští provoz.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"026c5e29-da42-4c2d-934d-dccecfff2119",correct:"Paketový filtr je implementací firewallu a může být umístěn jak na routeru, tak i na koncovém zařízení pro zvýšení bezpečnosti.",incorrect:"Paketový filtr není považován za implementaci firewallu, ale za doplňkový bezpečnostní prvek, který nemůže fungovat samostatně.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"8ee422a8-2755-4f8b-ba79-ad5f8e3f911c",correct:"Paketové filtry klasifikují příchozí pakety na základě pravidel definovaných operátorem a mohou je propustit, zahodit nebo odmítnout.",incorrect:"Paketové filtry automaticky klasifikují pakety bez nutnosti definování pravidel operátorem a mohou je pouze propustit nebo zahodit.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"67b12d3c-40a6-4dee-ae07-878360d93cd3",correct:"Pro paketové filtry existují dvě hlavní komponenty: nástroj pro správu pravidel a kernelová část pro samotnou klasifikaci paketů.",incorrect:"Paketové filtry se skládají pouze z jedné komponenty, která je zodpovědná jak za správu pravidel, tak za klasifikaci paketů.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"aede42f7-7f40-46ad-87c4-e3a14e491922",correct:"Stavový paketový filtr si pamatuje stav spojení a díky tomu může lépe rozhodovat o propouštění paketů v rámci daného spojení.",incorrect:"Stavový paketový filtr neudržuje informace o stavu spojení a rozhoduje o propouštění paketů pouze na základě hlaviček jednotlivých paketů.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"5ab9df1d-a313-435d-bfe4-af0b820a9791",correct:"Číselné adresy je obtížné si zapamatovat, proto se používají hostitelská jména.",incorrect:"Číselné adresy je snadné si zapamatovat, proto se hostitelská jména nepoužívají.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"d68f21f8-116d-4a30-9503-c7bd3e676d7b",correct:"Hostitelská jména mohou být uložena v souboru jako například `/etc/hosts`, ale to je nepraktické pro více než 3 počítače.",incorrect:"Hostitelská jména nemohou být uložena v souboru jako například `/etc/hosts`, protože to je praktické i pro více než 3 počítače.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"0cc8ceb5-c1ce-4f3f-afb6-f6e11de9a8f3",correct:"Systém DNS je navržen jako škálovatelný adresář pro miliony jmen, který je efektivně aktualizován a dotazován.",incorrect:"Systém DNS není navržen jako škálovatelný adresář pro miliony jmen a není efektivně aktualizován.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"2a0b3eab-6400-43ef-adc0-73b7935c4619",correct:"DNS je hierarchický protokol pro překlad jmen, který běží nad protokoly TCP nebo UDP.",incorrect:"DNS je centralizovaný protokol pro překlad jmen, který běží pouze nad protokolem TCP.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"b401561e-6b0d-412b-8f0a-5e2b9da7c43b",correct:"Doménová jména jsou v DNS rozdělena na části oddělené tečkami, což umožňuje distribuovanou databázi jmen.",incorrect:"Doménová jména jsou v DNS rozdělena na části oddělené čárkami, což zjednodušuje správu centralizované databáze jmen.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"3115344e-9b8f-4040-a61f-8bc02b55feb0",correct:"DNS servery typu NS slouží k udávání informací o dalších DNS serverech, které mohou poskytnout další informace o doméně.",incorrect:"DNS servery typu NS slouží k udávání IP adres koncových zařízení pro danou doménu.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"b198045c-26ad-4611-b1e2-03a11007ccc5",correct:"Proces rekurze v DNS obvykle provádí specializovaný typ DNS serveru, který ukládá výsledky do cache pro budoucí dotazy.",incorrect:"Proces rekurze v DNS se provádí pouze na klientském počítači a výsledky se nikdy neukládají do cache.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"fe6828d5-67c3-4f58-ad1a-9b591d4dc084",correct:"Nástroj `dig` je součástí sady nástrojů ISC a slouží k diagnostice a pozorování rekurze v DNS.",incorrect:"Nástroj `dig` je součástí operačního systému Windows a slouží pouze k zobrazení IP adresy pro dané doménové jméno.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"759791c6-5a6d-478e-a2b1-cca299752f23",correct:"V moderních operačních systémech koncept 'uživatele' primárně reprezentuje jednotku vlastnictví.",incorrect:"V moderních operačních systémech koncept 'uživatele' primárně reprezentuje jednotku správy procesů.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"1b202e87-f06d-4870-bbc7-a7e670283688",correct:"Význam 'uživatele' v operačních systémech se rozšířil z pouhého reprezentování jednotlivých osob na obecnější abstrakci.",incorrect:"Význam 'uživatele' v operačních systémech zůstal striktně omezen na reprezentování jednotlivých osob.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"55f9a72d-db64-49bf-a492-b0fa07e34033",correct:"Mechanizmy řízení přístupu v operačních systémech jsou často navrženy s 'uživatelem' jako centrální entitou.",incorrect:"Mechanizmy řízení přístupu v operačních systémech jsou primárně navrženy s 'procesem' jako centrální entitou, nikoli 'uživatelem'.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"3b355e7c-34b8-4cc3-b198-0faaf23077f8",correct:"Efektivní využití počítačových zdrojů bylo hlavním důvodem pro zavedení multi-tenancy.",incorrect:"Efektivní využití počítačových zdrojů nebylo důvodem pro zavedení multi-tenancy.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"80641d84-93ad-42c5-8fac-8598232a9acf",correct:"Sdílení dat mezi uživateli vyžaduje zavedení kontroly přístupu v systémech.",incorrect:"Sdílení dat mezi uživateli nevyžaduje zavedení kontroly přístupu v systémech.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"c2c8f6f1-5742-4e78-b063-7a441ef6d706",correct:"Globální sdílený souborový systém zvýšil potřebu kontroly přístupu k datům uživatelů.",incorrect:"Globální sdílený souborový systém snížil potřebu kontroly přístupu k datům uživatelů.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"738d85c3-a73a-44e8-b36d-a8b06fa07da7",correct:"V operačním systému mohou být různé objekty vlastněny, zejména soubory a procesy.",incorrect:"V operačním systému mohou být vlastněny pouze procesy, soubory vlastnictví nemají.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"8691c49b-6a7f-462b-bdb0-84ba1d8f61e0",correct:"Procesy v operačním systému jednají jménem uživatele, kterému patří, a mají stejná oprávnění.",incorrect:"Procesy v operačním systému jednají nezávisle na uživateli a nemají žádná uživatelská oprávnění.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"e1acb22e-356a-4d09-92ca-c6832a77737f",correct:"Vlastnictví souboru v operačním systému dává uživateli práva číst soubor, zapisovat do něj a měnit jeho oprávnění.",incorrect:"Vlastnictví souboru v operačním systému dává uživateli právo pouze soubor číst, nikoliv do něj zapisovat nebo měnit jeho oprávnění.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"b0f2b7f5-c7ab-4868-9dd1-b0bda92c5a20",correct:"Procesy jsou v operačním systému považovány za aktivní účastníky, zatímco soubory jsou pasivní.",incorrect:"Jak procesy, tak soubory jsou v operačním systému považovány za aktivní účastníky.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"b888ebaf-7d2c-40d6-8c02-481768be354a",correct:"Vlastnictví objektu v operačním systému může být převedeno původním vlastníkem nebo systémovým administrátorem.",incorrect:"Vlastnictví objektu v operačním systému nemůže být nikdy převedeno a zůstává trvale původnímu vlastníkovi.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"2b48f950-40c0-4019-b6ff-ceac8b49862a",correct:"V modelu DAC vlastníci objektů rozhodují o přístupových právech.",incorrect:"V modelu DAC centrální autorita rozhoduje o přístupových právech k objektům.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"3480c4d7-6b73-451c-bbbd-f099b118dfb2",correct:"Model MAC je typicky používán v prostředích s vysokými nároky na bezpečnost.",incorrect:"Model MAC je běžně používán v běžných operačních systémech pro domácí použití.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"28949b88-7310-4e39-b444-6766f8401421",correct:"V obou modelech, DAC i MAC, OS rozhoduje o přístupu na základě politiky řízení přístupu.",incorrect:"Pouze v modelu DAC operační systém rozhoduje o přístupu na základě politiky řízení přístupu.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"154d9537-3e89-4122-8c2c-6cbc4499cce9",correct:"Politika řízení přístupu v modelu MAC je obvykle koherentnější než v modelu DAC.",incorrect:"Politika řízení přístupu je stejně koherentní v modelech DAC i MAC.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"7e6bc301-5814-4ca6-9e62-a1147beb4f89",correct:"Uživatelé se ukázali být užitečnou abstrakcí pro správu systémových prostředků.",incorrect:"Uživatelé se neukázali být užitečnou abstrakcí pro správu systémových prostředků.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"caffc52e-7676-4440-8910-15596afb4391",correct:"Systémové služby často běží pod vlastními speciálními uživatelskými účty.",incorrect:"Systémové služby nikdy neběží pod vlastními speciálními uživatelskými účty.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"2ebc9b16-f49c-46d2-a8f5-81d2c0b27baf",correct:"Díky uživatelům mohou služby vlastnit soubory a být omezeny v přístupu k systému.",incorrect:"Uživatelé nezajišťují, aby služby mohly vlastnit soubory v systému.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"75ad4c5e-57fd-458e-b12c-052c773b4994",correct:"Princip nejmenšího privilegia se vztahuje jak na softwarové komponenty, tak na lidské uživatele systému.",incorrect:"Princip nejmenšího privilegia se vztahuje pouze na softwarové komponenty systému, nikoli na lidské uživatele.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"2eb9df33-f341-41e0-8ffc-b119b9a37d1a",correct:"Cílem principu nejmenšího privilegia je omezit rozsah škod způsobených chybami nebo bezpečnostními kompromitacemi.",incorrect:"Cílem principu nejmenšího privilegia je maximalizovat rozsah škod způsobených chybami nebo bezpečnostními kompromitacemi.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"540e54cf-6578-4e54-ba83-b5ae1db9240d",correct:"Podle principu nejmenšího privilegia by měla být oprávnění udělena pouze tehdy, když existuje skutečná potřeba pro manipulaci s objektem.",incorrect:"Podle principu nejmenšího privilegia by měla být oprávnění udělena i bez skutečné potřeby pro manipulaci s objektem.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"774139e4-976f-46a1-8f14-50a425e53664",correct:"Systémy s principem nejmenších privilegií se dělí na nezávislé komponenty.",incorrect:"Systémy s principem nejmenších privilegií se nesmí dělit na nezávislé komponenty.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"06960c65-53f4-40f4-9084-62e3fcde98ab",correct:"Komponenty v systémech s oddělením privilegií spolu komunikují pomocí IPC.",incorrect:"Komponenty v systémech s oddělením privilegií spolu nekomunikují.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"329a389e-814b-46d1-b5d1-11baf6853b9a",correct:"Oddělení privilegií je návrhový vzor založený na principu nejmenších privilegií.",incorrect:"Oddělení privilegií je návrhový vzor nesouvisející s principem nejmenších privilegií.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"23367b71-e69d-4fe4-bfcc-2b7508491569",correct:"Každý proces má přidělený vlastní adresní prostor, který je implicitně oddělený od ostatních procesů.",incorrect:"Procesy sdílejí jeden společný adresní prostor, což umožňuje implicitní sdílení paměti mezi nimi.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"402e3918-5027-4974-97a0-bc2b8b205901",correct:"Sdílení paměti mezi procesy vyžaduje explicitní souhlas a nastavení, není implicitní.",incorrect:"Sdílení paměti mezi procesy je implicitní a automatické, bez nutnosti explicitního nastavení.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"44726b2b-a7ab-42a0-a8f7-34b27e3138f7",correct:"Systém souborů poskytuje globální sdílený jmenný prostor pro všechny uživatele a procesy.",incorrect:"Každý uživatel má izolovaný jmenný prostor systému souborů, oddělený od ostatních uživatelů.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"a30b1643-0095-4ef6-bbe3-0bd1cc4cd826",correct:"Cesty k souborům nejsou považovány za bezpečnostní tokeny pro kontrolu přístupu.",incorrect:"Cesty k souborům slouží jako primární bezpečnostní mechanismus pro kontrolu přístupu.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"a3b1bf08-9d8b-4ba0-bb41-aa5b1ee67f91",correct:"Politika řízení přístupu definuje pravidla, která určují, zda subjekt smí provést danou akci s objektem.",incorrect:"Politika řízení přístupu definuje pravidla, která určují, jaké akce musí subjekt provést s objektem.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"25210fd1-48fd-4820-8db2-bab168594fd6",correct:"Subjekty v systémech řízení přístupu jsou typicky uživatelé, programy nebo role.",incorrect:"Subjekty v systémech řízení přístupu jsou výhradně fyzické osoby, nikoliv programy.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"25cb4e25-96dc-461e-9ab3-b85f76ec3d88",correct:"Dostupné akce, jako čtení nebo zápis, se liší v závislosti na typu objektu, například souboru nebo adresáři.",incorrect:"Dostupné akce jsou univerzální a nezávisí na typu objektu, ke kterému subjekt přistupuje.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"61c8069c-cac1-45a5-929c-bbd854156a5e",correct:"Oprávnění ke čtení souboru se ověřuje při otevření souboru, nikoliv při každém volání operace čtení.",incorrect:"Oprávnění ke čtení souboru se ověřuje při každém volání operace čtení, nikoliv při otevření souboru.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"76a49be0-11b3-40d8-a143-791485bf25fb",correct:"Mezi objekty řízení přístupu v operačním systému patří soubory, adresáře a síťová připojení.",incorrect:"Mezi objekty řízení přístupu v operačním systému patří pouze fyzická paměť a procesor.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"a10b33bb-3b4e-4efe-9d88-1691f485d874",correct:"Jádro operačního systému běží v privilegovaném režimu CPU.",incorrect:"Uživatelské programy běží v privilegovaném režimu CPU.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"6f1f1df2-dbb2-4c18-9c49-76e1f5510793",correct:"MMU zajišťuje izolaci procesů v operačním systému.",incorrect:"MMU nezajišťuje izolaci procesů v operačním systému.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"852bb691-0627-42fb-a2a9-26b7a65a0a3a",correct:"Přístup k hardwarovým zdrojům je zprostředkován systémovými voláními.",incorrect:"Přímý přístup k hardwarovým zdrojům je povolen bez systémových volání.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"4cdb9809-979b-4bbd-9ff0-65eeffd20c6d",correct:"Souborové systémy jsou integrální součástí jádra operačního systému.",incorrect:"Souborové systémy běží mimo jádro operačního systému jako uživatelský prostor.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"ab308c40-64b4-4dcb-90d1-e4f0442b3a15",correct:"Operační systém využívá hardwarové prostředky k prosazování bezpečnostní politiky.",incorrect:"Operační systém se spoléhá výhradně na software pro prosazování bezpečnostní politiky.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"d2a1bd86-c64a-421c-b476-cca7e307524e",correct:"Uživatelské procesy mohou vynucovat řízení přístupu s pomocí jádra operačního systému.",incorrect:"Uživatelské procesy mohou vynucovat řízení přístupu zcela nezávisle na jádru operačního systému.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"c3e335c3-ef2a-4263-919d-f77bc1a75f06",correct:"Systémové služby často poskytují IPC API, například systémové volání getpeereid().",incorrect:"Systémové služby obvykle neposkytují IPC API, a getpeereid() není příkladem takového API.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"177ae90b-f221-4ce2-9d21-4f1d0b76d5dd",correct:"Řízení přístupu na uživatelské úrovni se spoléhá na mechanismy poskytované jádrem operačního systému.",incorrect:"Řízení přístupu na uživatelské úrovni je zcela nezávislé na jádru operačního systému.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"6dd1ba5e-697b-4c3d-9be3-349e24990eaf",correct:"Databázový server může používat systémové volání getpeereid() k získání ID uživatele klienta.",incorrect:"Databázový server používá systémové volání open() k získání ID uživatele klienta.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"2d901671-09c0-45d9-be50-d7acc31d8205",correct:"Jádro operačního systému zabraňuje procesům v přímém přístupu k souborům databáze, pokud nemají oprávnění.",incorrect:"Jádro operačního systému umožňuje všem procesům přímý přístup k souborům databáze bez omezení.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"7b2425a2-6fe7-4aae-88ab-2eeee611c957",correct:"V systémech POSIX existují dva základní typy subjektů: uživatelé a skupiny.",incorrect:"V systémech POSIX existují tři základní typy subjektů: uživatelé, skupiny a procesy.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"77128b13-836d-4061-b7a5-3c912b2f18eb",correct:"Uživatel v systémech POSIX může patřit do více skupin.",incorrect:"Uživatel v systémech POSIX může patřit pouze do jedné skupiny.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"899300b4-ebe7-4190-a78d-a08b9a45a0b7",correct:"Uživatel root v systémech POSIX nepodléhá kontrole oprávnění.",incorrect:"Uživatel root v systémech POSIX podléhá kontrole oprávnění jako běžní uživatelé.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"7a0468f1-daed-4b19-bed9-9f29a02e74e7",correct:"Pouze uživatel root může v systémech POSIX provádět určité akce, například restartovat počítač.",incorrect:"Každý uživatel může v systémech POSIX provádět všechny akce, včetně restartování počítače.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"026de7b6-6976-4a83-94e7-ba9c7224039c",correct:"Uživatelé a skupiny jsou reprezentovány číselnými identifikátory pro zvýšení efektivity operací v systému.",incorrect:"Uživatelé a skupiny jsou reprezentovány textovými řetězci pro zvýšení efektivity operací v systému.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"eb8a3b01-c89b-41bf-a498-882fdd53626c",correct:"Číselné identifikátory uživatelů umožňují efektivní porovnávání a kompaktní uložení v i-node.",incorrect:"Textové identifikátory uživatelů umožňují efektivní porovnávání a kompaktní uložení v i-node.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"407f4a3a-84a2-4b6f-b6ee-8545b2067c12",correct:"Databáze uživatelů mapuje uživatelská jména na číselné identifikátory, které systém interně používá.",incorrect:"Databáze uživatelů mapuje číselné identifikátory na uživatelská jména, která systém interně používá.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"8037d44f-5620-47e9-90a1-d65c839a9f53",correct:"V lokálních sítích je žádoucí sdílet uživatelské identity a jejich číselné mapování mezi počítači.",incorrect:"V lokálních sítích není žádoucí sdílet uživatelské identity a jejich číselné mapování mezi počítači.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"f6190c75-3db4-45be-adbc-ee840a165c33",correct:"Soubory /etc/passwd a /etc/group mohou fungovat jako jednoduchá lokální databáze uživatelů.",incorrect:"Soubory /etc/passwd a /etc/group fungují jako komplexní distribuovaná databáze uživatelů.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"f11e60ed-9751-4487-83ef-11fd33a0c1ff",correct:"LDAP a Active Directory jsou příklady centralizovaných databází uživatelů pro lokální sítě.",incorrect:"LDAP a Active Directory jsou příklady decentralizovaných databází uživatelů pro lokální sítě.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"ba7b2f13-9282-4c84-a3d7-a94012427421",correct:"Každý proces v systému patří konkrétnímu uživateli.",incorrect:"Ne všechny procesy v systému patří konkrétnímu uživateli.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"cd768ff1-dde4-4589-aa92-7b424028e289",correct:"Vlastnictví procesu se dědí při volání fork().",incorrect:"Vlastnictví procesu se nedědí při volání fork().",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"acf5cafb-1086-4959-abcb-cdfc3e892099",correct:"Procesy s oprávněními superuživatele mohou měnit vlastníka pomocí setuid().",incorrect:"Procesy s oprávněními superuživatele nemohou měnit vlastníka pomocí setuid().",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"4ff4e3a0-f697-4202-ada4-8693017cf3a7",correct:"Volání exec() může někdy změnit vlastníka procesu.",incorrect:"Volání exec() nikdy nemůže změnit vlastníka procesu.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"ad8b921a-d893-4a22-84ad-86eddb5ea8a8",correct:"S výjimkou init, všechny procesy vznikají voláním fork().",incorrect:"Všechny procesy, včetně init, vznikají voláním fork().",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"079b9f19-7772-4d64-8f00-2434b3d5f0e9",correct:"Program login autentizuje uživatele pomocí jména a hesla.",incorrect:"Program login autorizuje uživatele pomocí jména a hesla.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"50bbd9a0-101f-4ae2-8cf5-12d6775ca557",correct:"Funkce setuid() se používá pro změnu vlastníka procesu na přihlášeného uživatele.",incorrect:"Funkce exec() se používá pro změnu vlastníka procesu na přihlášeného uživatele.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"fab177a3-fedf-4c6b-b2ce-bcae269ae962",correct:"Program login kontroluje přihlašovací údaje oproti uživatelské databázi.",incorrect:"Program login kontroluje přihlašovací údaje oproti systémové databázi.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"56440692-ac22-4716-a6e0-21ccb4ba87fd",correct:"Proces login se spouští na konci bootovacího procesu systému.",incorrect:"Proces login se spouští na začátku bootovacího procesu systému.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"bf55cf5e-71a0-4a3d-98bf-aacf0f11354d",correct:"Nejběžnější metodou autentizace uživatelů je zadání hesla nebo přístupové fráze.",incorrect:"Nejběžnější metodou autentizace uživatelů je veřejné sdílení osobních údajů.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"d1091d95-58e3-4324-9ad8-88c12e6b3125",correct:"Systém by měl ideálně ukládat pouze informaci potřebnou k ověření hesla, nikoliv heslo samotné.",incorrect:"Systém by měl ideálně ukládat hesla uživatelů v nezašifrované podobě pro snadnější přístup.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"034040f5-483b-4694-a6bc-fc74a8bdc8f7",correct:"Kromě hesel existují i jiné metody autentizace, například biometrické metody.",incorrect:"Kromě hesel neexistují žádné další široce používané metody autentizace uživatelů.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"d2d27564-9dd7-4f27-b57b-5e9685f933e0",correct:"Účelem autentizace je ověřit, zda je uživatel skutečně tím, za koho se vydává.",incorrect:"Účelem autentizace je pouze přidělit uživateli přístupová práva k souborům.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"dd86bcce-04cd-468b-a202-9d78e76d15f4",correct:"Pro ověření hesla se běžně používají kryptografické hashovací funkce.",incorrect:"Pro ověření hesla se běžně používá prosté porovnání zadaného hesla s uloženým heslem v databázi.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"6737744d-7f05-4431-a16f-cfb5e068b3ae",correct:"Autentizace přes síť představuje větší bezpečnostní výzvy než lokální autentizace kvůli nezabezpečeným sítím.",incorrect:"Autentizace přes síť je stejně bezpečná jako lokální autentizace, protože sítě jsou ze své podstaty bezpečné.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"2c6dde03-3cd1-46a8-9969-42efe9315b8a",correct:"Hesla, i když se snadno používají, vyžadují šifrování pro bezpečný přenos přes síť.",incorrect:"Hesla, kvůli své jednoduchosti, nevyžadují šifrování pro bezpečný přenos přes síť.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"7c90a4b3-987c-4dc9-b5b2-36ea7d08b919",correct:"Dvoufaktorová autentizace může zvýšit bezpečnost nad rámec pouhého používání silných hesel pro síťovou autentizaci.",incorrect:"Dvoufaktorová autentizace je zbytečná, pokud jsou pro síťovou autentizaci použita silná hesla.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"8b64ed6c-98b5-4ab8-9c3d-34246d2431a4",correct:"I při šifrování hesla je autentizace počítače klíčová pro prevenci útoků ze strany škodlivých počítačů.",incorrect:"Šifrování hesla samotné je dostačující pro bezpečnou síťovou autentizaci, takže autentizace počítače je zbytečná.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"4d3e2ded-5dda-4a72-b0a1-4d9fe22f5799",correct:"Riziko útoků se významně zvyšuje při síťové autentizaci, protože uživatelé nemusí být fyzicky přítomni.",incorrect:"Riziko útoků se významně nezvyšuje při síťové autentizaci, protože fyzická přítomnost je vždy vyžadována.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"962270f7-9dec-4202-91d9-2630f14ee4c7",correct:"Dvoufaktorová autentizace kombinuje znalost hesla a vlastnictví tokenu pro zvýšení bezpečnosti.",incorrect:"Dvoufaktorová autentizace využívá pouze biometrické údaje pro ověření identity uživatele.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"7a2d68bb-b7aa-40a4-afa0-2a27946cc2b6",correct:"Pro vzdálenou autentizaci je dvoufaktorová autentizace s heslem a kryptografickým tokenem běžnější než biometrická autentizace.",incorrect:"Pro vzdálenou autentizaci je biometrická autentizace praktičtější a běžnější než dvoufaktorová autentizace s tokenem.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"e7fab4f1-bf7a-44be-87cf-a7958f2ee4d4",correct:"Kryptografické tokeny pro lokální autentizaci obvykle komunikují s počítačem přímo, nikoliv přes uživatele.",incorrect:"Kryptografické tokeny pro lokální autentizaci vyžadují, aby uživatel ručně přepisoval kódy pro ověření.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"00c30f93-170b-44b6-bf7f-5e743481bc90",correct:"Ověření identity vzdáleného počítače je klíčové pro zabránění odeslání citlivých dat nechtěným příjemcům.",incorrect:"Ověření identity vzdáleného počítače je důležité hlavně pro zajištění integrity dat, nikoliv důvěrnosti.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"2247cb79-ca68-4eef-bc26-6bf3ad239dea",correct:"Asymetrická kryptografie umožňuje ověření identity vzdáleného počítače pomocí digitálních podpisů generovaných soukromými klíči.",incorrect:"Symetrická kryptografie se běžně používá pro ověření identity vzdáleného počítače pomocí digitálních podpisů a soukromých klíčů.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"18f46685-8a71-45e9-bd34-b65926fedde9",correct:"Při ověřování identity vzdáleného počítače klient odesílá výzvu, kterou server musí podepsat svým soukromým klíčem.",incorrect:"Při ověřování identity vzdáleného počítače server odesílá výzvu, kterou klient musí podepsat svým soukromým klíčem pro ověření identity klienta.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"35aae33d-e647-44c7-b52c-6e271ef030e8",correct:"Každý počítač má unikátní soukromý klíč a jeho veřejný protějšek je distribuován pro ověření identity.",incorrect:"Každý počítač má unikátní veřejný klíč a jeho soukromý protějšek je distribuován pro ověření identity.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"}]},{uuid:"045b187c-821b-4a56-9ef5-19b8812653de",sectionNumber:"10",sectionTitle:"POSIX a jazyk C",statements:[{uuid:"3c285e0d-d26a-4079-9219-0776beb8b0dd",correct:"Jazyk C má v kontextu operačních systémů výjimečné postavení.",incorrect:"Jazyk Python má v kontextu operačních systémů výjimečné postavení.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"0c4d5980-2315-4b5c-9d7a-6f112d012c61",correct:"Většina jazyků, s nimiž se studenti setkají, spadá do kategorie jazyků vyšší úrovně abstrakce.",incorrect:"Většina jazyků, s nimiž se studenti setkají, spadá do kategorie jazyků nižší úrovně abstrakce.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"d4db40d9-8801-4d50-970e-dd3e78737d75",correct:"Jazyky C++, Java a C# jsou příklady jazyků odvozených od C a spadají mezi jazyky vyšší úrovně.",incorrect:"Jazyky C++, Java a C# jsou příklady jazyků odvozených od C a spadají mezi jazyky nižší úrovně.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"dc40e836-b915-4d28-a1c6-7f461800f6ba",correct:"Pro účely kurzu se budeme zabývat především jazykem C a shellem POSIX, který je také považován za programovací jazyk.",incorrect:"Pro účely kurzu se budeme zabývat především jazykem Python a shellem POSIX, který není považován za programovací jazyk.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"e8a18231-8a9d-48be-8ce6-1dea498b815a",correct:"Různé programovací jazyky existují na různých úrovních abstrakce a mají odlišné účely použití.",incorrect:"Všechny programovací jazyky existují na stejné úrovni abstrakce a mají stejné účely použití.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"6c82ac37-5b6d-4708-bb1a-f88891e04731",correct:"C lze považovat za přenosný assembler s několika málo doplňky ve formě standardní knihovny.",incorrect:"C je považován za moderní jazyk s mnoha pokročilými funkcemi, který se používá pro vývoj webových aplikací.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"c0fab552-2096-49d4-9801-16d2bf7e5f83",correct:"Hlavní výhodou jazyka C oproti assembleru je abstrakce od strojových instrukcí a strukturované řízení toku programu.",incorrect:"Hlavní výhodou jazyka C oproti assembleru je automatická správa paměti a podpora objektově orientovaného programování.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"980b7c49-ae21-4e88-b7da-f94477b5a2bd",correct:"Popularita jazyka C v systémovém programování pramení z jeho schopnosti snadno propojovat se s kódem napsaným v jiných jazycích.",incorrect:"Popularita jazyka C v systémovém programování pramení z jeho složitosti a obtížné integrace s jinými programovacími jazyky.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"55d8be60-3e9d-4cba-90c9-99b9ff948c29",correct:"Většina operačních systémových jader je napsána v jazyce C.",incorrect:"Všechna operační systémová jádra jsou napsána v jazyce C.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"c3e3f924-c064-46c5-b0e7-c1c2718b55ef",correct:"Systémové knihovny jsou obvykle psány v jazyce C, stejně jako jádro operačního systému.",incorrect:"Systémové knihovny jsou obvykle psány v jazyce C++, na rozdíl od jádra operačního systému.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"7c64b75d-608d-46ef-a057-38e7cb0c8b39",correct:"I operační systémy nenapsané v jazyce C poskytují C API pro programy.",incorrect:"Operační systémy nenapsané v jazyce C nikdy neposkytují C API.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"d896a2d6-597d-466c-8902-c12c48c78e3a",correct:"C knihovny se skládají z hlavičkových souborů a kompilovaného kódu knihovny.",incorrect:"C knihovny obsahují pouze hlavičkové soubory, které definují implementaci funkcí.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"f3bc978d-b42f-447d-8a17-638a64a39453",correct:"Hlavičkové soubory v C knihovnách poskytují deklarace funkcí, nikoliv jejich definice.",incorrect:"Hlavičkové soubory v C knihovnách obsahují kompletní definice všech funkcí knihovny.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"cc8ab086-44ae-4d76-bb1d-8e89ad2267b5",correct:"Statické knihovny v C, jako například libc.a, se liší od sdílených knihoven, například libc.so.",incorrect:"Statické i sdílené knihovny v C mají stejnou příponu souboru a funkční princip.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"01efce0e-407f-42be-9786-a537af45d0ae",correct:"Deklarace funkce v C specifikuje rozhraní funkce, tedy její jméno, argumenty a návratový typ.",incorrect:"Deklarace funkce v C zahrnuje kompletní implementaci funkce, včetně těla a prováděných operací.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"8fadd642-e2b4-493c-95fe-491b310c0966",correct:"Knihovna libc obsahuje funkce standardu ISO C, jako například printf, fopen a fread.",incorrect:"Knihovna libc neobsahuje žádné funkce standardu ISO C, ale pouze POSIX funkce.",sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"5bfd966c-ff32-4e4b-a2c9-ff42d8382008",correct:"POSIX funkce v knihovně libc, jako například open a read, jsou C obálky systémových volání.",incorrect:"POSIX funkce v knihovně libc, jako například open a read, nejsou C obálky systémových volání.",sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"542d4dee-77aa-4a4f-9780-7cca27acb74d",correct:"V systémech UNIX tradičně knihovna libc kombinuje základní C knihovnu a knihovnu POSIX.",incorrect:"V systémech UNIX knihovna libc odděluje funkce základní C knihovny a knihovny POSIX do samostatných celků.",sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"9e5e79a6-5e6a-4a5e-a63c-7ce6a87bb9fe",correct:"Knihovna `libc` je klíčová, avšak v systémech UNIX existuje mnoho dalších specializovaných knihoven.",incorrect:"Knihovna `libc` je nejdůležitější knihovna v UNIXU a ostatní knihovny jsou jen doplňkové.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"d94c3f30-ebfc-471b-9abc-0fa1aa9832cb",correct:"Matematická knihovna `libm` poskytuje funkce pro výpočty s plovoucí desetinnou čárkou, jako sinus a kosinus.",incorrect:"Knihovna `libm` se v UNIXU používá primárně pro operace s řetězci a textem.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"fb88c322-1211-47d9-aee2-9a1138777d97",correct:"Knihovna `libpthread` obsahuje funkce pro tvorbu vícevláknových programů, včetně `pthread_create`.",incorrect:"Knihovna `libpthread` slouží pouze pro správu procesů, nikoliv pro vlákna.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"65985ef8-e612-41d6-ac9b-d8b1b8b090e7",correct:"Standardní knihovna C++ v UNIXU, často `libstdc++`, nelze přímo používat z programů v jazyce C.",incorrect:"Standardní knihovna C++ v UNIXU, `libstdc++`, je plně kompatibilní a zaměnitelná s knihovnou `libc`.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"e7c5489d-7eff-4130-92d2-4042c2fdddda",correct:"Kryptografická knihovna `libcrypto` nabízí symetrické šifry jako AES a asymetrické algoritmy jako RSA.",incorrect:"Knihovna `libcrypto` v UNIXU poskytuje pouze hashovací funkce a digitální podpisy.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"8381601e-e903-4c6a-8cdd-ea593d7a801a",correct:"Knihovna `libcurses` umožňuje programům pracovat přenositelně s různými typy hardwarových a softwarových terminálů.",incorrect:"Knihovna `libcurses` je zastaralá a v moderních systémech UNIX se již nepoužívá.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"1a7e8937-5cb0-4ef2-927a-7f305a3154fa",correct:"V mnoha systémech UNIX lze systémové knihovny nalézt v `/usr/lib` a uživatelské knihovny v `/usr/local/lib`.",incorrect:"Ve všech systémech UNIX se systémové knihovny nacházejí výhradně v `/lib` a uživatelské knihovny výhradně v `/usr/local/lib`.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"ec73af1f-82c6-49a5-bed1-33ef13fd2097",correct:"Konkrétně v systémech založených na Linuxu lze systémové a uživatelské knihovny nalézt smíšené dohromady v adresáři `/usr/lib`.",incorrect:"Konkrétně v systémech založených na Linuxu se systémové knihovny nacházejí v `/lib` a uživatelské knihovny v `/usr/local/lib`.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"45dc8f7c-afb0-43c8-860f-5f5282a5909b",correct:"V systému Windows jsou systémové i aplikační knihovny často instalovány ve společném umístění, například `C:\\Windows\\System32`.",incorrect:"V systému Windows se systémové knihovny nacházejí v `C:\\Windows\\System32` a aplikační knihovny se instalují samostatně s každým programem.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"024d8666-77b9-4637-9ff9-98afb2ff22aa",correct:"V systémech Windows a macOS jsou sdílené knihovny často instalovány společně s aplikací samotnou.",incorrect:"Sdílené knihovny jsou instalovány pouze v systémových adresářích a nikdy společně s aplikací v systémech Windows a macOS.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"bbee2aa2-076e-4a59-85f6-fa76ea0405d5",correct:"Statické knihovny se používají během fáze linkování při kompilaci programů.",incorrect:"Statické knihovny se používají během fáze běhu programů.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"a2050c26-6826-4fb2-b962-2b83e5fc84fb",correct:"Při použití statických knihoven se potřebný kód kopíruje přímo do spustitelného souboru.",incorrect:"Při použití statických knihoven se potřebný kód dynamicky linkuje během běhu programu.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"fcc73947-9163-493a-b3e4-aec45642530f",correct:"Spustitelné soubory vytvořené se statickými knihovnami jsou soběstačné a nezávisí na externích knihovních souborech za běhu.",incorrect:"Spustitelné soubory vytvořené se statickými knihovnami závisí na externích knihovních souborech za běhu.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"fb58138d-8fa7-41ea-bc74-415cb63eab92",correct:"Statické linkování může vést k duplicitě kódu v mnoha spustitelných souborech v systému.",incorrect:"Statické linkování eliminuje duplicitě kódu v mnoha spustitelných souborech v systému.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"3843d3bc-07e7-4aa0-880c-7c2f124707fd",correct:"Operační systémy nemusí standardně obsahovat statické knihovny a vyžadují samostatnou instalaci.",incorrect:"Operační systémy vždy standardně obsahují statické knihovny pro všechny uživatele.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"5df6b259-edcc-485c-a723-6947cd28cdfd",correct:"Pro spuštění programů využívajících dynamické knihovny je přítomnost těchto knihoven nezbytná.",incorrect:"Pro spuštění programů využívajících dynamické knihovny není přítomnost těchto knihoven nezbytná.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"7054ccd9-cbf7-4e66-aecd-32380a8ca404",correct:"Linkování dynamických knihoven se provádí až při spuštění programu, nikoliv během kompilace.",incorrect:"Linkování dynamických knihoven se provádí během kompilace programu, nikoliv až při spuštění.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"df663c85-cbfe-4a45-b7de-305caa2d1c19",correct:"Sdílené knihovny redukují redundanci kódu jak v operační paměti, tak i v souborovém systému.",incorrect:"Sdílené knihovny zvyšují redundanci kódu jak v operační paměti, tak i v souborovém systému.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"5f27b574-b756-4e5d-b40f-417fb543a60f",correct:"Aktualizace dynamické knihovny může proběhnout odděleně od aplikací, které na ní závisejí.",incorrect:"Aktualizace dynamické knihovny musí proběhnout současně s aktualizací všech aplikací, které na ní závisejí.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"745569c8-a798-4faf-985b-5e2be0fbd06d",correct:"Problémy se závislostmi jsou běžným negativem spojeným s používáním dynamických knihoven.",incorrect:"Problémy se závislostmi se nikdy nevyskytují při používání dynamických knihoven.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"c6423309-e218-4e36-8486-f75702af3f32",correct:"Hlavičkové soubory obsahují prototypy funkcí v jazyce C a definice datových struktur.",incorrect:"Hlavičkové soubory obsahují implementace funkcí v jazyce C a definice datových struktur.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"531cd101-db4e-4501-ac70-f9b8f05b2b65",correct:"Hlavičkové soubory jsou vyžadovány při kompilaci programů v jazycích C a C++, ale ne při jejich používání.",incorrect:"Hlavičkové soubory jsou vyžadovány jak při kompilaci, tak i při používání programů v jazycích C a C++.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"ca314db8-fac1-4236-8ba7-575341caf0c2",correct:"Na systémech UNIX jsou systémové hlavičkové soubory tradičně uloženy v adresáři `/usr/include`.",incorrect:"Na systémech UNIX jsou systémové hlavičkové soubory tradičně uloženy v adresáři `/usr/lib`.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"91e4e9fb-747d-4652-8396-94afcadc4ef9",correct:"Rozložení datových struktur definovaných v hlavičkových souborech je součástí aplikačního binárního rozhraní (ABI).",incorrect:"Rozložení datových struktur definovaných v hlavičkových souborech není součástí aplikačního binárního rozhraní (ABI).",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"52dce79e-8e9e-4561-b72b-28451f8f01d6",correct:"Hlavičkové soubory jsou fragmenty zdrojového kódu v jazyce C.",incorrect:"Hlavičkové soubory jsou binární soubory obsahující kompilovaný kód.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"19a434ed-76dc-47b2-93c5-868a08ce9772",correct:"Manuálové stránky v UNIXu jsou obvykle součástí instalace operačního systému.",incorrect:"Manuálové stránky v UNIXu jsou dodávány pouze jako externí doplněk k operačnímu systému.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"eb515284-5bf9-4b67-99fd-62835e39b90f",correct:"Příkaz `man` v UNIXu umožňuje prohlížet dokumentaci k systémovým voláním.",incorrect:"Příkaz `man` v UNIXu slouží pouze k manipulaci s procesy.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"e4d717c2-2fbe-487f-85f1-4b006c2f30d9",correct:"MSDN poskytuje rozsáhlou dokumentaci pro programátory operačního systému Windows.",incorrect:"MSDN poskytuje dokumentaci pouze pro uživatele operačního systému Windows, nikoliv programátory.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"61ded96e-dcc0-4be0-9f72-930a00368022",correct:"Sekce 2 manuálových stránek v UNIXu popisuje systémová volání.",incorrect:"Sekce 2 manuálových stránek v UNIXu popisuje knihovní funkce.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"93b6c918-8de7-4c41-8d0b-94b5aa839e6e",correct:"Dokumentace pro Windows byla dříve dostupná i na optických médiích.",incorrect:"Dokumentace pro Windows byla dříve dostupná výhradně v tištěné podobě.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"2c7769d5-9cd3-49c8-9302-3ffde570cfa2",correct:"Systémy POSIX často obsahují překladač jazyka C.",incorrect:"Systémy POSIX nikdy neobsahují překladač jazyka C.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"a7767baa-86a9-4f7e-a082-0c9936db490d",correct:"Výstupem překladače je objektový soubor obsahující strojový kód.",incorrect:"Výstupem překladače je zdrojový soubor v textové podobě.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"3d7bb553-75ca-4e0f-a100-b5ddf821a39c",correct:"Objektový soubor sice obsahuje strojový kód, ale není přímo spustitelný.",incorrect:"Objektový soubor je přímo spustitelný, protože obsahuje strojový kód.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"f9e5c4a7-847c-4f98-b931-b9b8da8cf74b",correct:"Program nelze spustit dokud není spojen linkovacím programem.",incorrect:"Program lze spustit ihned po kompilaci bez linkování.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"81c3d086-788f-40b8-a9e4-449923bf1bb2",correct:"Objektové soubory obsahují spustitelný kód a statická data.",incorrect:"Objektové soubory obsahují pouze spustitelný kód bez statických dat.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"b5ae588c-7c50-4ce0-98d4-837506c059af",correct:"Objektové soubory mohou být rozděleny do sekcí jako .text, .rodata a .data.",incorrect:"Objektové soubory jsou vždy rozděleny do sekcí .text, .rodata a .data.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"36240eb7-0abe-43c4-87c1-f7c9dfe17843",correct:"Sekce .text v objektovém souboru typicky obsahuje strojový kód.",incorrect:"Sekce .text v objektovém souboru typicky obsahuje metadata.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"4e338e06-d8c1-4e95-abb8-628618f83a71",correct:"Tabulka symbolů v metadatech objektového souboru udává adresy funkcí relativní k souboru.",incorrect:"Tabulka symbolů v metadatech objektového souboru udává absolutní adresy funkcí.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"11c7b529-7cd1-4c9d-ab07-7f17ea68892a",correct:"Sekce .rodata je určena pro data určená jen pro čtení, jako jsou řetězcové literály.",incorrect:"Sekce .rodata je určena pro spustitelný kód.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"e51d615c-e196-4078-94ec-78f4e43d48f7",correct:"Formát ELF je nejběžnější formát objektových souborů v systémech POSIX.",incorrect:"Formát PE je nejběžnější formát objektových souborů v systémech POSIX.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"82c66b80-7813-40b4-96e8-259b1cadee75",correct:"Formát Mach-O je formát objektových souborů používaný v systémech macOS.",incorrect:"Formát Mach-O je formát objektových souborů používaný v systémech Windows.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"024ebc75-7cfe-40e4-9903-98f140d37af6",correct:"Formát COFF rozšiřuje formát a.out o podporu sekcí.",incorrect:"Formát COFF je starší formát než a.out a nepodporuje sekce.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"e13e3442-ec3b-43ca-9c52-2a99080a586f",correct:"Formáty PE, Mach-O a ELF jsou běžně používané formáty objektových souborů v současných systémech.",incorrect:"Formáty PE, Mach-O a ELF jsou zastaralé formáty objektových souborů a již se nepoužívají.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"1819a68f-2165-40f1-9170-6640aa80ac61",correct:"Statické knihovny v UNIXu se nazývají archivy a mají příponu .a.",incorrect:"Statické knihovny v UNIXu se nazývají dynamické knihovny a mají příponu .a.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"3ad16b29-b924-448f-8feb-b1f737b7aede",correct:"Archiv statické knihovny obsahuje kromě objektových souborů i tabulku symbolů.",incorrect:"Archiv statické knihovny obsahuje pouze objektové soubory, nikoliv tabulku symbolů.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"2146e0b6-47ed-40b3-8622-3d4cb0fd39b0",correct:"Symbolová tabulka v archivu urychluje linkování tím, že linker nemusí prohledávat všechny objektové soubory.",incorrect:"Symbolová tabulka v archivu zpomaluje linkování, protože linker musí prohledávat tabulku symbolů i objektové soubory.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"346f4ced-061e-40ed-a150-3ea5e1bd7eb2",correct:"Archiv statické knihovny je sbírka objektových souborů, kde každý soubor si zachovává svou identitu.",incorrect:"Archiv statické knihovny je sloučený soubor, kde objektové soubory ztrácejí svou původní identitu.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"62b1ba4f-6def-4d82-bb1e-24d3c24a5dff",correct:"Linker kombinuje objektové soubory za účelem vytvoření spustitelného souboru.",incorrect:"Linker kombinuje zdrojové soubory za účelem vytvoření spustitelného souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"4e35b24b-27a8-41e9-9dfd-b0aee34e2ec0",correct:"Objektové soubory mohou používat symboly definované v knihovnách nebo jiných objektových souborech.",incorrect:"Objektové soubory mohou používat pouze symboly definované v samotném objektovém souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"d5386b67-d1dd-4e16-8313-315b76fdaf56",correct:"Objektové soubory poskytnuté linkeru přímo se vždy stanou součástí výsledného spustitelného souboru.",incorrect:"Objektové soubory poskytnuté linkeru přímo se nikdy nestanou součástí výsledného spustitelného souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"f92c386c-33ab-491b-aec4-5e7a777071e2",correct:"Objektové soubory v archivech jsou použity pouze pokud poskytují symboly potřebné k dokončení spustitelného souboru.",incorrect:"Objektové soubory v archivech jsou použity vždy, bez ohledu na to, zda poskytují symboly potřebné k dokončení spustitelného souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"f91496d7-7452-43b5-b271-671a9067ce8b",correct:"Linker je zodpovědný za přiřazení adres symbolům, které jsou definovány v programu.",incorrect:"Kompilátor je zodpovědný za přiřazení adres symbolům, které jsou definovány v programu.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"fa802ccd-ed7a-466b-a703-d2c703c4aec5",correct:"Symbolická jména v programovacím jazyce jsou překládána na adresy až v fázi linkování.",incorrect:"Symbolická jména v programovacím jazyce jsou překládána na adresy již v fázi kompilace.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"d0aab571-a599-4feb-a8c8-dbd05f22840c",correct:"Strojové instrukce používají adresy pro volání podprogramů a přístup k datům v paměti.",incorrect:"Strojové instrukce používají symbolická jména přímo pro volání podprogramů a přístup k datům.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"ae1b8428-be73-44fe-9ac1-0136fe65a314",correct:"Programátor při psaní kódu obvykle pracuje se symbolickými jmény, nikoliv s fyzickými adresami paměti.",incorrect:"Programátor při psaní kódu musí manuálně přiřazovat fyzické adresy paměti proměnným a funkcím.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"dd6a8951-1f36-43ad-9cdf-c2bb5f92afdc",correct:"Linker postupně zpracovává objektové soubory a aktualizuje tabulku symbolů pro každý z nich.",incorrect:"Linker zpracovává všechny objektové soubory najednou a tabulku symbolů aktualizuje až po jejich kompletním načtení.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"83a4cebf-68ed-4d47-9575-d87e00cba554",correct:"Symbolová tabulka v linkeru slouží k mapování symbolických jmen na jejich absolutní adresy v paměti.",incorrect:"Symbolová tabulka v linkeru slouží pouze k dočasnému uložení symbolických jmen bez vazby na adresy.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"741f7083-78c3-4fa2-a3a8-179957dd1604",correct:"Aktualizace symbolové tabulky linkeru probíhá inkrementálně s každým dalším zpracovaným objektovým souborem.",incorrect:"Aktualizace symbolové tabulky linkeru probíhá jednorázově až po načtení všech objektových souborů.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"648fa573-18d7-492f-9a41-d6590b349c1e",correct:"Proces relokace symbolů, spočívající v nalezení a dosazení adres, se provádí až po kompletním sloučení všech sekcí.",incorrect:"Proces relokace symbolů se provádí průběžně ihned po načtení každé sekce z objektových souborů.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"682cbed0-dded-4283-bab3-89d7cecb896d",correct:"Výstupní spustitelný soubor linkeru obsahuje pro každý typ sekce, jako .text a .data, právě jednu souhrnnou sekci.",incorrect:"Výstupní spustitelný soubor linkeru obsahuje pro každý vstupní objektový soubor oddělené sekce .text a .data.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"bb5ae495-0884-49db-8eaa-743a00df41bf",correct:"Relokační tabulka zaznamenává adresy instrukcí, které vyžadují doplnění o konkrétní adresy symbolů pro správné provedení.",incorrect:"Relokační tabulka zaznamenává pouze symboly, jejichž adresy je nutné dodatečně doplnit, bez ohledu na instrukce.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"870c47f6-5e93-4ab0-85d9-3bbfc5988930",correct:"Zachování symbolové tabulky ve výstupním souboru je volitelné a může být užitečné pro účely ladění a analýzy.",incorrect:"Symbolová tabulka je vždy povinně odstraněna z výstupního souboru, protože není potřebná pro běh programu.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"16dd1410-8315-42c9-812f-a97cb09b48f5",correct:"Výstupem linkeru je spustitelný soubor, který má obvykle stejný formát jako objektové soubory.",incorrect:"Výstupem linkeru je spustitelný soubor, který má formát zcela odlišný od objektových souborů.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"80e2983b-9cd6-48d6-9a20-7e531116d428",correct:"Statické spustitelné soubory mohou být přímo spuštěny CPU bez nutnosti dalších úprav adres.",incorrect:"Statické spustitelné soubory vyžadují další úpravy adres a relokací před spuštěním CPU.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"38cfc969-3c9e-44f1-8730-25437f371f22",correct:"Virtuální adresy ve spustitelných souborech umožňují různým programům používat překrývající se adresy.",incorrect:"Virtuální adresy ve spustitelných souborech vyžadují, aby různé programy používaly disjunktní adresní prostory.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"6108905b-3140-4338-ac27-66aa5827b7cd",correct:"Sdílené knihovny se načítají do paměti pouze jednou, i když je používá více programů.",incorrect:"Sdílené knihovny se načítají do paměti pro každý program, který je používá, zvlášť.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"e642617f-f8b2-493f-bf77-03c86b040767",correct:"Závislosti sdílených knihoven tvoří orientovaný acyklický graf (DAG).",incorrect:"Závislosti sdílených knihoven tvoří orientovaný cyklický graf.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"7dfc7a01-1655-4874-a6ab-383d6bc65c20",correct:"Pro řešení symbolických jmen v sdílených knihovnách se používá runtime linker v operačním systému.",incorrect:"Pro řešení symbolických jmen v sdílených knihovnách se používá standardní kompilátor.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"d4013a72-2c0a-4138-aa90-7eced300fac8",correct:"Sdílené knihovny mohou mít závislosti na jiných sdílených knihovnách.",incorrect:"Sdílené knihovny nemohou mít závislosti na jiných sdílených knihovnách a jsou zcela izolované.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"a1fc1bea-284a-4665-872c-951d3c8b2c75",correct:"Runtime linker je podobný linkeru z doby kompilace, ale funkčně se od něj liší.",incorrect:"Runtime linker je v podstatě identický s linkerem používaným v době kompilace.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"431cb2f0-15e9-4026-b5d1-2cd28953f988",correct:"Pro spuštění programu musí být program zaveden do paměti.",incorrect:"Pro spuštění programu nemusí být program zaveden do paměti.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"93a8ce8d-d2ba-44ad-bd4d-8db1ff7b5ea3",correct:"Sdílené knihovny používají kód nezávislý na pozici, aby mohly být zavedeny na libovolné adrese.",incorrect:"Sdílené knihovny používají absolutní adresy, aby mohly být zavedeny pouze na pevně dané adrese.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"14536c05-7ce0-4cef-84be-0ca7e2fd118f",correct:"Kód nezávislý na pozici umožňuje sdíleným knihovnám být zavedeny na různých adresách v paměti pro různé programy.",incorrect:"Kód nezávislý na pozici vyžaduje, aby sdílené knihovny byly zavedeny na stejné adrese v paměti pro všechny programy.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"0649b74b-f1e0-46c0-9a0a-ee75bddb31b3",correct:"Použití kódu nezávislého na pozici v sdílených knihovnách může způsobit mírnou režii při provádění.",incorrect:"Použití kódu nezávislého na pozici v sdílených knihovnách nezpůsobuje žádnou režii při provádění.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"65324b63-a738-4538-9a80-a171b83eea0d",correct:"Naivní přístup s fixními adresami pro sdílené knihovny se stává nepraktickým s rostoucím počtem knihoven kvůli konfliktům adres.",incorrect:"Naivní přístup s fixními adresami pro sdílené knihovny je praktický i s rostoucím počtem knihoven bez konfliktů adres.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"997c272b-494b-44b4-aedc-93d57313029e",correct:"Na mnoha systémech UNIX jsou překladač a linker standardně součástí systému.",incorrect:"Na všech systémech UNIX jsou překladač a linker standardně součástí systému.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"2ab02509-b827-479b-9aa6-aeb53b9d0633",correct:"Překladač jazyka C se obvykle vyvolává příkazem ‹cc›.",incorrect:"Překladač jazyka C se nikdy nevyvolává příkazem ‹cc›.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"f88c6e42-467a-47e3-b061-b3bd0de4bae0",correct:"Pro správu archivů, statických knihoven, se používá program ‹ar›.",incorrect:"Pro správu archivů, statických knihoven, se používá program ‹ld›.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"9e423ee2-60ca-4630-b1c9-e42985718eeb",correct:"V souladu s filozofií Unixu jsou adresáře považovány za speciální typ souborů umožňující čtení metadat.",incorrect:"V souladu s filozofií Unixu jsou adresáře považovány za speciální typ souborů umožňující přímou editaci obsahu textovým editorem.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"79fe0847-480c-49cd-98f9-537a2f459174",correct:"V Unixu je koncept souboru zobecněn natolik, že zahrnuje i hardwarová zařízení jako tiskárny a zvukové karty.",incorrect:"V Unixu je koncept souboru omezen pouze na fyzické soubory uložené na diskovém úložišti.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"9f5c818e-e533-4104-81f6-de172c7e66a0",correct:"Roury (pipes) v Unixu představují formu souboru, která umožňuje jednosměrnou komunikaci mezi dvěma procesy.",incorrect:"Roury (pipes) v Unixu jsou implementovány výhradně pomocí síťových protokolů a nemají nic společného s konceptem souboru.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"be9a1a00-66e1-4b66-9475-babd5b338068",correct:"Síťová připojení v Unixu sdílejí princip abstrakce souboru, což zjednodušuje práci se sítí.",incorrect:"Síťová připojení v Unixu obcházejí koncept souboru a vyžadují specializované systémové volání pro komunikaci.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"6e792b84-0475-4031-9733-8e5d044d00f1",correct:"Základní abstrakcí souboru v Unixu je možnost sekvenčního i přímého čtení a zápisu bajtů.",incorrect:"Základní abstrakcí souboru v Unixu je pouze sekvenční přístup pro čtení a zápis dat.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"2c9896b5-5f74-41cb-b36b-90cf9df39148",correct:"Opakované použití API souborového systému pro objekty podobné souborům zvyšuje flexibilitu a zjednodušuje systém.",incorrect:"Opakované použití API souborového systému pro objekty podobné souborům snižuje flexibilitu a komplikuje systém.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"d7e71ba8-7f5b-4a5e-a2ed-330aad2dba04",correct:"Díky existujícímu API pro abstraktní soubory je rozumné ho použít i pro jiné objekty, které se chovají jako soubory.",incorrect:"Díky existujícímu API pro abstraktní soubory není rozumné ho použít i pro jiné objekty, které se chovají jako soubory.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"56091e65-b3d5-4b4f-bccb-76f9f8b1fa94",correct:"Opakované použití mechanismů, jako API souborů, obecně vede k flexibilnějším a jednodušším systémům.",incorrect:"Opakované použití mechanismů, jako API souborů, obecně vede k méně flexibilním a složitějším systémům.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"60d3dc4e-19a9-4625-a07e-15d2252130ca",correct:"Pro práci s objekty podobnými souborům je výhodné používat existující nástroje příkazové řádky založené na souborech.",incorrect:"Pro práci s objekty podobnými souborům není výhodné používat existující nástroje příkazové řádky založené na souborech.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"08653595-4ad1-4ff4-92e1-181dcdc10ae0",correct:"Snaha o jednoduchost návrhu operačního systému je žádoucí, protože snižuje pravděpodobnost výskytu chyb.",incorrect:"Snaha o jednoduchost návrhu operačního systému není žádoucí, protože nezáleží na pravděpodobnosti výskytu chyb.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"5433e846-78f0-4eb2-b17a-397c570e24af",correct:"Cesty v souborových systémech slouží k navigaci a odkazování na soubory a adresáře.",incorrect:"Cesty v souborových systémech slouží pouze k pojmenování souborů, nikoliv k navigaci.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"c9db1be2-e915-4203-91f4-0aae849671ab",correct:"Úvodní lomítko v cestě, například /usr/include, značí začátek od kořenového adresáře.",incorrect:"Úvodní lomítko v cestě, například /usr/include, značí začátek od aktuálního adresáře.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"6a4607d7-32e1-4c1c-8393-93510eb04058",correct:"V cestách souborového systému se jako oddělovač adresářů používá znak lomítko.",incorrect:"V cestách souborového systému se jako oddělovač adresářů používá znak tečka.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"d0b2f7cb-5600-4816-afd1-c99c553c13ed",correct:"Každý prvek cesty, kromě kořenového adresáře, představuje jméno adresáře nebo souboru.",incorrect:"Každý prvek cesty představuje fyzické umístění dat na disku.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"8a46943f-ba53-4ddf-bdbb-b9d6d9a244c1",correct:"V systémech typu Plan9 je souborový systém koncipován tak, že téměř vše, co může být souborovým systémem, je jím.",incorrect:"V systémech typu Plan9 je souborový systém méně centrální než v tradičních systémech UNIX.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"c5a2d79e-aefe-49cf-86c7-a72ffd2755c9",correct:"Většina systémů UNIX, včetně Linuxu, používá souborový systém jako klíčový prvek pro přístup k různým funkcím OS, například skrze /proc a /sys.",incorrect:"Většina systémů UNIX se spoléhá na souborový systém jen pro ukládání dat, nikoliv pro přístup k funkcím operačního systému.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"2e4d13c9-cc4a-4612-aa58-6ed0c87d11c2",correct:"Systémy Android a iOS záměrně omezují přístup běžných aplikací a uživatelů k souborovému systému, ačkoliv jsou založeny na POSIXu.",incorrect:"Systémy Android a iOS plně zpřístupňují souborový systém aplikacím a uživatelům, podobně jako tradiční systémy POSIX.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"b1a6f7c0-82e5-4061-b0a2-90cd3646db55",correct:"Pro práci se souborem je obvykle nutné jej nejprve otevřít pomocí systémového volání `open()`.",incorrect:"Pro práci se souborem není nutné jej otevírat, stačí rovnou použít systémová volání `read()` nebo `write()`.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"ecb0611f-6a3b-40ef-a065-41daf4889b06",correct:"Po otevření souboru je možné z něj číst data a také do něj zapisovat data pomocí systémových volání `read()` a `write()`.",incorrect:"Po otevření souboru je možné z něj pouze číst data, ale nelze do něj zapisovat, to vyžaduje speciální režim otevření.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"77cb9da7-ed59-4126-ae11-074e4681d942",correct:"Systémové volání `close()` slouží k uvolnění systémových zdrojů, které byly alokovány při operaci `open()` souboru.",incorrect:"Systémové volání `close()` slouží k okamžitému fyzickému smazání souboru z disku, pokud s ním již nepracujeme.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"2bf102ed-77b8-408c-92ec-65e6e5c08b11",correct:"Přejmenování souboru pomocí `rename()` je považováno za operaci s adresářem, nikoliv přímo se souborem.",incorrect:"Přejmenování souboru pomocí `rename()` je operace, která se provádí přímo na souboru a adresáře se jí netýkají.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"5bda4468-00c0-469d-976e-d05c9edd99a1",correct:"Systémové volání `unlink()` odstraňuje záznam o souboru z adresáře, čímž soubor přestane být dostupný v systému souborů.",incorrect:"Systémové volání `unlink()` fyzicky smaže data souboru z diskového prostoru, záznam v adresáři zůstává zachován.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"d2201560-4258-4819-9645-131c345a5364",correct:"Pro vytváření nových adresářů v systému souborů se používá systémové volání `mkdir()`.",incorrect:"Pro vytváření nových adresářů v systému souborů se používá systémové volání `create_dir()`.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"52595e6d-56e4-42ff-8c13-6f16f95bc9ea",correct:"Pro běžnou práci s adresáři není nutné je explicitně otevírat pomocí systémového volání `open()`, i když to systém POSIX umožňuje.",incorrect:"Pro jakoukoliv práci s adresáři, včetně výpisu obsahu nebo vytváření souborů v nich, je nutné adresář nejprve otevřít.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"f3506e67-063c-48f6-a900-2e6d8a378915",correct:"Jádro operačního systému udržuje tabulku otevřených souborů a souborový deskriptor je index do této tabulky.",incorrect:"Jádro operačního systému udržuje tabulku otevřených souborů, ale souborový deskriptor není index do této tabulky.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"ce35ffea-158f-48b3-bc2b-2c13f0b79842",correct:"Souborové deskriptory umožňují jádru operačního systému vyhledat metadata souboru v konstantním čase.",incorrect:"Souborové deskriptory umožňují jádru operačního systému vyhledat metadata souboru v lineárním čase.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"5ca79ad3-d391-45a7-8d33-b2702ebb25de",correct:"V systémech Windows se koncept souborového deskriptoru označuje termínem handle.",incorrect:"V systémech Windows se koncept souborového deskriptoru označuje termínem pointer.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"caacd468-0e76-4984-b128-8917cf7d6c9f",correct:"Cesta k souboru není ideální pro jeho identifikaci kvůli možnosti přejmenování nebo nahrazení souboru.",incorrect:"Cesta k souboru je ideální pro jeho identifikaci, protože soubory nemohou být přejmenovány nebo nahrazeny.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"71926f11-a5df-4be3-b452-1cd4122d99a9",correct:"Vyhledávání souboru pomocí cesty je výpočetně nákladnější operace než vyhledávání pomocí deskriptoru.",incorrect:"Vyhledávání souboru pomocí cesty je stejně rychlé jako vyhledávání pomocí souborového deskriptoru.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"688db036-7491-4085-8b99-2ccad04907c4",correct:"V systému UNIX jsou všechny souborové systémy sjednoceny do jediné hierarchie.",incorrect:"V systému UNIX má každý souborový systém vlastní hierarchii reprezentovanou písmenem disku.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"ec02628e-f669-4d6a-a14e-58b7940ff8cb",correct:"V UNIXu se kořenový adresář jednoho souborového systému stává připojovacím bodem v jiném souborovém systému.",incorrect:"V UNIXu se kořenový adresář jednoho souborového systému stává kořenovým adresářem celého systému.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"67f91806-d973-4b6a-90c3-ecf9400bdc0d",correct:"Systém Windows používá písmena jednotek, jako například C: a D:, k reprezentaci samostatných souborových systémů.",incorrect:"Systém Windows sjednocuje všechny souborové systémy do jediné hierarchie, podobně jako UNIX.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"21a70d91-3455-443d-8e3c-09528ff14a03",correct:"Pokud se v UNIXu připojí souborový systém na neprázdný adresář, původní obsah tohoto adresáře se skryje.",incorrect:"Pokud se v UNIXu připojí souborový systém na neprázdný adresář, původní obsah tohoto adresáře se sloučí s obsahem připojeného systému.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"b33cb1ac-8e75-4a69-8261-ecab7ac51b3a",correct:"V systému UNIX je jeden souborový systém vybrán jako kořenový, jehož kořenový adresář '/' je stejný jako kořenový adresář systému.",incorrect:"V systému UNIX jsou všechny souborové systémy považovány za kořenové a mají kořenový adresář '/’.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"384cc2cb-6874-404b-b7bf-95dadae4eb61",correct:"Socket API pochází z raného BSD Unixu.",incorrect:"Socket API pochází z moderního Linuxového jádra.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"cadf904c-27f6-48f2-b8d4-84f70b060c3b",correct:"Socket reprezentuje síťové připojení mezi procesy.",incorrect:"Socket reprezentuje lokální souborový deskriptor.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"63ab3d5f-af58-49af-b9a3-eeda87939db6",correct:"Pro otevřený socket získáte deskriptor souboru.",incorrect:"Pro otevřený socket získáte ukazatel do paměti.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"7e951387-8c00-4b26-aed5-54c3ecaac212",correct:"Můžete číst a zapisovat do socketů pomocí funkcí read() a write().",incorrect:"Můžete číst a zapisovat do socketů pomocí fopen() a fprintf().",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"71ee7766-dbb3-4b1e-a5e8-68e5a3e05334",correct:"Existují tři hlavní typy socketů: poslouchající, připojený a datagramový.",incorrect:"Existují pouze dva typy socketů: streamový a datagramový.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"d1565bf6-c773-4237-9925-6bfe88e47478",correct:"Poslouchající socket neslouží k přenosu dat, ale k navazování spojení.",incorrect:"Poslouchající socket primárně slouží k přímému přenosu dat mezi klienty.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"174138cf-c9bf-4a97-b1d2-30b380372a3a",correct:"Připojený socket se chová podobně jako obousměrná roura.",incorrect:"Připojený socket se chová jako jednosměrná roura pro výstup dat.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"3bd54446-435d-4dfd-be5a-eb69a877dd18",correct:"Datagramový socket umožňuje posílat data bez navazování trvalého spojení.",incorrect:"Datagramový socket vyžaduje navázání spojení před každým odesláním dat.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"8e0fc99b-dda5-4c18-89c5-77df18f79509",correct:"Servery poslouchají na specifické adrese, aby klienti mohli navázat spojení.",incorrect:"Klienti poslouchají na adrese serveru a aktivně iniciují spojení.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"b357c12d-737d-4b24-bdf9-b7e88f9837fd",correct:"Sockets jsou v jistém smyslu zobecněním konceptu rour pro síťovou komunikaci.",incorrect:"Roury jsou modernější a flexibilnější variantou socketů pro síťovou komunikaci.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"e34a0dbe-d776-4b4d-a947-039d8737ee8d",correct:"Navazování spojení u socketů je složitější než práce s běžnými soubory.",incorrect:"Navazování spojení u socketů je stejně jednoduché jako otevření běžného souboru.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"fd98cbb0-f890-4af1-a72d-86e7851f7c4d",correct:"Ztráta paketů je běžným jevem při komunikaci přes sockety v síti.",incorrect:"Ztráta paketů je u socketů extrémně vzácná díky spolehlivosti sítě.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"8f23d085-885d-4366-8079-7fc2add9f7e7",correct:"Internetové sockety slouží pro komunikaci mezi různými počítači a využívají protokol TCP/IP.",incorrect:"Internetové sockety slouží výhradně pro lokální komunikaci v rámci jednoho počítače.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"488a720f-6b43-40e3-b31a-5677b256af2b",correct:"Unixové sockety pro lokální komunikaci mají cestu v systému souborů podobně jako pojmenované roury.",incorrect:"Unixové sockety pro lokální komunikaci nemají cestu v systému souborů a nepodobají se pojmenovaným rourám.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"ba25fd89-2c9d-4b46-aff7-4eff3270afe2",correct:"Streamové sockety umožňují zápis souvislého proudu dat, podobně jako fungují roury v operačním systému.",incorrect:"Streamové sockety slouží k posílání jednotlivých zpráv a neumožňují souvislý proud dat.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"54fa157b-7cc3-4f13-95a7-bdcc81047386",correct:"Datagramové sockety se používají pro posílání jednotlivých zpráv, zatímco streamové sockety pro souvislý tok dat.",incorrect:"Datagramové sockety se používají pro souvislý tok dat, zatímco streamové sockety pro posílání jednotlivých zpráv.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"6b6b17b0-0080-472e-bbbc-2d2c58a0c7be",correct:"Existují dva základní typy adres socketů: internetové a unixové, lišící se účelem komunikace.",incorrect:"Existuje pouze jeden základní typ adres socketů, který je univerzální pro všechny druhy komunikace.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"}]},{uuid:"a696dee9-3091-4a3e-9d9b-88b4bf4c1266",sectionNumber:"11",sectionTitle:"The Kernel",statements:[{uuid:"4b49ab24-d1dc-470f-aa4b-71b15da88249",correct:"Moderní univerzální procesory typicky disponují režimem supervizora a uživatelským režimem.",incorrect:"Moderní univerzální procesory pracují pouze v uživatelském režimu bez režimu supervizora.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"dafc8566-7f7e-4694-8b3d-618dcb8470ea",correct:"Architektura x86 poskytuje čtyři odlišné úrovně oprávnění, označované jako ringy 0 až 3.",incorrect:"Architektura x86 poskytuje pouze dvě úrovně oprávnění, ring 0 a ring 3.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"009dae67-d7a4-4e00-8b38-4050a8e62ca9",correct:"Hypervisor Xen může využívat ring 1 pro běh kernelů hostovaných operačních systémů.",incorrect:"Hypervisor Xen nikdy nevyužívá ring 1 a spoléhá se pouze na ring 0 a ring 3.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"3560bc97-8d2a-42ee-b687-c84b2aa55581",correct:"Pouze programy běžící v supervizorském režimu mohou provádět určité privilegované operace.",incorrect:"Programy v uživatelském režimu mají stejná oprávnění k provádění operací jako programy v supervizorském režimu.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"2cf06d06-58a1-4572-81cf-26c3949338c9",correct:"Ovladače zařízení mohou běžet v méně privilegované úrovni než jádro operačního systému.",incorrect:"Ovladače zařízení musí běžet ve stejném nebo vyšším privilegovaném režimu jako jádro operačního systému.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"a86a00fc-e3c1-4a63-a529-3c5f4f26bccc",correct:"Kernel operačního systému běží v privilegovaném režimu procesoru.",incorrect:"Kernel operačního systému běží v uživatelském režimu procesoru.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"4ced23a5-7a0e-46e6-9d8a-8d00042dd7b5",correct:"V privilegovaném režimu může software programovat jednotku správy paměti MMU.",incorrect:"V uživatelském režimu může software programovat jednotku správy paměti MMU.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"4626ab91-e36c-4e11-bfb9-2a0d7de3f43a",correct:"Většina kódu operačního systému, včetně knihoven a démonů, běží v uživatelském režimu.",incorrect:"Většina kódu operačního systému, včetně knihoven a démonů, běží v privilegovaném režimu.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"8c9dc983-6051-4310-8cb1-b5b50b626f80",correct:"Uživatelský režim procesoru je navržen jako více omezený než privilegovaný režim.",incorrect:"Uživatelský režim procesoru je navržen jako méně omezený než privilegovaný režim.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"6d984243-7970-4e45-8e3c-4268e477c36a",correct:"Kód běžící v privilegovaném režimu má možnost měnit paměť libovolného běžícího programu.",incorrect:"Kód běžící v uživatelském režimu má možnost měnit paměť libovolného běžícího programu.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"fbb55a61-e03a-4308-9261-62cb92f4d8f1",correct:"Jednotka správy paměti (MMU) je klíčová pro implementaci oddělení paměti mezi programy.",incorrect:"Jednotka správy paměti (MMU) není relevantní pro implementaci oddělení paměti mezi programy.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"ae545e08-651c-4465-bab8-4a19fa2c1b58",correct:"MMU je subsystém procesoru, který se stará o překlad virtuálních adres na fyzické.",incorrect:"MMU je subsystém paměti, který se stará o přidělování fyzické paměti procesům.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"bcbbad53-2866-420d-8e97-12c1cb820863",correct:"Programy používají virtuální adresy, které jsou překládány MMU na fyzické adresy.",incorrect:"Programy používají fyzické adresy, které jsou překládány MMU na virtuální adresy.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"d78720e9-bdf4-4077-b7c7-9de544661c10",correct:"Operační systém (jádro) spravuje mapování virtuálních adres na fyzické adresy v MMU.",incorrect:"Uživatelský prostor spravuje mapování virtuálních adres na fyzické adresy v MMU.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"542524db-9bc4-461c-a770-5c1422f6c4e8",correct:"Jádro operačního systému poskytuje MMU překladové tabulky pro adresový překlad.",incorrect:"MMU si dynamicky vytváří překladové tabulky bez zásahu jádra operačního systému.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"96121a78-cdff-4335-96dd-d6857208cd7b",correct:"Mapování jádra do všech procesů zvyšuje výkon, ale přináší i bezpečnostní rizika jako Meltdown.",incorrect:"Mapování jádra pouze do některých procesů je běžná technika pro zvýšení bezpečnosti systému.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"55f97d20-0acd-43ba-a5ab-de3c4013e749",correct:"Stránky jádra chrání speciální příznak supervizora, který zakazuje přístup z uživatelského režimu.",incorrect:"Uživatelský režim má plný přístup ke stránkám jádra, což umožňuje flexibilní správu paměti.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"facaf35b-c295-4f42-8b84-9e6641afc43b",correct:"Operační systémy se snaží minimalizovat nahrazování tabulek stránek kvůli jeho vysoké náročnosti.",incorrect:"Nahrazování tabulek stránek je nenáročná operace, běžně využívaná při systémových voláních.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"2f1f7f5c-127e-48c8-9ca7-afa7d6bf6037",correct:"Po zapnutí napájení je systém v implicitním stavu kvůli volatilitě RAM paměti.",incorrect:"Po zapnutí napájení je systém v plně funkčním stavu s operačním systémem v RAM.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"ad3df8f4-cac6-453a-95b1-8cf55f853f47",correct:"Dynamická RAM paměť po odpojení napájení rychle ztrácí svůj uložený obsah.",incorrect:"Dynamická RAM paměť uchovává data i po odpojení napájení díky stálému napájení z baterie.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"d60abf0d-7f73-4d20-b698-5464899f9328",correct:"Po zapnutí počítače je nutné inicializovat CPU a další hardwarové komponenty platformy.",incorrect:"Po zapnutí počítače se inicializuje pouze operační systém, hardware je již inicializován z výroby.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"ba19d638-74b9-40fc-811e-616b2a2a13fc",correct:"Firmware zavádí bootloader z trvalého úložiště před zavedením kernelu.",incorrect:"Firmware zavádí kernel z trvalého úložiště před zavedením bootloaderu.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"dfd5d64c-240e-4046-8694-926615950961",correct:"Bootloader je považován za součást operačního systému a má za úkol zavést kernel.",incorrect:"Bootloader je považován za součást firmwaru a má za úkol zavést kernel.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"52a50014-d24d-4c49-a5d0-a37aa542204e",correct:"Jednoduchý bootloader může pro zavedení kernelu používat seznam diskových bloků.",incorrect:"Jednoduchý bootloader vždy rozumí složitým souborovým systémům pro zavedení kernelu.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"ea34eab6-b72e-4261-a60a-77e7aa57bf64",correct:"CPU x86 se po startu spouští v 16bitovém režimu z důvodu zpětné kompatibility.",incorrect:"CPU x86 se po startu spouští v 64bitovém režimu z důvodu zpětné kompatibility.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"c8ded9ef-f8c1-4386-95a7-0bf156ee2ba0",correct:"V 16bitovém režimu procesoru x86 je MMU standardně deaktivována.",incorrect:"V 16bitovém režimu procesoru x86 je MMU standardně aktivována.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"be3e0601-eec7-4fc0-ac71-16f990362a7b",correct:"Jádro operačního systému přepíná CPU x86 do chráněného režimu z 16bitového režimu.",incorrect:"Jádro operačního systému ponechává CPU x86 v 16bitovém režimu.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"31afcfec-f431-44e3-be3f-653346c75f45",correct:"Firmware může u moderních 64bitových x86 procesorů přepnout CPU do 64bitového režimu před bootloaderem.",incorrect:"Firmware u moderních 64bitových x86 procesorů nikdy nepřepíná CPU do 64bitového režimu.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"71dce89f-b12f-41d6-b120-0441db225210",correct:"Bootloader je krátký program specifický pro platformu, který zavádí jádro z trvalého úložiště do RAM.",incorrect:"Bootloader je rozsáhlý program nezávislý na platformě, který zavádí ovladače zařízení z operační paměti.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"0bbb2f79-ade4-40f0-9b3d-292e7dc0d2ba",correct:"V moderních x86 systémech firmware s rozhraním FAT usnadňuje bootování načítáním souborů do paměti.",incorrect:"V moderních x86 systémech firmware nerozumí souborovému systému FAT a musí používat nízkoúrovňový přístup k disku.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"d50c875c-25ef-4044-b6c4-a104f37066ac",correct:"Bootování ARM systémů je komplikovanější kvůli menší standardizaci a nutnosti přizpůsobení bootloaderu pro SoC.",incorrect:"Bootování ARM systémů je jednodušší než x86 díky jednotnému firmware rozhraní a vysoké standardizaci hardwaru.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"23a8bcf8-2d1d-4545-91ec-b8c48192a9ca",correct:"U-boot se stal de-facto standardem pro bootování ARM systémů, i když vyžaduje adaptaci pro každý SoC.",incorrect:"U-boot je pouze okrajově používaný pro bootování ARM systémů a většina výrobců používá vlastní bootloadery.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"ee08fb82-fa00-482c-a40d-cb9facc8d33a",correct:"Kernel inicializuje ovladače zařízení před hledáním root filesystemu.",incorrect:"Kernel inicializuje root filesystem před inicializací ovladačů zařízení.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"5390e66c-4b9d-4c87-9064-d2963434fd68",correct:"Po inicializaci root filesystemu kernel spouští init proces a předává mu řízení.",incorrect:"Před inicializací root filesystemu kernel spouští init proces a předává mu řízení.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"3cf7b58f-79e5-4e3a-8aae-fc0c7fba21cd",correct:"Bootloader zavádí kernel do RAM a skáče na předem určenou adresu pro start inicializace.",incorrect:"Bootloader zavádí kernel do persistentního úložiště a skáče na předem určenou adresu pro start inicializace.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"c34679b7-979e-4aee-88f1-2717d08f83cf",correct:"Po spuštění init procesu se uživatelský prostor ujímá kontroly nad systémem.",incorrect:"Po spuštění init procesu kernel nadále řídí veškeré akce v systému.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"7f4bae10-0dda-479e-a413-f61a092a2690",correct:"Inicializace kernelu začíná nízkoúrovňovým nastavením CPU a základních periferií.",incorrect:"Inicializace kernelu začíná inicializací uživatelského prostoru a aplikací.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"9efa779a-ee25-42e7-b39a-59aafdadf21a",correct:"Proces init po zavedení systému připojí souborové systémy a spouští systémové služby uživatelského režimu.",incorrect:"Proces init po zavedení systému spouští pouze aplikační služby a nepřipojuje souborové systémy.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"60812212-0bcc-4ff2-a7ef-9af6f05162d6",correct:"Proces init spouští aplikační služby, které zahrnují i démoni, jež nejsou součástí operačního systému.",incorrect:"Proces init spouští aplikační služby, které jsou vždy klíčovou součástí samotného operačního systému.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"b1ac5469-6a53-4c1e-adb4-09650e297e00",correct:"Proces login je spuštěn procesem init až po dokončení startu všech nezbytných systémových služeb.",incorrect:"Proces login je spuštěn procesem init ještě před zahájením jakýchkoliv systémových služeb.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"0612cc31-c1cc-4ec4-aee6-d51b5015c0b6",correct:"Po spuštění procesu login se uživateli zobrazí přihlašovací obrazovka pro zadání jména a hesla.",incorrect:"Po spuštění procesu login se automaticky spustí grafické uživatelské rozhraní bez nutnosti přihlášení.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"d96003fd-98ad-42eb-af95-78e6cb3ccfd2",correct:"Přihlašovací proces inicializuje uživatelskou relaci.",incorrect:"Přihlašovací proces neinicializuje uživatelskou relaci.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"f464c73f-534e-4685-b907-1178806b062b",correct:"Během přihlášení se zavádí moduly desktopu a aplikační software.",incorrect:"Během přihlášení se zavádí pouze aplikační software, nikoli moduly desktopu.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"5cca15bd-35b5-4038-be88-d3d59cfed3bc",correct:"Po přihlášení je uživatel přesměrován do textového nebo grafického shellu.",incorrect:"Po přihlášení je uživatel přesměrován přímo do spuštěné aplikace.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"a562de58-6e31-4e2d-ab00-f6378997ee12",correct:"Nastavení relace po přihlášení umožňuje uživateli pracovat s počítačem.",incorrect:"Nastavení relace po přihlášení je zbytečné pro práci uživatele s počítačem.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"c1ac4671-66e1-4c19-9b7d-f15724733a14",correct:"Monolitické jádra představují nejrozsáhlejší a mikrokernelová jádra nejmenší návrh mainstreamových jader operačních systémů.",incorrect:"Mikrokernelová jádra jsou nejrozsáhlejší a monolitické jádra nejmenší návrh mainstreamových jader operačních systémů.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"f964119b-5f39-443e-943a-a90ce109edfc",correct:"Hybridní jádra kombinují mikrokernel a takzvaný superserver, což je osekané monolitické jádro.",incorrect:"Hybridní jádra kombinují monolitické jádro a takzvaný superserver, který je rozšířený mikrokernel.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"e303a469-5e39-405f-8f21-98d1e220d19a",correct:"Hypervisory typu 1 jsou považovány za specifický typ operačního systému, kde jsou aplikace virtuální stroje.",incorrect:"Hypervisory typu 1 jsou běžným typem operačního systému, který přímo spouští aplikace bez virtualizace.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"7c4309e6-30d4-482a-9294-40959405187a",correct:"Exokernelové operační systémy radikálně omezují služby poskytované aplikacím ve srovnání s monolitickými jádry.",incorrect:"Exokernelové operační systémy rozšiřují služby poskytované aplikacím nad rámec běžných monolitických jader.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"f2d51065-ad61-4e7b-a66b-f68533b54e5d",correct:"Mikrokernel se stará o ochranu paměti programováním MMU.",incorrect:"Mikrokernel se nestará o ochranu paměti a nechává to na uživatelský prostor.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"c73ca7f7-9ebf-4e0f-81f7-7bf26f9348f0",correct:"Obsluha hardwarových přerušení je klíčovou součástí mikrokernelu.",incorrect:"Obsluha hardwarových přerušení se obvykle provádí mimo mikrokernel v uživatelském prostoru.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"040d8b21-b3b5-4edc-a9b2-dec757c5d8b6",correct:"Plánování úloh a procesů typicky spadá do kompetencí mikrokernelu.",incorrect:"Plánování úloh a procesů je obvykle implementováno jako samostatná služba mimo mikrokernel.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"4a2eb192-5dc4-4caa-8750-c7b46ec87a96",correct:"Mikrokernel poskytuje mechanismy pro předávání zpráv mezi procesy.",incorrect:"Mikrokernel se nezabývá předáváním zpráv mezi procesy a spoléhá na sdílenou paměť.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"8b932d21-fdd6-412d-bee6-ae16fd0e9f76",correct:"Mikrokernel poskytuje nízkoúrovňové služby pro ovladače zařízení, jako je programování DMA.",incorrect:"Mikrokernel neposkytuje žádné specifické služby pro ovladače zařízení kromě základních služeb pro procesy.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"d96345eb-70a3-4879-a3e0-2d26aa061360",correct:"Monolitické jádro zahrnuje vše, co mikrokernel, a navíc ovladače zařízení a souborové systémy.",incorrect:"Mikrokernel zahrnuje vše, co monolitické jádro, a navíc ovladače zařízení a souborové systémy.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"16eff613-f5ed-455c-9c6b-d037c68e6f24",correct:"Monolitické jádro integruje výkonově kritické ovladače zařízení přímo do kernelu.",incorrect:"Monolitické jádro neintegruje výkonově kritické ovladače zařízení přímo do kernelu.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"92bada91-be33-4a35-b4c3-480e8b48538c",correct:"TCP/IP stack je téměř vždy součástí monolitického jádra.",incorrect:"TCP/IP stack nikdy není součástí monolitického jádra.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"ede57709-07f9-4a07-99a5-2a0a8f1903a7",correct:"Kód monolitického jádra běží v privilegovaném režimu a má úplnou kontrolu nad systémem.",incorrect:"Kód monolitického jádra běží v uživatelském režimu a má omezenou kontrolu nad systémem.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"3baede32-c805-43f5-8fb3-02732ce3513d",correct:"Mikrokernel obvykle neobsahuje souborové systémy a správu svazků.",incorrect:"Mikrokernel obvykle obsahuje souborové systémy a správu svazků.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"360d8d6e-64ea-4e1e-be98-687a5c426b25",correct:"V mikrokernelovém operačním systému běží každý ovladač zařízení v samostatném procesu.",incorrect:"V mikrokernelovém operačním systému běží všechny ovladače zařízení v jednom procesu.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"3cee2233-1c29-4748-a3b8-2eeee7b6c368",correct:"Pravý mikrokernelový operační systém se skládá z mnoha modulů, které se nazývají servery.",incorrect:"Pravý mikrokernelový operační systém se skládá pouze z mikrokernelu a několika málo modulů.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"ece0c989-196c-4e51-b529-3af71cd6ac2c",correct:"V mikrokernelu jsou souborové systémy a síťové služby implementovány jako samostatné procesy, zvané servery.",incorrect:"V mikrokernelu jsou souborové systémy a síťové služby implementovány přímo v mikrokernelu.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"a481ba7c-48dd-44c9-b478-743e51c2d0cb",correct:"Hybridní jádra operačních systémů jsou založena na mikrokernelu.",incorrect:"Hybridní jádra operačních systémů jsou založena na monolitickém kernelu.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"ce92704f-6e97-49a7-852b-4ecfe0734d9e",correct:"V hybridním jádře operačního systému je většina služeb poskytována superserverem.",incorrect:"V hybridním jádře operačního systému je většina služeb poskytována mikrokernelem.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"a76e8d93-1a7b-4f4f-9b53-f07c3a54ee72",correct:"Implementace hybridního jádra je jednodušší než implementace čistého mikrokernelu.",incorrect:"Implementace hybridního jádra je složitější než implementace čistého mikrokernelu.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"dc772c42-4d39-4c38-871a-0dc51ec47490",correct:"Hybridní jádra operačních systémů představují kompromis z hlediska výkonu.",incorrect:"Hybridní jádra operačních systémů dosahují nejlepšího možného výkonu.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"861b93dc-ed1b-4947-9cc8-31270acc7454",correct:"Superserver v hybridním jádře je částečně izolován od hardwaru.",incorrect:"Superserver v hybridním jádře je plně integrován s hardwarem.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"e5e4f8e6-899c-43c9-8aa3-5bf2365568f7",correct:"Server hybridního jádra je často založen na monolitickém kernelu.",incorrect:"Server hybridního jádra je často založen na distribuovaném systému.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"ec1d0d9d-22f3-4c87-9a3b-31b8bddf23c3",correct:"Návrh hybridních jader je levnější než návrh čistých mikrokernelových systémů.",incorrect:"Návrh hybridních jader je dražší než návrh čistých mikrokernelových systémů.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"fb3ea2d6-922d-42d1-9cef-3303a480dcb7",correct:"Hybridní jádra teoreticky dosahují lepšího výkonu než čisté mikrokernelové systémy.",incorrect:"Hybridní jádra teoreticky dosahují horšího výkonu než čisté mikrokernelové systémy.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"a4f4f0c5-147d-460a-bba5-75dd0ac92e92",correct:"Mikrokernelové architektury jsou robustnější díky menšímu jádru a izolaci serverů.",incorrect:"Monolitické architektury jsou robustnější díky menšímu jádru a izolaci serverů.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"f66de558-6a83-4336-a52c-4e50a31a9da9",correct:"Monolitická jádra nabízejí vyšší výkon, hlavně díky menšímu kontextovému přepínání.",incorrect:"Mikrokernelová jádra nabízejí vyšší výkon, hlavně díky menšímu kontextovému přepínání.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"676d86fa-9b86-4805-8a1a-3fe28e2c13c8",correct:"Monolitická jádra umožňují psát kód přímým synchronním stylem a snadněji sdílet datové struktury.",incorrect:"Mikrokernelová jádra umožňují psát kód přímým synchronním stylem a snadněji sdílet datové struktury.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"20788971-5faf-44f9-be8b-cbf0a4c4ee85",correct:"Mikrokernelové systémy často vyžadují asynchronní komunikaci a předávání zpráv, což ztěžuje implementaci.",incorrect:"Monolitické systémy často vyžadují asynchronní komunikaci a předávání zpráv, což ztěžuje implementaci.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"7b006219-7a01-4663-b60c-2a0304bc33ef",correct:"Výkonnostní rozdíl mezi monolitickými a mikrokernelemi se zmenšuje díky bezpečnostním vylepšením monolitických jader.",incorrect:"Výkonnostní rozdíl mezi monolitickými a mikrokernelemi se zvětšuje díky bezpečnostním vylepšením monolitických jader.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"c5b55400-786e-47ac-985f-220f3025da27",correct:"Z dlouhodobého hlediska mikrokernele nabízejí lepší modularitu a izolaci komponent.",incorrect:"Z dlouhodobého hlediska monolitické kernele nabízejí lepší modularitu a izolaci komponent.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"c1f760eb-2c77-49df-bd23-8232abc1dc26",correct:"Exokernely poskytují aplikační izolaci na úrovni procesů, ale s velmi omezenými abstrakcemi operačního systému.",incorrect:"Exokernely neposkytují aplikační izolaci na úrovni procesů a nabízejí plnohodnotné abstrakce operačního systému.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"57b2d7d0-7f77-464c-b834-33b68db46975",correct:"Hypervizor může používat hrubší abstrakce než operační systém, například celé úložné zařízení místo systému souborů.",incorrect:"Hypervizor používá jemnější abstrakce než operační systém, například systém souborů místo celého úložného zařízení.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"7bf8d5ed-02c9-49be-a993-4005003ac390",correct:"Unikernely jsou navrženy pro běh jediné aplikace a poskytují podmnožinu tradičních abstrakcí operačního systému.",incorrect:"Unikernely jsou navrženy pro běh více aplikací a poskytují plnohodnotné tradiční abstrakce operačního systému.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"f070309b-1512-4c37-8281-43868e6a5572",correct:"Exokernely poskytují méně abstrakcí než mikrokernelové operační systémy.",incorrect:"Exokernely poskytují více abstrakcí než mikrokernelové operační systémy.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"8c331bc9-8516-43ff-a822-bd42eaa1c081",correct:"Unikernely se často spouštějí přímo na hypervizoru, aby se minimalizovala režie obecného operačního systému.",incorrect:"Unikernely se nikdy nespouštějí přímo na hypervizoru, protože vyžadují plnohodnotný operační systém pod nimi.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"0b23a227-27bd-42a3-8aad-ac6714d688e3",correct:"Jádro operačního systému běží v privilegovaném režimu procesoru.",incorrect:"Uživatelský kód běží v privilegovaném režimu procesoru.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"b9746ae4-cae8-481e-a5c5-9cf9554feae3",correct:"Paměť jádra je chráněna před přímým přístupem z uživatelského kódu.",incorrect:"Uživatelský kód může přímo číst a zapisovat do paměti jádra.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"447ec85b-34b1-412d-a3af-4e77c3ac8af3",correct:"Uživatelský kód musí žádat jádro o služby pomocí systémových volání.",incorrect:"Uživatelský kód může přímo volat funkce jádra bez systémových volání.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"7f5a038c-8380-4144-b8b1-5c2ff23f067d",correct:"Systémová volání umožňují bezpečný přechod mezi uživatelským prostorem a jádrem.",incorrect:"Systémová volání umožňují uživatelskému kódu obejít bezpečnostní mechanismy jádra.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"69748e73-bd79-445e-b78b-ee03d40d948b",correct:"Mechanismus systémových volání přepíná CPU do privilegovaného režimu pro provedení kódu jádra.",incorrect:"Mechanismus systémových volání ponechává CPU v uživatelském režimu i během běhu kódu jádra.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"ac70523d-a23b-4b76-9a27-1c24f3e400cf",correct:"Aplikace nemůže spustit svůj vlastní kód v privilegovaném režimu pomocí systémových volání.",incorrect:"Aplikace může pomocí systémových volání spustit libovolný kód v privilegovaném režimu.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"e0c5bd79-efc7-4f54-979d-1371efc09f4f",correct:"Systémová volání se chovají podobně jako standardní podprogramy z knihoven.",incorrect:"Systémová volání se chovají zcela odlišně od standardních podprogramů z knihoven.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"5faae2cd-a47c-4738-abf2-b2c1e37ef76d",correct:"Při systémovém volání se provádění předává kernelové rutině pro provedení operace.",incorrect:"Při systémovém volání se provádění ponechává uživatelskému prostoru bez zásahu kernelu.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"0edd8909-4102-46bb-8d59-0174e510765f",correct:"Argumenty pro systémové volání musí být předány do jádra bezpečným způsobem.",incorrect:"Argumenty pro systémové volání se předávají do uživatelského prostoru pro manipulaci jádrem.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"79eda6f3-cf7f-4b65-a3f4-971d084153d5",correct:"Z uživatelského prostoru by nemělo být možné číst ani modifikovat paměť jádra.",incorrect:"Uživatelský prostor má plný přístup ke čtení a modifikaci paměti jádra během volání.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"67226360-3bf7-4653-b445-787052fbc88b",correct:"Systémová volání v operačních systémech jsou závislá na architektuře a spoléhají na pevnou vstupní adresu nastavenou jádrem.",incorrect:"Systémová volání v operačních systémech jsou nezávislá na architektuře a spoléhají na dynamicky určenou vstupní adresu.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"9e1b68ad-c7f2-4ab7-9afc-1b7be5cc56d4",correct:"Mechanismus systémových volání, ač závislý na architektuře, univerzálně zajišťuje eskalaci privilegií s přenosem na pevnou adresu.",incorrect:"Mechanismus systémových volání je nezávislý na architektuře a univerzálně umožňuje eskalaci privilegií bez přenosu na pevnou adresu.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"f1dc243e-3a6c-4320-8d1d-106df8806ae9",correct:"Na architektuře x86 mohou být systémová volání implementována pomocí instrukce softwarového přerušení, jako je `int`.",incorrect:"Na architektuře x86 jsou systémová volání implementována výhradně pomocí hardwarových přerušení, nikoli softwarových.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"48beee78-bb3a-4513-84fc-993dd33adba4",correct:"Softwarová přerušení nejsou obecně příliš efektivní pro systémová volání kvůli režii spojené s ukládáním stavu procesoru.",incorrect:"Softwarová přerušení jsou obecně velmi efektivní pro systémová volání díky minimální režii spojené s ukládáním stavu procesoru.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"6d9d7462-07c0-4715-8e21-9c36acba962a",correct:"Adresa obslužné rutiny softwarového přerušení se získává z paměti, konkrétně z tabulky vektorů přerušení.",incorrect:"Adresa obslužné rutiny softwarového přerušení se získává přímo z registru procesoru, což zrychluje zpracování.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"abaa2ad7-36d0-4b27-bb6b-0bf703709c57",correct:"Mechanismus softwarových přerušení vyžaduje uložení značného množství stavu procesoru, což přispívá k latenci systémových volání.",incorrect:"Mechanismus softwarových přerušení vyžaduje uložení pouze minimálního stavu procesoru, čímž se minimalizuje latence systémových volání.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"c0192c84-ed22-433a-97e8-e2565318b14c",correct:"Na architektuře x86 byla softwarová přerušení preferovaným mechanismem pro systémová volání do konce 32bitové éry procesorů.",incorrect:"Na architektuře x86 jsou softwarová přerušení stále preferovaným a nejefektivnějším mechanismem pro systémová volání i v 64bitové éře.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"7bd455e0-3874-424c-9ba4-c05478fecdb4",correct:"Procesory x86 od modelu 80386 nabízely mechanismus syscall, který byl však operačními systémy zpočátku spíše ignorován.",incorrect:"Procesory x86 od modelu 80386 nabízely mechanismus syscall, který byl operačními systémy okamžitě široce přijat a využíván.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"b7144b30-ab84-4c6a-8dd3-97163a3e2660",correct:"Softwarová přerušení se používala jak v reálném módu, například pro BIOS a MS-DOS, tak i v chráněném módu pro moderní OS.",incorrect:"Softwarová přerušení se používala výhradně v chráněném módu moderních operačních systémů a nikdy nebyla využívána v reálném módu.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"41ce1d53-6e26-4d71-a0b4-9ca17a1d4b8a",correct:"Instrukce sysenter a syscall pro eskalaci privilegií mají pouze jeden vstupní bod.",incorrect:"Instrukce sysenter a syscall pro eskalaci privilegií mají více vstupních bodů.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"bc8acec1-31c8-45f9-9989-dd7f65399164",correct:"Mechanismus sysenter a syscall je rychlejší než softwarová přerušení díky minimalizaci režie.",incorrect:"Mechanismus sysenter a syscall je pomalejší než softwarová přerušení kvůli větší režii.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"3c879767-9c17-4b18-8d95-9b162929efb8",correct:"Stav výpočtu je u sysenter a syscall spravován softwarově, na rozdíl od přerušení.",incorrect:"Stav výpočtu je u sysenter a syscall spravován hardwarově, podobně jako u přerušení.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"a0bffc50-8062-40ad-ab47-c823ff7c4a3b",correct:"Moderní operační systémy, jako Linux a Windows, typicky poskytují stovky systémových volání.",incorrect:"Moderní operační systémy, jako Linux a Windows, poskytují pouze desítky systémových volání.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"99016920-e64b-44a9-b4e7-4b3fc6e85cdb",correct:"Pro zpracování systémových volání operační systémy obvykle využívají jediný vstupní bod.",incorrect:"Pro každé systémové volání operační systémy vyžadují dedikovaný vstupní bod.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"2ae210fe-7b40-4e0b-a5e9-a17d12504120",correct:"Operační systém identifikuje požadovanou službu systémového volání na základě čísla volání předaného v registru procesoru.",incorrect:"Operační systém identifikuje požadovanou službu systémového volání na základě názvu volání předaného v paměti.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"8b82e19a-d4c3-4337-9428-09749f16e313",correct:"První fáze systémového volání se provádí v uživatelském režimu a je obvykle implementována v knihovně ‹libc›.",incorrect:"První fáze systémového volání se provádí v privilegovaném režimu a je obvykle implementována v jádře operačního systému.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"22c0e333-5eaf-486c-af46-7f04a18a0f1f",correct:"Po přepnutí do privilegovaného režimu začne provádění rutina jádra – obslužný program systémových volání.",incorrect:"Před přepnutím do privilegovaného režimu začne provádění rutina jádra – obslužný program systémových volání.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"d25c9346-01a4-4944-a963-e371c26ed86e",correct:"V moderních systémech, jako je amd64 Linux, se argumenty systémových volání předávají v registrech CPU.",incorrect:"V moderních systémech, jako je amd64 Linux, se argumenty systémových volání předávají v paměti na uživatelském zásobníku.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"6781d2a5-e908-485c-9e18-2bff94279cbb",correct:"Zpracování argumentů systémového volání se provádí až po Dispatch systémového volání na základě jeho čísla.",incorrect:"Zpracování argumentů systémového volání se provádí před Dispatch systémového volání na základě jeho čísla.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"24a94a05-43ee-46ef-af40-4464e8f00c8f",correct:"Správa paměti a plánování procesů jsou klíčové funkce jádra operačního systému.",incorrect:"Správa paměti a plánování procesů jsou obvykle outsourcovány do externích služeb.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"22e9b880-f2fb-456a-9e31-a04d8e7ae117",correct:"Ovladače zařízení jsou nezbytnou součástí operačního systému, ale nemusí být vždy součástí jádra.",incorrect:"Ovladače zařízení jsou vždy implementovány výhradně jako součást jádra operačního systému.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"14ffd357-f1fe-4e4c-a752-96f43f068e07",correct:"Souborové systémy jsou považovány za klíčovou součást operačního systému, ačkoli nejsou vždy součástí jádra.",incorrect:"Souborové systémy nejsou považovány za klíčovou součást moderního operačního systému.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"1cce98b0-cdf2-475b-ac87-7a33af4df0c6",correct:"Síťové služby jsou klíčovou součástí moderního operačního systému, i když tradičně mohly být součástí jádra.",incorrect:"Síťové služby jsou spíše doplňkovou funkcí operačního systému než jeho klíčovou součástí.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"04757062-3387-40c6-a623-13ebe2b2354a",correct:"Monolitické jádro může poskytovat různé doplňkové služby, například správu časovačů.",incorrect:"Monolitické jádro vždy poskytuje všechny doplňkové služby uvedené v seznamu.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"61b4b1ca-80a3-440d-858f-ce58a0719e15",correct:"Implementace IPC se mohou mezi různými monolitickými operačními systémy značně lišit.",incorrect:"Implementace IPC jsou v monolitických jádrech napříč systémy vždy zcela identické.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"6b529d35-9b5d-4cad-9ec8-f401614bf11e",correct:"IPC mechanismy jsou v mikrokernelech ještě důležitější než v monolitických jádrech.",incorrect:"IPC mechanismy hrají v mikrokernelech méně významnou roli než v monolitických jádrech.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"2a5ac551-4c54-4e4e-b57e-8ca8734851dd",correct:"Mikrokernel poskytuje pouze služby, které nelze rozumně implementovat mimo něj.",incorrect:"Mikrokernel poskytuje širokou škálu služeb, podobně jako monolitické jádro.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"9fc9156f-483c-4b7d-8f63-b8100f24c0e9",correct:"V systémech s pravým mikrokernelem běží každá služba ve vlastním procesu.",incorrect:"V systémech s pravým mikrokernelem běží všechny služby v jediném procesu superserveru.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"a1d4c8a4-0e45-4bde-972a-c0cb1b16ec23",correct:"Hybridní systémy jsou obvykle rychlejší než systémy s pravým mikrokernelem kvůli menšímu počtu přepnutí kontextu.",incorrect:"Hybridní systémy jsou obvykle pomalejší než systémy s pravým mikrokernelem kvůli většímu počtu přepnutí kontextu.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"23f22994-776a-4906-85a9-b74513252030",correct:"Superservery v hybridních systémech mají vnitřní architekturu podobnou monolitickým jádrům.",incorrect:"Superservery v hybridních systémech mají distribuovanou architekturu, na rozdíl od monolitických jader.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"18763896-6d40-4283-a265-de8b8c2960ee",correct:"Systémy s pravým mikrokernelem jsou teoreticky lépe škálovatelné na velké SMP systémy než hybridní systémy.",incorrect:"Systémy s pravým mikrokernelem jsou teoreticky hůře škálovatelné na velké SMP systémy než hybridní systémy.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"e5cf3ec5-ef5a-4652-b6c4-1b5799360feb",correct:"Z pohledu uživatelského prostoru aplikace využívají systémové knihovny pro komunikaci s kernelem bez ohledu na architekturu.",incorrect:"Z pohledu uživatelského prostoru aplikace musí detailně znát architekturu kernelu pro správnou komunikaci.",sectionNumber:"11.5.4",sectionTitle:"Kernel Services"},{uuid:"4e296ed0-c2e5-4990-a3c4-3ee5a184b407",correct:"Programy v uživatelském prostoru se nestarají o to, který server poskytuje služby, protože je to abstrahováno.",incorrect:"Programy v uživatelském prostoru musí aktivně vyhledávat a adresovat specifické servery pro služby.",sectionNumber:"11.5.4",sectionTitle:"Kernel Services"},{uuid:"a6bfc807-bc9d-419c-9685-120eb5e9b580",correct:"Ovladače tiskáren mají významné komponenty v uživatelském prostoru operačního systému.",incorrect:"Ovladače tiskáren jsou výhradně součástí jádra operačního systému.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"6ee10307-da70-4826-a9b8-8d4a596474fb",correct:"U grafických karet je nízkoúrovňový přístup k hardwaru zajištěn jádrem, ale velká část ovladače běží v uživatelském prostoru.",incorrect:"U grafických karet běží kompletní ovladač, včetně nízkoúrovňového přístupu k hardwaru, výhradně v uživatelském prostoru.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"d6b6e4c5-d2d1-4246-9806-3e3817d93939",correct:"Ne všechny ovladače zařízení jsou nutně součástí jádra operačního systému, například ovladače tiskáren.",incorrect:"Všechny ovladače zařízení, včetně ovladačů tiskáren, jsou vždy integrální součástí jádra operačního systému.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"e1fbb28e-48a0-42d9-8c55-b47f8407eda5",correct:"Většina OpenGL se obvykle nachází v uživatelském prostoru operačního systému.",incorrect:"Většina OpenGL se pro svůj výkon obvykle nachází přímo v jádře operačního systému.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"c77db53a-9c97-4014-a425-4d6f406f691d",correct:"I v monolitických jádrech operačních systémů mohou mít některé ovladače významné komponenty v uživatelském prostoru.",incorrect:"V monolitických jádrech operačních systémů jsou všechny ovladače vždy výhradně součástí jádra.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"}]},{uuid:"2bac8616-733e-44f0-a50a-b3818d8199c2",sectionNumber:"12",sectionTitle:"OS Virtualization",statements:[{uuid:"418de05c-da86-45b0-86e5-1b1a322701f4",correct:"Hypervisor, také známý jako Virtual Machine Monitor, umožňuje spouštění více operačních systémů.",incorrect:"Hypervisor, také známý jako Virtual Machine Monitor, umožňuje spouštění pouze jednoho operačního systému.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"3a2646ed-2618-4057-a772-523432499395",correct:"Hypervisor se chová jako kernel, který běží mezi hardwarem a virtualizovanými operačními systémy.",incorrect:"Hypervisor se chová jako běžná aplikace, která běží nad operačním systémem a virtualizuje hardware.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"a75ee7a1-dd71-4c1a-af17-ee04609055d5",correct:"Virtualizované operační systémy sdílejí procesory a jsou izolovány v fyzické paměti pomocí MMU.",incorrect:"Virtualizované operační systémy sdílejí procesory, ale nejsou izolovány v fyzické paměti.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"9b05a169-c6b4-4aa6-98e5-33c0a274ee93",correct:"Rozhraní hypervizoru a operačního systému je jednodušší než rozhraní operačního systému a aplikace.",incorrect:"Rozhraní hypervizoru a operačního systému je složitější než rozhraní operačního systému a aplikace.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"3f245951-66b3-4c15-8a5e-02078ee80ad9",correct:"Virtualizované operační systémy umožňují stupeň autonomie, který není běžný, když více uživatelů sdílí jeden OS.",incorrect:"Virtualizované operační systémy umožňují menší stupeň autonomie, než když více uživatelů sdílí jeden OS.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"d1ec81e0-7325-4e6b-921b-8584b2007fdb",correct:"Mezi hypervizorem a operačním systémem neexistují systémy souborů pro komunikaci.",incorrect:"Mezi hypervizorem a operačním systémem existují sdílené systémy souborů pro komunikaci.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"6d2ccad6-a7a7-40c6-893b-0e03e740ede5",correct:"Virtuální stroje sdružují zdroje a zpřístupňují je operačnímu systému.",incorrect:"Virtuální stroje poskytují přímý přístup k hardwaru operačnímu systému.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"99bccb9d-095c-4f78-aedc-0f08736b401b",correct:"MMU virtualizuje fyzickou paměť, což je klíčový aspekt virtualizace zdrojů v počítačích.",incorrect:"MMU virtualizuje virtuální paměť, což přímo zjednodušuje správu fyzických periferií systému.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"cff85e9f-83cb-4dab-b25b-5b869bb2a8f7",correct:"Operační systém virtualizuje periferie, aby umožnil bezpečné a spravedlivé sdílení hardwarových zdrojů.",incorrect:"Operační systém virtualizuje pouze paměť, přičemž periferie jsou spravovány přímo hardwarem.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"9db6dbb9-7d59-45a4-9b36-5d01fa7c3f91",correct:"Virtualizace usnadňuje správu zdrojů a umožňuje izolaci komponent v operačním systému.",incorrect:"Virtualizace komplikuje správu zdrojů a ztěžuje izolaci komponent v operačním systému.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"3b3fd330-be19-4e73-8a96-2aedb2ba3f74",correct:"Hypervizory typu 1 jsou umístěny přímo nad hardwarem a fungují jako jednoduchý mikrokernel.",incorrect:"Hypervizory typu 1 běží jako aplikace nad běžným operačním systémem.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"9e290401-7468-4405-a2a5-fcc100677838",correct:"Hypervizory typu 2 využívají plánovač a správu paměti hostitelského operačního systému.",incorrect:"Hypervizory typu 2 si samy spravují plánování procesoru a paměť, nezávisle na hostitelském systému.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"27c7f614-f6a5-479b-9230-9538c9212cb5",correct:"Hlavní rozdíl mezi hypervizory typu 1 a 2 spočívá v jejich umístění v softwarovém zásobníku systému.",incorrect:"Hypervizory typu 1 a 2 se liší pouze v podpoře různých typů hardwaru, nikoli v architektuře.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"b849cf44-53c6-4e82-802c-ffa47004a133",correct:"Z/VM, Xen a Hyper-V jsou příklady hypervizorů typu bare metal.",incorrect:"VMWare, VirtualBox a Hyper-V jsou příklady hypervizorů typu bare metal.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"495e0a55-d70c-499d-aea9-20ab02085a88",correct:"VMWare a VirtualBox jsou uvedeny jako příklady hosted hypervizorů.",incorrect:"Xen a VirtualBox jsou uvedeny jako příklady hosted hypervizorů.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"f28e3a1e-5e8f-4afd-b4a5-0f314cba7d18",correct:"IBM provedla první pokusy s provozováním více OS na stejném hardwaru v 60. letech.",incorrect:"Microsoft provedla první pokusy s provozováním více OS na stejném hardwaru v 60. letech.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"afac5d09-a74d-47f8-8690-9c4e12994c9a",correct:"CP/CMS z roku 1968 a VM/370 z roku 1972 jsou rané systémy pro virtualizaci od IBM.",incorrect:"CP/CMS z roku 2000 a VM/370 z roku 1972 jsou rané systémy pro virtualizaci od IBM.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"50947234-b11e-4536-bba4-19deb08263a5",correct:"Architektura x86 postrádá režim virtuálního supervizora.",incorrect:"Architektura x86 disponuje režimem virtuálního supervizora.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"c65b1ca0-d291-49ae-9f63-d2eefa94d94a",correct:"Softwarová virtualizace se stala proveditelnou řešením koncem 90. let.",incorrect:"Softwarová virtualizace byla proveditelná řešením již v raných 90. letech.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"ab7560f7-fbe0-4375-bfce-487bdf532677",correct:"Výkon procesorů PC se stal dostatečným pro emulaci PC-na-PC v polovině 90. let.",incorrect:"Výkon procesorů PC se stal dostatečným pro emulaci PC-na-PC až na začátku 21. století.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"3c29d622-1197-460b-87b8-99e570660cc6",correct:"Bochs byl uveden v roce 1994, VMWare v roce 1999 a QEMU v roce 2003.",incorrect:"Bochs byl uveden v roce 1999, VMWare v roce 1994 a QEMU v roce 2003.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"6bb7a057-d7d7-423e-8703-676b174f0de4",correct:"Paravirtualizace, představená společností VMWare v roce 2005, vyžaduje modifikace hostovaného operačního systému.",incorrect:"Paravirtualizace, představená společností VMWare v roce 2005, nevyžaduje modifikace hostovaného operačního systému.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"f5a01684-2e63-43a3-b7d3-1ba13451faf5",correct:"Alternativní přístup k paravirtualizaci byl představen v Xenu v roce 2006.",incorrect:"Alternativní přístup k plné virtualizaci byl představen v Xenu v roce 2006.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"4899f107-3f39-41b8-993c-8c5c362d7ff8",correct:"Paravirtualizace umožňuje dosáhnout téměř nativní rychlosti bez hardwarové podpory.",incorrect:"Paravirtualizace umožňuje dosáhnout téměř nativní rychlosti pouze s hardwarovou podporou.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"b26ae74d-529a-4af0-89ad-73e4ef516431",correct:"Virtualizační rozšíření pro x86 architekturu se objevila okolo roku 2005.",incorrect:"Virtualizační rozšíření pro x86 architekturu se objevila až po roce 2010.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"fdb8f4eb-5bf8-44f6-99c7-fc658c902ec9",correct:"Virtualizace MMU se stala běžnou součástí desktopových procesorů přibližně v roce 2008.",incorrect:"Virtualizace MMU se stala běžnou součástí desktopových procesorů již v roce 2000.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"15d1ff47-af0c-438e-ac6e-cc1ea15a90ed",correct:"Díky virtualizačním rozšířením není v principu nutné modifikovat hostovaný operační systém.",incorrect:"Díky virtualizačním rozšířením je nutné modifikovat hostovaný operační systém.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"1f75a261-3ada-4d4f-ad34-940e4f05fcba",correct:"MMU virtualizace přispěla ke zjednodušení návrhu hypervizorů pro x86 architekturu.",incorrect:"MMU virtualizace zkomplikovala návrh hypervizorů pro x86 architekturu.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"d806ce22-ccef-44c2-86ee-f6789dc98bb7",correct:"Softwarová virtualizační řešení se stala zastaralými s nástupem hardwarové virtualizace.",incorrect:"Softwarová virtualizační řešení zůstala dominantní i po nástupu hardwarové virtualizace.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"ca5351dd-3832-46c9-8ad7-ede86e6452a9",correct:"Procesory s virtualizačními rozšířeními umožňují běh nemodifikovaného hostovaného OS téměř nativní rychlostí.",incorrect:"Procesory s virtualizačními rozšířeními výrazně zpomalují běh hostovaného operačního systému.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"f3857e91-3c0d-435d-979d-b152ab02269a",correct:"Paravirtualizované periferie vyžadují speciální ovladače v hostovaném operačním systému.",incorrect:"Paravirtualizované periferie **ne**vyžadují speciální ovladače v hostovaném operačním systému.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"b5036837-f74a-4e54-b3ad-a216967361a8",correct:"Hardwarová virtualizace periférií je ekonomicky náročnější než paravirtualizace.",incorrect:"Hardwarová virtualizace periférií je **ekonomicky výhodnější** než paravirtualizace.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"6bb4d60e-adeb-4770-82a2-c2ee9cf8261b",correct:"Paravirtualizované periferie nevyžadují změny v hostovaném operačním systému.",incorrect:"Paravirtualizované periferie **vyžadují rozsáhlé** změny v hostovaném operačním systému.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"682a206e-c03c-4a4f-af97-3a3ab154692d",correct:"Virtualizace může být realizována hardwarově za pomoci technologií jako VT-x a EPT.",incorrect:"Virtualizace je výhradně softwarová záležitost a nepoužívá hardwarové technologie.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"143f1be0-8519-40d3-abff-7e3fb5b9018d",correct:"Virtuální stroj obvykle poskytuje procesor, paměť, blokové úložiště a síťové připojení.",incorrect:"Virtuální stroj typicky poskytuje jen procesor a paměť, ostatní zdroje nejsou nutné.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"862bfd9b-3a9d-4481-bb9e-2f87fecb8d93",correct:"Systém běžící pod virtualizovaným operačním systémem se označuje jako virtuální stroj.",incorrect:"Systém běžící pod virtualizovaným operačním systémem se nazývá hostitelský systém.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"63c1073d-7070-4cb8-8823-dff4c5734849",correct:"Správa virtuálních strojů je obecně považována za jednodušší než správa fyzického hardwaru.",incorrect:"Správa virtuálních strojů je obvykle složitější než správa fyzického hardwaru.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"22335399-ecb8-4e8c-b35d-a0a91a2deca4",correct:"Mezi běžné zdroje poskytované virtuálním strojem patří i konzolové zařízení pro správu.",incorrect:"Konzolové zařízení pro správu není typickým zdrojem poskytovaným virtuálním strojem.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"a04de73a-56f7-4cc8-a1b1-6b4af239857d",correct:"Hypervisor obsahuje plánovač procesů, který je však jednodušší než u běžného operačního systému.",incorrect:"Hypervisor neobsahuje plánovač procesů, protože plánování je plně delegováno na hostitelský operační systém.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"23329e8c-f1f0-4527-8615-2e9b5a7ef709",correct:"Privilegované instrukce jsou zachytávány hypervizorem a zpracovávány softwarově.",incorrect:"Privilegované instrukce jsou vykonávány přímo hostitelským CPU bez zásahu hypervizoru.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"b5723a26-336e-479b-aee0-1d2b02f38ecb",correct:"Hypervisor spravuje virtualizovanou MMU, což umožňuje izolaci paměti virtuálních strojů.",incorrect:"Hypervisor nesprávuje virtualizovanou MMU, správu paměti virtuálních strojů zajišťuje hostitelský OS.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"8b9ddc28-bd5c-4f97-aa0f-d29ef6a64d03",correct:"Většina instrukcí uživatelského prostoru je vykonávána hostitelským CPU nativně, bez režie hypervizoru.",incorrect:"Všechny instrukce, včetně instrukcí uživatelského prostoru, jsou emulovány hypervizorem.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"badf8917-1b80-4360-a98b-1552086781ef",correct:"Virtualizace paměti se opírá o stejné principy jako izolace procesů v OS, využívající stránkování a MMU.",incorrect:"Virtualizace paměti využívá zcela odlišné mechanismy než izolace procesů v OS a nepoužívá stránkování.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"072e2beb-f37d-451d-9853-f4aa33e40ce6",correct:"Shadow page tables představují softwarovou metodu virtualizace paměti, kde hostující systém nemá přímý přístup k MMU.",incorrect:"Shadow page tables jsou hardwarová metoda virtualizace paměti, umožňující hostujícímu systému přímý přístup k MMU.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"7e2aba11-7330-46f9-bc83-edd5ef29d1ca",correct:"V shadow page tables hypervisor synchronizuje guest page tables se shadow page tables, které odrážejí virtuální adresy hosta.",incorrect:"V shadow page tables jsou guest page tables synchronizovány přímo s fyzickou pamětí, bez účasti hypervisoru.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"8076ed93-ac8e-4bd7-9dbd-19bdd799ebfe",correct:"Druhá úroveň překladu, hardwarové řešení, zjednodušuje VMM a nabízí vyšší výkon než shadow page tables.",incorrect:"Druhá úroveň překladu, softwarové řešení, komplikuje VMM a je méně výkonná než shadow page tables.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"ed2a8990-6dc2-4db2-b8ba-28e51dd0bcc8",correct:"Moderní procesory umožňují hostujícímu OS modifikovat page tables přímo díky hardwarové virtualizaci MMU.",incorrect:"I s hardwarovou virtualizací MMU hostující OS nemůže přímo modifikovat page tables kvůli izolaci.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"dfe39581-5901-4b7a-96d1-00756eb942dc",correct:"Současná virtualizační řešení používají paravirtualizovanou síťovou kartu.",incorrect:"Starší virtualizační řešení běžně používají paravirtualizovanou síťovou kartu.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"ddc162b0-f48f-4bf0-884a-504a516b2052",correct:"Paravirtualizovaná síťová karta přenáší rámce mezi hostem a hostitelem.",incorrect:"Paravirtualizovaná síťová karta přenáší pakety mezi hostem a hostitelem.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"bc129d84-04ff-4102-ade7-4d8736b2a325",correct:"V hostitelském systému je paravirtualizovaná síťová karta obvykle připojena k softwarovému mostu.",incorrect:"V hostitelském systému je paravirtualizovaná síťová karta obvykle připojena k hardwarovému mostu.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"b9fa1cd5-4390-4bb1-b1ae-5061aedb284f",correct:"Alternativou k softwarovému mostu v hostiteli je směrování.",incorrect:"Jedinou alternativou k softwarovému mostu v hostiteli je směrování.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"4cc35ca5-a95c-41e8-9648-0aea3aad6453",correct:"Ethernetový tunel pseudo-zařízení v hostiteli funguje jako virtuální síťová karta.",incorrect:"Ethernetový tunel pseudo-zařízení v hostiteli funguje jako fyzická síťová karta.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"15bb8e28-dda0-4125-aef0-b367c8640ca6",correct:"Blokové úložiště je obvykle založeno na paravirtualizaci.",incorrect:"Blokové úložiště není nikdy založeno na paravirtualizaci.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"746de823-2658-4d79-88fe-e2eb57d4169a",correct:"Hostitelská strana blokového zařízení může být podložena běžným souborem v systému hostitele.",incorrect:"Hostitelská strana blokového zařízení nemůže být podložena běžným souborem v systému hostitele.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"4c6db57e-a61f-4721-81a0-a48028e1d244",correct:"Soubory pro blokové úložiště mohou být ve speciálním formátu, například copy-on-write.",incorrect:"Soubory pro blokové úložiště nikdy nejsou ve speciálním formátu jako copy-on-write.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"1597bfdd-0989-4778-95a0-4566d9c8b562",correct:"Blokové úložiště může být podloženo skutečným blokovým zařízením.",incorrect:"Blokové úložiště nemůže být nikdy podloženo skutečným blokovým zařízením.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"003a8d9b-4b89-43c6-817e-4929ec3a763d",correct:"LVM a device-mapper jsou technologie používané pro virtualizaci blokových zařízení.",incorrect:"LVM a device-mapper nejsou technologie používané pro virtualizaci blokových zařízení.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"d87660d1-e3e1-4bba-af26-f87c7bd9427b",correct:"Periferie jsou užitečné hlavně v desktopových systémech.",incorrect:"Periferie jsou užitečné hlavně v serverové virtualizaci.",sectionNumber:"12.1.15",sectionTitle:"Special Resources"},{uuid:"2376e8f8-a533-4220-9462-b42120f1cf32",correct:"Grafické karty, zvuková zařízení a tiskárny patří mezi periferie.",incorrect:"Servery a virtualizační software patří mezi periferie.",sectionNumber:"12.1.15",sectionTitle:"Special Resources"},{uuid:"d21db130-382f-4a57-8158-fd67d4959205",correct:"Anti-virtualizační technologie využívá I/O MMU pro přímý přístup virtuálního operačního systému k hardwaru.",incorrect:"Anti-virtualizační technologie obchází I/O MMU a umožňuje přímý přístup virtuálního operačního systému k hardwaru.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"2aa897ab-34d5-4078-981f-c0f7073fe803",correct:"I/O MMU zabraňuje virtuálnímu operačnímu systému přímý zápis do paměti hostitelského systému.",incorrect:"I/O MMU umožňuje virtuálnímu operačnímu systému přímý zápis do paměti hostitelského systému.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"262023e2-9b93-4ace-a97d-f1dcab0b0bd4",correct:"Při přímém přístupu virtuálního OS k PCI zařízení, hostitelský systém s tímto zařízením nesmí komunikovat.",incorrect:"Při přímém přístupu virtuálního OS k PCI zařízení, hostitelský systém může s tímto zařízením komunikovat.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"b0d49f49-5cde-4944-aa40-f1dc567bc46e",correct:"GPU může být přidělena jednomu operačnímu systému pomocí VT-d.",incorrect:"GPU může být sdílena více operačními systémy současně pomocí VT-d.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"bf7d6262-ac60-4df9-9f1f-d34d3ac8f078",correct:"Moderní GPU umožňují časové sdílení, které vyžaduje ovladače v hypervizoru.",incorrect:"Moderní GPU umožňují časové sdílení bez nutnosti ovladačů v hypervizoru.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"3d1828d5-7f5f-4e3e-9e94-adcd3f41bd1a",correct:"Paravirtualizace GPU využívá vendor-neutrální protokol pro komunikaci s hypervizorem.",incorrect:"Paravirtualizace GPU vyžaduje vendor-specifické ovladače na straně hosta i hypervizoru.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"44829cd7-15af-42e5-afe8-d6c9ffd57fec",correct:"Síťové grafické protokoly jako X11 jsou pro sdílení GPU méně efektivní než specializované metody.",incorrect:"Síťové grafické protokoly jako X11 poskytují pro sdílení GPU nejvyšší možnou efektivitu.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"66527bad-4aa1-4126-b0be-452346497847",correct:"Při paravirtualizaci GPU hostující systém potřebuje uživatelskou část ovladače GPU pro generování příkazů.",incorrect:"Při paravirtualizaci GPU hostující systém nepotřebuje žádnou část ovladače GPU.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"f85bfee8-1e2f-4560-96ad-ef82bed97e4a",correct:"Periferní zařízení jako tiskárny a skenery mohou být sdíleny přes standardní sítě bez ztráty výkonu.",incorrect:"Periferní zařízení jako tiskárny a skenery nemohou být sdíleny přes standardní sítě bez ztráty výkonu.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"5ede9177-5d47-4378-8fa4-729889b63437",correct:"Sdílení periférií typu passthrough využívá virtualizaci sběrnic PCI, USB nebo SATA.",incorrect:"Sdílení periférií typu passthrough využívá virtualizaci pouze sběrnice PCI.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"ccd005a4-9014-476d-9be4-21773205c089",correct:"Některá audio zařízení mohou být sdílena přes standardní sítě s mírným zvýšením latence.",incorrect:"Všechna audio zařízení nemohou být sdílena přes standardní sítě.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"e2ee40c1-e310-4198-a216-eff82d0af26e",correct:"Passthrough periférií zahrnuje přesměrování na skutečné zařízení, například USB disk.",incorrect:"Passthrough periférií zahrnuje virtualizaci celého fyzického zařízení.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"017ca9ae-ead4-48fe-8d10-c4a2c4ab1dc3",correct:"Virtuální stroj lze snadno zastavit a uložit jeho stav do souboru na hostitelském systému.",incorrect:"Virtuální stroj lze zastavit, ale jeho stav nelze uložit do souboru.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"3e32e59c-4138-4e80-883f-026e439bce2e",correct:"RAM paměť zastaveného virtuálního stroje může být zkopírována do souboru spolu s registry.",incorrect:"RAM paměť běžícího virtuálního stroje může být zkopírována do souboru.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"83dc46a8-7d62-41f4-a733-ce7c63d2bdac",correct:"Pro uspání virtuálního stroje není nutná spolupráce hostovaného operačního systému.",incorrect:"Pro uspání virtuálního stroje je nezbytná aktivní spolupráce hostovaného operačního systému.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"c7e80b4b-ef46-462f-99d3-3dcbffc58229",correct:"Stav virtuálního stroje může být uložen a odeslán po síti pro pozdější obnovení.",incorrect:"Stav virtuálního stroje nemůže být uložen a odeslán po síti pro pozdější obnovení.",sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"1ad48848-304f-462a-90c2-44e6d568b278",correct:'Obnovení virtuálního stroje na jiném hostiteli se nazývá "paused migration".',incorrect:'Obnovení virtuálního stroje na jiném hostiteli se nazývá "live migration".',sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"7a356cb8-80e2-400d-8a0f-e9a9f616d566",correct:"Pauzovaná migrace vyžaduje, aby virtuální prostředí bylo na obou hostitelích kompatibilní.",incorrect:"Pauzovaná migrace nevyžaduje, aby virtuální prostředí bylo na obou hostitelích kompatibilní.",sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"c886789a-11ab-486b-8fb8-a1b982b0489a",correct:"Živá migrace virtuálního stroje využívá asynchronní snímky paměti.",incorrect:"Živá migrace virtuálního stroje využívá synchronní snímky paměti.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"d25b9519-fbe9-42ea-9b58-733fd89b7152",correct:"Při živé migraci hostitel kopíruje stránky paměti a označuje je jako read-only.",incorrect:"Při živé migraci hostitel kopíruje stránky paměti a označuje je jako write-only.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"3db4bd96-632a-41a6-9ce7-3944ea62bee7",correct:"Během živé migrace se nejprve odešle snímek paměti a poté změněné stránky.",incorrect:"Během živé migrace se nejprve odešlou změněné stránky a poté snímek paměti.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"bbd4f3d3-c4d5-4fd2-9b00-d02e663e1f5b",correct:"Copy-on-write mechanism v živé migraci spočívá v označení stránek jako read-only před jejich kopírováním.",incorrect:"Copy-on-write mechanism v živé migraci spočívá v označení stránek jako read-write před jejich kopírováním.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"e9a2fb4c-5a71-4ff8-b743-7000746fbbc3",correct:"VM je pozastaven pouze krátce na konci živé migrace pro odeslání registrů a posledních stránek.",incorrect:"VM je pozastaven na začátku živé migrace, aby se mohl odeslat snímek paměti.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"3ae9e15c-cf37-4c4d-8b1c-ead9366226b2",correct:"Hypervisor alokuje paměť virtuálním strojům na vyžádání, ale operační systémy obvykle nemají koncept dealokace fyzické paměti.",incorrect:"Hypervisor alokuje paměť virtuálním strojům staticky a operační systémy běžně dealokují fyzickou paměť.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"7b9f7558-373a-4740-823f-4fd319621773",correct:'Paměťový ballooning driver vrací nevyužitou "fyzickou" paměť hostitelskému operačnímu systému ve virtualizovaném prostředí.',incorrect:'Paměťový ballooning driver alokuje dodatečnou "fyzickou" paměť pro hostitelský operační systém ve virtualizovaném prostředí.',sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"22648213-6569-4e6a-ad24-de01b18bd87e",correct:"Při použití memory ballooning driveru dochází k odmapování paměti na straně hostitele, což pro hosta znamená ztrátu obsahu paměti.",incorrect:"Při použití memory ballooning driveru dochází k mapování paměti na straně hostitele, což pro hosta znamená zachování obsahu paměti.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"cc496e1e-0f0f-46cb-9836-a66f8d13763f",correct:"Operační systémy běžící ve virtuálních strojích obvykle nemají zabudovanou funkcionalitu pro vracení fyzické paměti hypervizoru.",incorrect:"Operační systémy běžící ve virtuálních strojích mají zabudovanou funkcionalitu pro automatické vracení fyzické paměti hypervizoru.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"b19f1df7-945d-4709-a752-df067031f146",correct:"Kontejnery využívají virtualizaci na úrovni operačního systému, ale nejsou plnohodnotné virtuální počítače.",incorrect:"Kontejnery jsou plnohodnotné virtuální počítače s vlastním jádrem operačního systému.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"9034c8ef-372f-4812-809f-179541cab466",correct:"Virtualizované síťové zásobníky v kontejnerech sdílejí hardware, ale mají oddělené IP adresy a směrovací tabulky.",incorrect:"Virtualizované síťové zásobníky v kontejnerech sdílejí hardware i IP adresy s hostitelským systémem.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"6619ff66-c5ea-408b-a3d5-28d67920c29e",correct:"Kontejnery umožňují rozdělení přístupu k systému souborů, například pomocí nástroje chroot.",incorrect:"Kontejnery mají plný přístup k systému souborů hostitelského operačního systému bez omezení.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"c92523e6-fb80-4765-b07e-eeaac8014e19",correct:"Kontejnerizace je založena na procesech a rozšiřuje jejich izolaci pomocí virtualizace na úrovni OS.",incorrect:"Kontejnerizace je založena na hardwarové virtualizaci a nikoliv na procesech operačního systému.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"99fad027-44f8-4e14-9be3-7135fee2bf52",correct:"Kontejnery se spouští rychleji než virtuální stroje díky sdílení jádra operačního systému.",incorrect:"Kontejnery se spouští pomaleji než virtuální stroje kvůli složitější izolaci procesů.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"9b96e5cf-ca5a-47dc-a85b-14abceab91db",correct:"Virtuální stroje vyžadují inicializaci vlastního jádra, což zpomaluje jejich spouštění oproti kontejnerům.",incorrect:"Virtuální stroje sdílejí jádro hostitelského systému, což urychluje jejich spouštění oproti kontejnerům.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"fdb79068-3d7e-48fe-9479-0857d11343cd",correct:"Díky sdílenému jádru mohou kontejnery efektivněji sdílet paměť a systémové prostředky.",incorrect:"Kvůli odděleným jádrům mohou kontejnery efektivněji sdílet paměť než virtuální stroje.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"666dd68f-30a2-47fb-94ec-c979df8b0564",correct:"Kontejnery umožňují dosáhnout vyšší efektivity využití zdrojů díky sdílení jádra a menší režii.",incorrect:"Kontejnery snižují efektivitu využití zdrojů kvůli nutnosti dodatečné izolace na úrovni jádra.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"ca9849e7-1bfb-4a46-bccd-eded0c4ea47f",correct:"Sdílení jádra mezi kontejnery umožňuje rychlejší zprovoznění nových systémů.",incorrect:"Sdílení jádra mezi kontejnery zpomaluje zprovoznění nových systémů kvůli nutnosti správy konfliktů.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"60e65ad6-d1a1-4284-959c-de9fc0a1e8cc",correct:"Kernel musí explicitně podporovat izolaci kontejnerů, aby mohl sdílet jádro mezi nimi.",incorrect:"Kernel nemusí explicitně podporovat izolaci kontejnerů, izolace je zajištěna virtualizací hardwaru.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"5b53108a-b165-47c2-838b-5350288a720c",correct:"Kontejnery mohou být spuštěny až dvacetkrát rychleji než běžné virtuální stroje.",incorrect:"Kontejnery potřebují ke spuštění řádově sekundy, podobně jako běžné virtuální stroje.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"1a77a438-04b2-466a-bed3-66628e58322c",correct:"Virtuální stroje mají schopnost být uspány a následně obnoveny, což kontejnery postrádají.",incorrect:"Virtuální stroje nemohou být uspány a obnoveny, na rozdíl od kontejnerů.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"1232b5a2-eaec-46f9-aa9d-aea16e13f178",correct:"Neaktivní virtuální stroje zabírají významně více diskového prostoru než kontejnery.",incorrect:"Neaktivní virtuální stroje zabírají srovnatelné množství diskového prostoru jako kontejnery.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"2af12779-eddb-41aa-8e60-47ab2ae4ef89",correct:"Systém chroot dovoluje provozovat více instancí operačního systému s jedním sdíleným jádrem.",incorrect:"Systém chroot neumožňuje provozovat více instancí operačního systému s jedním sdíleným jádrem.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"13a1f6dd-1faa-4fbd-bc71-a1dc5d178603",correct:"Chroot kontejnery sdílejí systémové prostředky jako procesní tabulky s hostitelským systémem.",incorrect:"Chroot kontejnery mají izolované systémové prostředky jako procesní tabulky od hostitelského systému.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"353e3399-6952-4e2e-8e63-039c8e1e5b98",correct:"V chroot kontejnerech se bezpečnostní role superuživatele nepřenáší pouze na kontejner, ale i na hostitelský systém.",incorrect:"V chroot kontejnerech je bezpečnostní role superuživatele omezena výhradně na daný kontejner.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"3168de7e-1dc5-46c1-bfe9-57c6d33c21ea",correct:"Kvůli sdílení portů je v chroot kontejnerech problematické spustit dva nezávislé webové servery.",incorrect:"Díky izolaci portů je v chroot kontejnerech snadné spustit dva nezávislé webové servery.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"1d16e0f7-1ce8-4a3f-9218-fa75c9bc40ed",correct:"Ačkoliv chroot izoluje systém souborů, většina ostatních systémových prostředků zůstává sdílená.",incorrect:"Chroot izoluje nejen systém souborů, ale i většinu ostatních klíčových systémových prostředků.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"d1f4c604-141e-42f4-b941-8b3615c77f1b",correct:"FreeBSD jail mechanismus je evolucí chroot, přidávající izolaci uživatelů a procesů.",incorrect:"FreeBSD jail mechanismus je pouhá implementace chroot bez další izolace.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"caa7588a-8b01-4a7c-8eda-a60941e338c5",correct:"Jail mechanismus FreeBSD virtualizuje síťový stack, umožňující jailům vlastní IP adresy.",incorrect:"Jail mechanismus FreeBSD nesdílí síťový stack, ale neumožňuje jailům vlastní IP adresy.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"674ac4af-012c-40b1-824e-5bdca0879c53",correct:"Root uživatel v jailu FreeBSD má omezené pravomoci oproti root uživateli mimo jail.",incorrect:"Root uživatel v jailu FreeBSD má stejné pravomoci jako root uživatel mimo jail.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"5702df1d-2abe-49d2-9aca-25b0ed79f9cb",correct:"Compartmenty viditelnosti v jádře Linuxu virtualizují hierarchii souborového systému, tabulky procesů a sítě.",incorrect:"Compartmenty viditelnosti v jádře Linuxu virtualizují pouze hierarchii souborového systému a tabulky procesů.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"44fd423a-4e69-47c8-ad8d-0674fe46c944",correct:"Namespaces v Linuxu, na rozdíl od VServeru, jsou součástí oficiálního jádra Linuxu.",incorrect:"VServer, na rozdíl od namespaces v Linuxu, je součástí oficiálního jádra Linuxu.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"a7e14d2d-6104-4954-bb62-a43523abea6c",correct:"Při vytváření nového procesu pomocí `clone` může rodičovský proces specifikovat, které zdroje má sdílet.",incorrect:"Při vytváření nového procesu pomocí `fork` musí rodičovský proces specifikovat, které zdroje má sdílet.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"ed97f147-5429-4719-9f91-c471ddce1044",correct:"V Linuxu kontrolní skupiny řídí alokaci hardwarových zdrojů pro procesy.",incorrect:"V Linuxu kontrolní skupiny primárně monitorují využití softwarových zdrojů, nikoliv hardwarových.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"fcadbb59-bbf2-4bf3-a404-9c6bbd04f140",correct:"Paměťová skupina v kontrolních skupinách Linuxu definuje limity pro využití paměti procesy.",incorrect:"Paměťové skupiny v Linuxu slouží pouze k monitorování využití paměti, nikoliv k aktivnímu omezování.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"255c0843-84da-4f15-ae49-35520ba1254a",correct:"Kontrolní skupiny v Linuxu jsou převážně ortogonální k jmenným prostorům, což minimalizuje překrývání jejich funkcí.",incorrect:"Kontrolní skupiny v Linuxu jsou plně integrovány s jmennými prostory a sdílejí většinu mechanismů pro izolaci.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"ab9801de-1f24-4bc2-8e8e-4c68d79c560c",correct:"LXC kontejnery jsou založeny na Linuxových jmenných prostorech a kontrolních skupinách.",incorrect:"LXC kontejnery jsou založeny pouze na virtualizaci hardwaru, nikoliv na jmenných prostorech.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"1922d5cf-535c-4da5-a95d-fef7baf5fae0",correct:"LXC je sada nástrojů v uživatelském prostoru pro správu kontejnerů.",incorrect:"LXC je primárně nástroj pro správu virtualizace na úrovni hypervizoru.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"90e4b285-0848-4701-810a-895a332bb783",correct:"Od verze 1.0 LXC umožňuje neprivilegované kontejnery spravované běžnými uživateli.",incorrect:"Neprivilegované kontejnery v LXC vyžadují root oprávnění pro správu i po verzi 1.0.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"3f64c2dc-e3a0-46b4-8af0-f9356e83b68c",correct:"LXC se objevil později než VServer, přibližně o sedm let.",incorrect:"LXC byl vyvinut výrazně dříve než VServer, zhruba o sedm let.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"dd980b6d-875a-415e-9fc5-900ec9da09eb",correct:"Funkcionalita LXC je srovnatelná s VServer a OpenVZ v oblasti kontejnerizace.",incorrect:"Funkcionalita LXC je zásadně odlišná od VServer a OpenVZ a nabízí zcela jiné možnosti.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"7fa075be-f656-44e2-93e1-b7d1ff399f02",correct:"Uživatelské režimové jádra se nacházejí někde mezi kontejnery a virtuálními stroji.",incorrect:"Uživatelské režimové jádra se nacházejí ve stejné kategorii jako kontejnery.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"63ac9e8c-f181-47d2-aff3-5b792d28cdff",correct:"User-mode Linux byl integrován do jádra Linux verze 2.6 v roce 2003.",incorrect:"User-mode Linux byl integrován do jádra Linux verze 2.4 v roce 2001.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"ec7fc88a-0b94-4b11-9aae-5a5cbd794831",correct:"Uživatelské režimové jádra mohou využívat paravirtualizační techniky.",incorrect:"Uživatelské režimové jádra nemohou využívat paravirtualizační techniky.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"346e4f2e-3b4d-48b6-a11a-de0864544d94",correct:"Uživatelské režimové jádra jsou jednodušší na implementaci než kontejnery.",incorrect:"Uživatelské režimové jádra jsou složitější na implementaci než kontejnery.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"9635ecd1-8f0d-4a3f-aff8-25945c8d59d7",correct:"Z pohledu hostitelského OS se uživatelské režimové jádro jeví jako standardní proces.",incorrect:"Z pohledu hostitelského OS se uživatelské režimové jádro jeví jako virtualní stroj.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"9826bf9e-c706-4e08-8b2b-f68aad08b23a",correct:"Kontejnery a uživatelská jádra běžně nepodporují suspendování a obnovení stavu, což je jejich zásadní nevýhodou.",incorrect:"Kontejnery a uživatelská jádra plně podporují suspendování a obnovení stavu, podobně jako hypervizory.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"6a72a51c-a198-4b10-b02a-deb9732e6ba2",correct:"Serializace stavu procesu je u kontejnerů a uživatelských jader složitější než u virtuálních strojů kvůli deskriptorům souborů.",incorrect:"Serializace stavu procesu je u kontejnerů a uživatelských jader stejně jednoduchá jako u virtuálních strojů.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"f3fb660f-7265-4582-9a2a-9a13be9598d3",correct:"Rychlý čas vypnutí a spuštění kontejnerů částečně kompenzuje absenci nativní podpory suspendování a obnovení.",incorrect:"Pomalý čas vypnutí a spuštění kontejnerů plně kompenzuje absenci podpory suspendování a obnovení.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"719d15cc-5702-429e-ba20-e901597a247b",correct:"Pro kontejnery je absence suspendování a obnovení závažnější problém než pro uživatelská jádra z hlediska migrace.",incorrect:"Pro uživatelská jádra je absence suspendování a obnovení závažnější problém než pro kontejnery z hlediska migrace.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"6171dd6b-ac5e-4f5c-b896-cd310f3b4a7b",correct:"Na rozdíl od hypervizorů, kontejnery a uživatelská jádra nemají širokou podporu pro suspendování a obnovení stavu.",incorrect:"Podobně jako hypervizory, kontejnery a uživatelská jádra mají širokou podporu pro suspendování a obnovení stavu.",sectionNumber:"12.2.10",sectionTitle:"Migration"}]}],_n=[{uuid:"4abf1f05-d2d2-42d0-9e59-e59669eaa198",sectionNumber:"B",sectionTitle:"Základní pojmy a definice",statements:[{uuid:"8384fb22-17c2-4211-9cf2-b218a9e20839",correct:"Abstrakce v operačních systémech je klíčový koncept, který umožňuje vytvářet rozsáhlé a komplexní systémy tím, že skrývá vnitřní detaily implementace a soustředí se na vnější chování komponent. Podobně jako zedník nemusí znát detaily výroby cihel, aby mohl postavit zeď, vývojáři operačních systémů mohou pracovat s abstrakcemi, aniž by museli rozumět všem vnitřním mechanismům, což zjednodušuje vývoj a údržbu systému.",incorrect:"Abstrakce v operačních systémech je klíčový koncept, který vyžaduje detailní znalost vnitřní implementace komponent, aby bylo možné vytvářet rozsáhlé a komplexní systémy.  Podobně jako zedník musí znát detaily výroby cihel, aby mohl postavit zeď, vývojáři operačních systémů musí rozumět všem vnitřním mechanismům abstrakcí, což zkomplikovuje vývoj a údržbu systému.",sectionNumber:"0.1.1",sectionTitle:"Co je abstrakce?"},{uuid:"b210e84b-0ba0-4a98-bd80-702309a59558",correct:"Abstrakce v operačních systémech usnadňuje návrh systému tím, že umožňuje skládat složité systémy z jednodušších stavebních bloků, kde je klíčové znát vnější chování každého bloku. Architekti systému se tak mohou soustředit na vlastnosti systému jako celku, například spolehlivost a výkon, aniž by museli detailně znát implementaci jednotlivých abstrakcí, podobně jako se u zdi hodnotí její nosnost a izolační schopnosti bez ohledu na přesný typ cihel.",incorrect:"Abstrakce v operačních systémech komplikuje návrh systému tím, že vyžaduje detailní znalost vnějšího i vnitřního chování každého stavebního bloku pro správné složení komplexních systémů. Architekti systému se musí soustředit na detaily implementace jednotlivých abstrakcí, aby zajistili vlastnosti systému jako celku, například spolehlivost a výkon, podobně jako se u zdi musí detailně zkoumat každý typ cihly pro zajištění nosnosti a izolačních schopností.",sectionNumber:"0.1.1",sectionTitle:"Co je abstrakce?"},{uuid:"9e696e56-5c5b-454b-8088-1ad1f052aa65",correct:"Modulární systém je takový systém, který je postaven z vhodných abstrakcí, kde jednotlivé části ve své implementaci spoléhají pouze na vnější rozhraní ostatních částí, což umožňuje snadnou výměnu modulů s jinou vnitřní strukturou, ale se stejným vnějším chováním, podobně jako je možné vyměnit dodavatele cihel během stavby bez zásadních dopadů.",incorrect:"Modulární systém je takový systém, kde jednotlivé části ve své implementaci spoléhají na vnitřní implementaci ostatních částí, a proto je výměna modulů s jinou vnitřní strukturou, ale se stejným vnějším chováním velmi obtížná a často vyžaduje rozsáhlé úpravy v celém systému, podobně jako by výměna dodavatele cihel během stavby vedla k nutnosti kompletní přestavby.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"55c170d4-0727-422c-97ff-277fbbc20aff",correct:"Abstrakce v softwaru, reprezentovaná například modulem, odděluje vnější rozhraní, které definuje chování modulu, od vnitřní implementace, která popisuje mechanismus fungování modulu, a tato separace umožňuje, aby různé moduly s odlišnými implementacemi mohly být zaměněny, pokud dodržují stejné vnější rozhraní.",incorrect:"Abstrakce v softwaru, reprezentovaná modulem, primárně spojuje vnější rozhraní a vnitřní implementaci, čímž zajišťuje, že změna v implementaci jednoho modulu automaticky vyžaduje změnu v rozhraní a v implementacích všech ostatních modulů, které s ním interagují, a zamezuje tak možnosti snadné výměny modulů.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"ce0781c8-e49a-4824-84d8-8cb0a65e610c",correct:"Von Neumannova architektura představuje abstrakci počítače, která zdůrazňuje jednotné vnější chování výpočetního zařízení bez ohledu na specifické hardwarové detaily, jako je výrobce paměťových modulů nebo typ použitých tranzistorů v procesoru, a soustředí se na základní principy fungování počítače.",incorrect:"Von Neumannova architektura je konkrétní implementace počítače, která se liší v závislosti na výrobci a použitých technologiích, a popisuje detailní vnitřní fungování počítače včetně chemického složení polovodičů v tranzistorech a přesného fyzického uspořádání paměťových modulů a procesoru.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"baec71fa-444c-4834-805e-e1b4bfd8e8a5",correct:"V rámci von Neumannovy architektury je operační paměť klíčová pro uchovávání jak instrukcí, které procesor vykonává, tak i dat, se kterými program pracuje, přičemž tato paměť je adresovatelná, což znamená, že je organizována do očíslovaných buněk, ke kterým lze přistupovat pomocí adres pro čtení a zápis dat.",incorrect:"Podle von Neumannovy architektury operační paměť slouží výhradně k dočasnému uložení dat pro aktuálně spuštěný program, zatímco instrukce se uchovávají výhradně v procesoru a do operační paměti se nikdy neukládají, přičemž paměť není adresovatelná a programy přistupují k datům sekvenčně bez možnosti adresování konkrétních buněk.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"da0a6f5f-3ea4-4167-a95c-1bd1a2576e5e",correct:"Operační paměť ve von Neumannově architektuře se zásadně liší od registrů procesoru tím, že paměť je adresovatelná a umožňuje instrukcím přistupovat k datům na základě libovolně vypočtené adresy, podobně jako proměnná v programování, zatímco registry mají pevná jména a program nemůže dynamicky určit jejich adresy.",incorrect:"Registry ve von Neumannově architektuře jsou flexibilnější než operační paměť, protože registry jsou adresovatelné a program může dynamicky vypočítat a měnit registry, které se používají v instrukcích, zatímco operační paměť má pevná jména a je omezena na sekvenční přístup, což omezuje flexibilitu programování.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"9557c0b4-0cb9-45b0-966c-3cf88e3efe58",correct:"V kontextu operačních systémů, periferní zařízení představují klíčové komponenty pro realizaci interakce počítače s vnějším prostředím, přičemž jejich funkce zahrnuje jak příjem dat z externích zdrojů, která následně slouží jako vstupní informace pro výpočetní procesy, tak i odesílání dat, jež jsou výsledkem provedených výpočtů a manifestují se v reálném světě skrze fyzikální projevy.",incorrect:"V kontextu operačních systémů, periferní zařízení jsou výhradně určena pro odesílání dat, která vznikla jako výstup výpočetních procesů a projevují se ve vnějším prostředí, a jejich funkčnost se nijak netýká příjmu dat z externích zdrojů, která by mohla být využita jako vstupní informace pro další výpočty a zpracování.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"0b1a763f-2b3b-4d91-bac4-7061d9429fac",correct:"Z hlediska abstrakce, kterou operační systémy poskytují, je veškerá aktivita vykonávaná programem, a to včetně činností jako je uživatelská interakce, generování vizuálního obsahu či síťová komunikace, v jádru reprezentována jako manipulace s číselnými daty, což implikuje, že i zdánlivě ne-výpočetní operace jsou na hlubší úrovni pouze sofistikovanými formami výpočtů.",incorrect:"Z hlediska abstrakce operačních systémů, aktivity programu jako uživatelská interakce a generování vizuálního obsahu se zásadně liší od výpočetních procesů a jsou realizovány prostřednictvím mechanismů, které nesouvisejí s manipulací s číselnými daty, což znamená, že tyto aktivity nemají charakter skrytých výpočtů, ale představují samostatnou kategorii operací.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"a1533b4f-70dd-41e1-a50b-2ff9d154b1e2",correct:"V operačních systémech je pojem programu abstraktní konstrukcí, kterou lze chápat jako uspořádanou posloupnost instrukcí detailně specifikujících určitý výpočetní postup, přičemž toto pojetí programu se dále rozšiřuje o koncept synchronizace, který zahrnuje koordinaci a součinnost výpočetních procesů s periferními zařízeními a také s potenciálně paralelně probíhajícími výpočty jiných programů.",incorrect:"V operačních systémech je pojem programu abstraktní konstrukcí, kterou lze chápat pouze jako uspořádanou posloupnost instrukcí detailně specifikujících výhradně výpočetní postup, a koncept synchronizace, zahrnující koordinaci s periferními zařízeními a paralelními výpočty, je irelevantní pro základní definici programu a jeho fungování.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"4a9ba000-3225-4c0d-ba78-b8ecfe575b54",correct:"Původní koncept von Neumannova počítače předpokládal, že jeden počítač vykonává pouze jeden program. Nicméně, zavedením virtualizace zdrojů, realizované operačním systémem a hardwarem, se tento koncept překonal. Virtualizace umožňuje, aby se jeden fyzický počítač tvářil jako několik virtuálních počítačů, čímž dává každému programu iluzi, že má k dispozici vlastní dedikovaný počítač a může běžet souběžně s ostatními programy.",incorrect:"Původní koncept von Neumannova počítače byl založen na myšlence, že jeden počítač vykonává pouze jeden program, a tento koncept zůstává nezměněn i v moderních operačních systémech. Virtualizace zdrojů sice existuje, ale neslouží k tomu, aby jeden fyzický počítač vypadal jako několik virtuálních, nýbrž pouze k efektivnějšímu sdílení fyzických zdrojů mezi programy běžícími sekvenčně, nikoliv souběžně.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"d01f212a-c354-4003-93b6-793b189cbc49",correct:"Virtualizace, klíčová vlastnost moderních operačních systémů umožňující každému programu pracovat s iluzí vlastního počítače, je komplexní mechanismus implementovaný jak hardwarově, tak softwarově. Procesor hraje zásadní roli v podpoře virtualizace skrze specializované instrukce a mechanismy, zatímco operační systém poskytuje softwarovou vrstvu abstrakce a řízení, čímž společně vytvářejí prostředí pro efektivní a izolovaný běh více programů na jednom fyzickém stroji.",incorrect:"Virtualizace, ačkoliv je důležitou součástí moderních operačních systémů, je primárně softwarová záležitost implementovaná výhradně operačním systémem. Hardware, ačkoli tvoří základ pro běh operačního systému, nehraje žádnou aktivní roli v samotném procesu virtualizace. Virtualizace je dosažena pouze sofistikovanými algoritmy a technikami v rámci operačního systému, které spravují a rozdělují zdroje mezi jednotlivé programy.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"7e07b294-9477-447a-91fc-eaf07d0797e6",correct:"Klíčovým konceptem v popisu událostí je relace předcházení, která definuje chronologické uspořádání jevů; pro dvě události A a B platí, že buď A předchází B, B předchází A, nebo jsou A a B souběžné, což znamená, že ani jedna z událostí nepředchází té druhé.",incorrect:"Klíčovým konceptem v popisu událostí je relace předcházení, která definuje chronologické uspořádání jevů; pro dvě události A a B platí, že buď A předchází B, B předchází A, přičemž souběžnost událostí není možná, jelikož relace předcházení vždy stanoví lineární uspořádání všech událostí.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"ec65dfaa-0cb1-4884-8322-2153e9d4b73c",correct:"Události X a Y v uvedeném příkladu, kde relace předcházení je definována jako P = {(A, X), (X, B), (A, Y), (Y, B)}, jsou považovány za souběžné, protože neexistuje žádná relace předcházení ani ve směru od X k Y, ani od Y k X, ačkoli obě události X i Y následují po události A a předcházejí události B.",incorrect:"Události X a Y v uvedeném příkladu, kde relace předcházení je P = {(A, X), (X, B), (A, Y), (Y, B)}, nejsou souběžné, protože relace předcházení P jasně definuje, že událost A předchází X a Y, a X a Y předchází B, což vytváří lineární sekvenci událostí bez možnosti souběžnosti mezi X a Y.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"acecb102-bf5c-4713-b9f5-325e7e810a7d",correct:"Časový sled událostí, jak je definován v kontextu operačních systémů, představuje lineární uspořádání všech relevantních událostí. Pro libovolnou dvojici událostí v tomto uspořádání platí, že buď jedna událost striktně předchází druhou, nebo naopak, vylučuje se tak možnost, že by dvě události nastaly absolutně současně v rámci daného časového sledu. Tato linearita je klíčová pro konzistentní interpretaci událostí.",incorrect:"Časový sled událostí v operačních systémech je nelineární uspořádání, kde pro libovolnou dvojici událostí neplatí, že by jedna událost musela předcházet druhé. V tomto modelu je běžné, že události nastávají současně a nelze jim přiřadit unikátní časová razítka, což zjednodušuje analýzu souběžných procesů a minimalizuje složitost správy událostí v systému.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"6433afd2-0a51-4cf0-8f2e-6ebaf0617933",correct:"Hazard souběhu, známý také jako race condition, nastává v situacích, kdy vnější pozorovatel systému zaznamená rozdílné chování systému pro dva různé časové sledy událostí. Tyto časové sledy jsou přitom oba plně kompatibilní s definovanou relací předcházení událostí. To znamená, že rozdílné lineární uspořádání událostí, které respektují stejná omezení předcházení, vedou k nekonzistentnímu chování systému.",incorrect:"Hazard souběhu, nebo race condition, je stav systému, kdy vnější pozorovatel zaznamená identické chování systému bez ohledu na různé časové sledy událostí. I když existují různé časové sledy, které jsou kompatibilní s relací předcházení, vnější chování systému zůstává vždy stejné a konzistentní, čímž se eliminuje možnost nekonzistence způsobené různým pořadím událostí.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"32789915-f160-41aa-9dc7-507a2f7d8d8b",correct:"Abstrakce časového sledu událostí v operačních systémech je úzce spjata s konceptem relace předcházení. Pro každý platný časový sled musí platit kompatibilita s definovanou relací předcházení, což znamená, že pokud událost A předchází události B dle relace předcházení, pak v jakémkoliv platném časovém sledu musí událost A figurovat před událostí B. Tato kompatibilita zajišťuje konzistenci a předvídatelnost chování systému.",incorrect:"Abstrakce časového sledu událostí v operačních systémech je zcela nezávislá na konceptu relace předcházení. Platný časový sled nemusí být kompatibilní s relací předcházení, což umožňuje flexibilnější uspořádání událostí a dovoluje, aby událost A mohla figurovat za událostí B v časovém sledu, i když relace předcházení definuje, že A má předcházet B. Tato nezávislost zvyšuje efektivitu systému.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"2f84ea44-ec5f-4257-a5c9-1e44e863f250",correct:"Operační systémy jsou fundamentálním softwarovým vybavením počítačových systémů, jejichž primárním účelem je umožnit uživatelům spouštět a efektivně využívat aplikace, a to tím, že poskytují nezbytné rozhraní a prostředí pro jejich běh a interakci s hardwarem.",incorrect:"Operační systémy jsou specializovaným typem aplikačního softwaru, který se instaluje nad rámec běžných programů a slouží výhradně pro specifické úkoly, jako je správa souborů a tisk dokumentů, přičemž pro běh uživatelských aplikací nejsou operační systémy nezbytné.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"72ce3f83-031c-4fac-bc82-85d40a54d51f",correct:"Klíčovou funkcí operačních systémů je zprostředkování řízeného a bezpečného přístupu uživatelských programů k hardwarovým a softwarovým zdrojům systému, což zahrnuje procesor, paměť, úložná zařízení a další systémové komponenty a knihovny, a to s ohledem na správu a přidělování těchto zdrojů.",incorrect:"Operační systémy záměrně brání přímému přístupu uživatelských programů k hardwarovým zdrojům a softwarovým knihovnám systému, aby se maximalizovala bezpečnost a stabilita, a programy tak musí pracovat výhradně v izolovaném prostředí bez možnosti ovlivňovat systémové zdroje.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"6e160ae4-41a2-4499-8506-c06ef8d08ca6",correct:"Moderní víceúlohovové a víceuživatelské operační systémy jsou navrženy tak, aby umožňovaly současný běh více uživatelských programů a efektivně spravovaly jejich souběžné požadavky na systémové zdroje, přičemž klíčovým aspektem je zajištění izolace mezi běžícími programy, aby se minimalizovalo riziko vzájemného ovlivňování a chyb.",incorrect:"Víceúlohovové operační systémy sice umožňují spouštění více programů najednou, ale nemají mechanismy pro izolaci běžících programů, což v praxi vede k častým konfliktům a nestabilitě systému, jelikož programy nekontrolovaně sdílejí systémové zdroje a mohou se vzájemně ovlivňovat.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"f5f0972f-dad2-4db1-bdec-96d4023ec3f9",correct:'Standard POSIX, vyvinutý organizací The Open Group, představuje mnohem obsáhlejší a standardizované rozhraní než pouhá abstrakce "víceúlohový, víceuživatelský operační systém". Definuje především C API a je široce podporován napříč různými operačními systémy, i když ne všechny víceuživatelské operační systémy se ho striktně drží.',incorrect:'Standard POSIX, vyvinutý organizací IEEE, představuje méně obsáhlé a proprietární rozhraní než abstrakce "víceúlohový, víceuživatelský operační systém". Definuje především Java API a je podporován pouze minoritní skupinou operačních systémů, přičemž všechny víceuživatelské operační systémy se ho striktně drží.',sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"ddb470ed-cef3-4b4a-b323-c9dea107fe62",correct:"Rozhraní POSIX API, které je stěžejní součástí standardu POSIX, je popsáno jako sada funkcí v programovacím jazyce C a umožňuje uživatelským programům efektivně využívat širokou škálu služeb poskytovaných moderními operačními systémy, čímž zjednodušuje vývoj aplikací napříč různými platformami.",incorrect:"Rozhraní POSIX API, které je pouze okrajovou součástí standardu POSIX, je popsáno jako sada tříd v programovacím jazyce Java a omezuje uživatelské programy ve využívání základních služeb poskytovaných moderními operačními systémy, čímž komplikuje vývoj aplikací napříč různými platformami.",sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"1f87678b-3039-4a57-bb49-c81e6a73cc3c",correct:"Běžný návrh operačního systému zahrnuje jádro a uživatelský prostor, přičemž jádro má privilegovaný přístup k hardwarovým zdrojům, zejména k procesoru, což mu umožňuje řídit virtualizaci a přidělování zdrojů, jako je paměť a procesor, ostatním částem systému a uživatelským programům, a tím plnit roli strážce integrity systému.",incorrect:"Běžný návrh operačního systému zahrnuje jádro a uživatelský prostor, přičemž uživatelský prostor má privilegovaný přístup k hardwarovým zdrojům, zejména k procesoru, což mu umožňuje řídit virtualizaci a přidělování zdrojů, jako je paměť a procesor, ostatním částem systému a jádru, a tím plnit roli strážce integrity systému.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"c0a26249-d345-4ffe-ba8b-324ef09dd17a",correct:"Jádro operačního systému hraje klíčovou roli v realizaci a řízení virtualizace výpočetních zdrojů, jako je procesor a paměť, a zároveň funguje jako strážce integrity systému tím, že uživatelským procesům umožňuje pouze ty operace, které explicitně povolí, čímž chrání systém před neoprávněnými zásahy.",incorrect:"Jádro operačního systému hraje okrajovou roli v realizaci a řízení virtualizace výpočetních zdrojů, jako je procesor a paměť, a zároveň nefunguje jako strážce integrity systému, ale spoléhá se na uživatelské procesy, že budou dodržovat pravidla systému a chrání systém před neoprávněnými zásahy.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"069903bd-d781-4bdd-867b-eb21d85bc434",correct:"Ačkoli existují operační systémy bez jasně vyčleněného jádra, jsou považovány za vzácné a v základním kurzu operačních systémů se jimi autoři textu rozhodli nezabývat, protože drtivá většina moderních operačních systémů, na které se kurz zaměřuje, má architekturu s jasně odděleným jádrem.",incorrect:"Ačkoli existují operační systémy bez jasně vyčleněného jádra, jsou považovány za běžné a v základním kurzu operačních systémů se jimi autoři textu rozhodli zabývat detailně, protože drtivá většina moderních operačních systémů, na které se kurz zaměřuje, nemá architekturu s jasně odděleným jádrem.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"5d688992-13fe-4228-9110-f944daf90d24",correct:"Virtualizace operačního systému představuje významný krok vpřed v oblasti izolace výpočetních úloh, neboť na rozdíl od tradiční izolace procesů, kterou poskytuje jeden operační systém, umožňuje virtualizace vytvořit zcela oddělené instance operačních systémů. Tím se minimalizuje riziko vzájemného ovlivňování a kontaminace úloh, které sdílejí fyzické zdroje, a zvyšuje se celková robustnost a bezpečnost systému.",incorrect:"Virtualizace operačního systému sice nabízí určitou úroveň izolace výpočetních úloh, avšak v podstatě se jedná o stejný mechanismus izolace jako u procesů v rámci jednoho operačního systému. Virtualizace operačního systému se primárně zaměřuje na efektivnější sdílení hardwarových zdrojů a nezvyšuje významně úroveň izolace mezi jednotlivými úlohami běžícími na stejném fyzickém počítači.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"3e2f5c11-5538-4a3f-9d4d-190ed4b3e445",correct:"Z pohledu správy výpočetních systémů přináší virtualizace operačních systémů značné zjednodušení, jelikož umožňuje spravovat systém na úrovni jednotlivých instancí operačního systému, což je tradičně základní jednotka správy.  Navíc, virtualizace otevírá možnosti migrace, včetně živé migrace běžících operačních systémů mezi různými fyzickými servery, což zvyšuje flexibilitu a dostupnost služeb a snižuje nutnost plánovaných odstávek.",incorrect:"Z pohledu správy výpočetních systémů virtualizace operačních systémů ve skutečnosti správu komplikuje, protože vyžaduje správu více operačních systémů na jednom fyzickém serveru, čímž se zvyšuje administrativní zátěž. Migrace operačních systémů je sice teoreticky možná, ale v praxi je velmi složitá a nespolehlivá, a živá migrace běžících operačních systémů je zcela nemožná kvůli technickým omezením virtualizace.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"fc02aaef-561b-49c3-9090-96992c96b050",correct:"Jedním z klíčových rysů virtualizace operačního systému je schopnost provozovat více instancí operačního systému na jediném fyzickém počítači. Tato vlastnost umožňuje efektivnější využití hardwarových zdrojů a konsolidaci serverů, což vede ke snížení nákladů na hardware a energie. Každá instance operačního systému běží izolovaně, což zvyšuje bezpečnost a stabilitu celého systému.",incorrect:"Virtualizace operačního systému se primárně zaměřuje na zlepšení výkonu jednoho operačního systému na fyzickém počítači a nikoli na provoz více instancí. Myšlenka provozování více operačních systémů na jednom fyzickém počítači je s virtualizací neslučitelná, jelikož virtualizace je navržena tak, aby optimalizovala běh jediného operačního systému pro maximální efektivitu.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"0eaff0f2-cc96-4dff-b6d1-e80356bd64a2",correct:"Přenositelnost operačního systému na různé hardwarové platformy je usnadněna díky abstrakci, která odděluje většinu kódu operačního systému od specifických detailů hardwaru, což umožňuje modifikovat pouze tu část systému, která interaguje přímo s hardwarem, zatímco zbytek systému zůstává nezměněn.",incorrect:"Přenositelnost operačního systému na různé hardwarové platformy je usnadněna díky absenci abstrakce, která přímo propojuje kód operačního systému se specifickými detaily hardwaru, což umožňuje modifikovat libovolnou část systému a dosáhnout tak snadné přenositelnosti mezi různými platformami.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"},{uuid:"55c276ed-e3ba-43b9-8d79-43d1f55829fb",correct:"Přenositelnost aplikačního softwaru mezi různými operačními systémy je komplikována, pokud aplikace využívá vlastnosti a služby specifické pro daný operační systém, které nejsou skryty pod abstraktním rozhraním, což znamená, že taková aplikace nemusí fungovat správně na jiném operačním systému bez úprav.",incorrect:"Přenositelnost aplikačního softwaru mezi různými operačními systémy je zaručena, i když aplikace využívá vlastnosti a služby specifické pro daný operační systém, protože abstraktní rozhraní operačních systémů zajišťuje, že všechny aplikace budou fungovat identicky na jakémkoli operačním systému bez nutnosti úprav.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"}]},{uuid:"b7e389fb-7aa7-4716-95f8-44b5ba19e690",sectionNumber:"1",sectionTitle:"Virtualizace paměti",statements:[{uuid:"51373408-ac25-4f7c-b894-44d888762a04",correct:"Na fundamentální úrovni, instrukce typu ‹ld reg_addr → reg_out› slouží k načtení hodnoty z paměti, přičemž adresa paměti, z které se čte, je uložena v registru ‹reg_addr› a načtená hodnota se následně uloží do registru ‹reg_out›. Tato operace je základním stavebním kamenem pro interakci programů s pamětí.",incorrect:"Na fundamentální úrovni, instrukce typu ‹ld číslo → reg_out› slouží k zápisu hodnoty do paměti, přičemž adresa paměti, kam se zapisuje, je určena konstantou ‹číslo› přímo v instrukci a hodnota, která se má zapsat, se načte z registru ‹reg_out›. Tato operace je základním stavebním kamenem pro interakci programů s pamětí.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"f18dcd2c-a626-4d4c-b292-5c13d156914b",correct:"Instrukce typu ‹st reg_in → reg_addr› slouží k uložení hodnoty z registru ‹reg_in› do paměti na adresu, která je uložena v registru ‹reg_addr›.  Podle popisu v textu, libovolné složitější instrukce, které procesor poskytuje, mohou být rozloženy do sekvence základních operací jako ‹ld›, ‹st› a výpočetních instrukcí pracujících s registry.",incorrect:"Instrukce typu ‹st reg_in → reg_addr› slouží k uložení hodnoty z registru ‹reg_in› do paměti na adresu, která je uložena v registru ‹reg_addr›.  Nicméně, složité instrukce procesoru jsou nedělitelné atomické operace, které nelze rozložit na jednodušší sekvence instrukcí jako ‹ld›, ‹st› a výpočetní instrukce pracující pouze s registry.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"7ff355e4-5ac0-4918-8785-4f5ba8314d99",correct:"Adresní prostor operační paměti, jak je definován v moderních operačních systémech, se obvykle skládá z několika diskrétních, avšak souvislých bloků adres, kde každý blok reprezentuje ucelený rozsah paměťových lokací. Tyto bloky dohromady vymezují množinu platných adres, ke kterým má procesor povolený přístup pro operace čtení a zápisu dat, a tvoří tak základní rámec pro adresaci paměti.",incorrect:"Adresní prostor operační paměti je charakterizován jako jediný, rozsáhlý a nesouvislý blok adres, kde jednotlivé adresy jsou náhodně rozmístěny a netvoří logické celky. Tato fragmentace adresního prostoru ztěžuje efektivní správu paměti a alokaci souvislých oblastí pro programy, což vede k neefektivnímu využití paměťových zdrojů a potenciálním problémům s výkonem systému.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"de9bcbde-76ac-4b3e-84ec-b27e57dc0730",correct:"V kontextu standardní architektury počítačů se zažitou konvencí stalo, že každá adresa v adresním prostoru operační paměti jednoznačně koresponduje s úložným prostorem o velikosti jednoho bajtu dat. Tato granularita adresace na úrovni jednotlivých bajtů umožňuje operačnímu systému a aplikacím flexibilně a efektivně manipulovat s daty různé velikosti a struktury, od jednotlivých znaků až po komplexní datové objekty, uložené v souvislých paměťových oblastech.",incorrect:"V moderních počítačových systémech se běžně používá adresace, kde jedna adresa v adresním prostoru operační paměti reprezentuje větší datovou jednotku, například čtyřbajtové slovo, a jednotlivé bajty uvnitř tohoto slova nejsou samostatně adresovatelné. Tento přístup zjednodušuje adresaci velkých datových struktur, avšak omezuje flexibilitu při práci s menšími datovými celky a vyžaduje složitější mechanismy pro manipulaci s jednotlivými bajty.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"e360e03e-ab27-4064-b0e6-fcd2bbc76336",correct:"Během svého běhu má program k dispozici adresní prostor, který slouží k ukládání dat a skládá se z několika klíčových částí. Mezi tyto části patří pracovní paměť, určená pro ukládání libovolných dat dle potřeby programu, dále prostor pro kód, kde jsou uloženy instrukce programu, a v neposlední řadě hardwarový zásobník, který se využívá pro správu volání podprogramů a funkcí.",incorrect:"Adresní prostor programu je výhradně vyhrazen pro pracovní paměť, do které si program ukládá veškerá data. Nezahrnuje žádné vyhrazené oblasti pro uložení instrukcí programu, tedy kódu, ani pro hardwarový zásobník, který by sloužil k realizaci podprogramů a správě volání funkcí.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"6a82ebd9-abf3-4dd3-a4cb-138deb83985a",correct:"Zásobník, který je nedílnou součástí adresního prostoru každého programu, slouží v operačním systému k efektivní správě informací o aktuálně aktivních podprogramech. Tento zásobník se může dynamicky měnit, to znamená, že se jeho velikost a rozsah adres v paměti mohou zvětšovat a zmenšovat v průběhu běhu programu v závislosti na volání a návratech z podprogramů.",incorrect:"Zásobník, který je součástí adresního prostoru programu, je primárně určen k ukládání kódu programu a instrukcí, které se mají provést. Jeho velikost je statická a neměnná po celou dobu běhu programu, tudíž se nemůže dynamicky rozšiřovat ani zmenšovat v závislosti na volání podprogramů.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"c2d74d17-4684-4640-86a0-189f13535932",correct:"Fyzické adresy v počítači přímo pojmenovávají fyzické paměťové buňky hardwarových zařízení, zejména paměti RAM, ačkoli fyzický adresní prostor může zahrnovat i adresy periferií, jako jsou grafické a síťové karty, přičemž bloky fyzických adres, které neodpovídají RAM, obvykle nelze využívat pro pracovní data výpočtů.",incorrect:"Fyzické adresy v počítači přímo pojmenovávají fyzické paměťové buňky hardwarových zařízení, zejména paměti RAM, ačkoli fyzický adresní prostor je výhradně určen pro paměť RAM a nezahrnuje adresy periferií, jako jsou grafické a síťové karty, přičemž všechny bloky fyzických adres, včetně těch, které neodpovídají RAM, lze běžně využívat pro pracovní data výpočtů.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"48539d1a-d1f5-482f-9a8c-20133a3fca2d",correct:"Přestože fyzický adresní prostor je jednotný, největší část fyzických adres obvykle patří operační paměti RAM, která slouží primárně k ukládání pracovních dat programů, nicméně některé bloky fyzických adres mohou být vyhrazeny pro periferie nebo pro read-only paměť, kam nelze zapisovat data.",incorrect:"Přestože fyzický adresní prostor je rozdělený, největší část fyzických adres obvykle patří periferiím, které slouží primárně k ukládání pracovních dat programů, nicméně všechny bloky fyzických adres jsou vždy vyhrazeny výhradně pro operační paměť RAM a nikdy pro periferie nebo read-only paměť, což umožňuje zápis dat do všech bloků.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"010f87eb-017b-4798-9f29-7896cf9d14cd",correct:"Podle příkladu rozložení fyzického adresního prostoru klasického 32bitového počítače s procesorem x86, blok adres ‹000a'0000›–‹000b'ffff› je vyhrazen pro periferie, konkrétně pro framebuffer, a blok adres ‹000c'0000›–‹000f'ffff› je vyhrazen pro ROM BIOS, což demonstruje, že fyzické adresy nemusí vždy odkazovat pouze na RAM.",incorrect:"Podle příkladu rozložení fyzického adresního prostoru moderního 64bitového počítače s procesorem ARM, blok adres ‹000a'0000›–‹000b'ffff› je vyhrazen pro RAM, konkrétně pro volné použití, a blok adres ‹000c'0000›–‹000f'ffff› je vyhrazen pro RAM blok 2, což demonstruje, že fyzické adresy vždy odkazují pouze na RAM.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"d784f8cb-7d1c-4f41-8b35-ecd6afa95976",correct:"V principu programy mohou pracovat s fyzickými adresami paměti, ale tento přístup se stává problematickým při současném běhu více programů, protože vyžaduje koordinaci adres a představuje riziko vzájemného narušování a potenciálního škodlivého přístupu mezi programy běžícími na stejném počítači.",incorrect:"Programy mohou bez problémů volně používat fyzické adresy paměti i při současném běhu více aplikací, protože operační systém automaticky řeší koordinaci adres a zabraňuje jakémukoli rušení nebo škodlivému přístupu mezi nimi, a to i bez nutnosti explicitní koordinace ze strany programů.",sectionNumber:"1.2.1",sectionTitle:"Motivace"},{uuid:"5c8f01b4-ab3a-40bb-984e-358f389574e0",correct:"Při současném běhu více programů, které přímo používají fyzické adresy, je nutná koordinace využití paměti mezi programy, aby se předešlo konfliktům, kdy použití konkrétní adresy jedním programem by zabránilo jejímu použití jiným programem, což by vedlo k nepredvídatelnému chování systému.",incorrect:"Při současném běhu více programů, které přímo používají fyzické adresy, není nutná koordinace využití paměti, protože každý program pracuje izolovaně a nemůže zasahovat do paměťového prostoru jiných programů, a operační systém zajišťuje, že nedochází ke konfliktům adres.",sectionNumber:"1.2.1",sectionTitle:"Motivace"},{uuid:"c22f0c92-10f5-4add-b94f-89fa7542c82e",correct:"Chyby v programech, jako například překročení hranic pole, mohou při přímém použití fyzických adres vést k neúmyslnému přepsání nebo poškození dat jiného programu, což vytváří nestabilitu a potenciální bezpečnostní hrozby, protože programy by mohly nechtěně ovlivňovat paměť jiných aplikací.",incorrect:"Chyby v programech, jako například překročení hranic pole, jsou při přímém použití fyzických adres automaticky izolovány v paměťovém prostoru daného programu a nemohou ovlivnit jiné programy ani celkovou stabilitu systému, protože fyzické adresy jsou striktně odděleny pro každý program.",sectionNumber:"1.2.1",sectionTitle:"Motivace"},{uuid:"607b3a50-67ed-4bb7-9a96-d4a7da8a67c6",correct:"Virtuální adresní prostor poskytovaný moderními procesory pro běžné počítače je navržen tak, aby byl programům viditelný a zároveň důsledně oddělen od fyzického adresního prostoru, což znamená, že uživatelské programy nemají přímý přístup k fyzickému adresnímu prostoru a pracují výhradně s adresami v rámci přiděleného virtuálního prostoru.",incorrect:"Virtuální adresní prostor je v moderních procesorech pro běžné počítače pouze konceptuální abstrakcí, která sice programům usnadňuje práci s pamětí, ale ve skutečnosti není fyzicky oddělena od fyzického adresního prostoru, a uživatelské programy tak mají stále přímý přístup k fyzickému adresnímu prostoru, i když se jim adresy transformují.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"dba5f67f-1046-4ab9-8bb1-7be986363bd8",correct:"Existence virtuálních adresních prostorů umožňuje, aby stejná číselná hodnota adresy, například ‹0x0100›, mohla mít naprosto odlišný význam v různých virtuálních adresních prostorech, kde v jednom prostoru může odkazovat na jinou paměťovou lokaci než ve druhém prostoru, nebo dokonce nemusí být v druhém prostoru platnou adresou vůbec.",incorrect:"Existence virtuálních adresních prostorů zaručuje, že stejná číselná hodnota adresy, například ‹0x0100›, bude mít vždy identický význam napříč všemi existujícími virtuálními adresními prostory v systému, protože virtuální adresní prostory jsou pouze logickým rozšířením fyzického adresního prostoru a sdílejí stejnou interpretaci adres.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"3ea8c8ad-0ec4-4781-82fb-7ce956e35ce4",correct:'V kontextu virtuálních adresních prostorů je klíčové si uvědomit, že pojem "virtuální adresa" nezahrnuje pouze číselnou hodnotu adresy, ale také implicitně specifikuje, do kterého konkrétního virtuálního adresního prostoru tato adresa náleží, což znamená, že adresa ‹0x0100› ve virtuálním prostoru P a adresa ‹0x0100› ve virtuálním prostoru Q jsou považovány za dvě zcela odlišné virtuální adresy.',incorrect:'V kontextu virtuálních adresních prostorů se pojem "virtuální adresa" vztahuje výhradně k číselné hodnotě adresy, a nikoliv k příslušnosti k virtuálnímu adresnímu prostoru, což znamená, že adresa ‹0x0100› je vždy interpretována stejně bez ohledu na to, v jakém virtuálním prostoru se nachází, a adresa ‹0x0100› ve virtuálním prostoru P a adresa ‹0x0100› ve virtuálním prostoru Q jsou považovány za identické virtuální adresy.',sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"cbbab33e-41e6-4936-9844-49a7a4bfc2f1",correct:"Aby mohla virtuální adresa plnit svůj účel v operačním systému, musí být nutně propojena s fyzickou paměťovou buňkou, která má přidělenou právě jednu fyzickou adresu, avšak je důležité si uvědomit, že tato fyzická buňka může být mapována z několika různých virtuálních adres v závislosti na potřebách systému a běžících procesů.",incorrect:"Aby mohla virtuální adresa plnit svůj účel v operačním systému, musí být nutně propojena s fyzickou paměťovou buňkou, která má přidělenou právě jednu fyzickou adresu, a je klíčové, že tato fyzická buňka může být mapována výhradně z jedné virtuální adresy, čímž se zajišťuje přímá a jednoznačná korespondence mezi virtuálním a fyzickým adresováním.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"0585b689-7c5e-4b77-9eb6-6edde406e7db",correct:"Mechanismus virtuálních adres v moderních operačních systémech umožňuje, že fyzická paměťová buňka nemusí mít v daný okamžik přiřazenou žádnou virtuální adresu, což se využívá například pro optimalizaci využití paměti a správu volných stránek, a současně dovoluje, aby různé programy běžely izolovaně ve svých vlastních virtuálních adresních prostorech.",incorrect:"Mechanismus virtuálních adres v moderních operačních systémech vyžaduje, aby každá fyzická paměťová buňka měla neustále přiřazenou alespoň jednu virtuální adresu, aby bylo zajištěno její využití, a současně vyžaduje, aby všechny programy běžely sdíleně v jednom globálním virtuálním adresním prostoru pro zjednodušení správy paměti a sdílení dat mezi procesy.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"9128cb5d-6e77-4838-a75e-e716e8e1e42e",correct:"V kontextu správy paměti operačního systému je zásadní rozlišovat mezi virtuálními adresami, které, ačkoliv mohou být reprezentovány identickými číselnými hodnotami, jsou považovány za naprosto odlišné, pokud náleží do různých virtuálních adresních prostorů, což je klíčový koncept pro zajištění izolace procesů a bezpečnosti systému před neoprávněným přístupem.",incorrect:"V kontextu správy paměti operačního systému je nerozhodující rozlišovat mezi virtuálními adresami náležícími do různých virtuálních adresních prostorů, neboť pokud jsou reprezentovány stejnými číselnými hodnotami, jsou považovány za ekvivalentní a zaměnitelné, což umožňuje efektivnější sdílení paměti a zjednodušuje adresování napříč procesy.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"159494cc-f6c8-4525-b401-afb51e23a90f",correct:"Překlad adres z virtuálních na fyzické adresy je kriticky důležitý pro správnou funkci moderních operačních systémů, jelikož procesor pracuje s virtuálními adresami, které se musí před každým přístupem do paměti transformovat na fyzické adresy, aby bylo možné lokalizovat data v reálné paměti.",incorrect:"Překlad adres z virtuálních na fyzické adresy je zanedbatelný proces v moderních operačních systémech, jelikož procesor pracuje přímo s fyzickými adresami, a operační systém se tak nemusí starat o složitou transformaci adres před každým přístupem do paměti, což zjednodušuje správu paměti.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"845cd0c5-a4fa-424f-b180-b347ba6c77ce",correct:"Realizace překladu adres je implementována hardwarově jako součást centrální procesorové jednotky (CPU), konkrétně jednotkou správy paměti (MMU), což umožňuje dosáhnout vysoké rychlosti překladu potřebné pro efektivní běh programů a minimalizaci latence při přístupu do paměti.",incorrect:"Realizace překladu adres je implementována softwarově operačním systémem, což umožňuje maximální flexibilitu a snadnou modifikaci překladových algoritmů, avšak za cenu snížení výkonu a zvýšení latence při každém přístupu do paměti, což může zpomalit běh programů.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"4ce9cefd-db69-4480-9913-fd04b249347c",correct:"Operační systém, konkrétně jeho jádro, hraje klíčovou roli v procesu překladu adres tím, že spravuje překladové tabulky, které definují mapování mezi virtuálními a fyzickými adresami, a tím umožňuje řídit virtuální adresní prostory jednotlivých procesů a zabezpečit izolaci paměti.",incorrect:"Operační systém nehraje žádnou roli v procesu překladu adres, jelikož překlad je plně autonomní hardwarová operace řízená výhradně procesorem, a operační systém tak nemá možnost ovlivnit mapování virtuálních adres na fyzické adresy ani spravovat virtuální adresní prostory procesů.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"1480145d-39cb-4bfa-bfef-66c7fda1a2e1",correct:"Překlad virtuálních adres v moderních operačních systémech využívá stránkování, kde jsou virtuální adresy rozděleny do bloků pevné velikosti, označovaných jako stránky, jejichž velikost je typicky mocninou dvou a je závislá na hardwarové implementaci. Tato metoda nejenže redukuje paměťovou náročnost překladových tabulek, ale také zjednodušuje a zefektivňuje celý proces překladu virtuálních adres na fyzické adresy v paměti.",incorrect:"Překlad virtuálních adres v moderních operačních systémech využívá segmentaci, kde jsou virtuální adresy rozděleny do bloků proměnné velikosti, označovaných jako segmenty, jejichž velikost je libovolná a nezávislá na hardwarové implementaci. Tato metoda naopak zvětšuje paměťovou náročnost překladových tabulek a komplikuje a zneefektivňuje celý proces překladu virtuálních adres na fyzické adresy v paměti.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"e9bdf689-dc7e-4501-a0ca-09185be32f37",correct:"V kontextu stránkování paměti, za předpokladu, že velikost stránky je definována jako 2 na n-tou bajtů a každá stránka začíná na virtuální adrese, která je beze zbytku dělitelná touto velikostí, a je mapována na fyzickou adresu, která splňuje stejnou podmínku dělitelnosti, je možné efektivně využít spodních n bitů virtuální adresy pro přímé určení odpovídajících spodních n bitů fyzické adresy, což představuje optimalizační techniku v procesu překladu adres.",incorrect:"V kontextu stránkování paměti, i když je velikost stránky definována jako 2 na n-tou bajtů a každá stránka začíná na virtuální adrese, která je beze zbytku dělitelná touto velikostí, ale není mapována na fyzickou adresu, která splňuje stejnou podmínku dělitelnosti, je stále možné efektivně využít spodních n bitů virtuální adresy pro přímé určení odpovídajících spodních n bitů fyzické adresy, což představuje optimalizační techniku v procesu překladu adres.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"8e13c0b7-dce2-40f5-92c6-1e5967c2769b",correct:"Stránkovací tabulky, používané v moderních operačních systémech s velkými adresními prostory, jsou obvykle uloženy v operační paměti a implementovány jako víceúrovňové struktury, což umožňuje efektivně spravovat řídké adresní prostory a urychlit překlad virtuálních adres na fyzické adresy díky mechanismům jako TLB.",incorrect:"Stránkovací tabulky, používané v moderních operačních systémech, jsou obvykle uloženy přímo v procesoru a implementovány jako jedinou, rozsáhlou tabulku pro mapování všech virtuálních adres na fyzické, což zajišťuje nejrychlejší možný překlad adres bez dodatečné režie spojené s víceúrovňovým překladem.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"1e111be0-730b-43f0-a654-1477664b4013",correct:"V systému s víceúrovňovými stránkovacími tabulkami je virtuální adresa rozdělena na segmenty, kde každý segment, kromě segmentu pro přímé mapování do fyzické adresy, slouží jako index do tabulky určité úrovně, přičemž hodnota na daném indexu odkazuje na tabulku nižší úrovně, dokud se nedosáhne fyzické adresy.",incorrect:"V systému s víceúrovňovými stránkovacími tabulkami je virtuální adresa rozdělena na segmenty, kde každý segment slouží jako index do samostatné tabulky, a všechny tyto tabulky jsou prohledávány paralelně najednou, aby se urychlil proces překladu virtuální adresy na fyzickou adresu, což minimalizuje latenci překladu.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"79547ff3-d55b-4e41-a82f-c06d01b2f525",correct:"Pro urychlení překladu virtuálních adres operační systémy využívají TLB (Translation Lookaside Buffer), což je asociativní paměť, která uchovává nedávno přeložené virtuální adresy a odpovídající fyzické adresy, a tím snižuje potřebu opakovaného procházení víceúrovňových stránkovacích tabulek v operační paměti.",incorrect:"Pro urychlení překladu virtuálních adres operační systémy využívají vyrovnávací paměť na pevném disku, kam se ukládají často používané stránkovací tabulky, což urychluje přístup k překladovým informacím, zejména pokud jsou stránkovací tabulky příliš velké a nevejdou se do operační paměti.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"eeeea780-f6aa-412d-83f4-673ad9a47134",correct:"Proces, formálně definovaný jako virtuální adresní prostor v operačních systémech, zahrnuje kód programu a pracovní data potřebná pro jeho běh, přičemž operační systém o procesu vede záznam a proces může vlastnit různé zdroje, ale nevyžaduje se, aby proces byl nutně připraven ke spuštění nebo aby instrukce byly vykonávány sekvenčně v jeho rámci.",incorrect:"Proces, formálně definovaný jako virtuální adresní prostor, operační systém považuje za entitu, která musí být neustále připravena k okamžitému spuštění a vyžaduje, aby instrukce v rámci procesu byly vykonávány striktně sekvenčně, ačkoli stále platí, že proces zahrnuje kód programu a pracovní data a operační systém o něm vede záznam.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"faddbd59-12ac-4315-aaaf-d13e443dca6d",correct:"V kontextu operačních systémů, proces, chápaný jako abstrakce paměti podle von Neumannovy architektury, může být asociován s libovolným počtem vláken, včetně nuly, ačkoli proces bez vláken by byl z praktického hlediska méně užitečný, přičemž vlákna zajišťují sekvenční vykonávání instrukcí programu v rámci daného procesu.",incorrect:"Proces v operačních systémech je striktně vázán na právě jedno vlákno, které zajišťuje veškeré vykonávání instrukcí programu sekvenčně, a ačkoli se proces chápe jako abstrakce paměti von Neumannova typu, nemůže existovat proces bez alespoň jednoho vlákna, protože vlákna jsou nezbytná pro jeho funkčnost.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"2fdcd890-16aa-45a4-a2cb-f2b14807f933",correct:"Virtuální adresní prostory procesů jsou z velké části oddělené, což zajišťuje, že procesy standardně nemají přímý přístup k paměti jiných procesů. Nicméně existují výjimky z tohoto pravidla, které umožňují sdílení paměti mezi procesy, například pro sdílení kódu nebo pro implementaci komunikačních mechanismů, ačkoli toto sdílení je pečlivě kontrolováno operačním systémem.",incorrect:"Virtuální adresní prostory procesů jsou zcela oddělené, což znamená, že procesy nikdy nemají přímý přístup k paměti jiných procesů. Neexistují žádné mechanismy, které by umožňovaly sdílení paměti mezi procesy, a operační systém aktivně brání jakémukoli pokusu o takové sdílení, aby byla zajištěna maximální bezpečnost a izolace.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"1960deb5-3eff-4a1c-8829-b8562bc50d97",correct:"Operační systém realizuje oddělení adresních prostorů pomocí samostatných sad stránkových tabulek pro každý proces, což mu umožňuje detailně kontrolovat, které fyzické adresy jsou dostupné pro každý proces. Stránkové tabulky navíc obvykle obsahují mechanismy pro omezení přístupu k paměti na úrovni jednotlivých stránek, včetně možnosti zakázat zápis nebo spouštění instrukcí, a tím efektivně chránit paměť před neoprávněným přístupem.",incorrect:"Operační systém realizuje oddělení adresních prostorů výhradně na hardwarové úrovni bez použití stránkových tabulek, což je rychlejší, ale méně flexibilní.  Stránkové tabulky slouží pouze pro mapování virtuálních adres na fyzické a neobsahují žádné mechanismy pro řízení přístupových práv k paměti, protože veškerá kontrola přístupu je zajištěna fyzickým oddělením paměťových čipů.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"4cf5c802-bb5d-4560-a451-f4c89b4b2373",correct:"Mechanismus sdílené paměti umožňuje dvěma nebo více procesům mapovat stejný blok fyzické paměti do svých virtuálních adresních prostorů, a to i s povolením zápisu, čímž se vytváří prostor pro efektivní komunikaci a sdílení dat mezi procesy. Důležité je, že virtuální adresy tohoto sdíleného bloku paměti se nemusí nutně shodovat v adresních prostorech všech zúčastněných procesů.",incorrect:"Mechanismus sdílené paměti vyžaduje, aby všechny procesy, které sdílejí paměť, měly tuto paměť namapovanou na stejné virtuální adresy ve svých adresních prostorech. Operační systém aktivně zajišťuje, že virtuální adresy sdílené paměti jsou identické napříč všemi procesy, aby se zjednodušila správa paměti a minimalizovaly se potenciální konflikty.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"3d7c5549-eca6-46e6-9bc9-da275df653d7",correct:"Fyzická adresa stránkovací tabulky první úrovně, která je klíčová pro překlad virtuálních adres na fyzické, je uložena ve speciálním registru procesoru. Tato adresa se nastavuje pomocí privilegované instrukce, kterou může provést pouze jádro operačního systému, čímž se zajišťuje ochrana paměti a kontrola nad správou adresního prostoru. Změnou hodnoty tohoto registru se aktivuje nová stránkovací tabulka, což je základní mechanismus pro přepínání mezi procesy a správu jejich paměťových prostorů.",incorrect:"Fyzická adresa stránkovací tabulky první úrovně je uložena v běžné paměti RAM a je přístupná všem procesům. Tato adresa se nastavuje pomocí standardní instrukce, kterou může provést jakýkoliv proces, což umožňuje flexibilní správu paměti. Změnou hodnoty této adresy se aktivuje nová stránkovací tabulka, ale tento mechanismus není spojen s přepínáním procesů, ale slouží pouze pro dynamickou alokaci paměti v rámci jednoho procesu.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"7c6fd06a-bcb7-4bd8-a577-b3d1d6f63560",correct:"Přepnutí procesu v operačním systému se realizuje změnou aktivní stránkovací tabulky. Tato operace spočívá v nastavení registru procesoru, který obsahuje fyzickou adresu stránkovací tabulky první úrovně, na adresu tabulky patřící nově aktivovanému procesu. Díky tomu procesor začne používat pro překlad virtuálních adres novou sadu mapování, čímž se efektivně přepne kontext paměťového prostoru mezi různými procesy.",incorrect:"Přepnutí procesu v operačním systému se realizuje složitým kopírováním obsahu paměti z jednoho procesu do druhého. Tato operace spočívá v manuálním přesunu dat a kódu mezi paměťovými prostory procesů, což zajišťuje izolaci a bezpečnost. Aktivní stránkovací tabulka se při přepínání procesů nemění, protože všechny procesy sdílejí stejný adresní prostor a paměť.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"957d5e47-df3e-4bf4-b6df-50d2377eb8f5",correct:"Přepnutí vlákna je úzce spojeno s přepnutím procesu, avšak zahrnuje navíc výměnu hodnot výpočetních registrů procesoru. Zatímco přepnutí procesu se zaměřuje na změnu adresního prostoru pomocí stránkovacích tabulek, přepnutí vlákna se stará o přepnutí kontextu výpočetní jednotky. To je nezbytné, protože vlákno, a nikoliv proces, je považováno za virtuální výpočetní jednotku v operačním systému.",incorrect:"Přepnutí vlákna je zcela nezávislé na přepnutí procesu a zahrnuje pouze změnu adresního prostoru pomocí stránkovacích tabulek. Výměna hodnot výpočetních registrů procesoru se provádí pouze při přepnutí procesu, nikoliv vlákna. Proces je považován za virtuální výpočetní jednotku, zatímco vlákno slouží pouze pro paralelní provádění úloh v rámci jednoho procesu.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"93ae8169-4bd2-4cd1-b4ad-bcc371322b2c",correct:"Proces vytváření nového procesu operací `fork` v operačních systémech využívá techniku copy-on-write, která efektivně šetří systémové prostředky. Tato metoda spočívá v počátečním sdílení adresního prostoru mezi rodičovským a potomkovským procesem, přičemž fyzická data v paměti se zpočátku nekopírují. Stránky paměti jsou označeny jako „jen pro čtení“, a teprve při pokusu o zápis do sdílené paměti ze strany některého z procesů dojde ke skutečnému vytvoření kopie dat.",incorrect:"Proces vytváření nového procesu operací `fork` v operačních systémech zahrnuje okamžitou a úplnou duplikaci veškerých dat a adresního prostoru rodičovského procesu, čímž se zajistí naprostá izolace nově vzniklého procesu. Tato metoda sice spotřebovává více systémových prostředků na počátku, ale zaručuje, že jakékoli následné operace zápisu v jednom procesu neovlivní data druhého procesu, a to i bez použití techniky copy-on-write.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"9c7f7a8f-5cb2-4259-932e-1bbbdf236a7b",correct:"Mechanismus copy-on-write, implementovaný u operace `fork`, se opírá o iluzi oddělených adresních prostorů pro procesy, ačkoli ve skutečnosti data mohou být sdílena mezi procesy až do momentu, kdy jeden z nich provede zápis. Do té doby oba procesy pracují s identickými daty v paměti, což je umožněno označením stránek jako „jen pro čtení“ a následným zkopírováním pouze při detekci pokusu o zápis, čímž se šetří paměť a čas.",incorrect:"Mechanismus copy-on-write u operace `fork` vytváří skutečně oddělené adresní prostory pro procesy ihned po jejich vytvoření, přičemž data nejsou nikdy sdílena mezi rodičovským a potomkovským procesem. Operační systém provede kompletní kopii dat při volání `fork`, aby zajistil, že procesy budou od začátku pracovat s vlastními, nezávislými kopiemi dat, a předešlo se tak nechtěným interakcím a chybám.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"186e4590-3614-4120-9c5a-d0bfa8e62a5f",correct:"Pokus o přístup k neplatné virtuální adrese v operačním systému vždy vyvolá výjimku, což je mechanismus, který operačnímu systému umožňuje detekovat a reagovat na potenciální chyby a neobvyklé situace, přičemž následné zpracování této výjimky je plně v kompetenci jádra operačního systému.",incorrect:"Pokus o přístup k neplatné virtuální adrese v operačním systému je automaticky ignorován procesorem a nijak neovlivní běh programu ani operační systém, přičemž jádro operačního systému se o této události nijak nedozví a nemůže na ni reagovat.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"5db5a9d0-212c-46ab-a312-368a5b6dcfd5",correct:"Pokud se program pokusí zapsat data na virtuální adresu, která je v tabulce stránek označena jako pouze pro čtení, dojde k vyvolání výjimky ochrany paměti, což způsobí, že řízení nad systémem převezme jádro operačního systému, aby situaci vyřešilo.",incorrect:"Pokud se program pokusí zapsat data na virtuální adresu, která je v tabulce stránek označena jako pouze pro čtení, zápis se neprovede, ale nedojde k žádné výjimce a program pokračuje v běhu, aniž by o problému byl informován operační systém.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"ad7aa5a0-621e-4340-a942-70e2325aa304",correct:"V situaci, kdy virtuální adresa je neplatná, nemusí příslušný řádek v tabulce stránek obsahovat platnou fyzickou adresu, a operační systém má možnost využít toto pole v tabulce stránek pro své vlastní účely, například pro správu paměti nebo sledování stavu stránek.",incorrect:"V situaci, kdy virtuální adresa je neplatná, musí příslušný řádek v tabulce stránek vždy obsahovat platnou fyzickou adresu, která je alespoň implicitně nulová, a operační systém nesmí toto pole v tabulce stránek využívat pro žádné jiné účely než pro mapování platných fyzických adres.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"3b61604d-7946-4702-8338-52e50c69e115",correct:"Operační systém může přesunout data z operační paměti na externí úložiště, jako je pevný disk, pokud operační paměť začíná být nedostatečná a běžící programy vyžadují více paměti, než je fyzicky dostupné, přičemž v stránkové tabulce označí původní adresu stránky jako neplatnou.",incorrect:"Operační systém může přesunout data z operační paměti na externí úložiště, jako je pevný disk, pouze pokud operační paměť je zcela zaplněna a běžící programy vyžadují absolutně nezbytně více paměti, než je fyzicky dostupné, přičemž v stránkové tabulce smaže původní adresu stránky.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"883a0707-9f0e-499a-8fbf-b2d69bb0d7d9",correct:"Mechanismus přesunu stránek z operační paměti na externí úložiště umožňuje operačnímu systému efektivněji spravovat omezené zdroje fyzické paměti, a to i za cenu potenciálního zpomalení v případě častého přístupu k takto odklizeným stránkám, což je akceptovatelné, pokud se to neděje příliš často.",incorrect:"Mechanismus přesunu stránek z operační paměti na externí úložiště umožňuje operačnímu systému výrazně zvýšit výkon systému za všech okolností, a to i v případě častého přístupu k takto odklizeným stránkám, což je vždy akceptovatelné a nikdy nezpůsobuje zpomalení.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"d7bfe85c-b931-47f5-96a0-853edba44989",correct:"V kontextu externího stránkování, jak je popsáno v materiálech, se pojem rámec používá k označení rozsahu fyzických adres v paměti, které mají stejnou velikost a zarovnání jako stránky virtuální paměti, přičemž každý rámec je určen k uložení právě jedné stránky, což umožňuje flexibilní správu paměti a přesouvání stránek mezi rámci.",incorrect:"V kontextu externího stránkování se pojem rámec chybně používá k označení rozsahu virtuálních adres, které se mapují na fyzickou paměť a mají proměnlivou velikost v závislosti na aktuálních potřebách systému, přičemž jeden rámec může obsahovat více stránek a slouží k agregaci virtuálních adres pro efektivnější správu paměti.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"a27490ad-0330-4924-aac7-f3a86a615cde",correct:"Podle poskytnutých materiálů, zavedení pojmu rámec je motivováno potřebou přesnější terminologie v situacích, kdy externí stránkování způsobuje přemísťování stránek ve fyzické paměti, a proto je nutné rozlišovat mezi stránkou jako rozsahem virtuálních adres a rámcem jako rozsahem fyzických adres, do kterého se stránka ukládá.",incorrect:"Podle materiálů, zavedení pojmu rámec je motivováno snahou o zjednodušení terminologie v oblasti správy paměti, kdy rámec a stránka se stávají synonyma označující libovolný blok paměti, a to jak virtuální, tak fyzické, čímž se eliminuje potřeba rozlišovat mezi různými typy adres v paměťovém prostoru.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"b9e8e6bc-8399-44c1-b0f7-3eba60853cea",correct:"Líné načítání spustitelných souborů využívá stránkovací tabulku k zajištění načtení stránek programu z externího úložiště, jako je disk, pouze v okamžiku, kdy jsou skutečně potřeba, čímž se minimalizuje počáteční zpoždění při spouštění programu a šetří operační paměť.",incorrect:"Líné načítání spustitelných souborů vyžaduje, aby byl celý obsah spustitelného souboru načten do operační paměti ještě před samotným spuštěním programu, a teprve poté se stránkovací tabulka použije pro efektivní správu paměti, což zajišťuje rychlý start programu.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"344d3498-ff39-4fa0-a364-1d5312a6655a",correct:"Mechanismus líného načítání je principiálně shodný s externím stránkováním, avšak je jednodušší, protože při něm odpadá nutnost vyhledávání a ukládání obětní stránky na disk, jelikož požadované stránky se načítají přímo ze spustitelného souboru, kde jsou trvale uloženy.",incorrect:"Mechanismus líného načítání se zásadně liší od externího stránkování v tom, že nevyužívá stránkovací tabulku a místo toho spoléhá na segmentaci paměti pro načítání částí spustitelného souboru, přičemž proces hledání obětní stránky a jejího uložení na disk zůstává nezměněn.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"e8658506-b1ff-4006-bd14-b4da15b52365",correct:"V případě kombinace líného načítání s klasickým externím stránkováním, pokud je jako obětní stránka vybrána stránka obsahující kód nebo konstantní data, není nutné tuto stránku zapisovat na disk, protože její aktuální kopie již existuje ve spustitelném souboru, odkud může být v případě potřeby znovu načtena.",incorrect:"Při kombinaci líného načítání s externím stránkováním, i když je jako oběť zvolena stránka s kódem programu, je nezbytné ji před uvolněním paměti uložit na disk, a to i v případech, kdy je tato stránka identická s obsahem ve spustitelném souboru, aby se předešlo ztrátě dat.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"70acaa38-05fd-472c-b993-82e2c9acea94",correct:"Nejdůležitější aplikace externího stránkování v operačních systémech spočívá v mapování datových souborů do paměti na explicitní žádost aplikace, což umožňuje programům přistupovat k datům v souborech, jako by byly přímo uloženy v operační paměti, namísto provádění tradičních vstupně-výstupních operací.",incorrect:"Nejméně důležitá aplikace externího stránkování v operačních systémech spočívá v mapování datových souborů do paměti bez explicitní žádosti aplikace, což neumožňuje programům přistupovat k datům v souborech, jako by byly přímo uloženy v operační paměti, a vyžaduje provádění tradičních vstupně-výstupních operací.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"},{uuid:"9acfd0d4-7446-442c-9283-91fcadf1e3e4",correct:"Při mapování datových souborů do paměti pomocí externího stránkování jsou externí stránky, které reprezentují části souboru, fyzicky uloženy v běžném souboru na disku, což umožňuje efektivní správu paměti a sdílení dat mezi procesy, které mapují stejný soubor.",incorrect:"Při mapování datových souborů do paměti pomocí externího stránkování jsou externí stránky, které reprezentují části souboru, fyzicky uloženy ve vyhrazené swapovací oblasti, nikoli v běžném souboru na disku, což neumožňuje efektivní správu paměti a sdílení dat mezi procesy, které mapují stejný soubor.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"},{uuid:"606a0a12-b110-4d53-b846-a5861f013f0d",correct:"Mechanismus mapování souborů do paměti s využitím externího stránkování umožňuje programům transparentně upravovat obsah souborů tím, že se změněné stránky automaticky zapisují zpět do souboru na disku, čímž se eliminuje potřeba explicitních volání pro zápis dat a zjednodušuje se práce s persistentními daty.",incorrect:"Mechanismus mapování souborů do paměti s využitím externího stránkování vyžaduje, aby programy manuálně volaly systémová volání pro zápis dat zpět do souboru na disku, protože změněné stránky se automaticky nezapisují, což komplikuje práci s persistentními daty a vyžaduje explicitní správu zápisu.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"}]},{uuid:"e5677e54-477b-4271-a72d-865ee0251acb",sectionNumber:"2",sectionTitle:"Virtualizace procesoru",statements:[{uuid:"79503b05-27bd-48eb-a03b-f218a429566d",correct:"Procesory vykonávají instrukce, čímž realizují výpočet, a nejjednodušší třídou instrukcí jsou aritmetické a logické instrukce, které provádí aritmeticko-logická jednotka (ALU) a zahrnují sčítání, odečítání, násobení, dělení, bitové operace jako AND, OR, XOR a bitové posuvy, a také srovnání dvou hodnot pro rovnost nebo nerovnost.",incorrect:"Procesory vykonávají instrukce, čímž realizují výpočet, a nejjednodušší třídou instrukcí jsou instrukce pro správu paměti, které provádí paměťová jednotka (MU) a zahrnují pouze operace sčítání a odečítání, a také bitové operace jako AND, OR a XOR, ale nezahrnují srovnání hodnot.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"c8508a4c-07a3-4451-84d5-0d87a1939646",correct:"Mezi instrukce pro řízení toku programu patří podmíněné skoky a nepřímé skoky, které procesoru umožňují rozhodovat o tom, kterou instrukcí bude výpočet pokračovat na základě aktuálního stavu programu nebo externích událostí, čímž se dosahuje flexibility a dynamiky prováděného kódu.",incorrect:"Mezi instrukce pro řízení toku programu patří pouze přímé skoky a bezpodmínečné skoky, které procesoru umožňují sekvenční provádění instrukcí bez možnosti rozhodování o dalším kroku na základě aktuálního stavu programu, čímž se zajišťuje rigidita a prediktabilita prováděného kódu.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"2263e0e9-b538-4f55-a7be-684377fe6b75",correct:"Instrukce pro realizaci podprogramů, ačkoli nejsou nezbytné pro základní funkčnost procesoru, usnadňují abstrakci a zahrnují operace s hardwarovým zásobníkem pro ukládání a obnovování kontextu, instrukce pro aktivaci podprogramů a instrukce pro návrat z podprogramů, což zjednodušuje strukturované programování.",incorrect:"Instrukce pro realizaci podprogramů jsou nezbytné pro základní funkčnost procesoru a komplikují abstrakci, zahrnují pouze operace s registry pro ukládání a obnovování kontextu, a instrukce pro aktivaci a návrat z podprogramů jsou nahrazeny složitými sekvencemi podmíněných skoků, což komplikuje strukturované programování.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"f86b0af6-e1bb-4f59-b933-8af2a8e7893a",correct:"Registry i paměť slouží v počítači k ukládání čísel, přičemž klíčovým rozdílem je, že registry jsou adresovány přímo v instrukcích a jejich adresy nelze dynamicky vypočítávat jako u paměti, a dále, registry pracují s daty monoliticky na úrovni slov, nikoliv jednotlivých bajtů, což zjednodušuje a zrychluje manipulaci s daty uloženými v registrech oproti paměti, kde je nutné pracovat s jednotlivými bajty nebo skládat slova z bajtů.",incorrect:"Registry a paměť slouží v počítači k ukládání čísel, přičemž klíčovým rozdílem je, že registry jsou adresovány nepřímo pomocí složitých adresních schémat a jejich adresy lze dynamicky vypočítávat jako u paměti, a dále, registry pracují s daty po jednotlivých bajtech, nikoliv monoliticky na úrovni slov, což komplikuje a zpomaluje manipulaci s daty uloženými v registrech oproti paměti, kde je práce se slovy efektivnější.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"a80a0b43-9425-4f3d-9ce0-86f16f564393",correct:"Programový čítač (PC) je speciální registr v procesoru, který uchovává virtuální adresu instrukce, jež má být aktuálně vykonána, a tímto způsobem určuje sekvenci provádění instrukcí programu, přičemž jeho hodnota je typicky modifikována instrukcemi řízení toku programu, jako jsou skoky a volání podprogramů, a běžné aritmetické instrukce nemají přímý vliv na jeho obsah, aby byla zajištěna kontrola nad tokem provádění programu.",incorrect:"Programový čítač (PC) je univerzální registr v procesoru, který uchovává fyzickou adresu dat, jež mají být aktuálně zpracována, a tímto způsobem určuje datový tok programu, přičemž jeho hodnota je libovolně modifikována běžnými aritmetickými instrukcemi, a instrukce řízení toku programu nemají žádný vliv na jeho obsah, protože jeho hlavním účelem je optimalizace datových operací, nikoliv řízení sekvence provádění programu.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"ecc83559-dd11-4fa1-b46a-3706b6afc5a7",correct:"Instrukce strojového kódu je definována jako elementární příkaz, což znamená, že představuje nejmenší a dále nedělitelnou jednotku činnosti, kterou lze procesoru zadat k provedení konkrétní operace, a instrukce jako příkaz procesor přímo řídí a přikazuje mu provedení této akce.",incorrect:"Instrukce strojového kódu je definována jako komplexní makropříkaz, což znamená, že představuje největší a dále dělitelnou jednotku činnosti, kterou lze procesoru zadat k provedení abstraktní operace, a instrukce jako doporučení procesor pouze navrhuje a doporučuje mu provedení této akce.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"5db6f6f7-9388-4eff-a549-f78e35afa1c1",correct:"Ačkoliv mnemonický zápis strojového kódu a jazyk symbolických adres sdílejí podobnou syntaxi a vizuálně se mohou jevit srovnatelné, je důležité si uvědomit, že mnemonický zápis je podmnožinou jazyka symbolických adres a v jazyce symbolických adres nemusí být vždy zapsány přímo instrukce strojového kódu.",incorrect:"Mnemonický zápis strojového kódu a jazyk symbolických adres jsou zcela identické koncepty, které se liší pouze formálním označením, sdílejí naprosto shodnou syntaxi a jazyk symbolických adres je vždy přímým a doslovným zápisem instrukcí strojového kódu bez jakýchkoliv odlišností.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"794fb96e-4741-4d28-bc96-b647939f1533",correct:"Pojem operace v kontextu strojového kódu se nevztahuje k jediné konkrétní instrukci, ale označuje celou skupinu příbuzných instrukcí, které charakterizuje společná funkčnost, například sčítání, a tato operace obvykle specifikuje počet a datový typ operandů, s nimiž instrukce v rámci této skupiny pracují.",incorrect:"Pojem operace v kontextu strojového kódu se vztahuje výhradně k jediné a unikátní instrukci, která je v rámci instrukční sady procesoru definována, a tato operace explicitně určuje pouze specifickou funkčnost dané instrukce, nikoliv však počet nebo datový typ operandů, s nimiž má pracovat.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"ecfa156f-4b11-490d-88f6-747f9e93fe66",correct:"Efekt instrukce v kontextu operačních systémů lze chápat jako elementární změnu stavu systému, která se primárně projevuje na stavu procesoru, ale může také zahrnovat modifikace paměti nebo připojených periferií, v závislosti na specifické instrukci a její zamýšlené funkci v rámci programu.",incorrect:"Efekt instrukce v kontextu operačních systémů je výhradně omezen na změnu stavu procesoru a nikdy nezasahuje do stavu paměti nebo připojených periferií, jelikož instrukce jsou navrženy tak, aby operovaly pouze s interními registry procesoru pro maximalizaci výkonu a minimalizaci vedlejších efektů.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"b8c33f0d-1bce-4361-bcdb-39232fd6ecc1",correct:"Program v operačním systému lze definovat jako posloupnost instrukcí, kde každá instrukce způsobuje elementární změnu stavu systému, a celkový výpočet programu představuje postupnou manipulaci se stavem, která transformuje vstupy, jež jsou počáteční součástí stavu, na požadované výstupy, které se stanou součástí stavu na konci výpočtu.",incorrect:"Program v operačním systému je primárně chápán jako statický popis algoritmů a datových struktur, přičemž jeho provedení nezahrnuje dynamické změny stavu systému, a interakce s vstupy a výstupy je řešena výhradně prostřednictvím externích volání operačního systému, nikoli manipulací se stavem procesoru a paměti.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"48a8c3c6-8a65-41ad-a321-781a3d71b08b",correct:"U interaktivních programů v operačních systémech je smyslem manipulace se stavem systému reagovat na vnější změny stavu, jako je stisk klávesy uživatelem, a vyvolat programem řízené změny stavu, například aktualizaci obsahu obrazovky, čímž se demonstruje, že interaktivita je dosažena skrze reakci na vnější události promítající se do změn stavu.",incorrect:"Interaktivní programy v operačních systémech pracují na principu přímé manipulace s hardwarem a obcházejí koncept stavu systému, přičemž interakce s uživatelem je realizována pomocí specializovaných hardwarových přerušení, která nemají vliv na celkový stav systému, a program tak reaguje na vnější události bez změny interního stavu.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"19a0245f-a243-41ec-a334-91f68f8c9518",correct:"Program se skládá z posloupnosti instrukcí uložených v operační paměti, které procesor interpretuje a provádí v zásadě sekvenčním způsobem, postupujíc od instrukcí umístěných na nižších paměťových adresách k instrukcím na adresách vyšších, přičemž klíčovou výjimkou z tohoto lineárního toku jsou instrukce skoku, které umožňují implementaci řídicích struktur, jako jsou podmíněné příkazy a programové smyčky, a tím i nelineární provádění kódu.",incorrect:"Program se skládá z posloupnosti instrukcí uložených v operační paměti, které procesor interpretuje a provádí výhradně sekvenčním způsobem, postupujíc od instrukcí umístěných na vyšších paměťových adresách k instrukcím na adresách nižších, bez jakýchkoliv výjimek, což znamená, že instrukce skoku nemají žádný vliv na tok programu a program se vždy vykonává lineárně směrem k nižším adresám.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"d090d8b8-92a6-4aba-a40c-f9b5678642cd",correct:"V kontextu běhu programu se převážná část instrukcí zpracovává v souladu s rostoucími virtuálními adresami paměti, jelikož instrukce, které nespadají do kategorie instrukcí skoku, standardně modifikují programový čítač tak, aby ukazoval na paměťové místo bezprostředně následující instrukci v paměti, což implikuje postupné provádění kódu směrem k vyšším adresám.",incorrect:"V kontextu běhu programu se převážná část instrukcí zpracovává v souladu s klesajícími virtuálními adresami paměti, jelikož instrukce, které nespadají do kategorie instrukcí skoku, standardně modifikují programový čítač tak, aby ukazoval na paměťové místo bezprostředně předcházející instrukci v paměti, což implikuje postupné provádění kódu směrem k nižším adresám.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"d221cdfa-50f0-4dcc-8bf4-ef183366db05",correct:"Instrukce skoku hrají zásadní roli při odchylkách od standardního sekvenčního toku provádění programu, neboť umožňují programově přeskočit bloky instrukcí, typicky využívané v implementaci selekčních řídicích struktur jako 'if' příkazy, a současně umožňují návrat k již provedeným instrukcím, což je klíčové pro implementaci iterativních řídicích struktur, jako jsou cykly 'while', a tím i efektivní opakování kódu.",incorrect:"Instrukce skoku nemají žádný vliv na standardní sekvenční tok provádění programu a slouží výhradně k potvrzení lineárního postupu provádění instrukcí od nižších k vyšším adresám, přičemž nemohou být využity k implementaci selekčních ani iterativních řídicích struktur, a tedy program se vždy vykonává striktně sekvenčně bez možnosti odchýlení toku.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"f676c33c-9b6b-43ae-9f9a-ef0031faaada",correct:"Aktivace podprogramu, což je specializovaný typ skoku v rámci programu, vyžaduje uložení části aktuálního stavu procesoru a vyhrazení paměťového prostoru pro lokální proměnné podprogramu, což umožňuje opakované použití podprogramu z různých částí programu a správný návrat řízení po jeho dokončení.",incorrect:"Aktivace podprogramu, což je specializovaný typ skoku v rámci programu, vyžaduje uložení celého aktuálního stavu procesoru a vyhrazení paměťového prostoru pro globální proměnné podprogramu, což umožňuje jednorázové použití podprogramu z jedné části programu a správný návrat řízení po jeho dokončení.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"0226d491-36e0-4aca-bba4-f2ff616868b0",correct:"Mechanismus zásobník, implementovaný hardwarově, hraje klíčovou roli při aktivaci podprogramů, jelikož slouží k uložení návratové adresy a lokálních dat podprogramu v souvislé oblasti virtuálního adresního prostoru, přičemž rozsah zásobníku je dynamicky určen ukazatelem vrcholu zásobníku a pevným dnem zásobníku.",incorrect:"Mechanismus halda, implementovaný softwarově, hraje klíčovou roli při aktivaci podprogramů, jelikož slouží k uložení návratové adresy a lokálních dat podprogramu v nesouvislé oblasti fyzického adresového prostoru, přičemž rozsah haldy je staticky určen programátorem a flexibilním vrcholem haldy.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"374cb028-346a-49fb-863d-d51d5a2c64a5",correct:"Podprogramy, definované jako ucelené bloky instrukcí pro pomocné výpočty, jsou navrženy pro opakované použití v rámci programu nebo pro volání z různých kontextů, čímž umožňují modularizaci kódu a efektivní správu výpočetních úloh, a jejich aktivace je realizována pomocí mechanismu zásobníku pro správu návratů a lokálních dat.",incorrect:"Podprogramy, definované jako ucelené bloky instrukcí pro hlavní výpočty, jsou navrženy pro jednorázové použití na začátku programu a volání z jednoho kontextu, čímž umožňují centralizaci kódu a neefektivní správu výpočetních úloh, a jejich aktivace je realizována pomocí mechanismu fronty pro správu návratů a lokálních dat.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"a3109f9f-ad21-4b2a-8f1f-070d3bc33bbd",correct:"Zásobník typického programu v operačním systému je implementován jako sekvence aktivačních záznamů, přičemž každý záznam odpovídá aktivaci podprogramu, která ještě nebyla dokončena. Díky principu LIFO, kdy poslední volaný podprogram končí jako první, je zásobník ideální datovou strukturou pro správu volání a návratů podprogramů, včetně rekurzivních volání, a zajišťuje tak řádné provádění programového kódu.",incorrect:"Zásobník typického programu v operačním systému je implementován jako fronta aktivačních záznamů, přičemž každý záznam odpovídá aktivaci podprogramu, která ještě nebyla dokončena. Díky principu FIFO, kdy první volaný podprogram končí jako první, je fronta ideální datovou strukturou pro správu volání a návratů podprogramů, včetně rekurzivních volání, a zajišťuje tak řádné provádění programového kódu.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"4753e6e6-237f-4eab-a47a-726d07fed449",correct:"Orientace zásobníku v paměti, tedy zda roste směrem k vyšším nebo nižším adresám, není univerzálně stanovena a závisí na konkrétní architektuře procesoru. Některé procesory, jako například architektura x86, implementují zásobníky, které rostou směrem k nižším paměťovým adresám, což znamená, že nově volané podprogramy a jejich aktivační záznamy jsou umisťovány na adresy s číselně menší hodnotou.",incorrect:"Orientace zásobníku v paměti je univerzálně stanovena tak, že vždy roste směrem k vyšším adresám, nezávisle na architektuře procesoru. Všechny procesory, včetně architektury x86, implementují zásobníky, které rostou směrem k vyšším paměťovým adresám, což znamená, že nově volané podprogramy a jejich aktivační záznamy jsou umisťovány na adresy s číselně větší hodnotou.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"9d5caefc-7d65-4682-92c0-37ec56677229",correct:"Aktivační záznam na zásobníku typicky obsahuje nejen lokální proměnné podprogramu, ale i uložené registry procesoru, návratovou adresu pro pokračování v volajícím podprogramu a ukazatel rámce, který slouží k obnovení stavu zásobníku po návratu z podprogramu, zejména v případech, kdy velikost rámce není staticky známa kvůli například alokaci proměnné délky.",incorrect:"Aktivační záznam na zásobníku typicky obsahuje pouze lokální proměnné podprogramu a neobsahuje uložené registry procesoru, návratovou adresu ani ukazatel rámce, protože tyto informace jsou spravovány výhradně operačním systémem mimo zásobník, a ukazatel rámce je irelevantní i v případech alokace proměnné délky, jelikož velikost rámce je vždy staticky známa.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"63c83969-013f-4bfc-8790-3a4c381eddd0",correct:"Výpočet v kontextu operačních systémů je definován jako posloupnost stavů, respektive jako série postupných změn stavu systému. Každý následující stav je transformací předchozího stavu na základě prováděného programu a vstupních dat. Toto pojetí umožňuje detailní sledování a řízení běhu programů a procesů v operačním systému.",incorrect:"Výpočet v kontextu operačních systémů je definován jako neměnný stav systému, který zůstává konstantní po celou dobu běhu programu. Stav systému se nemění v závislosti na prováděném programu ani vstupních datech, což zjednodušuje sledování, avšak neodpovídá realitě dynamicky se měnících systémů a procesů.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"944bfb05-1963-4008-be89-f6b1a7c6ff41",correct:"Stav procesoru v operačních systémech zahrnuje klíčové komponenty, mezi které patří hodnoty uložené v aritmetických registrech pro provádění výpočtů, hodnota programového čítače, která určuje aktuálně prováděnou instrukci, a hodnota ukazatele zásobníku, který je nezbytný pro správu volání funkcí a alokaci lokálních proměnných během běhu programu.",incorrect:"Stav procesoru v operačních systémech zahrnuje pouze hodnoty uložené v aritmetických registrech a stav externích periferií. Programový čítač a ukazatel zásobníku nejsou považovány za součást stavu procesoru, protože jejich hodnoty se dynamicky mění a nemají přímý vliv na základní operace procesoru a výpočetní procesy.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"ad913026-a870-44c5-a90d-e7993fcad41b",correct:"Za specifických podmínek, kdy program neobsahuje instrukce pro přímý přístup do paměti a virtuální adresní prostor je exkluzivně vyhrazen pro aktivní program, je výpočet považován za deterministický. To znamená, že výpočet je plně určen počátečním stavem procesoru a samotným programem, a opakované spuštění s identickým počátečním stavem povede k naprosto stejným výsledkům.",incorrect:"I za podmínek, kdy program neobsahuje instrukce pro přímý přístup do paměti a virtuální adresní prostor je exkluzivně vyhrazen pro aktivní program, výpočet nemusí být deterministický. Faktory jako vnější hardwarové události, časování instrukcí nebo drobné odchylky v napájení procesoru mohou způsobit, že opakované spuštění s identickým počátečním stavem povede k odlišným výsledkům.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"f602e865-80d9-4467-8b10-39833fbe6efa",correct:"V prostředí s neizolovaným adresním prostorem, kde do paměti programu mohou zasahovat externí entity jako jiné programy nebo operační systém, se opakované čtení z určité paměťové lokace nemusí nutně vrátit stejný výsledek. Tato situace nastává, protože externí zásahy mohou hodnotu v paměti mezi čteními změnit, což vede k potenciálně rozdílným výsledkům i při čtení z téže adresy v krátkém časovém intervalu.",incorrect:"V prostředí s neizolovaným adresním prostorem, kde do paměti programu mohou zasahovat externí entity jako jiné programy nebo operační systém, se opakované čtení z určité paměťové lokace vždy vrátí stejný výsledek.  Izolace adresního prostoru zajišťuje, že externí zásahy nemohou ovlivnit hodnoty v paměti programu, a proto opakované čtení z téže adresy bude konzistentní a nezávislé na vnějších událostech.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"ad38b1cf-9d12-4247-a4ad-c6fa967fa88e",correct:"Synchronizace v kontextu operačních systémů nastává, když průběh výpočtu programu je ovlivněn externí událostí, jako je například zápis hodnoty do paměti jiným programem nebo operačním systémem. Tato interakce mění chování programu oproti izolovanému prostředí, kde by program běžel deterministicky, a vyžaduje mechanismy pro koordinaci a řízení přístupu ke sdíleným zdrojům, aby se předešlo nekonzistencím.",incorrect:"Synchronizace v kontextu operačních systémů je mechanismus, který zajišťuje, že průběh výpočtu programu není nikdy ovlivněn externími událostmi, jako je zápis hodnoty do paměti jiným programem nebo operačním systémem.  Cílem synchronizace je udržet program v izolovaném prostředí a zabránit jakékoli interakci s externími entitami, čímž se zaručí deterministické chování a předejde se nekonzistencím způsobeným vnějšími zásahy.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"29c48690-cda5-4e91-a15f-98654a6cbf71",correct:"Uvažujme program s nekonečnou smyčkou, který v izolovaném prostředí nikdy neskončí. Nicméně, v neizolovaném prostředí, externí entita, jako operační systém, může zapsat hodnotu 0 na paměťovou adresu, kterou program opakovaně čte v podmínce smyčky. Tento externí zásah změní stav programu a způsobí, že smyčka se ukončí, demonstrujíc princip synchronizace skrze externí událost.",incorrect:"Uvažujme program s nekonečnou smyčkou, který v neizolovaném prostředí může být ukončen pouze vnitřní logikou programu, nikoli externím zásahem.  I když externí entita, jako operační systém, může zapsat hodnotu 0 na paměťovou adresu, kterou program opakovaně čte, program v neizolovaném prostředí bude ignorovat tyto externí zásahy a pokračovat v nekonečné smyčce, dokud nedosáhne interního stavu ukončení.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"eebf848a-5b5f-4df7-90f3-ddc9785f3f67",correct:"Vlákno je definováno jako výpočet, což je posloupnost změn stavu procesoru, který nepřetržitě vykonává instrukce řízené jedním programem, přičemž tento výpočet není zcela izolovaný, protože může být ovlivněn synchronizací a vnějšími událostmi pozorovatelnými skrze sdílený adresní prostor, a stav procesoru, definovaný programově pozorovatelnými registry a ukazateli, je určen výhradně prováděným programem.",incorrect:"Vlákno je definováno jako izolovaný výpočet, což je posloupnost změn stavu procesoru, který nepřetržitě vykonává instrukce řízené jedním programem, přičemž tento výpočet je zcela jednoznačný a izolovaný od vnějších událostí a synchronizace, a stav procesoru, definovaný programově pozorovatelnými registry a ukazateli, může být ovlivněn i vnějšími faktory mimo řízení prováděného programu.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"a3e3dfca-2aa9-43cb-8d2c-9ba0248a5615",correct:"Synchronizace mezi vlákny je v operačních systémech umožněna, a to pasivně prostřednictvím čtení paměti, kdy vlákno sleduje změny v paměti, a aktivně zápisem do paměti, čímž vlákno může iniciovat synchronizační události, za předpokladu, že zapsaná data budou čtena jiným vláknem nebo periferií, a ačkoliv zásobník technicky není chráněn před přístupem jiných vláken v rámci stejného procesu, obecně se předpokládá, že je pro externí entity nepřístupný a považuje se za součást stavu vlákna.",incorrect:"Synchronizace mezi vlákny v operačních systémech je omezena pouze na aktivní operace, jako je zápis do paměti, kdy vlákno iniciuje synchronizační události, zatímco pasivní sledování změn v paměti čtením není považováno za formu synchronizace, a zásobník je striktně chráněn před přístupem jiných vláken v rámci stejného procesu, a proto nemůže být považován za součást sdíleného stavu vláken, ale za privátní oblast paměti každého vlákna.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"50ed9b4f-c9e9-49f7-8adf-b071c85f4ca5",correct:"Podle definice logického procesoru, stav logického procesoru je plně určen aktuálními hodnotami registrů procesoru a tento stav se mění výhradně prováděním instrukcí, což umožňuje operačnímu systému uložit a obnovit stav logického procesoru pro účely virtualizace procesoru.",incorrect:"Podle definice logického procesoru, stav logického procesoru zahrnuje kromě hodnot registrů také stav paměti a I/O zařízení a tento stav se mění nejen prováděním instrukcí, ale i vnějšími událostmi, což operačnímu systému usnadňuje uložení a obnovení stavu logického procesoru pro účely virtualizace procesoru.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"6c7ea696-d55b-47fc-aecf-647bfa11e1a1",correct:"Koncept logického procesoru, jak je popsán v textu, slouží jako abstrakce pro definici vlákna a umožňuje realizaci virtualizace procesoru na fyzickém procesoru díky schopnosti operačního systému ukládat a obnovovat stav logického procesoru, což je klíčové pro efektivní sdílení fyzického procesoru mezi více vlákny.",incorrect:"Koncept logického procesoru, jak je popsán v textu, slouží jako přímá reprezentace fyzického procesoru a neumožňuje realizaci virtualizace procesoru na fyzickém procesoru, protože operační systém nemá schopnost efektivně ukládat a obnovovat stav fyzického procesoru, což omezuje možnosti sdílení fyzického procesoru.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"6f4714fd-8ec1-459b-bea7-9b142b6c5da0",correct:"Pro dosažení virtualizace procesoru, operační systém musí být schopen provádět operace uložení a obnovení stavu logického procesoru bez přímé součinnosti běžícího vlákna, což je umožněno vnějšími událostmi, jako jsou přerušení, které operačnímu systému umožňují převzít kontrolu nad fyzickým procesorem a efektivně spravovat logické procesory.",incorrect:"Pro dosažení virtualizace procesoru, operační systém musí být schopen provádět operace uložení a obnovení stavu logického procesoru pouze s přímou součinností běžícího vlákna, což je realizováno synchronizačními mechanismy na úrovni vláken a nevyžaduje vnější události jako přerušení pro převzetí kontroly nad fyzickým procesorem.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"e954f8b0-37e2-4ff4-816f-d2bea40fda61",correct:"Ukládání a obnova stavu logického procesoru jsou klíčové pro přepínání kontextu vláken, což umožňuje, aby na jednom fyzickém procesoru běželo střídavě více vláken, přičemž každé vlákno má iluzi vlastního, vyhrazeného procesoru pro svůj běh.",incorrect:"Přepínání kontextu vláken je plně softwarová záležitost a nevyžaduje ukládání a obnovu stavu logického procesoru, protože každé vlákno pracuje ve svém vlastním izolovaném paměťovém prostoru, čímž se eliminuje potřeba hardwarového zásahu.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"4ee782d2-e201-434b-8234-c56ca98e9e93",correct:"Ačkoli se ukládání a obnova aritmetických registrů pro přepínání kontextu vláken zdá teoreticky jednoduché, v praxi se stává složitým, protože aritmetické registry jsou nezbytné pro výpočty, což znemožňuje uložit nebo obnovit všechny registry bez asistence procesoru.",incorrect:"Ukládání a obnova aritmetických registrů během přepínání kontextu vláken je přímočarý proces, snadno zvládnutelný softwarem bez významného zapojení procesoru, protože tyto registry jsou nezávislé na čítači instrukcí a ukazateli zásobníku.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"5df7171a-36d0-40a4-9957-0c701ac71601",correct:"Programový čítač představuje největší problém při přepínání kontextu vláken, protože nemůže být přímo uložen ani obnoven pouze softwarem, což vyžaduje speciální podporu procesoru, aby se zajistilo, že se neztratí kontrola během procesu, zvláště když aritmetické registry nejsou v kritickém kroku obnovy k dispozici.",incorrect:"Programový čítač je snadno spravován během přepínání kontextu vláken a nepředstavuje významný problém, protože jeho hodnota může být uložena a obnovena pomocí standardních softwarových instrukcí, podobně jako se zachází s aritmetickými registry, bez potřeby speciálních funkcí procesoru.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"e71f550f-beed-43da-851a-833b22ddfc3f",correct:"Vzhledem ke složitosti ukládání a obnovy stavu procesoru, zejména programového čítače, nemůže být přepínání kontextu vláken plně implementováno bez specializované hardwarové podpory procesoru a spoléhá se na mechanismy, jako je zpracování přerušení, které usnadňují ukládání a obnovu stavu.",incorrect:"Přepínání kontextu vláken může být efektivně implementováno výhradně v softwaru, bez nutnosti jakékoli specifické hardwarové podpory ze strany procesoru, protože software dokáže spravovat ukládání a obnovu všech potřebných registrů, včetně programového čítače, pomocí standardních programovacích technik.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"09b55891-a868-44bd-9f02-b763284e5ce9",correct:"Mechanismus zpracování přerušení přirozeně poskytuje nezbytnou hardwarovou podporu pro přepínání kontextu vláken, protože zpracování přerušení již vyžaduje uložení alespoň části stavu procesoru a jeho obnovení po návratu, což činí tuto funkcionalitu znovu použitelnou pro přepínání kontextu vláken.",incorrect:"Mechanismus zpracování přerušení a přepínání kontextu vláken jsou zcela oddělené a nesouvisející funkce operačního systému, přičemž zpracování přerušení se zaměřuje výhradně na reakci na externí události a nijak nepřispívá k požadavkům na přepínání kontextu vláken ani se s nimi nepřekrývá.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"03c47661-66b6-452b-9cc5-343981871aad",correct:"Plánovač vláken, klíčová součást jádra operačního systému zodpovědná za přidělování procesorového času vláknům, je aktivován na každém fyzickém procesoru v systému pravidelnými intervaly prostřednictvím programovatelného časovače, který generuje přerušení, umožňující plánovači rozhodnout o přerušení běžícího vlákna a výběru dalšího vlákna k spuštění.",incorrect:"Plánovač vláken, klíčová součást jádra operačního systému zodpovědná za přidělování procesorového času vláknům, je aktivován na každém fyzickém procesoru v systému pouze na vyžádání běžících vláken, což mu umožňuje rozhodnout o přerušení běžícího vlákna a výběru dalšího vlákna k spuštění, avšak pouze za součinnosti aktuálně běžícího vlákna.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"66681e4d-cb9b-49c1-8e6b-b0379ae85d7a",correct:"Základní funkcí plánovače vláken je rozhodování o tom, zda má aktuálně aktivní vlákno na daném procesoru pokračovat ve svém výpočtu, nebo má být přerušeno a nahrazeno jiným vláknem, přičemž toto rozhodnutí je prováděno nezávisle na součinnosti běžícího vlákna díky mechanismu preempce, který je založen na pravidelných přerušeních generovaných časovačem.",incorrect:"Základní funkcí plánovače vláken je rozhodování o tom, zda má aktuálně aktivní vlákno na daném procesoru pokračovat ve svém výpočtu, nebo má být přerušeno a nahrazeno jiným vláknem, přičemž toto rozhodnutí je prováděno výhradně na základě požadavků běžícího vlákna, jelikož plánovač nemůže vlákno přerušit bez jeho aktivní součinnosti, což je charakteristické pro kooperativní plánování.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"d8d4d62a-c4cb-49a7-bb30-f217aa1ea5f0",correct:"Přestože se historicky používal termín plánovač procesů, moderní operační systémy používají plánovač vláken pro řízení běhu vláken na procesorech, přičemž plánovač je aktivován periodickým časovačem, který vyvolává přerušení a umožňuje tak plánovači preemptivně odebírat procesor běžícím vláknům a přidělovat ho jiným vláknům podle předem definovaných algoritmů.",incorrect:"Přestože se historicky používal termín plánovač vláken, moderní operační systémy používají plánovač procesů pro řízení běhu procesů na procesorech, přičemž plánovač je aktivován pouze při vzniku nového procesu, což mu umožňuje alokovat procesor novému procesu, ale nemůže preemptivně odebírat procesor běžícím procesům, jelikož vyžaduje kooperaci běžícího procesu k uvolnění procesoru.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"c957db25-7247-442a-b3e1-d4a4c8234ac2",correct:"Plánovací algoritmy operačního systému se snaží maximalizovat propustnost systému, což se projevuje snahou o maximální využití všech procesorů a minimalizaci času stráveného rozhodováním o plánování, aby se co nejvíce času věnovalo produktivní práci a minimalizovalo se zbytečné přepínání kontextu mezi procesy.",incorrect:"Plánovací algoritmy operačního systému se zaměřují na minimalizaci propustnosti systému, což je dosaženo častým přepínáním kontextu mezi vlákny a záměrným zdržováním rozhodování o plánování, aby se minimalizovalo využití procesorů a maximalizoval čas strávený neproduktivními operacemi, jako je například správa plánovače.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"5696a374-d0c1-4937-b575-5f87cf8d0dc2",correct:"Minimalizace latence, neboli reakční doby systému, je klíčovým požadavkem na plánovací algoritmy, zejména u interaktivních programů a síťových služeb, kde uživatelé očekávají rychlou odezvu a nechtějí zbytečně dlouho čekat na výsledek, což vyžaduje, aby vlákna nečekala na procesor příliš dlouho.",incorrect:"Maximalizace latence, neboli reakční doby systému, je preferovaným cílem plánovacích algoritmů, zvláště u interaktivních programů a síťových služeb, jelikož dlouhé čekání uživatelů na odezvu systému podporuje efektivnější využití procesoru a celkovou propustnost systému.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"f7da1996-8b21-4bcc-8e9c-3eba27dee78e",correct:"Férovost v kontextu plánování operačního systému znamená, že všechna vlákna by měla v průměru obdržet spravedlivý podíl procesorového času, ideálně úměrný jejich prioritě, což je důležité jak pro výpočetní programy, tak pro interaktivní aplikace, aby se zajistilo včasné dokončení a rychlá reakce a zabránilo se strádání některých procesů.",incorrect:"Férovost v kontextu plánování operačního systému znamená, že některá vybraná vlákna by měla obdržet dominantní podíl procesorového času, zatímco ostatní vlákna by měla být omezena na minimum, což je klíčové pro maximalizaci propustnosti systému, i když to vede k značnému znevýhodnění některých aplikací a potenciálnímu strádání procesů.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"f8d5ba83-4096-420e-a5cf-a4e26f47c8a2",correct:'Vlákno, které je v stavu "čeká na procesor", se nachází ve stavu připravenosti a čeká na přidělení procesoru plánovačem, aby mohlo pokračovat ve výpočtu, přičemž plánovač operačního systému rozhoduje o přechodu tohoto vlákna do stavu "běží", což mu umožní aktivně využívat procesorový čas.',incorrect:'Vlákno, které je v stavu "čeká na procesor", se nachází ve stavu spánku a čeká na přidělení procesoru samotným vláknem, aby mohlo pokračovat ve výpočtu, přičemž samo vlákno operačního systému rozhoduje o přechodu tohoto vlákna do stavu "běží", což mu umožní aktivně využívat procesorový čas.',sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"fd3aa6aa-8b57-436d-9720-568f40c1ece7",correct:'Pokud vlákno přechází ze stavu "běží" do stavu "čeká na událost", je tento přechod iniciován samotným vláknem, které signalizuje operačnímu systému, že potřebuje čekat na určitou externí událost, jako je dokončení I/O operace nebo uvolnění zámku, než bude moci pokračovat ve své činnosti.',incorrect:'Pokud vlákno přechází ze stavu "běží" do stavu "čeká na událost", je tento přechod iniciován plánovačem operačního systému, který na základě algoritmů plánování a priority vláken rozhodne, že vlákno má čekat na určitou externí událost, než bude moci pokračovat ve své činnosti.',sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"91ea7210-2ffc-40a1-bbee-f4a5098340c6",correct:'Podle definovaných stavů vlákna v operačním systému není možný přímý přechod ze stavu "čeká na procesor" do stavu "čeká na událost", protože přechod do stavu čekání na událost vyžaduje aktivní akci ze strany samotného vlákna, které musí explicitně signalizovat potřebu čekání na událost.',incorrect:'Podle definovaných stavů vlákna v operačním systému je možný přímý přechod ze stavu "čeká na procesor" do stavu "čeká na událost", protože plánovač operačního systému může automaticky přesunout vlákno do stavu čekání na událost, pokud usoudí, že vlákno nemůže momentálně efektivně využívat procesor.',sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"d693e1c8-caf5-45fe-98fd-44bb3aaca4eb",correct:"Základním pracovním nástrojem plánovače operačního systému jsou běhové fronty úloh, do nichž se řadí vlákna čekající na procesor, přičemž konkrétní implementace front, zahrnující typ fronty a její organizaci, má zásadní vliv na chování plánovače a určuje výběr vlákna pro spuštění a přiřazení k fyzickému procesoru.",incorrect:"Základním pracovním nástrojem plánovače operačního systému jsou sice běhové fronty úloh, avšak jejich implementace nemá zásadní vliv na chování plánovače, protože plánovač se primárně řídí typem procesoru a aktuálním zatížením systému, nikoliv detaily implementace front úloh, které jsou pro celkový výkon systému marginální.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"a3b6678a-bdab-4d7f-8b92-b22d693cb975",correct:"Plánovací algoritmy operačních systémů se liší především v chování běhových front úloh, které mohou být globální, sdílené mezi všemi procesory, nebo lokální, kdy každý procesor disponuje vlastní frontou, a dále se mohou lišit v pořadí vláken, které může být FIFO, tedy první příchozí první obsloužen, nebo prioritní, umožňující vláknům předbíhat na základě definovaných kritérií.",incorrect:"Plánovací algoritmy operačních systémů se primárně neliší v chování běhových front úloh, jelikož ty jsou standardizované a vždy globální s FIFO pořadím, a rozdíly v plánování spočívají zejména v hardwarové konfiguraci systému a specifických instrukcích procesoru, které ovlivňují rychlost zpracování úloh, nikoliv v softwarové implementaci front.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"9704c906-0dfa-470d-baa4-f611f6217ef2",correct:"Prioritní běhové fronty úloh, používané v plánovačích operačních systémů, se implementačně dělí na monolitické, typicky realizované pomocí binární haldy nebo červeno-černého stromu, a složené, kde každá prioritní třída disponuje vlastní FIFO frontou, což ovlivňuje efektivitu a komplexnost plánování.",incorrect:"Prioritní běhové fronty úloh se v operačních systémech implementují výhradně jako složené fronty, kde každá priorita má vlastní zásobník LIFO, a monolitické implementace s binární haldou nebo červeno-černým stromem se v moderních systémech nepoužívají z důvodu jejich neefektivity a vysoké režie spojené s komplexní správou priorit.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"3e275e2b-1598-4518-b341-58fa5c04fbaa",correct:"Migrace vláken mezi fyzickými procesory v operačním systému představuje nákladnou operaci, především kvůli nutnosti invalidace a přesunu obsahu mezipamětí, které nejsou sdílené mezi procesory. Z tohoto důvodu moderní operační systémy implementují mechanismy afinity vláken, které se snaží minimalizovat zbytečné migrace a opakovaně plánovat vlákna na stejný procesor, čímž se snižuje režie spojená s přesuny a zlepšuje se celkový výkon systému.",incorrect:"Migrace vláken mezi fyzickými procesory v operačním systému je operace s minimálními náklady, protože moderní procesory sdílejí mezipaměti a invalidace dat je rychlá. Proto operační systémy obvykle neimplementují mechanismy afinity vláken, protože migrace vláken je efektivní a opakované plánování vláken na stejný procesor nepřináší žádné významné zlepšení výkonu systému.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"916713fc-172b-483f-a6f7-0d668d0c9149",correct:'Strategie kradení práce, používaná v plánovačích operačních systémů s lokálními frontami, představuje kompromisní řešení pro efektivní využití zdrojů a zároveň minimalizaci migrací vláken. Procesor, který se stane nečinným, aktivně vyhledává a "kradne" vlákna z jiných, zatíženějších front, čímž se zlepšuje celkové využití procesorů a zároveň se, díky lokálním frontám a preferenci nemigrace vláken, do jisté míry zachovává afinita vláken k procesorům.',incorrect:'Strategie kradení práce v plánovačích operačních systémů s lokálními frontami je primárně zaměřena na maximální využití všech procesorů bez ohledu na afinitu vláken.  Procesor, který je nečinný, agresivně "kradne" vlákna z jiných front, i když to vede k častým migracím, protože hlavním cílem je rovnoměrné rozložení zátěže a maximální propustnost systému, přičemž afinita vláken je považována za druhořadý aspekt.',sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"e50fefe3-b8e4-42f9-8bbf-178a5e34c4a6",correct:"Plánovače operačních systémů s globální frontou, do které jsou zařazována všechna vlákna čekající na spuštění, typicky neposkytují žádnou afinitu vláken k procesorům. V takovém systému je vláknu přidělen první volný procesor bez ohledu na to, na kterém procesoru běželo dříve, což vede k častým migracím a potenciálně nižšímu výkonu v porovnání s plánovači využívajícími lokální fronty a afinitu.",incorrect:"Plánovače operačních systémů s globální frontou, do které jsou zařazována všechna vlákna čekající na spuštění, inherentně zaručují silnou afinitu vláken k procesorům.  Globální fronta zajišťuje, že vlákna jsou vždy plánována na nejvhodnější procesor, což minimalizuje migrace a maximalizuje využití mezipamětí, čímž se dosahuje optimálního výkonu systému a efektivního využití výpočetních zdrojů.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"4059f9df-ee0b-48d4-ae77-9fd10f6e7cf3",correct:"Interaktivní plánovače běžně využívají prioritní plánování, kde každé vlákno má přidělenu prioritu, která staticky nebo dynamicky ovlivňuje jeho šanci na získání procesoru. V rámci každé prioritní třídy jsou vlákna uspořádána do fronty FIFO, a plánovač vybírá vlákno z nejvyšší neprázdné prioritní fronty.",incorrect:"Interaktivní plánovače se obvykle vyhýbají prioritnímu plánování kvůli jeho složitosti a nepředvídatelnosti. Místo toho preferují rovnoměrné rozdělení procesorového času mezi všechna vlákna bez ohledu na jejich priority, a vlákna v rámci prioritních tříd jsou řazena do fronty LIFO, což zajišťuje, že nově příchozí vlákna mají přednost.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"c440b522-27f4-466a-a003-4b32ad5cf373",correct:"Dynamická úprava priority u interaktivních plánovačů slouží k řešení problému, kdy dlouho běžící výpočetní vlákno s vysokou prioritou může zablokovat procesor pro ostatní vlákna. Tato úprava spočívá ve snižování priority vlákna za každou přidělenou jednotku výpočetního času, což umožňuje i vláknům s nižší prioritou se nakonec dostat ke spuštění.",incorrect:"Dynamická úprava priority u interaktivních plánovačů je primárně zaměřena na zvýhodňování dlouho běžících výpočetních vláken, aby se maximalizovala propustnost systému. Priorita vláken se s každou přidělenou jednotkou výpočetního času zvyšuje, čímž se zajišťuje, že dlouhodobě aktivní procesy mají neustále přednost před krátkodobými úkoly.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"3c904add-6fa9-47f8-8259-22cb0e971d0a",correct:"Zatímco se v tomto kurzu zaměřujeme na interaktivní plánovače, existují i jiné typy plánovačů, jako například dávkové plánovače, které jsou optimalizovány pro maximální propustnost a efektivitu při zpracování velkého množství úloh bez interakce s uživatelem, a plánovače reálného času, které kladou důraz na dodržení striktních časových limitů pro provádění úloh.",incorrect:"V kontextu operačních systémů se rozlišují pouze dva základní typy plánovačů: interaktivní plánovače, které se starají o rychlou odezvu pro uživatelské aplikace, a plánovače reálného času, které se používají v systémech bez interakce s uživatelem, jako jsou servery a datová centra. Dávkové plánovače a jiné specializované typy plánovačů se v moderních operačních systémech již nepoužívají.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"ca82828b-5600-4ba4-973a-42ce9b7388a0",correct:"Férový plánovač se snaží zajistit rovnoměrné rozdělení výpočetního času mezi všechna vlákna, případně zohledňuje priority vláken, a v tomto ohledu se podobá systémům s dynamickou úpravou priorit, avšak na rozdíl od pevných prioritních tříd pracuje s prioritami v libovolném rozsahu, což umožňuje jemnější a flexibilnější řízení přidělování času.",incorrect:"Férový plánovač se snaží maximalizovat celkový výpočetní výkon systému bez ohledu na rovnoměrné rozdělení času mezi vlákna a nepodobá se systémům s dynamickou úpravou priorit, protože pracuje s pevnými prioritními třídami, což zjednodušuje správu priorit a zajišťuje předvídatelnější chování systému.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"d3b0af77-4319-4f6a-a8d6-b151f2cbeb87",correct:"Priorita vláken v férovém plánovači je dynamicky upravována a je inverzně úměrná dosud využitému výpočetnímu času, což znamená, že vlákna, která již spotřebovala více času, mají nižší prioritu, a naopak vlákna s menším využitým časem mají prioritu vyšší, což podporuje spravedlivé rozdělení zdrojů.",incorrect:"Priorita vláken v férovém plánovači je staticky definována a nemění se v průběhu běhu systému, což zajišťuje, že důležitější vlákna mají trvale vyšší prioritu bez ohledu na jejich dosavadní využití výpočetního času, a tím se dosahuje předvídatelného a deterministického chování systému.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"0053685a-8d8b-4716-96a4-3a74835e9a89",correct:"Plánovací kvantum je minimální čas, po který operační systém nechá běžet aktivní vlákno na procesoru, a to i v případě, že existuje další vlákno s vyšší prioritou připravené k běhu, čímž se zamezuje nadměrnému přepínání kontextu a optimalizuje se celková propustnost systému na úkor potenciálního zvýšení latence.",incorrect:"Plánovací kvantum je maximální čas, po který operační systém nechá běžet aktivní vlákno na procesoru, a to i v případě, že existuje další vlákno s nižší prioritou připravené k běhu, čímž se zamezuje nadměrnému přepínání kontextu a optimalizuje se celková propustnost systému na úkor potenciálního zvýšení latence.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"423b7640-be82-45d6-9fe5-99b160eab21d",correct:"V systémech využívajících plánovací algoritmy FIFO nebo Round Robin jsou vlákna s rovnocennou prioritou spravedlivě rotována na procesoru, přičemž každému vláknu je přiděleno stejné časové kvantum pro běh, pokud ovšem vlákno předčasně neuvolní procesor například uspáním, což umožňuje efektivní využití procesoru a spravedlivé sdílení mezi vlákny.",incorrect:"V systémech využívajících plánovací algoritmy FIFO nebo Round Robin jsou vlákna s rovnocennou prioritou spravedlivě rotována na procesoru, přičemž každému vláknu je přiděleno proměnlivé časové kvantum pro běh v závislosti na jeho prioritě, pokud ovšem vlákno předčasně neuvolní procesor například uspáním, což umožňuje efektivní využití procesoru a spravedlivé sdílení mezi vlákny.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"2c794ac6-d5ea-4c93-82bd-8b8458068006",correct:"V moderních preemptivních operačních systémech se dobrovolné propuštění procesoru aktivním vláknem považuje za neefektivní postup, protože v situacích, kdy vlákno čeká na událost, je výhodnější explicitně signalizovat čekání na danou událost a v případech potřeby snížení priority vlákna je doporučeno přímo upravit plánovací prioritu vlákna, nikoli dobrovolně uvolňovat procesor.",incorrect:"V moderních preemptivních operačních systémech se dobrovolné propuštění procesoru aktivním vláknem považuje za efektivní postup, protože v situacích, kdy vlákno čeká na událost, je výhodnější implicitně signalizovat čekání na danou událost a v případech potřeby snížení priority vlákna je doporučeno dobrovolně uvolňovat procesor, nikoli přímo upravovat plánovací prioritu vlákna.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"b15a5d5c-9aa3-4327-9960-6fef313ccb86",correct:"Když vlákno čeká na vyřízení soukromého požadavku, jako je například operace čtení ze souboru, operační systém toto vlákno uspí a interně si poznačí, že toto vlákno čeká na dokončení konkrétního požadavku. Jakmile je požadavek vyřízen a data jsou k dispozici, komponenta operačního systému, která daný požadavek zpracovala, probudí čekající vlákno a to je následně přesunuto do stavu připravenosti k běhu.",incorrect:"Když vlákno čeká na vyřízení soukromého požadavku, operační systém ho uspí. Po vyřízení tohoto požadavku je probuzeno první vlákno z běhové fronty, nikoliv vlákno, které původně odeslalo daný požadavek. Tímto mechanismem se operační systém snaží zajistit spravedlivé přidělování procesoru mezi všechna vlákna, bez ohledu na původní požadavek.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"},{uuid:"4e60023e-b950-4193-9747-f44cefe272f4",correct:"V situacích, kdy vlákna soutěží o přístup ke sdílenému zdroji, jako je například kritická sekce chránící sdílená data, operační systém spravuje pro každý takový zdroj čekací frontu. V momentě, kdy vlákno uvolní držený zdroj, operační systém probudí z čekací fronty pouze první vlákno v pořadí a umožní mu získat přístup ke zdroji, zatímco ostatní čekající vlákna zůstávají nadále v klidu.",incorrect:"Při soutěži o sdílený zdroj operační systém po uvolnění zdroje probudí všechna vlákna čekající ve frontě na tento zdroj. Všechna probuzená vlákna se pak současně pokusí získat přístup ke zdroji, a operační systém následně rozhodne na základě priority vláken, které z nich zdroj získá, zatímco ostatní se vrátí zpět do čekacího stavu.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"}]},{uuid:"335453af-3c29-4043-93c4-c865a33f8988",sectionNumber:"3",sectionTitle:"Souborové systémy",statements:[{uuid:"1f278289-b982-4783-b08a-9fe14988c5df",correct:"Perzistentní úložiště, jako například SSD disky, se používají pro dlouhodobé uchovávání dat, která zůstávají zachována i po vypnutí počítače, a jsou charakteristická operacemi pracujícími s bloky dat o velikosti alespoň 512 bajtů, což je odlišuje od operační paměti, která je typicky adresována po jednotlivých bajtech a slouží spíše pro dočasné uložení dat.",incorrect:"Perzistentní úložiště, jako například SSD disky, se používají výhradně pro krátkodobé uchovávání dat, která se ztrácejí po vypnutí počítače, a jsou charakteristická operacemi pracujícími s jednotlivými bajty dat, podobně jako operační paměť, která je typicky adresována po blocích a slouží primárně pro dlouhodobé uložení dat.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"e11bed94-2ee7-4f3b-a2b7-d13d58336b20",correct:"Mezi hlavní rozdíly mezi perzistentním úložištěm a operační pamětí patří zejména vyšší latence perzistentního úložiště, které vykazuje delší prodlevu mezi požadavkem na data a jejich zpřístupněním, a také fakt, že perzistentní úložiště je navrženo pro práci s bloky dat, zatímco operační paměť umožňuje adresaci na úrovni jednotlivých bajtů.",incorrect:"Mezi hlavní podobnosti mezi perzistentním úložištěm a operační pamětí patří zejména srovnatelná latence obou typů paměti, kdy perzistentní úložiště vykazuje podobnou prodlevu mezi požadavkem na data a jejich zpřístupněním jako operační paměť, a také fakt, že perzistentní úložiště i operační paměť jsou navrženy pro práci s jednotlivými bajty dat.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"b89cec01-268d-4c92-b762-a03e1eb106f6",correct:"Perzistentní úložiště, zahrnující technologie jako HDD, SSD a NVMe, je primárně určeno pro ukládání uživatelsky relevantních dat, jako jsou dokumenty, obrázky a multimediální soubory, a obvykle se nevyužívá pro dočasné a uživatelsky nepodstatné mezivýsledky výpočtů, pro které je vhodnější operační paměť s rychlejším přístupem.",incorrect:"Perzistentní úložiště, zahrnující technologie jako HDD, SSD a NVMe, je primárně určeno pro ukládání dočasných a uživatelsky nepodstatných mezivýsledků výpočtů, a naopak se obvykle využívá pro ukládání uživatelsky relevantních dat, jako jsou dokumenty, obrázky a multimediální soubory, pro které je méně vhodná operační paměť s rychlejším přístupem.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"9d3aa61a-fe3a-4f86-8ccb-3e8a92e4d2dc",correct:"Ačkoliv magnetické pásky a optické disky mohou být považovány za typy úložišť, magnetické pásky se odlišují sekvenčním přístupem k datům, což je činí nevhodnými pro abstrakci blokových zařízení typickou pro perzistentní úložiště, zatímco optické disky, i přes komplikace se zápisem a přepisováním, spadají do kategorie perzistentních úložišť, i když často pouze pro čtení.",incorrect:"Ačkoliv magnetické pásky a optické disky mohou být považovány za typy perzistentních úložišť, magnetické pásky se vyznačují přímým přístupem k datům, což je činí ideálními pro abstrakci blokových zařízení typickou pro perzistentní úložiště, zatímco optické disky, i přes jednoduchost zápisu a přepisování, nespadají do kategorie perzistentních úložišť, a to ani pro čtení.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"42a116ec-d707-4f12-beb9-5bee5ab71d51",correct:"V souvislosti s blokově orientovanými zařízeními, jako jsou pevné disky, platí, že adresní prostor je souvislý a adresa vždy odkazuje na celý blok dat. To znamená, že operace čtení a zápisu se provádějí s celými bloky, což reflektuje fyzickou organizaci zařízení a liší se od jemnější adresace v operační paměti.",incorrect:"V souvislosti s blokově orientovanými zařízeními, jako jsou pevné disky, adresní prostor není souvislý a adresa odkazuje pouze na část bloku dat. Operace čtení a zápisu se mohou provádět s libovolně velkými částmi bloků, podobně jako v operační paměti, a fyzická organizace zařízení nemá vliv na adresaci.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"2310e672-538a-4e9a-bc32-4793fbad96a2",correct:"Komunikace s blokově orientovanými zařízeními je typicky asynchronní kvůli latenci spojené s mechanickými operacemi a přenosovými časy. Data se mezi zařízením a operační pamětí přenášejí po větších blocích, což je efektivní pro hromadné operace, ale zavádí prodlevu před zahájením samotného přenosu.",incorrect:"Komunikace s blokově orientovanými zařízeními je typicky synchronní, protože latence je zanedbatelná a operace jsou okamžité. Data se mezi zařízením a operační pamětí přenášejí po jednotlivých bajtech, což umožňuje jemnozrnnou kontrolu nad přenosem a eliminuje prodlevy spojené s blokovým přenosem.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"760db8d7-ec61-412e-b25c-1d296dbe15a5",correct:'Operační systémy musí řešit problém latence, která se projevuje jako prodleva mezi požadavkem na uložení dat a potvrzením o úspěšném zápisu, protože na rozdíl od latence operační paměti nelze tuto latenci efektivně skrýt na hardwarové úrovni, což klade zvýšené nároky na návrh a implementaci mechanismů zajišťujících spolehlivé a trvalé uložení dat, známé jako "durability" v kontextu ACID vlastností databázových transakcí.',incorrect:'Operační systémy se nemusí primárně zabývat problémem latence při ukládání dat, protože moderní hardwarové technologie efektivně maskují prodlevu mezi požadavkem na uložení a potvrzením o úspěšném zápisu, a proto je latence v kontextu trvalého uložení dat, známého jako "durability" v ACID vlastnostech databází, spíše marginálním problémem, který nemá významný dopad na celkovou spolehlivost systému.',sectionNumber:"3.1.3",sectionTitle:"Latence"},{uuid:"f1803347-73fe-48b1-b5cf-dc55c56e13a0",correct:"Operační systém implementuje mezipaměť pro trvalá úložiště softwarově a klíčovým aspektem je politika mezipaměti, která určuje, které nedávno čtené bloky dat zůstanou uloženy v operační paměti, aby se urychlil budoucí přístup k nim, přičemž cílem je efektivně skrýt latenci spojenou s pomalejším přístupem k trvalému úložišti.",incorrect:"Operační systém implementuje mezipaměť pro trvalá úložiště hardwarově a klíčovým aspektem je typ paměti, která určuje, které nedávno čtené bloky dat zůstanou uloženy v operační paměti, aby se urychlil budoucí přístup k nim, přičemž cílem je primárně zvýšit spolehlivost ukládání dat na trvalém úložišti.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"fe4f923a-1ebb-41bb-811b-cca7710ef869",correct:"V kontextu mezipaměti trvalých úložišť operační systém často využívá techniku přednačítání dat, kdy se bloky dat načítají do mezipaměti s předstihem, ještě předtím, než o ně aplikace explicitně požádá, a to zejména v situacích sekvenčního čtení, aby se maximalizovala efektivita využití přenosové kapacity a snížila latence přístupu.",incorrect:"V kontextu mezipaměti trvalých úložišť operační systém zásadně nepoužívá techniku přednačítání dat, protože přednačítání bloků dat do mezipaměti s předstihem, ještě předtím, než o ně aplikace explicitně požádá, by mohlo vést k neefektivnímu využití operační paměti a zbytečnému zatížení systému.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"440d9d8b-c071-4064-bbeb-d072978d6a25",correct:"Mezipaměť operačního systému, implementovaná pro trvalá úložiště, primárně slouží ke zlepšení rychlosti přístupu k datům tím, že uchovává často nebo nedávno používané bloky v rychlejší operační paměti, ačkoli nemá přímý vliv na spolehlivost samotného trvalého úložiště, ale zásadně ovlivňuje celkovou latenci operací čtení a zápisu.",incorrect:"Mezipaměť operačního systému, implementovaná pro trvalá úložiště, primárně slouží ke zvýšení spolehlivosti ukládání dat na trvalém úložišti tím, že redundantně ukládá data v rychlejší operační paměti, ačkoli nemá žádný vliv na rychlost přístupu k datům, ale zásadně ovlivňuje integritu dat v případě selhání trvalého úložiště.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"2f5fb911-83c7-40f8-8b12-72034188c7b5",correct:"Vyrovnávací paměť v operačních systémech slouží k ukládání dat určených k zápisu na trvalé úložiště, čímž se liší od mezipaměti, která primárně slouží k urychlení čtení dat z trvalého úložiště do aplikace, a jejím hlavním účelem je vyrovnávat rozdíly v rychlosti mezi aplikací a pomalým trvalým úložištěm při zápisu dat.",incorrect:"Vyrovnávací paměť v operačních systémech slouží k ukládání dat určených ke čtení z trvalého úložiště, čímž se neliší od mezipaměti, která primárně slouží k urychlení zápisu dat na trvalé úložiště, a jejím hlavním účelem je vyrovnávat rozdíly v rychlosti mezi aplikací a rychlým trvalým úložištěm při čtení dat.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"a8f1b0e7-99d5-4998-bad4-d03568e1078a",correct:"Vyrovnávací paměť, implementovaná v operačním systému pro zápis dat na trvalé úložiště, je dočasné úložiště, což znamená, že v případě neočekávaného výpadku napájení nebo systému mohou být data uložená pouze ve vyrovnávací paměti ztracena, a proto je důležitá její synchronizace s mezipamětí pro zajištění konzistence dat.",incorrect:"Vyrovnávací paměť, implementovaná v operačním systému pro zápis dat na trvalé úložiště, je trvalé úložiště, což znamená, že v případě neočekávaného výpadku napájení nebo systému nemohou být data uložená ve vyrovnávací paměti ztracena, a proto není důležitá její synchronizace s mezipamětí pro zajištění konzistence dat.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"d2a723dd-2866-463d-a74f-e24be5ee0c0f",correct:"Operační systémy mohou implementovat vyrovnávací paměti dvěma hlavními způsoby: buď odděleně od mezipaměti, kdy vyrovnávací paměť drží jak požadavky na zápis, tak samotná data, nebo propojeně s mezipamětí, kde vyrovnávací paměť obsahuje jen frontu požadavků a data jsou uložena v mezipaměti, což se chová jako mezipaměť s opožděným zápisem.",incorrect:"Operační systémy mohou implementovat vyrovnávací paměti dvěma hlavními způsoby: buď odděleně od mezipaměti, kdy vyrovnávací paměť drží pouze požadavky na zápis, a data jsou uložena v mezipaměti, nebo propojeně s trvalým úložištěm, kde vyrovnávací paměť obsahuje jak frontu požadavků, tak samotná data, což se chová jako mezipaměť s okamžitým zápisem.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"4f1d6c28-31cd-4b7c-86c5-9e3d0259d60b",correct:"Paměti typu mezipaměti a vyrovnávací paměti existují nejen na úrovni operačního systému, ale také na straně samotných zařízení trvalého úložiště, kde plní podobnou funkci snižování latence, avšak tyto paměti na straně zařízení mají obvykle menší přímý dopad na fungování a správu operačního systému ve srovnání s pamětmi implementovanými v jádře systému.",incorrect:"Paměti typu mezipaměti a vyrovnávací paměti existují pouze na úrovni operačního systému a nemají žádnou obdobu na straně samotných zařízení trvalého úložiště, protože veškeré mechanismy pro snižování latence a zlepšení výkonu trvalých úložišť jsou plně v kompetenci operačního systému a implementace pamětí na straně zařízení by byla redundantní a neměla by žádný vliv na výkon systému.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"ed12eda8-65b1-40c1-a8f6-94e15316191e",correct:"Pro většinu úložných zařízení platí, že sekvenční přístup, tedy čtení dat z po sobě jdoucích adres, je výrazně rychlejší než nahodilý přístup, kdy jsou čteny adresy, které spolu logicky nesouvisí, což je dáno fyzikálními vlastnostmi a architekturou úložných médií, jako jsou rotační disky, kde mechanický pohyb hlavy hraje klíčovou roli.",incorrect:"Pro většinu úložných zařízení platí, že nahodilý přístup, tedy čtení dat z adres, které spolu logicky nesouvisí, je výrazně rychlejší než sekvenční přístup, kdy jsou čteny data z po sobě jdoucích adres, protože moderní technologie, jako jsou SSD disky, optimalizují výkon pro náhodný přístup a eliminují mechanická omezení rotačních disků.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"d41a4ea6-d29f-4436-abc9-bf85be486566",correct:"Operační systémy využívají vysokou míru souběžnosti operací s trvalým úložištěm, jelikož do systému přichází mnoho nezávislých požadavků na diskové operace od souběžných vláken, což umožňuje operačnímu systému přeuspořádávat tyto požadavky a optimalizovat tak propustnost systému, například seskupováním sekvenčních zápisů do větších bloků.",incorrect:"Operační systémy se snaží minimalizovat souběžnost operací s trvalým úložištěm, jelikož souběžné diskové operace od mnoha vláken vedou ke snížení výkonu systému a fragmentaci dat, proto operační systém striktně dodržuje pořadí příchozích požadavků a neprovádí žádné přeuspořádávání diskových operací.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"f8506701-c842-4f07-a88e-a253ffbd61c6",correct:"U operací čtení je prostor pro přeuspořádání obvykle menší než u operací zápisu, protože aplikace, která operaci čtení vyžádala, typicky musí čekat na doručení dat a nemůže pokračovat ve své činnosti ani generovat další požadavky na čtení, dokud není aktuální požadavek obsloužen a data nejsou k dispozici.",incorrect:"U operací čtení je prostor pro přeuspořádání obvykle větší než u operací zápisu, protože moderní operační systémy a diskové řadiče aktivně přeuspořádávají operace čtení, aby maximalizovaly výkon a minimalizovaly latenci, a to i v případech, kdy aplikace čeká na data, s cílem prediktivního načítání a optimalizace přístupových vzorů.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"75c91a6e-8f5b-4633-9bf7-45fd81fa0df4",correct:"V kontextu virtualizace trvalých úložišť se tradiční přístup vytváření soukromých instancí, úspěšně aplikovaný u paměti a procesoru, ukazuje jako nevhodný, protože uživatelská data vyžadují interakci a nemohou být skryta v privátním prostoru jednoho programu.  Alternativní řešení zahrnují buď poskytnutí vyšší úrovně abstrakce operačním systémem, kde trvalé úložiště není aplikacím přímo přístupné, nebo vyčlenění specializované aplikace pro správu dat, skrze kterou ostatní aplikace interagují s úložištěm.",incorrect:"V kontextu virtualizace trvalých úložišť se tradiční přístup vytváření soukromých instancí, úspěšně aplikovaný u paměti a procesoru, je ideálním řešením, protože zajišťuje izolaci a bezpečnost dat každého programu. Alternativní řešení zahrnují pouze vyčlenění specializované aplikace pro správu dat, skrze kterou ostatní aplikace interagují s úložištěm, přičemž abstrakce operačního systému není považována za relevantní.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"2cc38139-4a7b-4b95-a1b1-eb17eaa48a1f",correct:"Obě navrhovaná řešení pro virtualizaci trvalých úložišť, tedy abstrakce na úrovni operačního systému a vyčlenění specializované aplikace pro správu úložiště, se v zásadě sbližují v omezení přímého přístupu k fyzickému úložišti na jediný program.  Tento program, ať už je součástí operačního systému nebo samostatnou aplikací,  pak plní klíčovou roli v rozhodování o fyzické organizaci dat, povolených operacích a přístupových právech pro ostatní programy.",incorrect:"Obě navrhovaná řešení pro virtualizaci trvalých úložišť se zásadně liší, přičemž abstrakce na úrovni operačního systému umožňuje přímý přístup aplikací k fyzickému úložišti, zatímco vyčlenění specializované aplikace pro správu úložiště tento přístup omezuje.  Nicméně, ani v jednom z těchto řešení nemá program spravující úložiště významný vliv na organizaci dat, operace nebo přístupová práva, protože tato rozhodnutí jsou plně v kompetenci operačního systému.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"6a8b01de-54ab-4fe3-88a0-a7ec63fdb2d8",correct:"Pokud by virtualizace trvalého úložiště spočívala výhradně v poskytování soukromých virtuálních instancí každému programu, uživatel by v prohlížeči souborů standardně neviděl žádná svá data.  To je způsobeno tím, že data uložená v soukromé instanci jednoho programu by nebyla automaticky sdílena s jinými programy, včetně prohlížeče souborů, který by tak neměl přístup k datům uloženým jinými aplikacemi, pokud by je tam prohlížeč sám neuložil.",incorrect:"Pokud by virtualizace trvalého úložiště spočívala výhradně v poskytování soukromých virtuálních instancí každému programu, uživatel by v prohlížeči souborů bez problémů viděl všechna svá data.  To je proto, že operační systém by automaticky zajišťoval sdílení dat mezi všemi virtuálními instancemi a prohlížečem souborů, takže by uživatel měl kompletní přehled o všech uložených datech bez ohledu na to, který program je uložil.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"9fbc4d58-49f6-42a1-81c0-dcade8b82c67",correct:"Souborový systém, poskytovaný operačním systémem, představuje nejběžnější metodu virtualizace trvalých úložišť, která umožňuje řízený přístup k datům pro mnoho aplikací současně a nabízí uživatelům možnost organizovat a spravovat data, čímž se stává klíčovou abstrakcí pro práci s daty v moderních výpočetních systémech.",incorrect:"Souborový systém, poskytovaný operačním systémem, je sice metodou virtualizace trvalých úložišť, ale je určen pouze pro specifické aplikace, neumožňuje současný přístup více aplikacím a správu dat zajišťuje výhradně systémový administrátor, nikoliv uživatelé, což omezuje jeho univerzálnost a praktické využití v běžných scénářích.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"87ddbd78-764d-4d9c-b9d6-9c0f5bb254c6",correct:"Virtualizace na aplikační úrovni, typicky reprezentovaná relačními databázovými systémy (RDBMS), spočívá v přímém přístupu vybrané aplikace k trvalému úložišti, přičemž tato aplikace zodpovídá za správu dat a poskytuje k nim přístup ostatním aplikacím prostřednictvím definovaných aplikačních protokolů, což umožňuje specializované a efektivní zpracování dat.",incorrect:"Virtualizace na aplikační úrovni, typicky reprezentovaná relačními databázovými systémy (RDBMS), spočívá v zprostředkovaném přístupu aplikací k trvalému úložišti skrze operační systém, přičemž operační systém zodpovídá za správu dat a aplikace mezi sebou komunikují přímo bez aplikačních protokolů, což zjednodušuje správu dat, ale snižuje flexibilitu a výkon systému.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"51bd2fca-05fc-4dc6-9985-b46c8955315c",correct:"Vytvoření izolované virtuální instance trvalého úložiště, analogické k virtualizaci operační paměti, se uplatňuje především v kontextu virtualizace operačních systémů a může sloužit jako podpůrný mechanismus pro aplikační virtualizaci, i když v běžných scénářích není primárně považováno za nejužitečnější metodu pro obecné účely správy dat.",incorrect:"Vytvoření izolované virtuální instance trvalého úložiště, analogické k virtualizaci operační paměti, je považováno za nejuniverzálnější metodu virtualizace trvalých úložišť v běžných scénářích, zatímco v kontextu virtualizace operačních systémů a aplikační virtualizace se jeho uplatnění minimalizuje kvůli složitosti a neefektivitě v porovnání s jinými metodami.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"1b58f20d-db46-4a07-a343-bd106a169f10",correct:"Technologie RAID, neboli Redundant Array of Inexpensive Disks, je postavena na principu virtualizace, která kombinuje více fyzických úložišť do jednoho virtuálního celku s cílem zvýšit spolehlivost a dostupnost dat skrze redundanci, a to rozložením dat mezi tato fyzická zařízení a umožněním systému fungovat i po selhání jednoho z nich, s výjimkou konfigurace RAID 0, která redundanci neposkytuje.",incorrect:"Technologie RAID, neboli Redundant Array of Inexpensive Disks, je postavena na principu virtualizace, která kombinuje více fyzických úložišť do jednoho virtuálního celku s cílem zvýšit výhradně výkon čtení a zápisu dat, a to rozložením dat mezi tato fyzická zařízení, přičemž hlavním cílem RAID je maximalizace rychlosti operací, a spolehlivost dat je pouze vedlejším efektem.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"132eed4d-0788-4eb3-98a5-e15dedd73a73",correct:"Softwarový RAID, běžně implementovaný v moderních operačních systémech, je integrální součástí blokové vrstvy operačního systému, kde se prezentuje vyšším vrstvám, jako je souborový systém, jako jediné a konzistentní virtuální úložiště, přičemž operace čtení a zápisu jsou transparentně distribuovány mezi jednotlivá fyzická zařízení podsystémem RAID.",incorrect:"Softwarový RAID, běžně implementovaný v moderních operačních systémech, je externí aplikací běžící nad souborovým systémem, která emuluje chování diskového pole a vyžaduje specifické úpravy v aplikacích pro správné fungování, přičemž operace čtení a zápisu jsou směrovány na softwarový RAID rozhraním souborového systému.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"403f1988-3e30-4b37-b997-6595c31c7306",correct:"RAID úrovně 1, známý jako zrcadlení, poskytuje vysokou úroveň redundance tím, že udržuje kompletní kopii dat na každém zařízení v poli, což umožňuje systému tolerovat selhání až n-1 zařízení v poli o velikosti n, aniž by došlo ke ztrátě dat nebo přerušení provozu, a to díky okamžité dostupnosti dat z zrcadlových disků.",incorrect:"RAID úrovně 1, známý jako zrcadlení, poskytuje omezenou úroveň redundance tím, že rozkládá data mezi dvě zařízení, což umožňuje systému tolerovat selhání pouze jednoho zařízení v poli, ale v případě selhání obou zařízení dojde ke ztrátě dat a nutnosti obnovy ze zálohy, protože RAID 1 neumožňuje obnovu dat z parity.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"f28e0db4-2c7c-4152-8824-081a15b5f1b6",correct:"RAID úrovně 0, charakteristický prokládáním dat po blocích mezi disky, je jedinou běžně používanou konfigurací RAID, která neimplementuje žádnou formu redundance, což znamená, že selhání jediného fyzického zařízení v poli RAID 0 vede k okamžité ztrátě všech dat uložených v tomto poli, a proto se RAID 0 primárně používá pro zvýšení výkonu, nikoli spolehlivosti.",incorrect:"RAID úrovně 0, charakteristický prokládáním dat po blocích mezi disky, je považován za nejspolehlivější konfiguraci RAID díky efektivnímu rozložení dat a implementaci distribuované parity, což zajišťuje vysokou odolnost proti selhání více disků současně a minimalizuje riziko ztráty dat i v případě rozsáhlých hardwarových problémů.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"ca46a74f-ccd2-493e-b531-e5aefa7ac61c",correct:"Šifrování dat na úrovni blokových zařízení, podobně jako RAID, je pro zbytek systému transparentní, což znamená, že souborový systém nemusí mít o jeho existenci žádné zvláštní povědomí a může s šifrovaným blokovým zařízením pracovat stejně jako s nešifrovaným, bez nutnosti implementace speciálních funkcí pro šifrování a dešifrování dat.",incorrect:"Šifrování dat na úrovni blokových zařízení, na rozdíl od RAIDu, není pro zbytek systému zcela transparentní, což znamená, že souborový systém musí mít speciální povědomí o jeho existenci a musí implementovat specifické funkce pro šifrování a dešifrování dat, aby mohl správně pracovat s šifrovaným blokovým zařízením.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"c2588063-bb51-4cf5-848c-f419cba70688",correct:"Šifrování dat na úrovni blokových zařízení využívá symetrické blokové šifry, jako je AES v módu CBC nebo XTS, a klíč pro šifrování a dešifrování je obvykle odvozen z hesla uživatele nebo z bezpečnostního tokenu, což zajišťuje ochranu dat i v případě fyzického odcizení zařízení.",incorrect:"Šifrování dat na úrovni blokových zařízení využívá asymetrické šifry, jako je RSA, a klíč pro šifrování a dešifrování je veřejně dostupný, což umožňuje snadný přístup k datům pro kohokoli, kdo má fyzický přístup k zařízení, a je primárně zaměřeno na ochranu dat během přenosu, nikoli na ochranu uložených dat.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"f59a5a90-8a62-488b-8b91-1605e7e3628e",correct:"Šifrování dat na úrovni blokových zařízení obvykle zachovává délku bloků, což znamená, že zašifrovaný blok dat má stejnou velikost jako původní nezašifrovaný blok, a lze jej přímo 1:1 uložit na fyzické úložiště, nicméně pokud je vyžadována kontrola integrity dat, pak tato vlastnost již neplatí a bloky mohou být větší kvůli přidaným kontrolním součtům.",incorrect:"Šifrování dat na úrovni blokových zařízení vždy zvětšuje délku bloků dat, což znamená, že zašifrovaný blok dat je větší než původní nezašifrovaný blok, a proto vyžaduje složitější mechanismy pro ukládání na fyzické úložiště, a to i v případech, kdy není vyžadována kontrola integrity dat, což vede k vyšší režii a menší efektivitě úložného prostoru.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"5d493e6d-7646-4716-91cf-41df48c8fea9",correct:"Soubory v operačních systémech představují abstrakci nad fyzickým úložištěm dat, která umožňuje operace čtení a zápisu po jednotlivých bajtech nebo v blocích libovolné velikosti, a efektivně skrývá detaily blokového charakteru fyzického úložného zařízení.",incorrect:"Soubory v operačních systémech umožňují výhradně operace čtení a zápisu dat pouze po jednotlivých bajtech, bez podpory práce s bloky dat libovolné velikosti, a abstrakce souborů naopak odhaluje blokovou povahu fyzického zařízení, na kterém jsou soubory uloženy.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"d0596aa2-d98e-4a11-b6b2-d2231b0ee2b4",correct:"Soubory v operačních systémech podporují automatické prodlužování své velikosti, pokud zápis dat probíhá za aktuální konec souboru, a jsou adresovány souvisle od adresy nula až po aktuální velikost souboru, podobně jako je tomu u virtuálního adresního prostoru v operační paměti.",incorrect:"Soubory v operačních systémech nepodporují automatické prodlužování své velikosti při zápisu za konec souboru a nejsou adresovány souvisle od adresy nula, ale adresování začíná od adresy jedna, což je zásadní rozdíl oproti virtuálnímu adresnímu prostoru v operační paměti.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"9e87a96a-a032-4f0c-bbe8-d664e130c9b0",correct:"Soubory v operačních systémech mohou být navrženy tak, aby implementovaly pouze operace čtení, nebo pouze operace zápisu, případně pouze sekvenční přístup k datům, a nemusí vždy reprezentovat paměť v tradičním slova smyslu, což umožňuje flexibilní využití souborů pro různé účely, nejen pro ukládání a následné načítání dat.",incorrect:"Soubory v operačních systémech musí vždy implementovat jak operace čtení, tak operace zápisu, a musí vždy reprezentovat paměť v tradičním slova smyslu s možností libovolného adresování, což omezuje možnosti využití souborů pouze na ukládání a následné načítání dat.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"2416e13e-99df-4e2c-865b-f3c23012d095",correct:"Soubory v operačních systémech jsou obvykle perzistentní, což znamená, že jejich existence je dlouhodobá a nezávislá na běžících procesech nebo stavu operačního systému, a pro efektivní manipulaci s nimi jsou opatřeny jednoznačnou identitou, která umožňuje jejich identifikaci i po restartování systému.",incorrect:"Soubory v operačních systémech jsou obvykle dočasné, existují pouze po dobu běhu procesu, který je vytvořil, a nejsou opatřeny žádnou trvalou identitou, což prakticky znemožňuje jejich využití po ukončení procesu nebo po restartování operačního systému.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"dc66d25d-8f0e-478e-9e6f-d36b28abfef6",correct:"Pro práci se souborem v systémech standardu POSIX je nezbytné soubor nejprve explicitně otevřít pomocí systémového volání `open`, které vrací takzvaný popisovač otevřeného souboru, jenž slouží jako klíčový identifikační prvek pro veškeré následné operace čtení a zápisu s daným souborem.",incorrect:"Pro práci se souborem v systémech standardu POSIX není nutné soubor předem otevírat, a operace čtení a zápisu se provádějí přímo s cestou nebo názvem souboru, přičemž koncept popisovače otevřeného souboru není v systémech POSIX vůbec definován ani používán.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"4fbeaee3-d338-43f7-8e12-a6394f275de6",correct:"Souborový systém představuje abstrakci perzistentní paměti, kde obyčejný soubor slouží jako reprezentace paměti pro uchování dat v sekvenci bajtů, přičemž souborový systém neprovádí interpretaci obsahu těchto souborů a  aplikace pracují s daty souboru bez ohledu na jejich fyzické uložení.",incorrect:"Souborový systém představuje abstrakci perzistentní paměti, kde obyčejný soubor slouží jako reprezentace paměti pro uchování dat v sekvenci bajtů, přičemž souborový systém aktivně interpretuje obsah těchto souborů a aplikace musí detailně znát fyzické uložení dat pro efektivní práci se soubory.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"d3970017-becd-4415-80d6-991eab95c8d5",correct:"Aplikační programy, pracující se soubory, nejsou omezeny blokovou strukturou fyzického úložiště ani nutností zarovnání dat na blokové hranice, protože souborový systém zajišťuje abstrakci od blokově orientovaného přístupu a operační systém se stará o mapování logických operací se soubory na fyzické bloky.",incorrect:"Aplikační programy, pracující se soubory, musí striktně respektovat blokovou strukturu fyzického úložiště a zarovnávat všechna data na blokové hranice, protože souborový systém přímo zpřístupňuje blokově orientovaný přístup k úložišti a operační systém vyžaduje explicitní práci s fyzickými bloky.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"049f7c5e-fe1c-47f4-8a53-9e302bcd1b00",correct:"Metadata souborů, spravovaná souborovým systémem, zahrnují informace o fyzickém umístění datových bloků souboru na pevném disku a umožňují operačnímu systému efektivně lokalizovat a načítat požadované části souboru, a také uchovávají další atributy souboru, jako je vlastník a čas poslední modifikace.",incorrect:"Metadata souborů, spravovaná souborovým systémem, se omezují pouze na atributy souboru, jako je vlastník a čas poslední modifikace, ale nezahrnují informace o fyzickém umístění datových bloků na pevném disku, protože operační systém lokalizuje a načítá soubory výhradně na základě názvu souboru.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"99596a5b-7d71-45fc-b30b-5d2c7bc4d264",correct:"Mapování souborů do paměti s využitím líného načítání stránek představuje efektivní přístup, obzvláště pro aplikace, které dominantně přistupují k datům pro čtení, jelikož minimalizuje režii spojenou s explicitními voláními operací read a write a umožňuje pracovat se soubory jako s paměťovými segmenty.",incorrect:"Mapování souborů do paměti s líným načítáním stránek je primárně navrženo pro aplikace, které intenzivně zapisují data do souborů, a jeho hlavní výhoda spočívá v redukci režie operací zápisu. Pro aplikace, které převážně čtou data, mapování souborů do paměti nepřináší žádné významné zlepšení výkonu.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"e93dfac0-9982-40af-919d-f853dfbf9183",correct:"Pokud aplikace přistupuje k souboru mapovanému do paměti a požadovaný rozsah dat je zarovnaný na hranice stránek jak ve virtuální paměti procesu, tak v souboru, operační systém může optimalizovat čtení přemapováním stránek, namísto kopírování dat, s potenciálním využitím mechanismu copy-on-write pro další zvýšení efektivity.",incorrect:"V situaci, kdy aplikace čte data ze souboru mapovaného do paměti a rozsah čtení je zarovnaný na stránky, operační systém vždy provádí explicitní kopírování dat mezi mezipamětí a pamětí procesu. Optimalizace přemapováním stránek, jako je mechanismus copy-on-write, se v těchto případech nikdy nepoužívá, a to ani při zarovnání na stránky.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"3ad1a761-fe73-45b1-a9e3-332f3b6a23b6",correct:"Při mapování souboru do paměti jsou externí stránky, které reprezentují data souboru, uloženy v běžném souborovém systému, avšak program s nimi manipuluje prostřednictvím paměťových instrukcí, nikoli explicitními systémovými voláními pro vstup a výstup, což umožňuje transparentní úpravy souboru a snižuje režii operací.",incorrect:"V režimu mapování souborů do paměti jsou externí stránky uloženy ve vyhrazené swapovací oblasti operačního systému a přístup k nim vyžaduje explicitní a režijně náročné vstupně-výstupní operace. Program nemůže s daty souboru pracovat přímo jako s obsahem paměti, a transparentní úpravy souboru nejsou možné.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"69415615-d8a1-4111-90f9-a6c43d3dd0ed",correct:"Přístup k souboru z více vláken je možný a pokud všechna vlákna přistupují k souboru pouze pro čtení, nevznikají žádné významné problémy spojené se souběžným přístupem, protože operace čtení nezpůsobují hazard souběhu.",incorrect:"Přístup k souboru z více vláken je možný a i když všechna vlákna přistupují k souboru pro zápis, nevznikají žádné významné problémy spojené se souběžným přístupem, protože moderní operační systémy efektivně řídí souběžný zápis do souborů bez nutnosti zamykání.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"26f28278-287d-4f82-b769-790fa89089f8",correct:"Jmenný prostor souborového systému je sdílený mezi všemi procesy, což znamená, že více procesů může pracovat se stejným souborem současně, podobně jako je sdílená operační paměť mapovaná ve více virtuálních adresních prostorech, což vyžaduje mechanismy pro řízení souběžného přístupu.",incorrect:"Jmenný prostor souborového systému je izolovaný pro každý proces zvlášť, což znamená, že i když více procesů pracuje se soubory se stejným jménem, ve skutečnosti pracují s různými, oddělenými instancemi souborů, a proto není potřeba řešit souběžný přístup.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"6c20db9f-b5e7-4fe6-9d59-f9acb6a37ce4",correct:"Operační systémy poskytují mechanismy zamykání souborů, jako například volání `flock` a `fcntl` v systémech POSIX, aby umožnily programům bezpečně přistupovat k souborům a předešly problémům se souběžným přístupem, zejména hazardu souběhu, který může vzniknout při čtení a zápisu.",incorrect:"Operační systémy se nesnaží aktivně řešit problémy souběžného přístupu k souborům a spoléhají se výhradně na aplikační programátory, aby zajistili koherentnost dat při souběžném přístupu k souborům, protože zamykání souborů by bylo příliš nákladné a zpomalovalo by operace.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"f52ef40e-d68a-44d9-b986-cfc38c049394",correct:"Pro zamykání souborů v systémech POSIX operační systémy poskytují systémová volání jako `flock`, které uzamkne celý soubor najednou, a `fcntl`, které umožňuje zamknout specifické rozsahy bajtů v souboru, což dává programátorům flexibilitu v řízení souběžného přístupu.",incorrect:"Pro zamykání souborů v systémech POSIX operační systémy poskytují pouze systémové volání `mutex_lock`, které je univerzálním mechanismem pro zamykání souborů i paměti, a neexistují specializovaná volání jako `flock` nebo `fcntl` pro specifické potřeby souborového zamykání.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"2d9c2f7b-a837-475f-8384-52fb63d3895d",correct:"Spustitelné soubory jsou z pohledu souborového systému považovány za běžné soubory a nevyžadují speciální zacházení, avšak pro operační systém jsou klíčové, protože obsahují veškeré informace nutné ke spuštění programu, včetně počátečního obrazu paměti, který definuje virtuální adresní prostor procesu po jeho spuštění.",incorrect:"Spustitelné soubory jsou v souborovém systému speciálně označeny a vyžadují odlišné zacházení než běžné soubory, ačkoli pro operační systém nejsou nijak zvlášť důležité, jelikož neobsahují kompletní informace nutné ke spuštění programu, a počáteční obraz paměti se vytváří dynamicky až v průběhu spouštění procesu.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"75ded3f3-44c3-4065-a2e6-d63c276c3b85",correct:"Spustitelné soubory obsahují takzvaný „obraz paměti“, který slouží k inicializaci virtuálního adresního prostoru nově spouštěného procesu, a tento obraz zahrnuje zejména text programu, tedy instrukce, a počáteční hodnoty globálních proměnných, což jsou data, která program používá od svého startu.",incorrect:"Spustitelné soubory neobsahují „obraz paměti“, ale pouze odkaz na externí zdroje, ze kterých se dynamicky sestavuje virtuální adresní prostor procesu až po jeho spuštění, a tento prostor zahrnuje pouze instrukce programu, zatímco globální proměnné se inicializují až v průběhu běhu programu, nikoliv při jeho startu.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"1ca5c6f0-b433-420e-9589-15c7d1865d8b",correct:"Roury v operačních systémech slouží jako jednoduchá komunikační zařízení umožňující jednosměrný tok dat, kde jedna strana data zapisuje a druhá strana je čte, přičemž se podobají souborům v možnosti zápisu a čtení bajtů, avšak na rozdíl od souborů data nejsou trvale uložena a po přečtení z roury zmizí, ačkoliv roura disponuje bufferem v operační paměti pro dočasné uchování dat.",incorrect:"Roury v operačních systémech slouží jako komplexní komunikační zařízení umožňující obousměrný tok dat, kde jedna strana data zapisuje a druhá strana je čte, přičemž se podobají souborům v možnosti zápisu a čtení bajtů, a stejně jako soubory data jsou trvale uložena a po přečtení z roury nezmizí, ačkoliv roura nedisponuje bufferem v operační paměti pro dočasné uchování dat.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"e9156351-6a70-486d-801a-01368194fac5",correct:"Anonymní roury v systémech, které nejsou typu POSIX, jsou obvykle přístupné skrze popisovače otevřených souborů a zanikají, jakmile jsou všechny přidružené popisovače uzavřeny, zatímco pojmenované roury v POSIX systémech existují trvale v souborovém systému pod jménem, ale data jimi přenášená nejsou trvale uložena, a liší se od anonymních rour hlavně způsobem otevírání, nikoliv mechanismem toku dat.",incorrect:"Anonymní roury v systémech typu POSIX jsou obvykle přístupné skrze popisovače otevřených souborů a zanikají, jakmile jsou všechny přidružené popisovače uzavřeny, a pojmenované roury v POSIX systémech neexistují trvale v souborovém systému pod jménem, a data jimi přenášená jsou trvale uložena, a neliší se od anonymních rour v mechanismu toku dat ani způsobem otevírání.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"f70844e9-7cf1-443f-a2a4-74162ff8125b",correct:"Znaková zařízení představují abstrakci operačního systému, která umožňuje programům pracovat s periferiemi, jež produkují nebo konzumují sekvence bajtů, a chovají se podobně jako roury, kde data zapsaná programem jsou odeslána do periferie a data z periferie mohou být čtena programem.",incorrect:"Znaková zařízení představují abstrakci operačního systému, která umožňuje programům pracovat s periferiemi, jež produkují nebo konzumují sekvence bloků, a chovají se podobně jako fronty, kde data zapsaná programem jsou odeslána do periferie a data z periferie musí být aktivně vyžádána programem.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"57cc368b-05ca-4cc1-8dc1-89c2dd0988cc",correct:"Znaková zařízení, jako například tiskárny a skenery, fungují tak, že data zapsaná do souborového rozhraní znakového zařízení tiskárny jsou interpretována a vytištěna, zatímco u skeneru optický senzor zachycuje pixely, které jsou kódovány a následně čteny aplikací ze znakového zařízení.",incorrect:"Znaková zařízení, jako například tiskárny a skenery, fungují tak, že data zapsaná do blokového rozhraní znakového zařízení tiskárny jsou interpretována a vytištěna, zatímco u skeneru optický senzor zachycuje pixely, které jsou kódovány a následně odeslány aplikaci bez nutnosti čtení ze znakového zařízení.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"bb9fd8f8-e37a-4e34-b35d-0676f15e08da",correct:"Souborové cesty slouží k popisu umístění souborů a složek v hierarchické adresářové struktuře, přičemž jako oddělovač adresářů se v systémech typu POSIX standardně používá znak dopředného lomítka `/`, ačkoli v jiných operačních systémech, jako například Windows, může být použit i znak zpětného lomítka `\\`. Tato konvence umožňuje flexibilitu v reprezentaci cest napříč různými platformami.",incorrect:"Souborové cesty slouží výhradně k popisu umístění souborů v lineární adresářové struktuře, přičemž jako jediný a univerzální oddělovač adresářů se ve všech operačních systémech používá znak zpětného lomítka `\\`, což zajišťuje jednotnost a přenositelnost mezi různými platformami. Použití dopředného lomítka `/` je považováno za zastaralé a nepoužívá se v moderních systémech.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"7bbbc2a4-bd75-4fb6-9a74-567d274800fb",correct:"Adresářová struktura je často označována jako adresářový strom z historických důvodů, avšak v moderních operačních systémech se ve skutečnosti jedná o acyklický orientovaný graf, což umožňuje složitější vztahy mezi adresáři a soubory. Toto grafové pojetí adresářové struktury je klíčové pro implementaci pokročilých funkcí správy souborů a adresářů, avšak abstrahuje od cyklických měkkých odkazů.",incorrect:'Adresářová struktura je přesně a vždy reprezentována jako stromová struktura, což znamená, že neexistují žádné cyklické odkazy ani složitější grafové vztahy mezi adresáři a soubory, a termín "adresářový strom" je tak naprosto přesný a odpovídá implementaci ve všech operačních systémech. Grafové reprezentace adresářů se v operačních systémech nepoužívají.',sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"c2152f49-e7dc-4605-9136-c0fac7f37f78",correct:"Při zpracování absolutní cesty, jako například `/usr/include/soubor.h`, operační systém začíná v kořenovém adresáři označeném znakem `/` a postupně vyhledává položky s odpovídajícími jmény, tedy nejprve `usr`, poté `include` a nakonec `soubor.h`, přičemž ověřuje, že `usr` a `include` jsou skutečně adresáře, a `soubor.h` je cílový soubor. Tento proces procházení adresářové struktury je základem pro přístup k souborům.",incorrect:"Při zpracování absolutní cesty, jako například `/usr/include/soubor.h`, operační systém nejprve prohledá aktuální pracovní adresář uživatele a v něm se snaží nalézt složku `usr`, následně v ní složku `include` a nakonec soubor `soubor.h`, přičemž kořenový adresář označený znakem `/` se v absolutních cestách ignoruje. Absolutní cesty se tedy chovají stejně jako relativní cesty, jen začínají lomítkem.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"299518a4-c9c6-4ff1-a24f-24b670c7582d",correct:"Složky v operačních systémech fungují na principu slovníku, kde klíčem je název souboru nebo podsložky a hodnotou je odkaz na daný soubor nebo podsložku, což umožňuje efektivní vyhledávání a správu souborů. Mezi základní operace se složkami patří přidávání a odebírání klíčů, a také vyhledávání odkazů na soubory nebo podsložky na základě jejich názvů, což je klíčové pro navigaci a manipulaci se souborovým systémem.",incorrect:"Složky v operačních systémech fungují na principu seznamu, kde položky jsou řazeny lineárně a přístup k nim je sekvenční, což vyžaduje pro vyhledávání souborů procházení celého seznamu.  Mezi základní operace se složkami patří pouze přidávání klíčů, zatímco odebírání a vyhledávání odkazů na soubory nebo podsložky na základě jejich názvů není podporováno, což omezuje možnosti správy souborového systému.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"62639219-3307-48cc-97fd-5264226764b1",correct:"Úkolem složek v adresářové struktuře operačního systému je organizovat a pojmenovávat soubory a další podsložky, čímž se vytváří hierarchický systém přístupu k datům. Složky neobsahují přímo data souborů, ale spíše strukturovaná metadata, která mapují názvy souborů a podsložek na jejich fyzické umístění v paměťovém médiu, umožňujíc tak uživatelům a aplikacím pracovat s daty pomocí logických cest namísto přímé manipulace s hardwarem.",incorrect:"Úkolem složek v adresářové struktuře operačního systému je ukládat samotná data souborů a podsložek, čímž se stávají kontejnery pro veškerý obsah souborového systému. Složky primárně obsahují neinterpretované sekvence bajtů, podobně jako běžné soubory, a metadata hrají pouze doplňkovou roli v organizaci dat, což vyžaduje, aby operační systém neustále interpretoval obsah složek jako data souborů.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"5879ab64-2715-46a2-8c12-1ce83438841a",correct:"Interakce uživatelských programů se složkami v operačních systémech se obvykle omezuje na dva hlavní způsoby: prvním je použití cest, kdy operační systém interně zpracovává operace se složkami při voláních jako `open`, a druhým je iterace složek pomocí speciálního rozhraní, například v systémech POSIX se pro tento účel používají volání jako `opendir`, `readdir` a `closedir`, které poskytují abstrakci pro čtení obsahu složky bez přímého přístupu k diskové reprezentaci.",incorrect:"Interakce uživatelských programů se složkami v operačních systémech je primárně založena na přímém čtení a zápisu bajtů do složek pomocí volání `read` a `write`, což umožňuje aplikacím plnou kontrolu nad strukturou složky. Systémy POSIX pro iteraci složek vyžadují přímou manipulaci s diskovými bloky, a proto neposkytují žádná vysokoúrovňová volání jako `opendir` nebo `readdir`, čímž se správa složek stává náchylnější k chybám a poškození dat.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"18eb56ec-92e4-4526-ac14-bea87033e802",correct:"V operačních systémech, které implementují koncept tvrdých odkazů, je možné, aby více adresářových záznamů odkazovalo na stejný i-uzel, což znamená, že jeden fyzický soubor může být přístupný pod různými jmény a umístěními v rámci adresářové struktury.",incorrect:"V operačních systémech s tvrdými odkazy, ačkoliv jeden soubor může mít více jmen, tato jména musí být vždy umístěna v různých souborových systémech a tvrdé odkazy slouží primárně k propojení souborů mezi různými diskovými oddíly, nikoliv v rámci jednoho souborového systému.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"db155380-755d-47b4-8d57-84e3bf0a304f",correct:"I-uzly v souborovém systému si udržují počítadlo odkazů, které se inkrementuje při každém vytvoření nového tvrdého odkazu na daný soubor a dekrementuje se při odstranění odkazu. Soubor je fyzicky odstraněn z disku až v momentě, kdy toto počítadlo dosáhne nuly, a to i v případě, že existují otevřené deskriptory souboru.",incorrect:"I-uzly v souborovém systému sice mají počítadlo odkazů, ale to se týká pouze symbolických odkazů a sleduje počet symbolických odkazů na daný soubor. Pro tvrdé odkazy se počítadlo odkazů nepoužívá a soubor je smazán ihned po odstranění posledního adresářového záznamu, bez ohledu na existenci dalších odkazů.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"478e1bf5-48b5-4f03-b6f0-c34bd6ff7238",correct:"Tvrdé odkazy v souborových systémech jsou z pohledu uživatele zcela transparentní a rovnocenné, což znamená, že všechny odkazy na stejný i-uzel poskytují identický přístup k souboru a jakákoliv operace provedená skrze jeden odkaz se projeví i při přístupu skrze jakýkoliv jiný odkaz na tentýž soubor.",incorrect:"Tvrdé odkazy v souborových systémech sice umožňují sdílení souborů, ale nejsou zcela rovnocenné. Původní adresářový záznam souboru má vždy přednost a tvrdé odkazy fungují spíše jako zástupci, kteří mohou mít omezenou funkčnost nebo zpoždění v aktualizacích oproti originálnímu souboru.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"efa4362c-d04e-4c46-9610-5ec43a93b614",correct:"Měkký odkaz v souborovém systému představuje úroveň nepřímosti, protože na rozdíl od tvrdých odkazů je implementován jako samostatný objekt s vlastním i-uzlem, což znamená, že se nejedná pouze o další jméno pro existující i-uzel, ale o nezávislou entitu, která obsahuje cestu k cílovému souboru nebo adresáři.",incorrect:"Měkký odkaz v souborovém systému nepředstavuje úroveň nepřímosti, protože podobně jako tvrdé odkazy je implementován pouze jako další jméno pro existující i-uzel, což znamená, že se nejedná o nezávislou entitu, ale pouze o alternativní cestu k již existujícímu souboru nebo adresáři, bez vlastního i-uzlu.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"54c42bbb-8a8b-43d7-b9ec-8f73dfbe42be",correct:"Když operační systém během procházení adresářové struktury narazí na měkký odkaz, přečte z něj uloženou cestu a pokračuje v dalším zpracování zbývajících částí původní cesty až po vyhodnocení cesty z měkkého odkazu, což umožňuje odkazovat i na složky a vytvářet komplexní struktury odkazů.",incorrect:"Když operační systém během procházení adresářové struktury narazí na měkký odkaz, ignoruje uloženou cestu a pokračuje v zpracování zbývajících částí původní cesty, aniž by bral v úvahu obsah měkkého odkazu, což znemožňuje odkazovat na složky a omezuje měkké odkazy pouze na koncové soubory.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"1350d109-5330-43c3-b40f-cb3db48c9ae2",correct:"Na rozdíl od tvrdých odkazů, měkké odkazy umožňují vytvářet odkazy napříč různými souborovými systémy, protože cesta uložená v měkkém odkazu může směřovat do zcela jiného souborového systému, než ve kterém se nachází samotný měkký odkaz, čímž se rozšiřuje flexibilita správy souborů a adresářů.",incorrect:"Podobně jako tvrdé odkazy, měkké odkazy jsou omezeny na stejný souborový systém, a proto cesta uložená v měkkém odkazu musí vždy směřovat do stejného souborového systému, ve kterém se nachází samotný měkký odkaz, což omezuje flexibilitu správy souborů a adresářů v rámci různých systémů.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"6cba4672-06bf-42b2-ae91-ea807c89febf",correct:"Sdílená adresářová struktura v operačních systémech přináší výhody v podobě snadného předávání souborů mezi různými programy, protože soubory vytvořené jedním programem jsou okamžitě dostupné i pro ostatní programy pod stejnou cestou, což umožňuje efektivní výměnu dat a zjednodušuje integraci aplikací v rámci systému.",incorrect:"Izolovaná adresářová struktura, kde každý program má svůj vlastní privátní adresářový prostor, je klíčová pro moderní operační systémy, jelikož zabraňuje nechtěnému sdílení souborů mezi programy a tím zvyšuje bezpečnost a stabilitu systému, ačkoliv to mírně komplikuje výměnu dat mezi aplikacemi, která vyžaduje speciální mechanismy.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"1bbca779-d7cc-4bd0-a9e5-7bf8ab5a332f",correct:"Globální adresářová struktura, sdílená všemi procesy v operačním systému, usnadňuje uživatelům orientaci a organizaci dat, protože uživatel vidí konzistentní pohled na soubory a složky napříč všemi aplikacemi, což eliminuje potřebu přepínání mezi různými pohledy na souborový systém a zjednodušuje správu dat.",incorrect:"Pro zvýšení bezpečnosti a přehlednosti moderní operační systémy implementují uživatelsky specifickou adresářovou strukturu, kde každý uživatel má kompletně oddělený souborový systém, neviditelný pro ostatní uživatele, což sice komplikuje sdílení souborů mezi uživateli, ale významně posiluje ochranu soukromí a dat.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"64886f31-3e46-4b48-823e-9cd29a548685",correct:"Sdílení adresářové struktury v operačním systému, ačkoliv přináší výhody v podobě jednoduchého sdílení souborů, s sebou nese i rizika hazardu souběhu, kdy se různé programy mohou pokusit současně přistupovat ke stejným souborům nebo adresářům, což může vést k chybám a nekonzistenci dat, a vyžaduje mechanismy pro synchronizaci přístupu.",incorrect:"Moderní operační systémy eliminují riziko hazardu souběhu v souvislosti s adresářovou strukturou tím, že implementují transakční souborové operace, které zaručují atomicitu a izolaci operací, čímž se zajišťuje, že i při souběžném přístupu k souborům nedojde k datové nekonzistenci a integrita dat je vždy zachována.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"a4b75888-f823-4f47-84f5-e0126c494af4",correct:"Základní datové struktury souborového systému se odlišují od klasických datových struktur především nutností optimalizace pro blokové čtení a zápis dat, což vyžaduje minimalizaci počtu blokových operací pro zvýšení efektivity, a také odolností vůči přerušení operací, aby byla zajištěna konzistence dat i v případě neočekávaného selhání systému během zápisu.",incorrect:"Základní datové struktury souborového systému jsou identické s klasickými datovými strukturami a nevyžadují žádnou specifickou optimalizaci pro blokové čtení a zápis dat, jelikož moderní souborové systémy efektivně pracují s malými objemy dat a jsou plně odolné vůči přerušení operací díky pokročilým mechanismům atomických transakcí.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"90c14115-e8a5-4bfd-8ca8-31f1a1b5c761",correct:"Pro návrh datových struktur souborového systému je klíčové vyhnout se strukturám, které vyžadují velké množství sekvenčních operací s malým objemem dat, jako například klasický zřetězený seznam, protože prodleva mezi jednotlivými blokovými operacemi může být značná, což by vedlo k neefektivnímu využití diskového prostoru a snížení celkové výkonnosti systému.",incorrect:"Pro návrh datových struktur souborového systému je ideální upřednostňovat struktury, které vyžadují velké množství sekvenčních operací s malým objemem dat, jako například klasický zřetězený seznam, protože tyto struktury umožňují maximální flexibilitu při práci s daty a minimalizují fragmentaci diskového prostoru, čímž zvyšují celkovou výkonnost systému.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"c45d3959-e104-4a25-b683-ff3c6944c679",correct:"Robustnost datových struktur souborového systému vůči přerušení operací je zásadní požadavek, který vylučuje použití složitých algoritmů, jež by mohly vést k nekonzistentnímu stavu dat po nečekaném ukončení operace, jako například vyvažování stromů rotacemi, kde by mohlo dojít k trvalé ztrátě dat v dočasně odpojených částech struktury.",incorrect:"Robustnost datových struktur souborového systému vůči přerušení operací je sice žádoucí, ale není kritická, a proto je možné bez obav používat i složité algoritmy, které mohou dočasně uvést strukturu do nekonzistentního stavu, jako například vyvažování stromů rotacemi, jelikož moderní systémy jsou vybaveny mechanismy pro automatické obnovení dat po přerušení.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"dd8958ee-25af-46b2-bb2a-279abf454741",correct:"Bitmapa je datová struktura používaná v souborových systémech pro správu volných a využitých bloků, kde každý bit v bitmapě reprezentuje stav jednoho datového bloku na disku, což umožňuje rychlé vyhledávání volného místa díky kompaktní reprezentaci a lineárnímu uspořádání bloků. Její jednoduchost a robustnost zápisu, plynoucí z absence odkazů mezi bloky, z ní činí efektivní nástroj pro správu diskového prostoru, ačkoli atomické operace s bity v různých bitmapových blocích mohou představovat výzvu.",incorrect:"Bitmapa je složitá datová struktura používaná v souborových systémech pro správu volných a využitých bloků, kde každý byte v bitmapě reprezentuje stav jednoho datového bloku na disku, což neumožňuje rychlé vyhledávání volného místa kvůli nekompaktní reprezentaci a nelineárnímu uspořádání bloků. Její složitost a náchylnost k chybám zápisu, plynoucí z přítomnosti odkazů mezi bloky, z ní činí neefektivní nástroj pro správu diskového prostoru, a atomické operace s byty v různých bitmapových blocích nepředstavují výzvu.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"1792f9e8-ca3c-46cd-a500-f10eb1789528",correct:"V kontextu souborových systémů bitmapa funguje jako přímá reprezentace alokace diskových bloků, kde jeden bit přesně odpovídá stavu jednoho bloku, ať už je volný nebo obsazený. Tato metoda umožňuje operačnímu systému efektivně spravovat volné místo na disku a rychle identifikovat dostupné bloky pro ukládání nových dat, přičemž kompaktní povaha bitmapy minimalizuje režii spojenou s metadaty pro správu diskového prostoru.",incorrect:"V kontextu souborových systémů bitmapa funguje jako nepřímá reprezentace alokace diskových bloků, kde jeden bit přibližně odpovídá stavu několika bloků, ať už jsou volné nebo obsazené. Tato metoda neumožňuje operačnímu systému efektivně spravovat volné místo na disku a pomalu identifikovat dostupné bloky pro ukládání nových dat, přičemž nekompaktní povaha bitmapy maximalizuje režii spojenou s metadaty pro správu diskového prostoru.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"94d2f91e-de4d-4231-8a88-3da510263350",correct:"Tabulky v souborových systémech, které se používají pro ukládání metadat, se často implementují jako souvislé oblasti paměti obsahující řádky fixní velikosti, přičemž velikost řádku je zvolena tak, aby se do jednoho bloku disku vešel celočíselný počet řádků, což usnadňuje efektivní správu a přístup k metadatům.",incorrect:"Tabulky v souborových systémech, které se používají pro ukládání metadat, se implementují jako nesouvislé seznamy paměti s řádky proměnné velikosti, přičemž velikost řádku je libovolná a nebere se ohled na velikost bloku disku, což ztěžuje správu a přístup k metadatům.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"a5ef668a-4a67-4701-b346-9a8bd9d4b5ba",correct:"Pro alokaci řádků v tabulkách, které slouží k uložení metadat souborů, se běžně používá bitmapa, která umožňuje rychlé nalezení volného řádku pro zápis nových metadat a efektivní správu obsazenosti jednotlivých řádků tabulky.",incorrect:"Pro alokaci řádků v tabulkách, které slouží k uložení metadat souborů, se běžně používá spojový seznam volných řádků, což umožňuje sice flexibilní, ale pomalejší nalezení volného řádku pro zápis nových metadat a méně efektivní správu obsazenosti jednotlivých řádků tabulky.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"31f8ddf6-93ca-469c-a63a-3d489a67bc38",correct:"Tabulky pro metadata souborů jsou obvykle alokovány staticky při vytváření souborového systému, což zjednodušuje implementaci a správu, avšak může vést k neefektivnímu využití diskového prostoru a potenciálnímu vyčerpání kapacity tabulky dříve, než dojde volné místo na datech.",incorrect:"Tabulky pro metadata souborů jsou obvykle alokovány dynamicky podle potřeby během běhu systému, což maximalizuje efektivitu využití diskového prostoru a zabraňuje vyčerpání kapacity tabulky, ale značně komplikuje implementaci a správu souborového systému.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"c71f3b97-c780-4dd4-b012-0599727603fc",correct:"B-strom je n-ární vyhledávací strom, kde každý uzel může mít až n potomků, přičemž hodnota n je obvykle relativně vysoká, dosahující desítek až stovek, což přispívá k menší hloubce stromu a optimalizaci pro operace s blokovým přístupem, jako jsou diskové operace v souborových systémech.",incorrect:"B-strom je binární vyhledávací strom, kde každý uzel může mít maximálně dva potomky, což zajišťuje jednoduchost implementace a robustnost, a je primárně optimalizován pro operace s nízkou latencí, jako jsou operace v operační paměti, a není typicky používán pro správu dat na disku.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"7e10ce44-6cee-4192-bc4c-ef85aff341b2",correct:"Díky své samovyvažovací povaze si B-strom udržuje logaritmickou hloubku bez ohledu na pořadí vkládaných a odebíraných klíčů, což zaručuje, že operace přidávání i odebírání klíčů mají logaritmickou časovou složitost, a činí z B-stromu efektivní datovou strukturu pro systémy s vysokou latencí blokových operací, například pro správu indexů v databázích.",incorrect:"Kvůli své složité implementaci a nutnosti manuálního vyvažování vyžaduje B-strom pravidelnou údržbu pro zachování optimální hloubky, a operace přidávání a odebírání klíčů mají lineární časovou složitost v nejhorším případě, což ho činí méně vhodným pro systémy s vysokou latencí blokových operací, a proto se B-stromy obvykle nepoužívají v moderních databázových systémech.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"2887d54a-4c41-4b4f-b150-34340f0b3054",correct:"Podle textu, mezi typy porušení konzistence souborového systému patří narušení jednotlivé datové struktury, jako například B-strom obsahující uzel, který není platným uzlem, což může nastat, pokud byl nový odkaz zapsán dříve než samotný odkazovaný uzel.",incorrect:"Podle textu, mezi typy porušení konzistence souborového systému patří narušení jednotlivé datové struktury, jako například B-strom obsahující uzel, který není platným uzlem, což může nastat, pokud byl nový odkaz zapsán později než samotný odkazovaný uzel.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"7fb2a85c-90c1-4a01-aae8-cc6cac0893b8",correct:"Text uvádí, že konflikt informací v různých datových strukturách představuje jeden z typů porušení konzistence souborového systému, například situace, kdy bitmapa označuje řádek tabulky za volný, avšak tento řádek je současně vyplněn smysluplnými metadaty.",incorrect:"Text uvádí, že konflikt informací v různých datových strukturách nepředstavuje typ porušení konzistence souborového systému, například situace, kdy bitmapa označuje řádek tabulky za volný, avšak tento řádek je současně vyplněn smysluplnými metadaty.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"51550880-3365-4454-919f-634815238548",correct:"Nesoulad mezi metadaty a datovými bloky je v textu popsán jako další typ porušení konzistence souborového systému, přičemž jako příklad je uvedena situace, kdy metadata souboru indikují vlastníka uživatele B, ale datové bloky odkazované metadaty ve skutečnosti obsahují data uživatele A.",incorrect:"Nesoulad mezi metadaty a datovými bloky není v textu popsán jako typ porušení konzistence souborového systému, přičemž jako příklad je uvedena situace, kdy metadata souboru indikují vlastníka uživatele B, ale datové bloky odkazované metadaty ve skutečnosti obsahují data uživatele A.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"d6df9140-a97b-4f80-a8c5-7008097d0251",correct:"Dle poskytnutého textu, jedním z hlavních důvodů vzniku nekonzistence souborového systému je přerušení kritické operace, která provádí více souvisejících změn, což může být způsobeno například výpadkem napájení systému nebo kritickou chybou, vedoucí k pádu celého operačního systému.",incorrect:"Dle poskytnutého textu, jedním z hlavních důvodů vzniku nekonzistence souborového systému je dokončení kritické operace, která provádí více souvisejících změn, což může být způsobeno například výpadkem napájení systému nebo kritickou chybou, vedoucí k pádu celého operačního systému.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"5c51606c-a002-4287-8864-b1d091dfc4b2",correct:"Text vysvětluje, že i v situacích, kdy je souborový systém navržen tak, aby byl odolný vůči přerušením, může být konzistence narušena přeuspořádáním pořadí zápisů, které může být způsobeno plánovačem operačního systému nebo samotným úložným zařízením.",incorrect:"Text vysvětluje, že i v situacích, kdy je souborový systém navržen tak, aby byl odolný vůči přerušením, nemůže být konzistence narušena přeuspořádáním pořadí zápisů, které může být způsobeno plánovačem operačního systému nebo samotným úložným zařízením.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"3623fa7a-e6bc-4faf-8429-8ce9afa3e291",correct:"Podle textu, mezi metody řešení problémů s konzistencí souborového systému patří detekce problému pomocí příznaku zapsaného při korektním ukončení operačního systému a následná křížová kontrola všech metadat, která se provádí v situacích, kdy mohlo dojít k poškození.",incorrect:"Podle textu, mezi metody řešení problémů s konzistencí souborového systému patří detekce problému pomocí příznaku zapsaného při nekorektním ukončení operačního systému a následná křížová kontrola všech metadat, která se provádí v situacích, kdy mohlo dojít k poškození.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"86ad1afe-21b0-41ab-91a9-aa6ef8f5be59",correct:"Žurnál, jakožto sofistikovanější metoda pro správu metadat souborového systému, využívá transakční zpracování, což zaručuje, že operace jsou seskupeny do transakcí, a změny metadat se na disk zapisují až po úspěšném dokončení a potvrzení zápisu celé transakce do žurnálu, čímž se efektivně minimalizuje riziko poškození metadat a významně se urychluje proces zotavení systému po potenciálních haváriích.",incorrect:"Žurnál, jakožto zastaralá metoda pro správu metadat souborového systému, využívá dávkové zpracování, což zaručuje, že operace jsou seskupeny do dávek, a změny metadat se na disk zapisují až po úspěšném dokončení a potvrzení zápisu všech dávek do žurnálu, čímž se maximalizuje riziko poškození metadat a významně se zpomaluje proces zotavení systému po potenciálních haváriích.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"2bb164c8-2572-43fd-8463-7d478ac0257d",correct:"Souborový systém ext4, běžně používaný v operačním systému Linux, implementuje dvouúrovňový žurnál, přičemž základní vrstvu tvoří JBD2, který funguje jako fyzický žurnál zaznamenávající blokové operace, a druhou vrstvu představuje logický žurnál fast commit, jenž nad uzavřenými transakcemi JBD2 uchovává informace o logických operacích s metadaty, jako je odstraňování položek ze složek, což přispívá k celkové robustnosti a konzistenci systému.",incorrect:"Souborový systém ext4, běžně používaný v operačním systému Windows, implementuje pouze jednodurovňový žurnál, přičemž základní vrstvu tvoří NTFS, který funguje jako fyzický žurnál zaznamenávající blokové operace i logické operace s metadaty dohromady, a druhou vrstvu, logický žurnál fast commit, ext4 vůbec nevyužívá, což snižuje celkovou robustnost a konzistenci systému v porovnání s modernějšími souborovými systémy.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"a70bdad5-a746-4606-ac2b-94338feb0e07",correct:"Záznamy v žurnálu souborového systému musí být navrženy jako idempotentní operace, což je klíčová vlastnost pro zajištění konzistence dat po obnově systému z havárie, protože idempotentnost zaručuje, že opakované provedení stejného záznamu v žurnálu, například při restartu systému během procesu obnovy, nezpůsobí žádné další nežádoucí změny v souborovém systému a operace se provede korektně pouze jednou.",incorrect:"Záznamy v žurnálu souborového systému musí být navrženy jako neidempotentní operace, což je klíčová vlastnost pro maximalizaci výkonu systému po obnově z havárie, protože neidempotentnost zaručuje, že opakované provedení stejného záznamu v žurnálu, například při restartu systému během procesu obnovy, způsobí žádoucí změny v souborovém systému a operace se provede opakovaně pro zajištění maximální propustnosti.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"4fd747c6-428a-44be-9c9b-d1ba95fde0b1",correct:"Jednou z metod, jak se vyhnout nekonzistenci metadat v operačních systémech, je princip, který spočívá v neměnnosti datových struktur, kde se místo přímé modifikace existující struktury vytváří její nová verze s využitím odkazů na nezměněné části, což eliminuje potřebu kopírovat celou datovou strukturu a je efektivní zejména u stromových struktur.",incorrect:"Jednou z metod, jak se vyhnout nekonzistenci metadat v operačních systémech, je princip, který spočívá v přímé modifikaci datových struktur na místě, kde se existující struktura upravuje bez vytváření nové verze, což minimalizuje režii spojenou s kopírováním a je efektivní u lineárních datových struktur.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"3377f562-fc0d-4efa-9457-914a96fad1e4",correct:"Při implementaci principu neměnných datových struktur, kde změna vyžaduje vytvoření kopie, je nutné rekurzivně aktualizovat odkazy na modifikované části struktury, a pro zajištění konzistence metadat v souborovém systému je klíčová synchronizace zápisu, která v případě stromových struktur často spočívá v atomickém zápisu nového kořene stromu po dokončení všech změn.",incorrect:"Při implementaci principu neměnných datových struktur, kde změna vyžaduje vytvoření kopie, není nutné rekurzivně aktualizovat odkazy na modifikované části struktury, a pro zajištění konzistence metadat v souborovém systému není nutná synchronizace zápisu, protože atomické operace zajišťují konzistenci i bez explicitní synchronizace, a to platí i pro stromové struktury.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"153ee28e-04e5-40ca-a906-57976a21d387",correct:"V kontextu souborových systémů se pro implementaci neměnných metadat často využívají B-stromy, protože jejich stromová struktura efektivně minimalizuje množství kopírovaných dat při změnách, a tento přístup má paralely s principem copy-on-write, známým z optimalizace správy paměti, kde se kopie dat vytváří až při pokusu o zápis, čímž se šetří systémové prostředky.",incorrect:"V kontextu souborových systémů se pro implementaci neměnných metadat často využívají lineární seznamy, protože jejich sekvenční struktura efektivně minimalizuje množství kopírovaných dat při změnách, a tento přístup nemá žádné paralely s principem copy-on-write, známým z optimalizace správy paměti, kde se kopie dat vytváří okamžitě při alokaci, čímž se šetří systémové prostředky.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"0b895050-5baf-419e-86b7-673bb580d510",correct:"Cílem správy volného místa v souborovém systému je nejen rychlé nalezení oblasti pro ukládání dat, ale také snaha udržet data souborů blízko sebe a minimalizovat externí fragmentaci, což zlepšuje výkon a efektivitu diskového prostoru, a to zejména při operacích vytváření a rozšiřování souborů, kde je efektivní alokace klíčová.",incorrect:"Cílem správy volného místa v souborovém systému je výhradně rychlé nalezení oblasti pro ukládání dat, přičemž se nebere ohled na udržení dat souborů blízko sebe ani minimalizaci externí fragmentace, protože tyto aspekty nemají vliv na výkon a efektivitu diskového prostoru, a moderní operační systémy se zaměřují pouze na rychlost alokace bez ohledu na další faktory.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"506420ca-9f38-43ee-babf-b3eea4aec855",correct:"Pro organizaci volných bloků v souborových systémech se běžně používají bitmapy nebo B-stromy, přičemž bitmapy jsou efektivní pro správu volných bloků v alokačních skupinách a B-stromy umožňují pokročilejší metody vyhledávání volného místa, například podle adresy nebo velikosti, a jsou vhodné pro systémy, kde je kladen důraz na škálovatelnost a flexibilitu správy diskového prostoru.",incorrect:"Pro organizaci volných bloků v souborových systémech se běžně používají výhradně bitmapy, zatímco B-stromy se pro správu volného místa nepoužívají, protože jsou příliš složité a neefektivní ve srovnání s bitmapami, které poskytují dostatečný výkon pro všechny běžné operace správy volného místa, a moderní systémy se od B-stromů odklánějí.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"feb61c1c-8cbc-4a0a-addd-fd7dded04187",correct:"B-stromy používané pro správu volného místa mohou být implementovány různými způsoby, včetně stromů, kde je klíčem adresa prvního bloku volné souvislé skupiny, stromů, kde je klíčem velikost volné oblasti, nebo kombinací obou přístupů, což umožňuje flexibilní a efektivní vyhledávání volného místa podle různých kritérií a optimalizaci pro specifické požadavky souborového systému.",incorrect:"B-stromy používané pro správu volného místa jsou vždy implementovány výhradně tak, že klíčem je velikost volné oblasti, a ostatní metody implementace, jako například použití adresy prvního bloku volné souvislé skupiny jako klíče, se v moderních souborových systémech nepoužívají kvůli jejich nižší efektivitě a praktické nepoužitelnosti v reálných scénářích správy diskového prostoru.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"aefcb36d-0987-4edf-876c-74a34ce63cea",correct:"Snaha o alokaci souborů do souvislých bloků v souborovém systému je motivována dvěma hlavními důvody: zlepšením rychlosti sekvenčního čtení souborů a umožněním úspornějších záznamů v metadatech souborového systému, což celkově přispívá k vyšší efektivitě a výkonu, a je zvláště důležité pro velké soubory a aplikace vyžadující vysokou propustnost dat.",incorrect:"Snaha o alokaci souborů do souvislých bloků v souborovém systému je motivována pouze snahou o úspornější záznamy v metadatech, zatímco zlepšení rychlosti sekvenčního čtení souborů není relevantním důvodem, protože moderní diskové technologie minimalizují rozdíl mezi sekvenčním a náhodným přístupem, a proto je snaha o souvislou alokaci zbytečná.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"f61ec897-3917-4a8e-b5c8-537b595c796f",correct:"Některé souborové systémy, jako například ufs, ffs a ext2, používají pro organizaci volného místa alokační skupiny, kde každá skupina má vlastní bitmapu volných bloků a tabulku i-uzlů, což umožňuje lepší lokalitu dat a metadat a snižuje fragmentaci v rámci jednotlivých skupin, a tento přístup je efektivní pro systémy s velkým počtem malých souborů.",incorrect:"Všechny moderní souborové systémy, včetně ufs, ffs a ext2, používají pro organizaci volného místa globální bitmapu volných bloků pro celý diskový oddíl, a koncept alokačních skupin s vlastními bitmapami a i-uzly se již v moderních systémech nepoužívá kvůli jeho neefektivitě a složitosti správy v rozsáhlých diskových polích a moderních úložných architekturách.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"eb873512-725f-4bdd-ab3d-7017250b3a28",correct:"V souvislosti s ukládáním souborů do blokových zařízení operačního systému se fragmentace dat objevuje jako důsledek externí fragmentace, kdy volné místo na disku není souvislé a nově vytvářené soubory nebo rozšiřované stávající soubory musí být ukládány do nesouvislých bloků, což vede k fragmentaci samotných dat souboru a snížení efektivity přístupu k nim.",incorrect:"V souvislosti s ukládáním souborů do blokových zařízení operačního systému se fragmentace dat objevuje primárně jako přímý důsledek nedostatku fyzické paměti RAM, což nutí operační systém fragmentovat soubory na disku za účelem uvolnění paměti, přičemž externí fragmentace hraje v tomto procesu pouze sekundární roli a nemá významný dopad na výkon čtení dat z disku.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"f19a2988-4f56-4a88-9df6-bb1479b13f5b",correct:"Při správě souborů v operačním systému, fragmentace dat, kdy jsou soubory uloženy v nesouvislých blocích, primárně zhoršuje výkon operací čtení, protože mechanické disky musí provádět časově náročné skoky mezi různými fragmenty souboru, zatímco u moderních SSD disků sice fragmentace dat má menší dopad na rychlost čtení, ale stále může negativně ovlivnit celkovou propustnost systému.",incorrect:"Při správě souborů v operačním systému fragmentace dat, projevující se nesouvislým uložením souborů, má nejvýraznější negativní dopad na rychlost zápisu nových dat na disk, zatímco operace čtení z fragmentovaných souborů nejsou prakticky ovlivněny, protože moderní diskové řadiče dokáží efektivně kompenzovat fragmentaci a zajistit plynulý přístup k datům bez ohledu na jejich fyzické uložení.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"c8841295-0864-4ccd-9559-54a94b5cb5dd",correct:"Tradiční způsob reprezentace souborů na disku využívá tabulky odkazů uložené v i-uzlu a v nepřímých blocích, kde každý záznam v tabulce směřuje na jeden datový blok, což je sice flexibilní, avšak pro rozsáhlé soubory může být správa diskového prostoru méně efektivní kvůli potenciálně velkému množství odkazů.",incorrect:"Tradiční způsob reprezentace souborů na disku se spoléhá na tabulky odkazů výhradně v i-uzlu, kde každý záznam ukazuje na jeden datový blok, což je navrženo pro maximální efektivitu správy diskového prostoru i u rozsáhlých souborů a eliminuje potřebu nepřímých bloků pro zjednodušení struktury metadat.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"494efab7-8103-4168-ba0b-f8e2a1aa7bc9",correct:"Použití extentů pro reprezentaci souborů na disku představuje vylepšení oproti tradičnímu přístupu tím, že namísto odkazování na jednotlivé datové bloky se odkazuje na souvislé oblasti datových bloků, což vede k úspornějšímu a efektivnějšímu využití metadat, obzvláště u souborů s daty uloženými sekvenčně.",incorrect:"Použití extentů pro reprezentaci souborů na disku je méně efektivní než tradiční přístup, protože extenty odkazují na nesouvislé datové bloky, což komplikuje správu metadat a snižuje výkon při sekvenčním přístupu k datům, a proto se extenty používají pouze v omezených specifických případech.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"b5bbd2dc-2e9f-4f3b-b165-5bcdb900c2b4",correct:"Vyhledávání datového bloku podle offsetu v metadatech, které využívají tabulku odkazů v tradiční reprezentaci souborů, má lineární složitost vzhledem k délce tabulky, avšak tato tabulka je obvykle menší než odpovídající tabulka jednotlivých adres, a při čtení celého souboru je celková složitost asymptoticky stejná a prakticky často lepší.",incorrect:"Vyhledávání datového bloku podle offsetu v tradiční reprezentaci souborů s tabulkami odkazů má konstantní složitost, protože tabulka odkazů je navržena tak, aby umožňovala přímý přístup k jakémukoli datovému bloku bez ohledu na velikost souboru, což zajišťuje vysokou rychlost vyhledávání i u velmi rozsáhlých souborů.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"d58b071d-107f-4bda-9ecf-f0bbb1a55c9d",correct:"Soubory s proměnnou délkou jsou v operačních systémech ukládány v blocích o pevné velikosti, což je klíčové pro správu úložného prostoru a efektivní přístup k datům, avšak toto blokové ukládání může vést k vnitřní fragmentaci, kdy část alokovaného bloku zůstane nevyužita kvůli proměnlivé délce souborů.",incorrect:"Soubory s pevnou délkou jsou v operačních systémech ukládány v blocích o proměnné velikosti, což je klíčové pro správu úložného prostoru a neefektivní přístup k datům, avšak toto blokové ukládání nemůže vést k vnitřní fragmentaci, kdy část alokovaného bloku zůstane využita kvůli pevné délce souborů.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"ef44607a-6d1b-4290-8a67-01160574ff1f",correct:"Vnitřní fragmentace vzniká, protože operační systémy alokují souborům celočíselný počet bloků pevné velikosti, a pokud soubor nevyužije celý poslední alokovaný blok, vznikne nevyužité místo uvnitř tohoto bloku, které představuje režii a plýtvání úložným prostorem.",incorrect:"Vnější fragmentace nevzniká, protože operační systémy alokují souborům neceločíselný počet bloků proměnné velikosti, a pokud soubor využije celý poslední alokovaný blok, nevznikne využité místo uvnitř tohoto bloku, které nepředstavuje režii a neplýtvání úložným prostorem.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"af5a3ca4-8560-49d6-bf24-a5aacc4750c3",correct:"Zarovnání souborů na hranice bloků pevné velikosti je kompromisem v návrhu operačních systémů, který sice způsobuje vnitřní fragmentaci a nevyužité místo, ale zároveň umožňuje efektivnější operace se soubory a jednodušší správu metadat, což celkově zrychluje přístup k datům.",incorrect:"Nezarovnání souborů na hranice bloků proměnné velikosti je kompromisem v návrhu operačních systémů, který sice nezpůsobuje vnitřní fragmentaci a nevyužité místo, ale zároveň neumožňuje efektivnější operace se soubory a jednodušší správu metadat, což celkově zpomaluje přístup k datům.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"0e58c5f6-dd13-46f5-a9a0-baaa471b7c39",correct:"Klasické řešení pro reprezentaci složek v souborovém systému se vyznačuje lineární časovou složitostí operací vyhledávání a odstraňování položek, zatímco operace vkládání je realizována v konstantním čase, což je efektivní pro malé složky, avšak z důvodu nepředvídatelnosti velikosti adresářů se v praxi běžně nepoužívá.",incorrect:"Klasické řešení pro reprezentaci složek v souborovém systému se vyznačuje konstantní časovou složitostí operací vyhledávání a odstraňování položek, zatímco operace vkládání je realizována v lineárním čase, což je efektivní pro velké složky a je proto běžně používaným řešením v moderních souborových systémech.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"6e291604-a590-412c-b096-fc66be99ed57",correct:"Hašovaná reprezentace složek v souborovém systému využívá hašovací tabulku pro uložení položek, což teoreticky umožňuje dosáhnout konstantní časové složitosti operací, avšak praktická výkonnost závisí na kvalitě hašovací funkce a distribuci jmen položek, přičemž iterace nad takovou složkou vrací položky v náhodném pořadí.",incorrect:"Hašovaná reprezentace složek v souborovém systému využívá hašovací tabulku pro uložení položek, což zaručuje logaritmickou časovou složitost operací a iterace nad takovou složkou vrací položky seřazené podle klíče, což je ideální pro aplikace vyžadující sekvenční přístup k datům.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"f095abeb-98ed-49f1-a400-e2daf89e0180",correct:"Stromová reprezentace složek v souborovém systému používá B-strom pro uložení položek, kde jména položek slouží jako klíče, a zajišťuje logaritmickou časovou složitost pro všechny operace, včetně vyhledávání, vkládání a odstraňování, přičemž iterace nad takovou složkou vrací položky seřazené podle jména.",incorrect:"Stromová reprezentace složek v souborovém systému používá B-strom pro uložení položek, kde jména položek slouží jako klíče, a zajišťuje lineární časovou složitost pro všechny operace, přičemž iterace nad takovou složkou vrací položky v náhodném pořadí.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"6e9f8ee6-bd88-4dda-aaa6-99e81d824e93",correct:"Zatímco klasické a hašované složky v souborovém systému jsou obvykle ukládány do datových bloků, podobně jako běžné soubory, stromové složky jsou přirozeněji považovány za součást metadat, což je běžná praxe v souborových systémech, které využívají B-stromy pro správu metadat v různých rolích.",incorrect:"Klasické, hašované i stromové složky v souborovém systému jsou obvykle ukládány výhradně do datových bloků, což zajišťuje jednotný přístup a správu úložného prostoru, a metadata se pro ukládání složek v moderních souborových systémech vůbec nepoužívají.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"}]},{uuid:"6b63955f-4e35-42cc-a033-58a2921b3496",sectionNumber:"4",sectionTitle:"Virtualizace periferií",statements:[{uuid:"686028c0-20c3-4a03-9acd-4ac27da564d4",correct:"Mezi pomocná vnitřní zařízení, která jsou klíčová pro funkčnost moderních počítačů, se řadí především řadiče sběrnic, jež zajišťují nezbytnou komunikaci a správu datového toku mezi procesorem, operační pamětí a dalšími hardwarovými komponentami uvnitř systému.",incorrect:"Mezi pomocná vnitřní zařízení počítačů se primárně řadí externí periferie jako tiskárny a skenery, které jsou připojeny k počítači zvenčí a zajišťují interakci s vnějším prostředím, zatímco řadiče sběrnic jsou považovány za méně důležité pro základní funkčnost systému.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"2a37bab7-b37c-416c-a608-be43426e30a2",correct:"Perzistentní úložiště, jako jsou pevné disky nebo SSD disky, slouží v počítačových systémech k dlouhodobému a spolehlivému uchování dat i v případě odpojení napájení, což je fundamentální pro zachování dat uživatelů a systémových informací mezi jednotlivými pracovními relacemi.",incorrect:"Perzistentní úložiště v počítačových systémech slouží výhradně k dočasnému ukládání dat operační paměti během krátkodobých výpočtů a po ukončení běhu programu se data automaticky a bezpečně mažou, čímž se minimalizuje riziko neoprávněného přístupu k informacím.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"57aeddea-68f2-4ac9-a0dc-c852f164cb42",correct:"Síťová rozhraní představují zásadní komponenty umožňující počítačům komunikovat v rámci sítí, a to jak lokálních, tak rozsáhlých, přičemž tato rozhraní realizují fyzické i logické propojení, které je nezbytné pro sdílení dat, zdrojů a provoz moderních distribuovaných aplikací a služeb.",incorrect:"Síťová rozhraní v počítačích jsou určena výhradně pro interní komunikaci mezi komponentami uvnitř jednoho počítače a nemají žádnou funkční roli v propojování počítačů do sítí, přičemž komunikace mezi počítači je řešena jinými, zcela oddělenými mechanismy.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"5eb24569-35c6-4e68-bbc0-2783f21baa22",correct:"Terminál, chápaný jako komplexní uživatelské rozhraní, integruje nejen obrazovku pro vizuální prezentaci informací a klávesnici pro zadávání textových příkazů, ale obvykle zahrnuje i další vstupní a výstupní zařízení, jako jsou myši, tiskárny, skenery a audio periferie, čímž poskytuje uživateli kompletní prostředky pro interakci s počítačem.",incorrect:"Terminál v moderním pojetí je striktně omezen na základní zobrazovací jednotku, tedy pouze obrazovku, a klávesnici pro zadávání znaků, přičemž veškerá další zařízení, jako myš, tiskárna nebo skener, jsou považována za volitelná a nesouvisející rozšíření, která nejsou integrální součástí terminálu.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"8ea74fe1-470d-461a-b2c1-4d2792c6c22d",correct:"Komunikace s periferiemi, které produkují a konzumují data v malém objemu, se typicky realizuje mapováním registrů těchto zařízení na fyzické adresy v paměti systému, což umožňuje procesoru přistupovat k registrům zařízení pomocí standardních instrukcí pro práci s pamětí, jako by se jednalo o běžnou operační paměť.",incorrect:"Komunikace s periferiemi, které produkují a konzumují data v malém objemu, se typicky realizuje mapováním registrů procesoru na fyzické adresy v paměti systému, což vyžaduje, aby operační systém pro každý přístup k periferii musel přeprogramovat mapování registrů procesoru a následně použít speciální instrukce pro komunikaci s periferiemi.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"aca8c7db-1097-48d4-8d01-08073dc6303a",correct:"Registry zařízení, na rozdíl od registrů procesoru, představují pevné paměťové buňky s předem definovanou funkcí, které jsou z pohledu hlavního procesoru adresovatelné entity, a jejich hodnoty se mohou měnit v čase i bez přímého zásahu hlavního procesoru nebo operačního systému, což se považuje za událost generovanou zařízením.",incorrect:"Registry zařízení jsou identické s registry procesoru a slouží k dočasnému uložení dat během výpočtů prováděných hlavním procesorem.  Z pohledu operačního systému registry zařízení nejsou adresovatelné přímo a vyžadují pro přístup speciální instrukce jádra operačního systému, přičemž jejich hodnoty se mění pouze na základě přímých instrukcí hlavního procesoru.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"63dc0db9-9b9e-45b9-9bfd-edc5d75611eb",correct:"Dostupnost dat z produkčních zařízení je často časově závislá, protože data jsou zpřístupněna po určité vnější události a jejich životnost je omezena kapacitou paměti zařízení, která funguje na principu FIFO, což vyžaduje, aby operační systém data včas přečetl, aby nedošlo k jejich ztrátě přepsáním novými daty.",incorrect:"Dostupnost dat z produkčních zařízení není časově závislá, protože data jsou trvale uložena v paměti zařízení a operační systém má neomezený čas na jejich přečtení. Paměť zařízení funguje na principu LIFO, což zajišťuje, že nejnovější data jsou vždy dostupná a starší data jsou automaticky archivována pro pozdější zpracování.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"0e103eb7-b263-4930-aff4-3f26cfb1587b",correct:"Kromě mapování registrů zařízení do fyzické paměti (memory-mapped IO) existuje i metoda komunikace s periferiemi nazývaná port-mapped IO, která využívá odlišný adresní prostor pro porty a vyžaduje speciální instrukce procesoru pro přístup k těmto portům, avšak tato metoda je považována za zastaralou a v moderních systémech se používá méně často.",incorrect:"Port-mapped IO je modernější a běžněji používaná metoda komunikace s periferiemi než memory-mapped IO. Port-mapped IO sdílí stejný adresní prostor jako operační paměť, ale nevyžaduje žádné speciální instrukce procesoru, což zjednodušuje programování a zvyšuje výkon systému při komunikaci s periferiemi.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"5fdcd92b-d56d-445a-8813-2b776c4ace34",correct:"Programovaný vstup/výstup (PIO) je metoda komunikace se zařízeními, která spočívá v přenosu dat postupným čtením a zápisem registrů zařízení hlavním procesorem, což vyžaduje aktivní účast procesoru v pravidelných časových intervalech určených přenosovou rychlostí a velikostí vyrovnávací paměti zařízení.",incorrect:"Programovaný vstup/výstup (PIO) je metoda komunikace se zařízeními, která spočívá v přenosu dat bez nutnosti aktivní účasti hlavního procesoru, kdy se data přenášejí automaticky pomocí řadiče přímého přístupu do paměti (DMA) a procesor je o dokončení operace informován přerušením.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"3a15f43d-fc53-4453-9f00-5d628769df64",correct:"Programovaný vstup/výstup (PIO) je efektivní a vhodná metoda pro komunikaci se zařízeními v případech občasných datových přenosů nebo přenosů s velmi malou šířkou pásma, jelikož v těchto scénářích je režie spojená s aktivní účastí procesoru v rozumných mezích a nezatěžuje systém nadměrně.",incorrect:"Programovaný vstup/výstup (PIO) je vysoce efektivní a preferovaná metoda pro přenos velkých objemů dat mezi operační pamětí a periferiemi, protože minimalizuje režii procesoru a umožňuje dosáhnout maximální možné přenosové rychlosti díky přímé manipulaci s registry zařízení.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"8cea97ad-0ab5-41d6-aa23-bf8197810832",correct:"Přímý přístup do paměti (DMA) umožňuje asynchronní přenos dat mezi periferiemi a operační pamětí, čímž se minimalizuje zapojení CPU a je zvláště vhodný pro časté nebo objemné přenosy dat, jako jsou síťové operace, komunikace s SSD disky a grafickými procesory. Tato metoda je klíčová pro efektivní fungování moderních počítačových systémů, kde je potřeba rychle přesouvat velké objemy dat bez zbytečného zatížení hlavního procesoru.",incorrect:"Přímý přístup do paměti (DMA) vyžaduje synchronní přenos dat mezi periferiemi a operační pamětí, čímž se maximalizuje zapojení CPU a je nevhodný pro časté nebo objemné přenosy dat, jako jsou síťové operace, komunikace s SSD disky a grafickými procesory. Tato metoda je klíčová pro neefektivní fungování moderních počítačových systémů, kde není potřeba rychle přesouvat velké objemy dat bez zbytečného zatížení hlavního procesoru.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"76095e3e-96a9-4319-bff7-bb20eeeb06e7",correct:"Asynchronní přenos dat metodou DMA může být realizován buď dedikovaným pomocným procesorem, který je součástí sběrnice a přijímá instrukce od hlavního procesoru, nebo může být řízen přímo periferií na základě podobných instrukcí od hlavního procesoru. Obě metody umožňují efektivní přenos dat mezi operační pamětí a periferiemi bez přímé účasti výpočetních jader hlavního procesoru.",incorrect:"Asynchronní přenos dat metodou DMA může být realizován pouze dedikovaným pomocným procesorem, který je součástí sběrnice a přijímá instrukce od hlavního procesoru, a nemůže být řízen přímo periferií. Obě metody vyžadují přímou účast výpočetních jader hlavního procesoru pro efektivní přenos dat mezi operační pamětí a periferiemi.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"2659b930-e1c0-487e-847d-756e9b2ec8d7",correct:"Při přenosu dat metodou DMA na sdílené sběrnici, jako je PCI, se role řídícího prvku sběrnice (bus master) může dočasně přesunout z procesoru na periferii, která provádí přenos dat mezi pamětí a sebou. Toto dočasné převzetí řízení sběrnice periferií je nezbytné, protože v daném okamžiku může sběrnici řídit pouze jedno zařízení, a procesor se přenosu DMA neúčastní.",incorrect:"Při přenosu dat metodou DMA na sdílené sběrnici, jako je PCI, role řídícího prvku sběrnice (bus master) nikdy nemůže přesunout z procesoru na periferii, a periferie nemůže provádět přenos dat mezi pamětí a sebou bez aktivní účasti procesoru. Toto trvalé držení řízení sběrnice procesorem je nezbytné, protože v daném okamžiku musí sběrnici řídit procesor, i když se procesor přenosu DMA neúčastní.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"b7fa5024-dde9-48b3-a626-3fc1308f867e",correct:"Je zásadní rozlišovat přímý přístup do paměti (DMA), kde periferie a operační paměť komunikují přímo bez účasti hlavního procesoru, od mapování paměti zařízení do fyzického adresního prostoru, kde procesor komunikuje s periferií bez přímé účasti operační paměti v samotném datovém přenosu, i když operační paměť adresy jsou používány pro mapování. Tyto dva koncepty se liší v tom, kdo iniciuje a provádí datový přenos a jaké komponenty se na něm přímo podílejí.",incorrect:"Není zásadní rozlišovat přímý přístup do paměti (DMA) a mapování paměti zařízení do fyzického adresního prostoru, protože v obou případech periferie a operační paměť komunikují přímo s účasti hlavního procesoru. Oba koncepty se neliší v tom, kdo iniciuje a provádí datový přenos a jaké komponenty se na něm přímo podílejí, a jsou v podstatě zaměnitelné z hlediska funkčnosti operačního systému.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"f4075836-963f-4893-b664-c44975be1185",correct:"V klasické implementaci DMA, ačkoliv operační systém udává periferii instrukce ohledně fyzických adres, které smí používat, neexistuje efektivní mechanismus, jak vynutit dodržování těchto instrukcí. To představuje významné bezpečnostní riziko, jelikož v takovém systému nic nebrání periferii v neoprávněné modifikaci obsahu paměti, včetně potenciálního přepsání kódu jádra a získání kontroly nad celým systémem.",incorrect:"V klasické implementaci DMA operační systém efektivně kontroluje přístup periferií do fyzické paměti prostřednictvím hardwarových mechanismů, které zajišťují, že se periferie striktně drží instrukcí operačního systému a nemohou překročit přidělené fyzické adresy. Tím je eliminováno jakékoli bezpečnostní riziko spojené s neoprávněným přístupem periferií do paměti a zneužitím DMA pro modifikaci kódu jádra.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"048a3f4a-6fc6-4da4-9dd5-5d2ab213e18c",correct:"IO-MMU představuje řešení bezpečnostních rizik spojených s DMA implementací tím, že zavádí mechanismus překladu adres pro periferie, analogický k MMU pro software. Toto zařízení je programovatelné výhradně operačním systémem, což umožňuje efektivní izolaci periferií nejen vzájemně, ale i od samotného operačního systému a veškerého dalšího softwaru běžícího v systému, čímž se významně zvyšuje bezpečnost DMA operací.",incorrect:"IO-MMU sice zavádí překlad adres pro periferie, ale je programovatelné jak operačním systémem, tak i ovladači periferií, což umožňuje flexibilnější správu DMA, avšak současně snižuje úroveň izolace periferií. Tato architektura sice přináší určité bezpečnostní výhody oproti klasickému DMA, ale plně neeliminuje riziko neoprávněného přístupu periferií do paměti, zejména v kontextu potenciálně škodlivých ovladačů.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"88ed048d-d032-4aa8-985b-ffb7b591978f",correct:"Sběrnice v počítači se skládá z fyzické vrstvy, která se stará o signalizaci a časování, a logické vrstvy, která definuje chování zařízení na sběrnici na vyšší úrovni, zahrnující adresaci, konfiguraci zařízení a přenosy dat. Logická vrstva je klíčová pro správnou komunikaci a organizaci datového toku mezi komponentami počítače.",incorrect:"Sběrnice v počítači se skládá pouze z fyzické vrstvy, která se stará o signalizaci a časování, a neobsahuje logickou vrstvu pro definování chování zařízení na vyšší úrovni, jako je adresace a konfigurace zařízení. Veškerá komunikace je řízena výhradně fyzickými signály.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"bd5d831a-6ad7-4a04-b51f-c6494c0e8f85",correct:"Řadič sběrnice, který propojuje sběrnice blíže hlavnímu procesoru s dalšími sběrnicemi, je považován za typ periferie, protože je s ním možné komunikovat a je často nutné s ním komunikovat pro správnou funkci systému. Tato komunikace umožňuje konfiguraci a správu připojených zařízení.",incorrect:"Řadič sběrnice, který propojuje sběrnice blíže hlavnímu procesoru s dalšími sběrnicemi, není považován za typ periferie, protože jeho primární funkcí je pouze zprostředkování komunikace mezi sběrnicemi a nikoliv interakce s procesorem. Řadič sběrnice je transparentní prvek bez možnosti konfigurace.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"81649a66-35ae-48b4-8326-bf42806920a0",correct:"Zatímco paměťová sběrnice typicky slouží výhradně pro připojení modulů RAM, sběrnice PCIe je mnohem univerzálnější a umožňuje připojení široké škály zařízení, včetně síťových rozhraní, pevných disků NVMe a řadičů dalších sběrnic jako USB a SATA. To demonstruje hierarchickou a rozmanitou povahu sběrnicových systémů v moderních počítačích.",incorrect:"Paměťová sběrnice a sběrnice PCIe mají v počítači stejnou úroveň univerzálnosti a obě umožňují připojení široké škály zařízení, včetně modulů RAM, síťových rozhraní, pevných disků NVMe a řadičů dalších sběrnic jako USB a SATA. Rozdíl mezi nimi spočívá pouze v rychlosti přenosu dat.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"abbcfd7d-5553-4118-bcd8-98ed9c1fd23a",correct:"Hlavním úkolem sběrnice v počítači je efektivní přenos dat, včetně adresace potřebné k jejich správnému směrování, a signalizace různých událostí, přičemž konfigurace a enumerace připojených periferií jsou považovány za vedlejší, avšak důležité úkoly. Bez těchto funkcí by počítač nemohl správně fungovat a komunikovat se svými komponentami.",incorrect:"Hlavním úkolem sběrnice v počítači je pouze konfigurace a enumerace připojených periferií, zatímco přenos dat a signalizace událostí jsou vedlejší funkce, které sběrnice zajišťuje pro podporu periferií. Primární význam sběrnice spočívá v inicializaci a nastavení hardwaru.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"8f8e0e4e-d3a3-4b9e-9202-f4ef295bfe62",correct:"V kontextu síťové karty funguje komponenta MAC jako řadič sběrnice MII, která propojuje MAC a PHY komponenty, což ukazuje, že i v rámci specializovaných zařízení se sběrnicové architektury a koncept řadičů uplatňují pro interní komunikaci. Tento přístup umožňuje modulární design a standardizaci rozhraní.",incorrect:"V kontextu síťové karty komponenta MAC nepůsobí jako řadič sběrnice, ale pouze jako rozhraní pro vyšší vrstvy síťového protokolu, a komunikace mezi MAC a PHY komponentami se neuskutečňuje prostřednictvím sběrnice MII. Komunikace je realizována proprietárním rozhraním specifickým pro danou síťovou kartu.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"2bf793f2-5d02-4df1-a523-8ffe3d499c7c",correct:"Enumerace sběrnice je klíčový proces v moderních operačních systémech, který automaticky detekuje a identifikuje připojená periferní zařízení a jejich specifické parametry bez nutnosti manuálního zásahu uživatele, což usnadňuje konfiguraci a správu hardwaru v počítačovém systému.",incorrect:"Enumerace sběrnice vyžaduje aktivní účast uživatele pro manuální konfiguraci a identifikaci připojených periferních zařízení, jelikož moderní operační systémy nejsou schopny automaticky detekovat hardware bez přímého uživatelského vstupu během procesu enumerace sběrnice, což komplikuje správu hardwaru.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"bc88bb98-aa2a-4502-87f4-634cdadacaf8",correct:"Prostřednictvím enumerace sběrnice operační systém získá jedinečné identifikátory pro každé detekované periferní zařízení, což mu umožňuje přesně určit typ zařízení a jeho výrobce, a následně automaticky aktivovat nebo nainstalovat příslušné softwarové ovladače, čímž se zajišťuje správná funkčnost hardwaru.",incorrect:"Proces enumerace sběrnice operačnímu systému poskytuje pouze obecné informace o kategorii zařízení, avšak neumožňuje získat unikátní identifikátory, což znemožňuje automatickou detekci výrobce a typu zařízení a vyžaduje manuální instalaci ovladačů, jelikož enumerace sběrnice neposkytuje dostatečné detaily.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"2ebf69af-7c36-42b5-9d41-b79d0ab1d3d2",correct:"Ovladače zařízení v operačním systému fungují jako abstrakční vrstva pro hardwarová zařízení a zprostředkovávají komunikaci mezi operačním systémem a periferiemi. Jejich klíčovou funkcí je transformace datových formátů a správa řídicích i uživatelských dat, což zajišťuje bezproblémovou interakci a funkčnost různých hardwarových komponent v systému. Tato abstrakce umožňuje operačnímu systému a aplikacím komunikovat s hardwarem jednotným způsobem, nezávisle na konkrétním modelu zařízení.",incorrect:"Ovladače zařízení v operačním systému fungují primárně jako přímé rozhraní k hardwarovým periferiím, obcházející operační systém za účelem zvýšení výkonu. Jejich hlavním úkolem je optimalizovat rychlost přenosu dat a minimalizovat latenci přímou manipulací s hardwarovými registry a řídicími signály. Tento přímý přístup k hardwaru umožňuje vysoce specializovanou a efektivní komunikaci, přizpůsobenou specifickým charakteristikám každého periferního zařízení, čímž se snižuje režie spojená s intervencí operačního systému.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"afaf1370-ec4d-431d-86c3-738667b3659b",correct:"Komunikace ovladače zařízení s periferií zahrnuje nejen přenos uživatelských dat, jako jsou bloky dat na disku nebo síťové rámce, ale také řídicí data. Tato řídicí data jsou klíčová pro konfiguraci a správu zařízení, umožňují ovlivňovat jeho chování a aktivovat specifické funkce nad rámec pouhého přenosu dat.  Řídicí data tak hrají zásadní roli v komplexní interakci mezi operačním systémem a hardwarem, zajišťují flexibilitu a kontrolu nad periferiemi.",incorrect:"Komunikace ovladače zařízení s periferií se omezuje výhradně na přenos uživatelských dat, přičemž řídicí data jsou zpracovávána výhradně operačním systémem mimo ovladač. Ovladač se stará pouze o efektivní přenos datových bloků a rámců, zatímco veškerá konfigurace a správa zařízení probíhá na úrovni operačního systému, bez přímého zapojení ovladače do řídicích operací.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"63dea0ee-4702-4dfd-a9a7-32241ca3e578",correct:"Podle textu, když operační systém potřebuje zapsat data na pevný disk, ovladač disku vytvoří požadavek a za pomoci ovladače sběrnice jej zapíše do fronty disku. Disk následně interně provede operace a pomocí sběrnice přenese data do operační paměti. Po dokončení přenosu disk informuje ovladač událostí, který pak předá potvrzení operace operačnímu systému. Tento proces ilustruje vrstvenou komunikaci a spolupráci mezi různými ovladači.",incorrect:"Podle textu, když operační systém potřebuje zapsat data na pevný disk, ovladač disku přímo zapisuje data na fyzickou adresu disku, obcházející ovladač sběrnice pro zvýšení rychlosti. Disk následně interně provede operace a přenese data do operační paměti, přičemž veškerá komunikace probíhá výhradně mezi ovladačem disku a diskem, bez zapojení ovladače sběrnice do procesu zápisu dat.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"f1f1e9bb-3d21-4187-8bc2-30431a7b04e1",correct:"V kontextu ovladačů sběrnic, ovladač SATA sběrnice nevykonává přímý výpočet fyzických adres registrů potřebných pro komunikaci. Namísto toho využívá služeb ovladače PCIe sběrnice, ke které je řadič SATA připojen. Tato závislost a hierarchie ovladačů sběrnic demonstruje modulární design operačního systému, kde složitější úlohy jsou rozděleny mezi specializované ovladače pro různé úrovně hardwarové abstrakce.",incorrect:"V kontextu ovladačů sběrnic, ovladač SATA sběrnice je plně autonomní a pro komunikaci s disky si sám vypočítává fyzické adresy registrů, bez závislosti na ovladači PCIe sběrnice. Ovladač PCIe sběrnice slouží pouze k inicializaci a správě PCIe rozhraní, ale nemá žádný vliv na adresování a komunikaci s disky na úrovni SATA sběrnice.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"052a71e3-a612-440f-bdc9-e8e081f14d95",correct:"Fyzický terminál, určený pro oboustrannou komunikaci s uživatelem, se skládá ze dvou hlavních částí: výstupní a vstupní. Výstupní část je typicky tvořena obrazovkou, která uživateli zobrazuje výstupy systému. Vstupní část pak zahrnuje klávesnici, a případně i myš nebo jiné ukazovací zařízení, umožňující uživateli zadávat vstupy a ovládat systém.",incorrect:"Fyzický terminál, určený pro jednosměrnou komunikaci s uživatelem, se skládá pouze z výstupní části, konkrétně z obrazovky. Tato obrazovka slouží výhradně k zobrazování výstupů systému uživateli, přičemž fyzický terminál neobsahuje žádnou vstupní část, jako je klávesnice nebo myš, a tudíž neumožňuje uživateli zadávat vstupy do systému.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"e0293a7e-9b52-4193-8212-8a3d8a719a93",correct:"Virtualizace textového terminálu spočívá ve vytvoření několika virtuálních terminálů, jejichž počet může být vyšší než počet fyzických terminálů. Klíčovým aspektem virtualizace je schopnost zapamatovat si obsah obrazovky každého virtuálního terminálu a umožnit přepojování vstupních zařízení mezi nimi, přičemž aktivace virtuálního terminálu obnoví jeho uložený obsah na fyzické obrazovce.",incorrect:"Virtualizace textového terminálu se zaměřuje pouze na sdílení fyzického terminálu mezi více uživateli současně, aniž by se zabývala vytvářením virtuálních terminálů s vlastním obsahem obrazovky. Proces virtualizace nevyžaduje zapamatování obsahu obrazovky a neumožňuje přepojování vstupních zařízení, přičemž aktivace virtuálního terminálu nemá vliv na obsah fyzické obrazovky.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"65c0dd05-1749-4c7c-b77b-80a3ef639a63",correct:"V kontextu virtualizovaných terminálů je možné fyzickou klávesnici připojit nebo odpojit od virtuálního terminálu bez jakéhokoli dopadu na program, který daný virtuální terminál aktuálně používá. Přepojování klávesnice a obrazovky je synchronizované, což zajišťuje, že fyzická obrazovka vždy zobrazuje ten virtuální terminál, ke kterému je právě připojena fyzická klávesnice pro zadávání vstupů.",incorrect:"V prostředí virtualizovaných terminálů je připojení nebo odpojení fyzické klávesnice od virtuálního terminálu operace, která má přímý a okamžitý vliv na program běžící v daném virtuálním terminálu, často vedoucí k jeho chybovému ukončení. Synchronizace mezi přepojováním klávesnice a obrazovky neexistuje, což způsobuje, že fyzická obrazovka může zobrazovat obsah jiného virtuálního terminálu, než ke kterému je připojena klávesnice.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"f8a60bcd-d76c-463f-92fb-e00c2de6a24d",correct:"Jeden virtuální terminál může být používán více programy současně, avšak pouze jeden z nich je aktivní a ovládá terminál v daném okamžiku, zatímco ostatní programy čekají na své přidělení času a zdrojů pro interakci s terminálem. Tato funkcionalita umožňuje spouštění interaktivních programů z jiných interaktivních programů, kde volající program předává kontrolu terminálu volanému programu, a terminál se vrací volajícímu programu po ukončení nebo přerušení volaného programu.",incorrect:"Jeden virtuální terminál může být používán více programy současně, přičemž všechny programy jsou aktivní a současně ovládají terminál, což umožňuje paralelní interakci s terminálem a efektivní sdílení zdrojů mezi různými programy bez nutnosti čekání na přidělení času. Tato funkcionalita zajišťuje, že všechny spuštěné programy mohou neomezeně interagovat s terminálem bez přepínání kontextu.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"76baf7d7-61dd-4342-82b7-6d5e78df2c84",correct:"V obrazovkovém režimu virtuálního terminálu má program schopnost cíleně modifikovat obsah, tedy jednotlivé znaky, v libovolném políčku obdélníkové mřížky, která reprezentuje obrazovku terminálu, což poskytuje detailní kontrolu nad zobrazením a umožňuje vytvářet komplexní textové uživatelské rozhraní pro interakci s uživatelem.",incorrect:"V obrazovkovém režimu virtuálního terminálu program nemá možnost cíleně modifikovat obsah jednotlivých políček obdélníkové mřížky obrazovky, ale je omezen pouze na sekvenční zápis znaků do jednoho řádku, podobně jako v řádkovém režimu, což omezuje možnosti tvorby komplexních textových uživatelských rozhraní a interaktivních aplikací.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"b5811f2d-7d00-46a2-9695-7017719122a1",correct:'Virtuální klávesnice v operačních systémech může pracovat ve dvou režimech: buď transparentně přeposílá data z fyzické klávesnice, čímž umožňuje aktivnímu programu v aktivním virtuálním terminálu přijímat vstup, nebo může fungovat jako "nulová" klávesnice, která nedělá nic, a k takové jsou připojené programy, které čekají na vstup, dokud nejsou přepojeny na fyzickou klávesnici.',incorrect:'Virtuální klávesnice v operačních systémech typicky pracuje pouze v jednom režimu, a to v režimu aktivního zpracování vstupu, kdy nezávisle na fyzické klávesnici aktivně generuje události a data pro aplikace, přičemž režim transparentního přeposílání dat z fyzické klávesnice, nebo režim "nulové" klávesnice, není pro virtuální klávesnice obvyklý ani podporovaný.',sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"10b85960-c5a2-4638-bf3b-8a43bb540fcd",correct:'V kontextu virtualizace klávesnice v operačních systémech platí, že aplikace jsou vůči klávesnici pasivní a nemohou ji přímo ovládat, což znamená, že i "nulová" virtuální klávesnice, která nedělá vůbec nic, splňuje požadavky aplikace na vstupní zařízení, protože aplikace pouze pasivně přijímá vstup, pokud je jí doručen.',incorrect:'V operačních systémech aplikace aktivně ovládají virtuální klávesnici a vyžadují, aby virtuální klávesnice poskytovala komplexní služby a funkce pro zpracování vstupu, a proto "nulová" virtuální klávesnice, která by nedělala nic, by byla pro aplikace zcela nepoužitelná a nesplňovala by jejich standardní požadavky na vstupní zařízení.',sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"4873d0db-4e42-47ad-b5a1-c34cd0fcee7f",correct:"Textové terminály, ačkoliv historicky významné, se ukázaly jako nedostatečné pro širokou škálu moderních aplikací, zejména pro ty, které vyžadují vizuálně bohaté rozhraní, jako jsou editory fotografií, protože jejich základní stavební prvek, buňka s písmeny, je principiálně omezený v možnostech grafického vyjádření a interakce s uživatelem ve srovnání s grafickými systémy založenými na pixelech.",incorrect:"Textové terminály jsou plně dostačující pro všechny moderní aplikace, včetně graficky náročných programů jako jsou editory fotografií, protože jejich základní stavební prvek, buňka s písmeny, umožňuje flexibilní a detailní grafické vyjádření a interakci s uživatelem, srovnatelné s grafickými systémy založenými na pixelech, a dokonce v některých aspektech je překonává, například v efektivitě zpracování textových dat.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"25013f71-cee7-4d8a-84ba-6e297db47f15",correct:"V grafickém režimu operačního systému dochází k zásadní změně v reprezentaci obrazu, kdy jsou tradiční buňky s písmeny, charakteristické pro textové terminály, nahrazeny pixely, což jsou malé obdélníkové prvky, jejichž barvu může aplikace individuálně ovlivňovat a tím vytvářet libovolný vizuální obsah na obrazovce, což otevírá cestu k mnohem bohatším a flexibilnějším uživatelským rozhraním.",incorrect:"V grafickém režimu operačního systému zůstávají buňky s písmeny základním prvkem pro reprezentaci obrazu, a pixely jsou pouze doplňkovým prvkem sloužícím k vylepšení textového výstupu, přičemž aplikace stále primárně manipuluje s buňkami s písmeny a nemůže přímo ovlivňovat barvu jednotlivých pixelů, což omezuje flexibilitu grafického výstupu ve srovnání s textovými terminály.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"808cbfee-5073-4123-9a44-4c14610f8021",correct:"Z hlediska virtualizace vstupních zařízení, jako je klávesnice a myš, platí v grafickém režimu podobná omezení jako v textovém režimu, což znamená, že možnosti virtualizace těchto zařízení jsou stále relativně omezené, nicméně grafická obrazovka jako výstupní zařízení nabízí větší flexibilitu než textová obrazovka a umožňuje implementaci nových metod virtualizace, které nejsou v textovém režimu možné.",incorrect:"Z hlediska virtualizace vstupních zařízení, jako je klávesnice a myš, grafický režim odstraňuje veškerá omezení, která existovala v textovém režimu, a umožňuje plně flexibilní virtualizaci těchto zařízení bez jakýchkoliv kompromisů, přičemž grafická obrazovka nenabízí žádné nové metody virtualizace oproti textové obrazovce, a virtualizace výstupu zůstává stejně omezená jako v textovém režimu.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"c0e9b5df-8ce9-439a-9c31-4cd3c1d81028",correct:"Okenní systémy fungují na principu virtualizace grafické obrazovky, kde každá aplikace obdrží vlastní virtuální obrazovku, která se následně zobrazuje jako okno na fyzickém displeji, přičemž přesné chování a vlastnosti těchto oken se mohou lišit v závislosti na konkrétním implementaci okenního systému.",incorrect:"Okenní systémy fungují na principu fyzického rozdělení grafické obrazovky, kde každá aplikace obdrží pevně danou část fyzického displeje, která se následně zobrazuje jako okno, přičemž chování a vlastnosti oken jsou standardizované napříč všemi okenními systémy.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"e5f8454a-20b4-4b86-ad33-c49790947f58",correct:"Koncept okenního systému je široký a zahrnuje nejen tradiční desktopová prostředí s plovoucími okny, ale i rozhraní mobilních telefonů s přepínáním mezi aplikacemi, přičemž okenní systém virtualizuje nejen grafický výstup, ale i vstupní zařízení, jako je klávesnice a myš.",incorrect:"Koncept okenního systému se omezuje výhradně na tradiční desktopová prostředí s plovoucími okny a nezahrnuje rozhraní mobilních telefonů, přičemž okenní systém se zaměřuje pouze na virtualizaci grafického výstupu a nijak neovlivňuje vstupní zařízení.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"cceddd86-b3c1-422f-8dd9-50ddec6c2284",correct:"Při zpracování událostí z ukazovacích zařízení, jako je myš nebo dotyková obrazovka, musí okenní systém provádět převod souřadnic mezi souřadnicovým systémem fyzické obrazovky a souřadnicovým systémem okna aplikace, ačkoli virtualizace oken je komplexní a zahrnuje i pokročilé funkce jako schránka a drag&drop.",incorrect:"Při zpracování událostí z ukazovacích zařízení se okenní systém obejde bez převodu souřadnic, protože souřadnicové systémy obrazovky a okna jsou vždy identické, a komplexnost okenních systémů spočívá výhradně v základní virtualizaci zobrazení oken bez dalších pokročilých funkcí.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"e620498d-01e7-4e63-a816-8d5f02e29818",correct:"Výpočet barvy každého pixelu, známý jako rasterizace, představuje výpočetně náročný proces, jehož náročnost se zvyšuje s rostoucím počtem pixelů a složitostí zobrazovaných objektů, což klade značné nároky na výpočetní zdroje systému. Specializovaný hardware, grafické procesory (GPU), byl vyvinut pro efektivní provádění těchto výpočtů.",incorrect:"Výpočet barvy každého pixelu, známý jako rasterizace, představuje výpočetně nenáročný proces, jehož náročnost se snižuje s rostoucím počtem pixelů a složitostí zobrazovaných objektů, což klade malé nároky na výpočetní zdroje systému. Specializovaný hardware, centrální procesory (CPU), byl vyvinut pro efektivní provádění těchto výpočtů.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"3ce4ae05-a91d-4a02-9817-4f78fb6106ee",correct:"Moderní grafické procesory (GPU) implementují virtualizaci na hardwarové úrovni, podobně jako centrální procesorové jednotky (CPU), a to prostřednictvím hardwarových kontextů, které umožňují efektivní přepínání a sdílení jednoho GPU mezi více aplikacemi, z nichž každá vnímá vlastní virtuální GPU, analogicky k virtuální paměti.",incorrect:"Moderní grafické procesory (GPU) neimplementují virtualizaci na hardwarové úrovni, na rozdíl od centrálních procesorových jednotek (CPU), a to prostřednictvím softwarových emulací, které neumožňují efektivní přepínání a sdílení jednoho GPU mezi více aplikacemi, z nichž každá vnímá sdílené fyzické GPU, na rozdíl od virtuální paměti.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"8a7ee744-5297-4fb8-8b22-f26c4d136505",correct:"Pixely vypočtené grafickým procesorem (GPU) se obvykle primárně ukládají do paměti, což představuje operaci náročnou na zdroje pro centrální procesor (CPU) z důvodu latence spojené s přístupem k pomalejší paměti a sběrnici, a tato náročnost se dále zvyšuje, pokud je pro výpočet barvy pixelu nutné načítat data z paměti, jako jsou textury nebo sprajty.",incorrect:"Pixely vypočtené grafickým procesorem (GPU) se obvykle primárně ukládají do registrů grafického procesoru, což představuje operaci nenáročnou na zdroje pro centrální procesor (CPU) z důvodu rychlého přístupu k registrům a sběrnici, a tato nenáročnost se dále snižuje, i když je pro výpočet barvy pixelu nutné načítat data z paměti, jako jsou textury nebo sprajty.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"11bbfd18-e298-4a0e-b821-7d0f0f095718",correct:"Kompozitor, jakožto výstupní komponenta okenního systému, má za úkol skládat obrazy jednotlivých aplikací do finálního snímku, který se následně zobrazí na obrazovce, přičemž každá aplikace zodpovídá za vykreslování pixelů ve svém okně a pro výpočet výsledného snímku se běžně využívá grafický procesor.",incorrect:"Kompozitor, jakožto vstupní komponenta okenního systému, má za úkol rozdělovat výpočetní zdroje mezi jednotlivé aplikace, přičemž každá aplikace zodpovídá za vykreslování pixelů ve svém okně a pro výpočet výsledného snímku se běžně využívá centrální procesor, zatímco grafický procesor se využívá jen zřídka.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"b83268aa-a5aa-4ac3-97c7-ca9ed9dc16c0",correct:"V rámci okenního systému kompozitor představuje klíčovou výstupní část, která se stará o finální zobrazení obsahu aplikací na obrazovce, a to tak, že skládá obrazy jednotlivých aplikací do jednoho celkového snímku s využitím grafického procesoru pro efektivní výpočet a správu souřadnic událostí.",incorrect:"V rámci okenního systému kompozitor představuje klíčovou vstupní část, která se stará o příjem uživatelského vstupu a jeho distribuci mezi aplikace, a to tak, že analyzuje vstupy jednotlivých aplikací a koordinuje jejich interakci s hardwarem bez nutnosti skládání obrazů aplikací do jednoho celkového snímku.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"3180a3f8-1af5-44d5-8bfc-31ee66eaf5b6",correct:"Grafický server představuje alternativní přístup k virtualizaci grafického subsystému, který se odlišuje od kompozitoru tím, že přijímá příkazy vyšší úrovně popisující 2D nebo 3D objekty namísto jednotlivých pixelů, což umožňuje efektivnější využití hardwaru pro rasterizaci, zejména v situacích, kdy hardware postrádá hardwarové kontexty a je obtížné jej přímo virtualizovat, a současně minimalizuje objem dat potřebný pro přenos mezi aplikací a serverem.",incorrect:"Grafický server, na rozdíl od kompozitoru, je navržen tak, aby pracoval s příkazy nižší úrovně, jako jsou jednotlivé pixely, ačkoli je schopen spravovat celý obsah obrazovky a poskytovat kreslící příkazy; tato architektura je výhodná především v situacích, kdy hardware disponuje hardwarovými kontexty a je snadno virtualizovatelný, a současně maximalizuje objem dat potřebný pro přenos mezi aplikací a serverem, což je efektivní pro lokální vykreslování.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"31497427-e635-4cad-b38d-1e50874c5884",correct:"V systémech využívajících grafický server pro virtualizaci grafického subsystému se dosahuje snížení objemu dat přenášených mezi aplikací a grafickým serverem, protože se přenášejí příkazy vyšší úrovně popisující objekty namísto rozsáhlé rastrové reprezentace, což je výhodné zejména pro vzdálené vykreslování, kde je minimalizace datového toku klíčová pro zajištění plynulého uživatelského zážitku.",incorrect:"V systémech založených na grafickém serveru pro virtualizaci grafiky je objem dat mezi aplikací a serverem maximalizován, jelikož se přenáší detailní rastrová reprezentace, což je sice náročnější na přenosovou kapacitu, ale naopak velice výhodné pro lokální vykreslování, kde je kladen důraz na maximální detail a kvalitu obrazu bez ohledu na datový tok.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"419f3345-2cc0-4839-b916-cf1f30cd51fe",correct:"Zvuková rozhraní v operačních systémech umožňují mixování výstupních zvukových proudů, což se projevuje například schopností kombinovat zvuk z více aplikací do jednoho výstupu pro reproduktory nebo sluchátka, a tím zajistit komplexnější zvukový zážitek pro uživatele.",incorrect:"Zvuková rozhraní v operačních systémech neumožňují mixování výstupních zvukových proudů, což znamená, že každá aplikace musí mít exkluzivní přístup k výstupnímu zvukovému zařízení, jako jsou reproduktory nebo sluchátka, a nelze kombinovat zvuk z více zdrojů současně.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"1a1a9197-f8a5-4ea6-ad36-45c5a6d96fef",correct:"Pro vstupní zvuková zařízení, jako jsou mikrofony a MIDI rozhraní, operační systémy typicky implementují přepínání vstupních proudů, což znamená, že v jeden okamžik může být aktivní pouze jeden vstupní zdroj, a systém mezi nimi přepíná na základě uživatelského vstupu nebo konfigurace.",incorrect:"Pro vstupní zvuková zařízení, jako jsou mikrofony a MIDI rozhraní, operační systémy běžně implementují mixování vstupních proudů, umožňující současné zpracování a kombinaci signálů z více vstupních zařízení do jednoho vstupního proudu pro flexibilnější a komplexnější zvukové vstupy.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"d2ed25ee-5ce3-4d82-9324-22564eaeef23",correct:"Latence zvukového subsystému operačního systému představuje časové zpoždění mezi akcí uživatele a zvukovou odezvou, přičemž vysoká latence může negativně ovlivnit interaktivní aplikace, jako jsou virtuální nástroje, kde je klíčová okamžitá reakce na uživatelský vstup.",incorrect:"Latence zvukového subsystému operačního systému je zanedbatelná a nemá prakticky žádný vliv na uživatelskou zkušenost, a to ani v interaktivních aplikacích, jako jsou virtuální nástroje, kde je odezva systému irelevantní pro plynulý a kvalitní zvukový výstup.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"034e5037-7bd2-4057-a483-6309eb95ef47",correct:"Zásadní rozdíl mezi tiskárnami a terminálovými periferiemi spočívá v jejich povaze zpracování úloh, kde tiskárny pracují spíše v dávkovém režimu, vyžadující ucelené úlohy pro tisk, a nejsou primárně navrženy pro interaktivní operace s okamžitou reakcí na změny požadavků operačního systému, což odlišuje jejich virtualizaci od virtualizace obrazovky.",incorrect:"Zásadní rozdíl mezi tiskárnami a terminálovými periferiemi spočívá v jejich povaze zpracování úloh, kde tiskárny pracují spíše v interaktivním režimu, umožňující okamžitou reakci na změny požadavků operačního systému a pružnou změnu tiskové úlohy, podobně jako je tomu u virtualizace obrazovky, což zdůrazňuje jejich adaptabilitu na dynamické požadavky uživatele.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"e90f6b2b-3747-4b5a-b833-18661ddf9b30",correct:"Virtualizace tiskáren v operačních systémech se implementuje pomocí fronty úloh, což je analogické k mechanismům plánování úloh v dávkových systémech, kde jednotlivé tiskové úlohy čekají ve frontě na zpracování tiskárnou, a tento přístup umožňuje sdílení tiskárny mezi různými aplikacemi a uživateli v systému.",incorrect:"Virtualizace tiskáren v operačních systémech se implementuje pomocí mechanismu prioritního plánování úloh v reálném čase, podobně jako u interaktivních systémů, kde se tiskové úlohy zpracovávají okamžitě podle priority, bez nutnosti čekání ve frontě, což zajišťuje exkluzivní přístup aplikací k tiskárně bez sdílení.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"19bc943f-780d-456a-9e22-b7c26b363875",correct:"Abstrakce tiskáren v operačních systémech se řeší zavedením společného formátu pro popis dokumentů, jako je například PDF, který umožňuje operačnímu systému konvertovat dokument do formátu specifického pro danou tiskárnu, a tím skrýt rozdíly mezi různými modely tiskáren z pohledu aplikací, i když některé aspekty tiskáren zůstávají v aplikacích relevantní.",incorrect:"Abstrakce tiskáren v operačních systémech se řeší standardizací hardwarového rozhraní tiskáren, což eliminuje potřebu softwarové konverze formátů dokumentů a zajišťuje, že všechny tiskárny pracují s jednotným formátem dat, čímž se kompletně skrývají veškeré rozdíly mezi tiskárnami z pohledu aplikací, a aplikace tak nemusí brát v úvahu specifika jednotlivých modelů.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"ea558ca0-c833-47bc-b262-c3a23f7b9a6b",correct:"Počítačová síť funguje na principu sdíleného komunikačního média, podobně jako sběrnice uvnitř počítače, kde síťová rozhraní plní obdobnou funkci jako řadiče sběrnice, umožňující propojení uzlů a výměnu dat mezi nimi, ačkoliv sítě obvykle postrádají centrální prvek s dominantní rolí, který by řídil komunikaci tak, jak to dělá procesor v rámci počítačové sběrnice.",incorrect:"Počítačová síť se vyznačuje centralizovaným řízením komunikace, podobně jako sběrnice uvnitř počítače, kde centrální uzel sítě, fungující jako hlavní řadič, koordinuje tok dat mezi jednotlivými síťovými rozhraními, zatímco síťová rozhraní samotná se starají pouze o fyzické propojení s přenosovým médiem a převod dat do formátu sítě.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"b2ab40b4-c89a-417f-8d2f-6b6ba93b7191",correct:"Síťové rozhraní v počítači slouží jako klíčové zařízení pro připojení k počítačové síti, přičemž na jedné straně se integruje do počítače skrze sběrnici, jako je například PCIe, a na druhé straně se připojuje k fyzickému přenosovému médiu sítě, ať už se jedná o drátové připojení pomocí konektoru RJ-45 nebo bezdrátové prostřednictvím antény, čímž umožňuje počítači komunikovat v síťovém prostředí.",incorrect:"Síťové rozhraní v počítači se primárně zaměřuje na softwarové zpracování síťových protokolů a správu datových toků, přičemž jeho hardwarová role spočívá pouze v pasivním zprostředkování fyzického připojení k síti pomocí konektorů jako RJ-45 nebo antén, a sběrnice PCIe slouží pouze k napájení rozhraní, nikoliv k datové komunikaci mezi rozhraním a zbytkem počítače.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"546c997e-3cec-484e-b915-481830ab637e",correct:"Podle ISO/OSI modelu síťové komunikace, vrstvy jedna a dvě, tedy fyzická a linková vrstva, jsou primárně implementovány hardwarem a představují rozhraní mezi fyzickým médiem a softwarem, zatímco vrstvy pět až sedm jsou převážně záležitostí aplikací a staví na abstrakcích poskytovaných nižšími vrstvami operačního systému.",incorrect:"Podle ISO/OSI modelu síťové komunikace, vrstvy pět až sedm, tedy aplikační vrstvy, jsou primárně implementovány hardwarem a představují rozhraní mezi fyzickým médiem a softwarem, zatímco vrstvy jedna a dvě jsou převážně záležitostí aplikací a staví na abstrakcích poskytovaných nižšími vrstvami operačního systému.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"2f677aa4-d209-42db-8df8-627c8c8bd588",correct:"Virtualizace v kontextu síťové komunikace se podle popsaného modelu ISO/OSI typicky umisťuje mezi transportní a aplikační vrstvu, konkrétně mezi čtvrtou a pátou vrstvu, protože transportní vrstva tvoří rozhraní mezi operačním systémem a aplikacemi, což je logické místo pro abstrakci a oddělení aplikační logiky od detailů síťové komunikace.",incorrect:"Virtualizace v kontextu síťové komunikace se podle popsaného modelu ISO/OSI typicky umisťuje mezi fyzickou a linkovou vrstvu, konkrétně mezi první a druhou vrstvu, protože fyzická vrstva tvoří rozhraní mezi operačním systémem a aplikacemi, což je logické místo pro abstrakci a oddělení aplikační logiky od detailů síťové komunikace.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"614b741b-020b-4cb4-acab-1f6758e41ed3",correct:"Architektura síťové komunikace je v ISO/OSI modelu záměrně rozvrstvena do několika vrstev abstrakce, podobně jako je tomu u perzistentního úložiště, protože přímá virtualizace hardwarových služeb poskytovaných fyzickou vrstvou, jako je například posílání rámců, by byla nepraktická a operační systém tak buduje vrstvy abstrakcí pro efektivnější správu a virtualizaci síťových zdrojů.",incorrect:"Architektura síťové komunikace v ISO/OSI modelu je navržena tak, aby minimalizovala počet vrstev abstrakce, a přímá virtualizace hardwarových služeb poskytovaných fyzickou vrstvou, jako je posílání rámců, je považována za efektivní a praktickou metodu pro správu síťových zdrojů, čímž se snižuje složitost operačního systému.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"112d7282-c4b9-477b-b1e7-0b1b30654ec9",correct:"Abstrakce pro potřeby operačního systému se nachází mezi druhou a třetí vrstvou síťového modelu, přičemž hlavním cílem v tomto kontextu je poskytnout abstrakci, nikoli virtualizaci, protože operační systém obvykle běží jako jediná instance a nepotřebuje virtualizovat hardware pro své interní operace v oblasti sítí.",incorrect:"Abstrakce pro potřeby operačního systému se nachází mezi čtvrtou a pátou vrstvou síťového modelu, přičemž hlavním cílem je zde virtualizace síťového hardwaru pro interní potřeby operačního systému, umožňující tak operačnímu systému efektivně spravovat síťové zdroje a izolovat jednotlivé síťové procesy.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"dd3608ef-208f-47db-a7a6-992c97fb3fa4",correct:"Pro potřeby aplikací se abstrakce a virtualizace síťové komunikace odehrávají mezi čtvrtou a pátou vrstvou síťového modelu, kde aplikační adresa je definována kombinací adresy uzlu a portu, což umožňuje aplikacím komunikovat v síti nezávisle na fyzické síťové infrastruktuře a detailních implementacích nižších vrstev.",incorrect:"Pro potřeby aplikací se abstrakce a virtualizace síťové komunikace odehrávají mezi druhou a třetí vrstvou síťového modelu, kde aplikační adresa je definována pouze adresou uzlu, bez použití portů, což zjednodušuje síťovou komunikaci aplikací a eliminuje potřebu správy portů na aplikační úrovni.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"19c1f9f2-4a06-4337-b06f-e30afbedf4fa",correct:"Klíčovým stavebním prvkem virtualizace síťové komunikace je multiplexing, který na čtvrté vrstvě přidává virtuální koncové body pro jednotlivé aplikace pomocí portů, přičemž každý port reprezentuje nezávislý proud dat nebo diskrétních paketů, což umožňuje souběžný provoz více síťových aplikací na jednom uzlu.",incorrect:"Klíčovým stavebním prvkem abstrakce síťové komunikace je směrování, které na třetí vrstvě přidává virtuální koncové body pro jednotlivé aplikace pomocí IP adres, přičemž každá IP adresa reprezentuje sdílený proud dat pro všechny aplikace, což optimalizuje využití síťové kapacity na úkor izolace mezi aplikacemi.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"63cba9f5-6dbb-4b05-98dc-6da74ef3a04e",correct:"Ethernetová technologie pro počítačové sítě se skládá ze dvou vrstev, fyzické vrstvy (PHY), která se stará o signalizaci a kabeláž a jejíž základní přenosovou jednotkou je bit, a linkové vrstvy (MAC), která odpovídá za rámce jako základní přenosové jednotky o maximální velikosti 1500 bajtů a s níž operační systém přímo komunikuje.",incorrect:"Ethernetová technologie pro počítačové sítě se skládá ze dvou vrstev, fyzické vrstvy (PHY), která se stará o rámce a linkové vrstvy (MAC), která se stará o signalizaci a kabeláž a s níž operační systém přímo komunikuje.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"782e616c-51d1-4b2d-b187-74129b164f0a",correct:"Moderní Ethernet, na rozdíl od starších implementací, využívá point-to-point topologii s aktivními přepínači, což znamená, že komunikace probíhá přímo mezi dvěma body a pro směrování dat se používají aktivní síťové prvky, a nikoliv sdílené médium.",incorrect:"Moderní Ethernet, podobně jako starší implementace, využívá sdílené médium s pasivními přepínači, což znamená, že komunikace probíhá broadcastově a pro směrování dat se používají pasivní síťové prvky, a nikoliv vyhrazené spoje.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"449dc2de-24a8-45a1-b7ef-1607cb1f2ec6",correct:"V ethernetové síti je adresace na druhé vrstvě omezena pouze na lokální segment, což znamená, že rozhraní může adresovat pouze jiná rozhraní připojená do stejné broadcastové domény, a pro komunikaci mezi různými segmenty je nutné použít adresování třetí vrstvy, například IP adresy.",incorrect:"V ethernetové síti je adresace na druhé vrstvě globální, což znamená, že rozhraní může adresovat libovolné jiné rozhraní v síti bez ohledu na segment, a pro komunikaci v rámci jednoho segmentu je nutné použít adresování třetí vrstvy, přičemž MAC adresy slouží pouze pro lokální identifikaci rozhraní uvnitř zařízení.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"1bb0159a-b780-40bb-8732-a91083674f0a",correct:"Přepínače v moderních ethernetových sítích fungují na principu mapování MAC adres na porty, což jim umožňuje efektivně přeposílat rámce pouze na port, kde se nachází cílová MAC adresa, a tím minimalizovat zbytečný provoz v síti a zvyšovat celkovou propustnost, na rozdíl od starších hubů, které rámce šířily na všechny porty.",incorrect:"Přepínače v moderních ethernetových sítích fungují na principu broadcastu, podobně jako starší huby, což znamená, že každý rámec, který přepínač přijme, je přeposlán na všechny porty kromě portu, ze kterého byl přijat, a tím je zajištěna doručitelnost rámců do všech segmentů sítě, avšak za cenu zvýšeného provozu.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"d70bd37f-64a6-463c-a4a3-ecaa6836fd29",correct:"Pro doručení paketu třetí vrstvy v ethernetové síti je nezbytné nejprve zjistit MAC adresu cílového rozhraní, což se obvykle provádí pomocí protokolu ARP, který umožňuje překlad IP adres na MAC adresy, a operační systém si udržuje překladové tabulky pro urychlení tohoto procesu, čímž se snižuje latence při komunikaci.",incorrect:"Pro doručení paketu třetí vrstvy v ethernetové síti je nezbytné nejprve zjistit IP adresu cílového rozhraní, což se obvykle provádí pomocí protokolu DHCP, který umožňuje překlad MAC adres na IP adresy, a operační systém si udržuje překladové tabulky pro urychlení tohoto procesu, primárně z důvodu přidělování dynamických IP adres.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"50dfe537-5615-404c-9aa0-bbae1a8793c5",correct:"Operační systém při odesílání paketu do sítě nejprve přidá rámec do odchozí fronty, která je implementována jako kruhová fronta v operační paměti. Tato fronta je spravována pomocí dvou ukazatelů, hlavového a koncového, přičemž koncový ukazatel je modifikován operačním systémem při přidávání nových rámců do fronty.",incorrect:"Operační systém při odesílání paketu do sítě nejprve přidá rámec do odchozí fronty, která je implementována jako lineární fronta v operační paměti. Tato fronta je spravována pomocí dvou ukazatelů, hlavového a koncového, přičemž hlavový ukazatel je modifikován operačním systémem při přidávání nových rámců do fronty.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"ed613024-e1a7-46b2-973b-ffb0b6f3dabb",correct:"Síťové rozhraní autonomně čte rámce z odchozí fronty pomocí přímého přístupu do paměti (DMA) a asynchronně je odesílá do sítě. Pro správu odchozí fronty, která je implementována jako kruhová fronta, síťové rozhraní ovládá hlavový ukazatel, který posouvá po zpracování rámce.",incorrect:"Síťové rozhraní autonomně čte rámce z odchozí fronty pomocí přímého přístupu do paměti (DMA) a synchronně je odesílá do sítě. Pro správu odchozí fronty, která je implementována jako kruhová fronta, síťové rozhraní ovládá koncový ukazatel, který posouvá po zpracování rámce.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"7c588c9b-0874-4777-a3fd-fcb95dc019bd",correct:"Odchozí fronta, sloužící pro odesílání síťových paketů, je v paměti organizována jako kruhová fronta pevné velikosti a je rozdělena na dvě části. Jedna část fronty je určena pro operační systém, který do ní umisťuje nové rámce k odeslání, zatímco druhá část je spravována síťovým rozhraním, které z ní rámce vyzvedává a odesílá do sítě.",incorrect:"Odchozí fronta, sloužící pro odesílání síťových paketů, je v paměti organizována jako lineární fronta proměnné velikosti a je rozdělena na dvě části. Jedna část fronty je určena pro síťové rozhraní, které do ní umisťuje nové rámce k odeslání, zatímco druhá část je spravována operačním systémem, který z ní rámce vyzvedává a odesílá do sítě.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"f1bbb818-031c-46f5-861e-e64eeb09f45c",correct:"Síťové rozhraní funguje na principu kruhové fronty pro příjem dat, kam rozhraní kopíruje příchozí rámce. Operační systém alokuje paměť pro tyto rámce a signalizuje rozhraní, že paměť může být přepsána, přesunutím položek do části fronty náležející rozhraní. Po zpracování dat síťové rozhraní přesune buňky zpět do části fronty operačního systému.",incorrect:"Síťové rozhraní pro příjem dat využívá lineární frontu, kam operační systém přímo zapisuje příchozí rámce. Síťové rozhraní alokuje paměť pro rámce a informuje operační systém o dostupnosti paměti přesunutím položek do fronty. Operační systém po zpracování dat přesune buňky zpět do fronty síťového rozhraní.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"40281bdc-b8ae-4d46-a1fb-b6469a993688",correct:"Příchod nových dat do příjmové fronty síťového rozhraní generuje událost, která může být sdružována pro více rámců, aby se snížila režie zpracování. Pokud operační systém odebírá data z fronty příliš pomalu a fronta se zaplní, dojde ke ztrátě příchozích dat. Standardní velikost paměťového bloku předávaného operačním systémem rozhraní odpovídá maximální přenosové jednotce (MTU), obvykle 1500 bajtů.",incorrect:"Příchod nových dat do příjmové fronty síťového rozhraní generuje událost pro každý rámec zvlášť, aby se maximalizovala okamžitá odezva systému. Pokud operační systém odebírá data z fronty příliš rychle a fronta je prázdná, dojde ke ztrátě dat z důvodu nedostatečného přísunu. Standardní velikost paměťového bloku předávaného operačním systémem rozhraní je proměnlivá a závisí na aktuálním zatížení sítě, avšak nikdy nepřesahuje 500 bajtů.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"f89084e6-9922-44ae-aeb7-7c961d9d9be9",correct:"Operační systém nemusí rámce z příjmové fronty zpracovávat okamžitě a paměť alokovanou pro ně nemusí vracet síťovému rozhraní ihned. Může alokovat nové bloky paměti pro další příchozí rámce a plné bloky, obsahující již zpracovaná data, uvolnit nebo znovu použít až po dokončení zpracování. Některá síťová rozhraní dokáží příchozí rámce rozdělit do více buněk, pokud je to nutné pro efektivnější správu paměti.",incorrect:"Operační systém musí rámce z příjmové fronty zpracovávat okamžitě a paměť alokovanou pro ně musí vracet síťovému rozhraní ihned po přijetí rámce. Nemůže alokovat nové bloky paměti pro další příchozí rámce a plné bloky musí být uvolněny před dalším příjmem dat. Síťová rozhraní nikdy nedělí příchozí rámce do více buněk, protože to by komplikovalo správu paměti a zvyšovalo latenci.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"c8c6cfa7-fb29-4daf-af90-33e30308db17",correct:"Současná síťová rozhraní s vysokou rychlostí, jako například 10GbE, mohou snadno saturovat jedno procesorové jádro kvůli množství práce potřebné pro zpracování každého paketu. Proto moderní adaptéry implementují více Tx a Rx front pro zlepšení paralelního zpracování síťového provozu, kde každá fronta má vlastní signalizaci událostí.",incorrect:"Současná síťová rozhraní s vysokou rychlostí, jako například 10GbE, obvykle nemohou saturovat jedno procesorové jádro, protože moderní procesory jsou dostatečně rychlé. Proto moderní adaptéry obvykle implementují pouze jednu sdílenou Tx a Rx frontu, čímž se minimalizuje režie spojená se správou více front a signalizací událostí.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"99c5d6f7-c537-4fb4-947a-6ae2e9286ef2",correct:"Operační systém má za úkol aktivovat a spravovat více Tx a Rx front síťového rozhraní, přičemž obvyklou konfigurací je nastavení jedné Tx a jedné Rx fronty pro každé procesorové jádro. Toto uspořádání umožňuje distribuci zátěže zpracování síťového provozu mezi různá jádra, čímž se zvyšuje celková propustnost systému a snižuje latence.",incorrect:"Operační systém nemá žádnou roli v aktivaci a správě více Tx a Rx front síťového rozhraní, protože toto je plně řízeno hardwarem síťové karty. Obvyklou konfigurací je sdílení jediné Tx a Rx fronty mezi všemi procesorovými jádry, což maximalizuje efektivitu využití hardwarových zdrojů síťového rozhraní.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"075e9c72-a971-490e-9fc5-d0eab0b5793a",correct:"Při příjmu síťových paketů rozhoduje o výběru Rx fronty síťové rozhraní, které je schopno filtrovat nebo hashovat rámce a rozřazovat je do různých front. Cílem tohoto mechanismu je udržet související rámce pohromadě ve stejné frontě, což zlepšuje lokalitu zpracování, a zároveň se snaží rovnoměrně zaplnit fronty pro lepší rozložení zátěže mezi procesorová jádra.",incorrect:"Při příjmu síťových paketů rozhoduje o výběru Rx fronty operační systém, který na základě aktuálního stavu procesů a zatížení procesorových jader dynamicky alokuje rámce do front. Cílem tohoto mechanismu je maximalizovat spravedlivost rozdělení síťových zdrojů mezi běžící procesy a minimalizovat dopad síťového provozu na interaktivní aplikace.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"e17c38dd-5ff2-4518-b49c-2cf607fb1a87",correct:"Bezdrátové sítě WiFi, založené na standardech IEEE 802, pracují na principu sdíleného média, konkrétně elektromagnetických vln šířících se vzduchem, což činí šifrování komunikace prakticky povinným pro zajištění důvěrnosti a integrity dat před odposlechem a neoprávněným přístupem.",incorrect:"Bezdrátové sítě WiFi, na rozdíl od standardů IEEE 802, využívají výhradně dedikované kabelové spoje, čímž eliminují potřebu šifrování, neboť fyzické médium samo o sobě zaručuje bezpečnost komunikace před odposlechem a neoprávněným přístupem, a proto je šifrování v WiFi sítích zcela volitelné.",sectionNumber:"4.3.9",sectionTitle:"WiFi"},{uuid:"a1743d07-ce89-4da8-a764-35af02652fa4",correct:"Vzhledem ke sdílené povaze bezdrátového média a nutnosti chránit komunikaci šifrováním, protokoly WiFi vyžadují komplexní autentizační mechanismy, které umožňují klientům a přístupovým bodům vzájemně se autentizovat a ustavit společné šifrovací klíče, čímž se minimalizuje riziko útoků typu man-in-the-middle.",incorrect:"Vzhledem k jednoduchosti a bezpečnosti bezdrátového média, protokoly WiFi nevyžadují komplexní autentizační mechanismy, a proto autentizace klientů a přístupových bodů není pro ustavení bezpečného spojení nutná a slouží pouze pro administrativní účely, nikoliv pro ochranu před útoky typu man-in-the-middle.",sectionNumber:"4.3.9",sectionTitle:"WiFi"},{uuid:"cfda184b-268d-41e0-95a9-e28c6511af39",correct:"Implementace protokolů WiFi je distribuována mezi hardware, firmware a software operačního systému, přičemž firmware, běžící na pomocném procesoru síťového rozhraní, se podílí na částečné realizaci protokolu a software operačního systému, běžící na hlavním procesoru, zajišťuje zbývající funkcionalitu, což odráží složitost těchto protokolů.",incorrect:"Implementace protokolů WiFi je soustředěna výhradně do softwaru operačního systému, běžícího na hlavním procesoru, což zjednodušuje architekturu a umožňuje snadnější aktualizace a modifikace protokolu, zatímco hardware a firmware síťového rozhraní se podílejí pouze na základních funkcích fyzické vrstvy.",sectionNumber:"4.3.9",sectionTitle:"WiFi"}]},{uuid:"dd722703-4150-4bf8-96fc-751c64b7ee97",sectionNumber:"5",sectionTitle:"Souběžnost a synchronizace",statements:[{uuid:"86cb48c8-228e-4158-9908-1f94dff1a2d9",correct:"Text definuje relaci „předcházení“ jako kauzální návaznost a zavádí graf předcházení jako tranzitivní redukci této relace, což je acyklický orientovaný graf, kde vrcholy reprezentují události a hrany reprezentují akce, které přímo spojují chronologicky po sobě jdoucí události bez přeskakování jakýchkoli mezilehlých událostí v kauzálním řetězci.",incorrect:"Text definuje relaci „předcházení“ jako chronologickou návaznost, ale graf předcházení není tranzitivní redukcí této relace, ale spíše přímou reprezentací všech chronologických závislostí, což je acyklický orientovaný graf, kde vrcholy reprezentují události a hrany reprezentují akce, které mohou spojovat chronologicky po sobě jdoucí události i s přeskakováním mezilehlých událostí v kauzálním řetězci.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"a27e13f4-d48b-45cb-be9e-0fea4f89ce14",correct:"Podle poskytnutých poznámek je graf předcházení, reprezentující relaci „předcházení“, acyklický orientovaný graf, kde každý vrchol odpovídá události, která je definována jako pozorovatelný jev v čase, a každá hrana, nazývaná akce, značí přímý kauzální vztah mezi dvěma událostmi, bez obcházení jakýchkoli intervenujících událostí v posloupnosti.",incorrect:"Podle poskytnutých poznámek je graf předcházení, reprezentující relaci „předcházení“, cyklický orientovaný graf, kde každý vrchol odpovídá akci, která je definována jako pozorovatelný jev v čase, a každá hrana, nazývaná událost, značí přímý kauzální vztah mezi dvěma akcemi, bez obcházení jakýchkoli intervenujících akcí v posloupnosti.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"ca002609-2d0e-46d1-a397-3642dc274f84",correct:"Podle definice souběžnosti událostí v operačních systémech, dvě události jsou považovány za souběžné, pokud mezi nimi neexistuje přímá kauzální souvislost, což znamená, že nenastává situace, kdy jedna událost musí nutně předcházet druhé. V grafovém znázornění událostí se souběžnost projevuje absencí cesty mezi uzly reprezentujícími tyto události, a proto mohou tyto události nastat v libovolném pořadí, potenciálně i simultánně na různých procesorových jádrech, aniž by jedna ovlivňovala nutný časový průběh druhé.",incorrect:"Souběžné události v operačních systémech jsou definovány jako události, které musí nastat přesně ve stejném okamžiku, aby se mohly považovat za skutečně souběžné. Tato definice vyžaduje, aby mezi souběžnými událostmi existovala silná časová závislost, kde jedna událost je spuštěna výhradně až po dokončení druhé, a v grafovém znázornění by souběžné události byly vždy reprezentovány uzly spojenými přímou cestou, indikující jejich vzájemnou závislost na časovém průběhu.",sectionNumber:"5.1.2",sectionTitle:"Souběžnost"},{uuid:"a08176ea-e675-4bcc-bfd2-3d0671d84fe9",correct:"Lineární uspořádání událostí, které je klíčové pro definici časového sledu v operačních systémech, vyžaduje, aby pro jakékoli dvě události, označené jako A a B, platilo, že buď událost A nutně předchází události B, nebo naopak událost B nutně předchází události A, čímž se vylučuje možnost, že by události nebyly vzájemně uspořádány v čase.",incorrect:"Nelineární uspořádání událostí, které je klíčové pro definici časového sledu v operačních systémech, vyžaduje, aby pro jakékoli dvě události, označené jako A a B, platilo, že buď událost A nutně předchází události B, nebo naopak událost B nutně předchází události A, čímž se vylučuje možnost, že by události nebyly vzájemně uspořádány v čase.",sectionNumber:"5.1.3",sectionTitle:"Časový sled"},{uuid:"d218bbdb-8364-42f0-b939-8e292d2a038a",correct:"V kontextu operačních systémů a správy událostí je časový sled událostí formálně definován jako lineární uspořádání, což znamená, že pro libovolný pár událostí, například události X a Y, musí platit striktní podmínka, že buď událost X předchází události Y, nebo událost Y předchází události X, a nemůže nastat situace, kdy by jejich vzájemný časový vztah nebyl definován.",incorrect:"V kontextu operačních systémů a správy událostí je časový sled událostí formálně definován jako nelineární uspořádání, což znamená, že pro libovolný pár událostí, například události X a Y, musí platit striktní podmínka, že buď událost X předchází události Y, nebo událost Y předchází události X, a nemůže nastat situace, kdy by jejich vzájemný časový vztah nebyl definován.",sectionNumber:"5.1.3",sectionTitle:"Časový sled"},{uuid:"8529d6ef-3197-4295-ac1d-0c2cde2dac49",correct:"Pro praktickou implementaci a reprezentaci časového sledu událostí v operačních systémech se často využívá mechanismus přidělování časových razítek, přičemž klíčovým aspektem tohoto přístupu je zajištění, aby žádné dvě události nemohly obdržet identické časové razítko, což explicitně zaručuje, že každá událost je v časovém sledu jednoznačně identifikovatelná a uspořádaná.",incorrect:"Pro praktickou implementaci a reprezentaci časového sledu událostí v operačních systémech se často využívá mechanismus přidělování časových razítek, přičemž je běžné a žádoucí, aby dvě a více událostí mohly obdržet identické časové razítko, což umožňuje efektivnější správu událostí v situacích, kdy je vyžadováno souběžné zpracování.",sectionNumber:"5.1.3",sectionTitle:"Časový sled"},{uuid:"25af9b2d-1989-47c1-b7c3-45b8d84a33f0",correct:"Relace předcházení je abstrakce v operačních systémech, která popisuje vnější chování procesů a dějů, přičemž záměrně abstrahuje od detailního časového uspořádání interních událostí. Tato abstrakce se soustředí na definování závislostí mezi událostmi tak, aby vnější chování systému bylo popsáno výhradně na základě těchto relací, a nikoliv na konkrétním časovém průběhu, který může být ovlivněn vnějšími faktory.",incorrect:"Relace předcházení v operačních systémech se zaměřuje na detailní popis vnitřního časového uspořádání událostí v procesech a dějích, s cílem přesně modelovat, jak se události odehrávají v reálném čase, včetně všech proměnlivých vlivů. Tato abstrakce klade důraz na zachycení konkrétního časového rozvržení událostí, namísto pouhého definování abstraktních závislostí mezi nimi, a vnější chování systému je tak přímo závislé na interním časovém průběhu.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"aea8f9e3-098d-4c8a-9341-ccbae2f8b062",correct:"Hazard souběhu, v kontextu relace předcházení, nastává, pokud existují alespoň dva různé časové sledy událostí, které jsou oba konzistentní s definovanou relací předcházení, avšak vedou k odlišnému vnějšímu chování systému. Tato situace indikuje porušení abstrakce relace předcházení, protože vnější chování systému by mělo být jednoznačně určeno pouze relací předcházení, a nemělo by se měnit v závislosti na konkrétním časovém průběhu událostí.",incorrect:"Hazard souběhu v kontextu relace předcházení nastává pouze tehdy, když existuje jediný časový sled událostí, který je v souladu s definovanou relací předcházení, a tento sled událostí vede k neočekávanému vnějšímu chování systému. Tato situace indikuje správnou funkci abstrakce relace předcházení, protože vnější chování systému je deterministicky určeno jediným možným časovým průběhem událostí, a jakékoli odchylky jsou považovány za chybu v relaci předcházení.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"87391ed8-c29e-4c98-85c2-942e4fff9969",correct:"V kontextu grafů předcházení v operačních systémech, termín 'hybatel' označuje entitu, která provádí akce reprezentované hranami grafu. Typickými hybateli jsou vlákna nebo periferie. Každému hybateli lze přisoudit 'barvu' hran, což umožňuje vizualizovat a rozlišovat akce prováděné různými hybateli v grafu předcházení.",incorrect:"V kontextu grafů předcházení v operačních systémech, termín 'hybatel' označuje výhradně proces, který provádí akce reprezentované hranami grafu. Periferie a vlákna nemohou být považovány za hybatele. Barva hran v grafu předcházení je globální a nespecifická pro jednotlivé hybatele.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"c46c274d-3ddf-4dcc-b13f-7468a683a4b2",correct:"Podle uvedeného příkladu s vlákny A a B, která nezávisle inkrementují sdílenou proměnnou V, je zřejmé, že konzistentní časové sledy akcí mohou zahrnovat prokládání operací obou vláken. Graf předcházení a konzistentní časové sledy ilustrují, že pořadí provádění akcí A1, A2, A3 a B1, B2, B3 není striktně sekvenční a umožňuje různé prokládané scénáře.",incorrect:"Podle uvedeného příkladu s vlákny A a B, která nezávisle inkrementují sdílenou proměnnou V, graf předcházení a konzistentní časové sledy striktně vyžadují, aby všechny akce vlákna A (A1, A2, A3) byly provedeny kompletně před zahájením jakýchkoli akcí vlákna B (B1, B2, B3). Prokládání operací mezi vlákny A a B není v tomto konkrétním případě v souladu s konzistencí časových sledů.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"77adcaee-872d-4bd4-b0ac-9f68a8f4b179",correct:"Akce jsou souběžné právě tehdy, když jsou souběžné libovolné dvě události, kterých se tyto akce týkají. Důležité je, že událost nemůže být souběžná sama se sebou, a ani události spojené jednou a tou samou akcí nemohou být souběžné, což vymezuje specifické scénáře souběžnosti akcí.",incorrect:"Akce jsou souběžné právě tehdy, když jsou souběžné všechny události, kterých se tyto akce týkají. Naopak, událost může být souběžná sama se sebou, a také události spojené jednou a tou samou akcí mohou být souběžné, což rozšiřuje možnosti souběžnosti akcí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"524df770-95ef-4957-9e1c-595687b95b90",correct:'Synchronizace akcí nastává ve specifické situaci, kdy se dvě akce sbíhají ve společné události. V kontextu souběžnosti to implikuje, že tyto akce, označované jako synchronizované, musí proběhnout prakticky "najednou", aby mohlo dojít k dané společné události, která je jejich cílem.',incorrect:"Synchronizace akcí nastává ve specifické situaci, kdy se dvě akce sbíhají v rozdílných událostech. V kontextu souběžnosti to implikuje, že tyto akce, označované jako synchronizované, mohou proběhnout v libovolném pořadí a čase, bez nutnosti jejich časové koordinace pro dosažení cílových událostí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"ce514d1f-2184-4c6f-bc3c-c0118a7cf64a",correct:"V případech, kdy akce vedou do souběžných událostí a jsou označeny jako nezávislé, je klíčové, že tyto akce mohou proběhnout v absolutně libovolném pořadí. Tato volnost v uspořádání provedení je dána charakterem nezávislých událostí, které se navzájem neovlivňují a nemají mezi sebou žádnou vazbu.",incorrect:"V případech, kdy akce vedou do souběžných událostí a jsou označeny jako nezávislé, je klíčové, že tyto akce musí proběhnout v přesně definovaném pořadí. Tato nutnost striktního uspořádání provedení je dána charakterem nezávislých událostí, které se navzájem ovlivňují a vyžadují specifickou sekvenci.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"e3a0985d-610f-4c72-add6-8d6a681f3186",correct:"Definice souběžných sledů akcí se rozšiřuje na situace, kdy sledy nesdílí žádnou událost, s jedinou výjimkou, kdy mohou sdílet počáteční a nebo koncovou událost. Tato výjimka umožňuje modelovat scénáře, kde se sledy mohou setkávat na začátku nebo na konci, ale jinak probíhají zcela odděleně.",incorrect:"Definice souběžných sledů akcí se rozšiřuje na situace, kdy sledy sdílí alespoň jednu událost, a to povinně včetně počáteční a koncové události. Tato nutnost sdílení událostí zajišťuje, že sledy jsou vzájemně provázané a jejich průběh je synchronizován skrze společné události, které je propojují.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"c51a9fc9-226c-4804-aef6-6a1ed9d4f4f1",correct:"Akce v kontextu operačních systémů slouží k propojení událostí a stavů, přičemž výpočet lze chápat jako posloupnost stavů, kde přechody mezi nimi jsou realizovány právě prostřednictvím akcí, což umožňuje modelovat dynamické chování systému a jeho reakce na vnější podněty.",incorrect:"Akce v kontextu operačních systémů jsou zcela nezávislé na stavech a událostech, a výpočet lze chápat jako statickou množinu stavů bez nutnosti akcí, což zjednodušuje modelování systému, ale neumožňuje zachytit dynamické chování a interakci s vnějším prostředím.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"b880fdef-3d7e-453e-b5df-fb15697a23d4",correct:"Stavový prostor operačního systému je reprezentován orientovaným grafem, kde vrcholy grafu představují jednotlivé stavy systému, definované hodnotami registrů procesoru a obsahem paměti, a hrany grafu reprezentují akce, které způsobují přechody mezi těmito stavy, čímž se modeluje dynamika systému.",incorrect:"Stavový prostor operačního systému je lineární posloupnost stavů, kde každý stav je následován pouze jedním dalším stavem, a akce jsou reprezentovány jako atributy stavů, nikoli jako přechody mezi nimi, což zjednodušuje analýzu, ale neodpovídá komplexní realitě operačního systému.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"02ab86a6-7913-4b09-856c-4501b80c1d24",correct:"Vstupní periferie operačního systému, jako například hodiny reálného času, mění svůj stav autonomně a nezávisle na řízení operačního systému, což znamená, že operační systém musí být schopen asynchronně reagovat na změny stavu těchto periferií a zpracovávat události iniciované vnějším světem.",incorrect:"Vstupní periferie operačního systému, jako například hodiny reálného času, jsou plně řízeny operačním systémem a jejich stav se mění pouze na základě instrukcí operačního systému, což zajišťuje synchronizaci a předvídatelnost chování systému, ale omezuje schopnost reagovat na vnější události asynchronně.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"f8045bba-6811-4e37-ba1d-870b39e76782",correct:"Běh, v kontextu stavového prostoru operačního systému, je definován jako orientovaná cesta. Tato cesta představuje posloupnost stavů, kterými systém prochází, přičemž každý přechod mezi stavy je vyvolán specifickou akcí. Běh úzce koresponduje s časovým sledem událostí, kde posloupnost událostí je propojena akcemi v čase.",incorrect:"Běh, v kontextu stavového prostoru operačního systému, je definován jako neorientovaná cesta. Tato cesta nepředstavuje posloupnost stavů, kterými systém prochází, přičemž přechody mezi stavy nejsou vyvolány specifickými akcemi. Běh nekoresponduje s časovým sledem událostí, kde posloupnost událostí není propojena akcemi v čase.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"a3fb728e-ba11-4141-ad20-09597ce90ab2",correct:"V operačních systémech můžeme sekvenci akcí interpretovat dvojím způsobem: buď jako běh, zdůrazňující posloupnost stavů a přechodů mezi nimi, nebo jako sled, kladoucí důraz na časovou posloupnost událostí. V obou interpretacích, pro jednoznačné určení konkrétního běhu nebo sledu, je nezbytné definovat počáteční stav systému nebo počáteční událost, od které se odvíjí celá sekvence.",incorrect:"V operačních systémech můžeme sekvenci akcí interpretovat pouze jedním způsobem: buď jako běh, zdůrazňující posloupnost stavů, nebo jako sled, kladoucí důraz na časovou posloupnost událostí. Pro určení konkrétního běhu nebo sledu, není nezbytné definovat počáteční stav systému nebo počáteční událost, protože sekvence akcí je sama o sobě dostatečná pro jednoznačné určení.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"2d40376c-f0ce-4419-8e05-6d1459d9259b",correct:"Příklad souběžného systému s vlákny A a B, která přistupují ke sdílené proměnné V, demonstruje, že různé pořadí provádění instrukcí (různé běhy) mohou vést k odlišným výsledným stavům systému. Tato variabilita ve výsledcích zdůrazňuje složitost stavového prostoru a potenciální problémy spojené se souběžným přístupem ke sdíleným zdrojům v operačních systémech.",incorrect:"Příklad souběžného systému s vlákny A a B, která přistupují ke sdílené proměnné V, demonstruje, že různé pořadí provádění instrukcí (různé běhy) vždy vedou ke stejnému výslednému stavu systému. Tato konzistence ve výsledcích zdůrazňuje jednoduchost stavového prostoru a absenci problémů spojených se souběžným přístupem ke sdíleným zdrojům v operačních systémech.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"5a6d2364-dce2-4a37-926d-576596dca310",correct:"V situacích, kdy hodnota uložená na určité paměťové adrese, například adrese sdílené proměnné V, má přímý dopad na vnější chování systému, mohou různé běhy s odlišnými výslednými stavy indikovat existenci hazardu souběhu. Tento hazard vzniká, když nekontrolovaný souběžný přístup ke sdíleným zdrojům vede k nepředvídatelným a nežádoucím výsledkům v chování systému.",incorrect:"V situacích, kdy hodnota uložená na určité paměťové adrese, například adrese sdílené proměnné V, má přímý dopad na vnější chování systému, různé běhy s odlišnými výslednými stavy nikdy nemohou indikovat existenci hazardu souběhu. Hazard souběhu vzniká pouze v situacích, kdy souběžný přístup ke sdíleným zdrojům je řízen operačním systémem a vede k předvídatelným a žádoucím výsledkům v chování systému.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"24f293e3-35e8-4e22-8aa3-1d540f92b19d",correct:"Kritická sekce běhu R vůči běhu S nastává tehdy, když vložení běhu S do běhu R způsobí chybu, i když samotné běhy R a S chybu nezpůsobují. Tato chyba se často označuje jako chyba atomicity a je specifickým případem hazardu souběhu, kde nežádoucí uspořádání souběžných akcí vede k chybové události, i když jednotlivé akce samy o sobě jsou korektní.",incorrect:"Kritická sekce běhu R vůči běhu S nastává tehdy, když provedení běhu S před nebo po běhu R způsobí chybu. Chyba kritické sekce se označuje jako chyba souběhu a není specifickým případem hazardu souběhu, ale obecným problémem paralelního programování, kde jakékoliv souběžné akce mohou vést k chybám, bez ohledu na jejich vzájemné uspořádání.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"7ce3737c-243d-4209-9809-1bfa9d959d5e",correct:"V kontextu kritických sekcí, chyba atomicity typicky znamená, že neočekávané proložení operací z různých souběžných běhů vede k nekonzistentnímu stavu systému. Například, v klasickém příkladu převodu peněz mezi účty, může dojít ke zdvojení nebo ztrátě peněz, pokud operace výběru a vkladu nejsou atomické a jsou proloženy operacemi jiného běhu.",incorrect:"V kontextu kritických sekcí, chyba atomicity obvykle znamená, že jakákoliv chyba v kódu jednoho z běhů vede k selhání celého systému. Například, pokud jeden běh obsahuje chybu dělení nulou, systém automaticky detekuje kritickou sekci a zastaví všechny souběžné běhy, aby se zabránilo dalším problémům, i když proložení běhů není příčinou chyby.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"f8d09a65-3450-47d2-9a69-316ec38aa928",correct:"Z textu je patrné, že symetrie kritických sekcí není nutná, což znamená, že běh B může být kritickou sekcí vůči běhu A, aniž by běh A byl kritickou sekcí vůči běhu B.  Tato asymetrie se projevuje například v situacích, kdy jeden běh provádí operace, které jsou citlivé na přerušení jiným během, zatímco operace druhého běhu nejsou ovlivněny přerušením prvním během.",incorrect:"Z textu je patrné, že kritické sekce jsou vždy symetrické, což znamená, že pokud je běh B kritickou sekcí vůči běhu A, pak je nutně i běh A kritickou sekcí vůči běhu B. Tato symetrie je základním předpokladem pro správnou synchronizaci souběžných běhů a zajišťuje, že žádný běh nemůže neúmyslně narušit atomicitu jiného běhu.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"05005e4f-9c7f-4f49-b649-4d4f26fe93e6",correct:"Problém čtenářů a písařů nastává v situacích, kdy více vláken sdílí společný zdroj dat, přičemž některá vlákna (čtenáři) data pouze čtou a jiná vlákna (písaři) data modifikují, a to asymetricky, kdy čtenáři si vzájemně nekonkurují, ale oba typy vláken konkurují písařům, a písaři konkurují i sobě navzájem.",incorrect:"Problém čtenářů a písařů nastává v situacích, kdy více vláken sdílí společný zdroj dat, přičemž všechna vlákna (čtenáři i písaři) data pouze čtou a žádná vlákna data nemodifikují, a to symetricky, kdy všechna vlákna si vzájemně konkurují a musí se navzájem vylučovat při přístupu ke sdílenému zdroji dat.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"4e22849b-b825-450b-8465-a1fd0b118b2c",correct:"V problému čtenářů a písařů je klíčové, že čtenáři si vzájemně nepředstavují kritickou sekci, což znamená, že více čtenářů může přistupovat ke sdíleným datům současně bez rizika nekonzistence dat, zatímco písaři a čtenáři s písaři si kritickou sekci představují a musí se navzájem vylučovat.",incorrect:"V problému čtenářů a písařů je klíčové, že čtenáři si vzájemně představují kritickou sekci, což znamená, že pouze jeden čtenář může přistupovat ke sdíleným datům v daném okamžiku, aby se předešlo riziku nekonzistence dat, podobně jako u písařů, kteří si také vzájemně představují kritickou sekci a musí se navzájem vylučovat.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"b90d5fb4-b858-49f3-a749-48a4ea1b109d",correct:"Nejjednodušší, avšak neefektivní řešení problému čtenářů a písařů spočívá v zavedení symetrického chování ke kritickým sekcím, kdy se i čtenáři chovají tak, jako by si vzájemně byli kritickou sekcí, čímž se zabrání souběžnému čtení, ačkoliv to není nutné a omezuje to potenciální paralelizmus operací čtení.",incorrect:"Nejefektivnější a zároveň nejjednodušší řešení problému čtenářů a písařů spočívá v zavedení symetrického chování ke kritickým sekcím, kdy se i čtenáři chovají tak, jako by si vzájemně byli kritickou sekcí, čímž se plně využije potenciální paralelizmus operací čtení a maximalizuje se propustnost systému.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"199d2c20-3002-43d4-9f6a-d668f5c40643",correct:"V situaci souběžného přístupu čtenářů a písařů ke sdíleným datům, může dojít k hladovění písařů, pokud je neustále aktivní alespoň jeden čtenář. V naivním řešení problému čtenářů a písařů, kdy čtenáři mají přednost, může neustálý příchod nových čtenářů způsobit, že písaři budou trvale blokováni a čekají na uvolnění sekce pro čtení, čímž jim bude znemožněn přístup ke sdílenému prostředku.",incorrect:"V situaci souběžného přístupu čtenářů a písařů ke sdíleným datům, k hladovění písařů dojít nemůže, i když je neustále aktivní alespoň jeden čtenář. Moderní operační systémy a sofistikované synchronizační mechanismy zajišťují, že písaři nebudou nikdy trvale blokováni čtenáři, a proto je hladovění v problému čtenářů a písařů v podstatě nemožné, a to i v naivních implementacích.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"f59b34d3-3262-41fc-82f3-285e91681d0e",correct:"Hladovění v kontextu operačních systémů označuje situaci, kdy vlákno nemůže trvale pokračovat ve svém výpočtu, aniž by nutně došlo k uváznutí. Tento stav je často způsoben nevhodnou synchronizací, která, paradoxně, má chránit před problémy souběžného přístupu. Hladovění se projevuje tak, že vlákno je neustále odsouváno stranou a nedostává přidělený procesorový čas potřebný k dokončení své práce.",incorrect:"Hladovění v kontextu operačních systémů je situace, kdy vlákno dočasně nemůže pokračovat ve svém výpočtu, ale vždy se jedná o přechodný stav, který je snadno řešitelný přidáním sofistikovanějších synchronizačních mechanismů. Hladovění je primárně způsobeno nedostatkem systémových prostředků a nemá nic společného s problémy v návrhu synchronizace, která naopak vždy hladovění efektivně předchází.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"46e2dc8e-717d-4fd3-8aec-fad85d937e02",correct:"Uváznutí, neboli deadlock, je v systémech s více vlákny běžnou příčinou hladovění. Uváznutí nastává, když se vlákna zablokují vzájemně čekáním na zdroje, které drží jiná vlákna v kruhu čekání. V důsledku toho se žádné z uváznutých vláken nemůže pohnout dál, což představuje specifický a závažný případ hladovění, kdy celý systém nebo jeho část přestane reagovat a efektivně vykonávat užitečnou práci.",incorrect:"Uváznutí, neboli deadlock, a hladovění jsou dvě naprosto odlišné a nesouvisející situace v operačních systémech. Uváznutí se týká pouze stavu, kdy program nemůže pokračovat kvůli chybě v kódu, zatímco hladovění je způsobeno výhradně nedostatkem hardwarových prostředků a nemá žádnou souvislost s uváznutím. Proto uváznutí nemůže být nikdy považováno za příčinu hladovění v žádném případě.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"95104b92-7762-4cf8-9303-e8d00d477605",correct:"Datová závislost v souběžných systémech vzniká, když akce Z čte z paměťové buňky nebo registru, do kterého naposledy zapisovala akce X. Tento typ závislosti může vést k chybám pořadí, pokud souběžné akce nejsou správně seřazeny, zvláště když je zapisující akce X krátká a čtecí akce Z trvá dlouho.",incorrect:"Datová závislost v souběžných systémech vzniká, když akce Z čte z paměťové buňky nebo registru, do kterého naposledy zapisovala akce X.  Toto je primárně problém kritických sekcí a nesouvisí s pořadím operací v souběžných systémech, protože datové závislosti jsou inherentně řešeny kritickými sekcemi zajišťujícími výhradní přístup.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"e17c1e9f-eb8e-4d41-8117-54ecdec9c9ff",correct:'Text popisuje datové závislosti v souběžných systémech jako vztah mezi akcemi, kde vstupem akce Z je paměťová buňka nebo registr, do kterého naposledy zapisovala akce X. Tento typ závislosti může vést k "chybám pořadí", pokud souběžné akce nejsou správně seřazeny, zvláště když je zapisující akce X krátká a čtecí akce Z má dlouhé trvání.',incorrect:'Text popisuje datové závislosti v souběžných systémech jako v zásadě stejný problém jako kritické sekce. Ačkoli obojí souvisí se souběžností, datové závislosti vedoucí k "chybám pořadí" se primárně řeší mechanismy vzájemného vyloučení, jako jsou semafory, což z nich činí v podstatě podmnožinu problémů kritických sekcí v souběžném programování.',sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"df2e2862-3285-4f8c-89f1-9ee5f76cac85",correct:"Problém producent-konzument v operačních systémech nastává, když skupina vláken generuje mezivýsledky, zatímco jiná skupina vláken tyto výsledky zpracovává, přičemž obě skupiny pracují souběžně, což může vést k situacím, kdy producenti vytvářejí data rychleji, než je konzumenti stíhají zpracovávat, nebo naopak, konzumenti zpracovávají data rychleji, než je producenti generují.",incorrect:"Problém producent-konzument v operačních systémech nastává, když skupina vláken generuje mezivýsledky, zatímco jiná skupina vláken tyto výsledky zpracovává, přičemž obě skupiny pracují sekvenčně, což nikdy nemůže vést k situacím, kdy producenti vytvářejí data rychleji, než je konzumenti stíhají zpracovávat, nebo naopak, konzumenti zpracovávají data rychleji, než je producenti generují.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"d4f2363f-854e-429f-b348-393e87ca25a4",correct:"V situaci producent-konzument, pokud producenti generují mezivýsledky rychleji než konzumenti je zpracovávají, může dojít k hromadění mezivýsledků, což potenciálně vyčerpá dostupnou paměť nebo způsobí ztrátu dat přepsáním dříve, než jsou zpracována, pokud není zavedena adekvátní synchronizace mezi producenty a konzumenty.",incorrect:"V situaci producent-konzument, pokud producenti generují mezivýsledky rychleji než konzumenti je zpracovávají, nemůže dojít k hromadění mezivýsledků, a to i bez synchronizace, protože operační systém automaticky řídí tok dat mezi producenty a konzumenty, čímž zabraňuje jakémukoliv potenciálnímu vyčerpání paměti nebo ztrátě dat.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"6ceb598c-de6e-4d3c-aa52-60a4878dbe20",correct:"Synchronizace v problému producent-konzument je klíčová pro zajištění efektivní spolupráce mezi vlákny, přičemž cílem je upřednostnit práci producentů, pokud je mezivýsledků nedostatek, a naopak upřednostnit práci konzumentů, pokud je mezivýsledků přebytek, a ideálně udržovat počet nezpracovaných mezivýsledků v pevných mezích, aby se předešlo problémům s pamětí a zpracováním dat.",incorrect:"Synchronizace v problému producent-konzument je zbytečná pro efektivní spolupráci mezi vlákny, protože operační systém dokáže automaticky a efektivně řídit tok mezivýsledků mezi producenty a konzumenty bez nutnosti explicitní synchronizace, přičemž se vždy upřednostňuje práce producentů bez ohledu na množství mezivýsledků.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"ea05682a-b6e6-494a-9a4b-afb3c147ab0b",correct:"V operačních systémech se můžeme setkat s problémem nedostatečné souběžnosti, kdy i přes dostatek výpočetních jader nejsou hardwarové zdroje plně využity, protože nedostatek vláken omezuje paralelní provádění akcí, které by jinak mohly probíhat souběžně, což vede k neefektivnímu využití výpočetního výkonu systému.",incorrect:"V operačních systémech se nemůžeme setkat s problémem nedostatečné souběžnosti, protože i při nedostatku výpočetních jader jsou hardwarové zdroje plně využity, protože dostatek vláken umožňuje paralelní provádění akcí, které by jinak nemohly probíhat souběžně, což vede k efektivnímu využití výpočetního výkonu systému.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"1c4b1bac-29a4-4b69-b6ef-c4d2d94d384b",correct:"Pokud výpočet obsahuje bloky, které mohou být provedeny v libovolném pořadí bez vlivu na výsledek, je možné a efektivní výpočet rozvětvit, aby se tyto bloky mohly provádět souběžně, čímž se zlepší využití vícejádrových procesorů a potenciálně se zkrátí celkový čas výpočtu, pokud je k dispozici dostatek výpočetních zdrojů.",incorrect:"Pokud výpočet obsahuje bloky, které musí být provedeny v pevném pořadí s vlivem na výsledek, je nemožné a neefektivní výpočet rozvětvit, aby se tyto bloky mohly provádět souběžně, čímž se zhorší využití vícejádrových procesorů a prodlouží se celkový čas výpočtu, i když je k dispozici dostatek výpočetních zdrojů.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"3fb52695-0be6-4644-8627-4d30c81caaa8",correct:"Vlákno v operačním systému definuje lineární uspořádání akcí, což znamená, že akce v rámci jednoho vlákna musí být prováděny sekvenčně v daném pořadí, a proto akce, které nejsou souběžné s jinými vlákny, nemohou být efektivně paralelně prováděny, i když jsou k dispozici volná výpočetní jádra.",incorrect:"Vlákno v operačním systému nedefinuje lineární uspořádání akcí, což znamená, že akce v rámci jednoho vlákna mohou být prováděny paralelně bez daného pořadí, a proto akce, které nejsou souběžné s jinými vlákny, mohou být efektivně paralelně prováděny, i když nejsou k dispozici volná výpočetní jádra.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"}]},{uuid:"2dfc454a-1180-4d9d-a73c-02e8ad67b8ed",sectionNumber:"6",sectionTitle:"Synchronizace",statements:[{uuid:"bc4eabf2-a5aa-419f-be05-681ad26f139f",correct:"Základním smyslem synchronizačních zařízení v operačních systémech je omezení souběžnosti, přičemž různé kategorie problémů souběžnosti vyžadují specifická zařízení. Tato zařízení jsou implementována jako datové struktury, umožňující existenci mnoha nezávislých instancí, které mezi sebou neinteragují. Každá instance je identifikována adresou, na které je uložen její stav, klíčový pro správnou funkci synchronizace.",incorrect:"Základním smyslem synchronizačních zařízení v operačních systémech je zvýšení souběžnosti, přičemž všechny kategorie problémů souběžnosti vyžadují univerzální zařízení. Tato zařízení jsou implementována jako sdílené globální proměnné, umožňující existenci jediné instance, která interaguje se všemi procesy. Každá instance je identifikována typem zařízení, který je klíčový pro globální funkci synchronizace.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"d21a96cd-8c62-48f5-b891-bfd7aa8cba0b",correct:"V kontextu synchronizačních zařízení v operačních systémech je důležité si uvědomit, že ačkoliv se jedná o datové struktury, různé instance těchto zařízení existují nezávisle a navzájem nesynchronizovaně. To znamená, že operace provedené na jedné instanci nemají přímý vliv na stav jiné instance téhož synchronizačního zařízení, což umožňuje jemnozrnnou kontrolu souběžnosti v rámci operačního systému.",incorrect:"V kontextu synchronizačních zařízení v operačních systémech je důležité si uvědomit, že ačkoliv se jedná o datové struktury, různé instance těchto zařízení existují závisle a navzájem synchronizovaně. To znamená, že operace provedené na jedné instanci mají přímý vliv na stav všech instancí téhož synchronizačního zařízení, což umožňuje hrubozrnnou kontrolu souběžnosti v rámci operačního systému.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"48c6512e-1ce4-4715-a350-fcb3e7c16042",correct:"Definice synchronizačního zařízení v operačních systémech se komplikuje v prostředí s virtuální pamětí a více procesy. Zatímco instance zařízení je koncepčně spjata s adresou, v případě synchronizace mezi procesy se tato adresa stává virtuální a může se lišit v závislosti na kontextu procesu. Rigorózní přístup proto vyžaduje uvažovat třídy ekvivalence virtuálních adres pro přesnou identifikaci synchronizačního zařízení.",incorrect:"Definice synchronizačního zařízení v operačních systémech se zjednodušuje v prostředí s virtuální pamětí a více procesy. Instance zařízení je vždy spjata s fyzickou adresou, která je sdílená mezi všemi procesy pro zajištění globální synchronizace. Virtuální adresy jsou irelevantní pro identifikaci synchronizačního zařízení, protože fyzická adresa je konzistentní napříč celým systémem.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"7f1fbe81-7bee-4b5c-8834-914764a51a8d",correct:'Mutex, označovaný také jako "mutual exclusion device", představuje základní synchronizační nástroj v operačních systémech, který efektivně řeší problém kritické sekce tím, že zajišťuje vzájemné vyloučení a chrání sdílené zdroje před souběžným přístupem více vláken. Jeho klíčovou funkcí je umožnit pouze jednomu vláknu v daném čase vlastnit zámek a vstoupit do chráněné kritické sekce, čímž se předchází nekonzistenci dat a závodním podmínkám.',incorrect:"Mutex, ačkoliv je považován za synchronizační nástroj, primárně neslouží k řešení problému kritické sekce, ale spíše k optimalizaci výkonu operačního systému povolením souběžného přístupu více vláken do kritických sekcí. Jeho hlavním cílem není zajištění vzájemného vyloučení, ale spíše koordinace vláken tak, aby se minimalizovaly časy čekání a maximalizovala propustnost systému, i za cenu potenciálního rizika závodních podmínek.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"8acbb160-f606-4497-988c-90ee017a23b4",correct:"Operace `lock` u mutexu je navržena tak, že pokud se vlákno pokusí zamknout mutex, který je již zamčený jiným vláknem, toto vlákno bude pozastaveno a uvedeno do stavu čekání, dokud aktuální vlastník mutexu neuvolní zámek operací `unlock`. Tento mechanismus čekání je zásadní pro synchronizaci a zaručuje, že kritická sekce bude vždy chráněna před současným vstupem více vláken, čímž se zachovává integrita sdílených dat.",incorrect:'Operace `lock` u mutexu nikdy nezpůsobí, že vlákno čeká, bez ohledu na to, zda je mutex již zamčený jiným vláknem. Vlákno, které volá `lock`, vždy okamžitě získá přístup, a pokud je mutex již "vlastněný", dojde k automatickému sdílení zámku mezi vlákny. Tento přístup eliminuje zbytečné zdržení a maximalizuje paralelizmus, i když to může vést k občasným nekonzistencím v datech v kritických sekcích.',sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"c93df86a-c617-4076-a754-7aaba3cadec8",correct:"Pro efektivní ochranu kritické sekce pomocí mutexu je naprosto klíčové, aby byla chráněna nejen samotná kritická sekce, ale také všechny běhy, vůči kterým je tato sekce kritická, a to důsledným používáním stejné instance mutexu pro všechny zúčastněné části kódu. Nesprávné použití, například ochrana pouze části kritických běhů nebo použití různých mutexů, může vést k selhání synchronizace a vzniku obtížně odhalitelných závodních podmínek.",incorrect:"Při ochraně kritické sekce mutexem je doporučeno používat pro každou kritickou sekci samostatný mutex, aby se minimalizovalo riziko vzájemného blokování a zvýšila se granularita zámků. Použití jediného mutexu pro ochranu více kritických sekcí nebo běhů se považuje za neefektivní a potenciálně škodlivé, protože to zbytečně omezuje paralelizmus a může vést k zbytečnému čekání vláken, čímž se snižuje celkový výkon systému.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"786000cd-6070-4a9c-81c4-feb351e7f15a",correct:"Zásadní upozornění týkající se mutexů spočívá v tom, že standardní implementace mutexů nedokáže detekovat situaci, kdy vlákno provede operaci `unlock` na mutexu, který aktuálně nevlastní. I když je takové odemčení logicky chybné a může mít katastrofální následky pro integritu dat a synchronizaci, operace `unlock` zpravidla uspěje bez jakéhokoliv varování nebo chybového hlášení, což klade velkou zodpovědnost na programátora pro správné používání mutexů.",incorrect:"Moderní implementace mutexů jsou vybaveny sofistikovanými mechanismy pro detekci chyb a zneužití, včetně situace, kdy se vlákno pokusí odemknout mutex, který nevlastní. V takovém případě mutex automaticky vyvolá výjimku nebo vrátí chybový kód, čímž aktivně zabraňuje potenciálním katastrofálním důsledkům a usnadňuje ladění a odhalování chyb v synchronizačním kódu, čímž se zvyšuje robustnost a spolehlivost aplikací.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"f063d29d-fa5f-43b9-bfdf-9858f4dc261b",correct:"Spinlock je synchronizační mechanismus, který se vyznačuje aktivním čekáním, což znamená, že vlákno, které se snaží získat zámek, opakovaně kontroluje stav zámku v smyčce, aniž by uvolnilo procesor. Tato implementace je efektivní v situacích, kdy je zámek držen jen krátkou dobu a přepínání kontextu by bylo dražší, ale stává se neefektivní při delším čekání nebo na jednoprocesorovém systému.",incorrect:"Spinlock je synchronizační mechanismus, který se vyznačuje pasivním čekáním, což znamená, že vlákno, které se snaží získat zámek, se uspí a uvolní procesor, dokud zámek není dostupný. Tato implementace je vždy efektivní, bez ohledu na délku čekání nebo typ systému, a je ideální i pro jednoprocesorové systémy, kde aktivní čekání může vést k neefektivnímu využití procesoru.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"c34b4399-e59f-4777-99af-0f2d43229cb4",correct:"Implementace operace lock u spinlocku s atomickou instrukcí cmpxchg zahrnuje porovnání očekávané hodnoty zámku s aktuální hodnotou v paměti a následnou výměnu hodnoty pouze v případě shody. Pokud se očekávaná hodnota neshoduje, operace se opakuje, dokud se zámek nepodaří získat atomicky, čímž se zajišťuje vzájemné vyloučení bez rizika stavu závodu.",incorrect:"Implementace operace lock u spinlocku s atomickou instrukcí cmpxchg zahrnuje pouze nastavení hodnoty zámku na zamknuto bez ohledu na aktuální stav zámku, což zjednodušuje proces získávání zámku a eliminuje nutnost opakování operace v případě, že zámek již drží jiné vlákno, a zaručuje tak efektivní a rychlé zamykání.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"c7f44b55-85c7-4c58-b57e-a45cc9a7c794",correct:"Použití spinlocku pro ochranu dlouhých kritických sekcí může vést k neefektivnímu využití procesorového času, protože vlákna čekající na zámek aktivně spotřebovávají procesorový čas v busy-waiting smyčce, místo aby procesor mohl být využit pro jiné produktivní úlohy. Proto je spinlock vhodnější pro krátkodobé kritické sekce, kde je minimalizováno plýtvání procesorovým časem.",incorrect:"Použití spinlocku pro ochranu dlouhých kritických sekcí je vysoce efektivní, protože aktivní čekání zajišťuje, že vlákna čekající na zámek okamžitě získají přístup ke kritické sekci, jakmile je zámek uvolněn, a minimalizuje se tak latence a maximalizuje propustnost systému i v případě dlouhotrvajících kritických sekcí.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"5ce0898b-d9bd-4296-bd6d-cbb94b08bdf0",correct:"“Uspávající mutex” je implementován s využitím služeb operačního systému, konkrétně systémových volání, což znamená, že operace zámku a odemčení jsou realizovány s asistencí jádra operačního systému, které spravuje fronty čekajících vláken a plánování procesů pro efektivní využití procesoru.",incorrect:"“Uspávající mutex” je implementován výhradně v uživatelském prostoru bez nutnosti systémových volání, což minimalizuje režii spojenou s přepínáním kontextu do jádra a zajišťuje vysokou efektivitu operací zámku a odemčení, srovnatelnou s atomickými instrukcemi.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"cf19e766-efd8-4846-99d9-cb07bea85a5c",correct:"Operace `lock` u “uspávajícího mutexu” v operačním systému zahrnuje kontrolu stavu zámku jádrem; pokud je zámek volný, jádro ho uzamkne a vrátí vláknu kontrolu, jinak vlákno zařadí do fronty spojené s mutexem a aktivuje plánovač pro probuzení jiného vlákna, čímž se efektivně zabrání plýtvání procesorovým časem čekáním ve smyčce.",incorrect:"Operace `lock` u “uspávajícího mutexu” se vždy pokouší o okamžité uzamčení pomocí atomických instrukcí v uživatelském prostoru a teprve v případě neúspěchu, kdy zámek je již držen jiným vláknem, dochází k systémovému volání a uspání vlákna, což minimalizuje režii systémových volání v případech, kdy je zámek často volný.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"e5d592e2-a8ca-480d-8831-e9488c4e8d4b",correct:"Odemčení “uspávajícího mutexu” v operačním systému zahrnuje kontrolu jádra, zda existují čekající vlákna ve frontě mutexu; pokud ano, jádro ihned znovu uzamkne mutex a předá ho prvnímu vláknu z fronty před návratem z systémového volání, což zajišťuje spravedlivé přidělování zámku čekajícím vláknům.",incorrect:"Odemčení “uspávajícího mutexu” je implementováno pouze jako jednoduchá atomická operace v uživatelském prostoru, která pouze uvolní zámek bez kontroly čekajících vláken a bez asistence plánovače, což zjednodušuje implementaci, ale může vést k neefektivnímu probouzení vláken a potenciálním zpožděním.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"404b41b3-48c8-4535-90e0-3cb64d05e287",correct:"Řešení pro efektivní implementaci mutexů spočívá v rozdělení stavu mutexu mezi uživatelské vlákno a operační systém, kde uživatelské vlákno rozhoduje o zamčení a odemčení pomocí atomických instrukcí podobně jako spinlock, a systémové volání se provádí jen v případě neúspěšného pokusu o zamčení.",incorrect:"Řešení pro efektivní implementaci mutexů spočívá výhradně v systémovém volání pro každý pokus o zamčení a odemčení, čímž se minimalizuje složitost uživatelského vlákna a veškerá logika správy mutexu je přesunuta do operačního systému, což zajišťuje maximální bezpečnost a minimalizuje riziko souběhu.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"5d8cbc90-0b9c-4094-b8ce-3d77508c088e",correct:"Systémová část stavu mutexu, označovaná jako futex, se skládá z fronty uspáných vláken a je svázána s uživatelskými mutexy pomocí adresy, což umožňuje operačnímu systému efektivně spravovat čekající vlákna a probouzet je pouze v případě potřeby, na základě počítadla pokusů o zamčení.",incorrect:"Systémová část stavu mutexu, označovaná jako futex, se skládá pouze z počítadla aktivních vláken, která aktuálně drží zámek, a není svázána s žádnými frontami uspáných vláken, protože operační systém probouzí vlákna čekající na mutex na základě mechanismu broadcast, čímž zajišťuje spravedlivé přidělování zámku.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"a5252e9d-4410-4874-a896-4260ca5ab136",correct:"Při odemykání mutexu se systémové volání pro probuzení čekajícího vlákna provede pouze tehdy, když je počítadlo pokusů o zamčení větší než jedna, což optimalizuje výkon a zamezuje zbytečnému probouzení vláken, pokud na mutex aktuálně žádné jiné vlákno nečeká.",incorrect:"Při odemykání mutexu se systémové volání pro probuzení čekajícího vlákna provede vždy, bez ohledu na hodnotu počítadla pokusů o zamčení, aby se zajistilo, že žádné vlákno nezůstane zbytečně spát, i když mutex může být brzy znovu odemčen jiným vláknem.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"ed6d3e78-955b-408d-8e0a-3b85d7bcecbc",correct:"Uživatelská část implementace mutexu využívá atomické instrukce pro rozhodování o zamčení a odemčení, podobně jako spinlock, a rozšiřuje stav mutexu o počítadlo vláken, která se pokusila o zamčení, což umožňuje efektivní detekci potřeby systémového volání pro probuzení čekajících vláken.",incorrect:"Uživatelská část implementace mutexu se spoléhá výhradně na standardní zámky poskytované programovacím jazykem a nevyužívá žádné atomické instrukce ani počítadlo pokusů o zamčení, přičemž veškerá synchronizace a správa čekajících vláken je plně v kompetenci operačního systému prostřednictvím futexu.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"c5725da8-5d65-45b5-81bc-481c4c4c4cfd",correct:"V situaci, kdy dva podprogramy sdílejí stejný mutex a jeden z nich volá druhý, může dojít k zablokování vlákna, pokud se naivně pokusíme o opětovné zamčení mutexu v rámci stejného vlákna, což je problém, který se řeší například použitím rekurzivních mutexů.",incorrect:"V situaci, kdy dva podprogramy sdílejí stejný mutex a jeden z nich volá druhý, nemůže dojít k zablokování vlákna, protože mutexy jsou navrženy tak, aby umožňovaly opakované zamčení stejným vláknem, což eliminuje potřebu rekurzivních mutexů.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"eb1d27dc-9105-4e7b-8d84-b2daa35f8614",correct:"Rekurzivní mutexy řeší problém opakovaného zamykání mutexu stejným vláknem tím, že si pamatují identifikátor aktuálního vlastníka mutexu a počítadlo zanoření, které se inkrementuje při každém úspěšném zamčení a dekrementuje při odemčení, přičemž mutex se skutečně odemkne až po dosažení nulového počítadla.",incorrect:"Rekurzivní mutexy řeší problém opakovaného zamykání mutexu stejným vláknem tím, že ignorují opakované pokusy o zamčení stejným vláknem a okamžitě povolí přístup, aniž by vyžadovaly počítadlo zanoření nebo identifikátor vlastníka, což zjednodušuje jejich implementaci.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"e075c6c2-2dc1-4361-a109-88b94c6de47b",correct:"Refaktorování programu s cílem vyčlenit část kódu do pomocné funkce a obalit volání kritické sekce zámkem a odemčením může být v některých případech praktickým řešením problému zablokování při volání podprogramů sdílejících stejný mutex, ale nemusí být vždy ideální, zejména pokud kritická sekce nepokrývá celé tělo funkce.",incorrect:"Refaktorování programu s cílem vyčlenit část kódu do pomocné funkce a obalit volání kritické sekce zámkem a odemčením je vždy ideálním a jednoduchým řešením problému zablokování při volání podprogramů sdílejících stejný mutex a eliminuje potřebu složitějších mechanismů, jako jsou rekurzivní mutexy.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"eed4ff10-c333-4407-9f03-e59cd5ac7822",correct:"Zařízení rwlock, určené pro řešení problému čtenářů a písařů, rozšiřuje koncept mutexu o stavy specifické pro čtení, konkrétně stavy 'čtení 1, 2, ...', umožňující více čtenářům souběžný přístup, zatímco stav 'zápis' zajišťuje exkluzivní přístup pouze pro jednoho písaře, čímž efektivněji spravuje souběžnost oproti standardnímu mutexu.",incorrect:"Zařízení rwlock, určené pro řešení problému čtenářů a písařů, funguje identicky jako standardní mutex, avšak s dodatečnými stavy pro čtení, které sice existují, ale nemají vliv na chování zámku, protože rwlock interně stále používá pouze binární stavy 'zamčeno' a 'odemčeno' bez ohledu na operace čtení či zápisu.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"4569293c-bc0c-4be6-89fb-995e39db4230",correct:"Operace wrlock na zařízení rwlock je navržena tak, aby byla exkluzivní, což znamená, že úspěšně proběhne pouze tehdy, když je zařízení ve stavu 'odemčeno'; v jakémkoli jiném stavu, včetně stavů 'čtení 1, 2, ...' nebo 'zápis', bude operace wrlock blokována, dokud se zařízení nepřepne do stavu 'odemčeno', čímž se zaručí, že v daný moment probíhá maximálně jeden zápis.",incorrect:"Operace wrlock na zařízení rwlock je navržena tak, aby byla sdílená, podobně jako rdlock, což znamená, že může úspěšně proběhnout i když je zařízení ve stavu 'čtení'; blokována bude pouze ve stavu 'zápis', aby se zabránilo konfliktům mezi zápisy, ale souběžný zápis a čtení jsou povoleny pro zvýšení propustnosti systému.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"9f0bd325-ba94-4373-bca0-83e3d6aa8377",correct:"Operace rdlock na zařízení rwlock, určená pro čtenáře, je sdílená zámková operace, která uspěje nejen ve stavu 'odemčeno', ale i ve stavech 'čtení 1, 2, ...', umožňujíc tak souběžný přístup více čtenářů;  blokována je pouze ve stavu 'zápis', aby se zabránilo konfliktu mezi čtením a zápisem, a čeká, dokud zařízení nepřejde do stavu 'odemčeno' nebo 'čtení'.",incorrect:"Operace rdlock na zařízení rwlock je exkluzivní zámková operace, která může úspěšně proběhnout pouze ve stavu 'odemčeno', podobně jako wrlock; ve stavech 'čtení 1, 2, ...' nebo 'zápis' je operace rdlock blokována, protože rwlock nepovoluje souběžný přístup ani pro čtenáře a vyžaduje výhradní přístup k zařízení pro každou operaci, včetně čtení.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"ff648c6c-fcee-4e1f-8e5b-bb390e36bc77",correct:"Mechanismus RCU (Read-Copy-Update) je alternativní řešení problému čtenářů a písařů, které se záměrně vyhýbá použití zámků a kritických sekcí, a tím umožňuje čtenářům pracovat souběžně s písaři bez nutnosti čekání na synchronizaci, což je dosaženo kopírováním datové struktury písařem a následnou aktualizací sdíleného ukazatele na novou verzi.",incorrect:"Mechanismus RCU (Read-Copy-Update) je alternativní řešení problému čtenářů a písařů, které **vyžaduje** použití zámků a kritických sekcí, a **proto ne**umožňuje čtenářům pracovat souběžně s písaři bez nutnosti čekání na synchronizaci, což je dosaženo kopírováním datové struktury písařem a následnou aktualizací sdíleného ukazatele na novou verzi.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"4b9a8331-2f6b-418c-a1c4-c70aeb1d3f46",correct:"V mechanismu RCU (Read-Copy-Update) písař neupravuje datovou strukturu přímo na místě, ale vytváří její kopii, na které provádí úpravy, zatímco čtenáři nadále pracují s původní verzí datové struktury, a až po dokončení úprav a přesměrování sdíleného ukazatele začnou noví čtenáři přistupovat k upravené kopii, což zajišťuje konzistenci dat pro čtenáře po celou dobu operace.",incorrect:"V mechanismu RCU (Read-Copy-Update) písař **upravuje datovou strukturu přímo na místě**, **aniž by vytvářel její kopii**,  zatímco čtenáři nadále pracují s původní verzí datové struktury, a až po dokončení úprav a přesměrování sdíleného ukazatele začnou noví čtenáři přistupovat k upravené kopii, což zajišťuje konzistenci dat pro čtenáře po celou dobu operace.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"995178a6-f11c-4b61-9c0e-ede8991d5f8b",correct:"Starší verze dat v mechanismu RCU (Read-Copy-Update) nemohou být uvolněny okamžitě po aktualizaci písařem, ale až poté, co je zaručeno, že žádný čtenář k nim již nepřistupuje, což se často řeší pomocí počítadla odkazů, které sleduje aktivní čtenáře, a poslední čtenář, který ukončí přístup, zodpovídá za uvolnění paměti staré verze dat.",incorrect:"Starší verze dat v mechanismu RCU (Read-Copy-Update) **mohou** být uvolněny **okamžitě** po aktualizaci písařem, **bez ohledu na to, zda k nim ještě přistupují nějací čtenáři**, což se často řeší pomocí počítadla odkazů, které sleduje aktivní čtenáře, a poslední čtenář, který ukončí přístup, zodpovídá za uvolnění paměti staré verze dat.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"e45756ea-c0c3-49ea-873d-ccec545617a9",correct:"Monitory představují abstrakci pro synchronizaci v programování, která kombinuje skrytá data a viditelné procedury, podobně jako objektově orientované programování, a jsou založeny na principu vzájemného vyloučení, což zajišťuje, že v daném okamžiku může do monitoru vstoupit pouze jedno vlákno, čímž se zjednodušuje koordinace a snižuje riziko chyb souběhu oproti přímému používání mutexů.",incorrect:"Monitory jsou sofistikovanou součástí operačního systému, která dynamicky řídí přístup k datům a procedurám, ačkoliv se podobají konceptům objektově orientovaného programování, interně nevyužívají princip vzájemného vyloučení, umožňují souběžný přístup více vláken a primárně se zaměřují na maximalizaci souběžnosti, i když to může vést ke složitější koordinaci a vyššímu riziku chyb.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"a77ad896-d276-4a9f-946b-d21c1c6c98a5",correct:"Implementace monitorů může být řešena dvěma strategiemi: ideálně překladačem, který automaticky vkládá zamykání a odemykání mutexů na začátku a konci operací, a méně ideálně ručně, kdy programátor musí zajistit správné zamykání a odemykání, přičemž v druhém případě se často využívají rekurzivní mutexy pro podporu vnořených volání operací monitoru.",incorrect:"Implementace monitorů je vždy výhradně závislá na operačním systému, který dynamicky spravuje zamykání a odemykání mutexů na základě aktuálního stavu systému, přičemž překladače nemají žádnou roli v implementaci monitorů a rekurzivní mutexy se v kontextu monitorů nikdy nepoužívají, protože by narušovaly princip vzájemného vyloučení.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"6bdb30f5-9b6f-4c61-99bf-3b8280428ab9",correct:"Přestože monitory usnadňují synchronizaci a snižují pravděpodobnost chyb souběhu, přidávají do programu více synchronizace, než je striktně nutné, což může vést k menší míře souběžnosti, ale tento kompromis mezi souběžností a bezpečností je v mnoha programech rozumný, protože minimalizuje riziko obtížně odhalitelných synchronizačních chyb.",incorrect:"Monitory jsou navrženy tak, aby minimalizovaly synchronizaci a maximalizovaly souběžnost v programech, a proto přidávají pouze absolutní minimum synchronizace potřebné pro korektní fungování, což zaručuje, že programy s monitory dosahují maximální možné paralelizace, i když to může vést k potenciálně složitější logice a obtížnějšímu ladění synchronizačních problémů.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"800699e9-437d-4548-9cb6-d24e298052f3",correct:"Monitor sám o sobě negarantuje, že program jako celek bude bez synchronizačních chyb, protože invarianty programu mohou přesahovat hranice jednotlivých monitorovaných datových struktur, což znamená, že i s použitím monitorů je stále možné, aby program obsahoval chyby souběhu, zejména v situacích, kdy je potřeba koordinovat operace mezi více datovými strukturami.",incorrect:"Monitor zaručuje, že jakýkoliv program, který ho používá, bude absolutně bez synchronizačních chyb, a to i v případech, kdy invarianty programu přesahují hranice monitorovaných datových struktur, protože monitor automaticky koordinuje synchronizaci mezi všemi datovými strukturami v programu a eliminuje veškeré potenciální chyby souběhu na systémové úrovni.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"93d36a99-a2fd-49d3-a423-6c87ff5c7ea9",correct:"Podmínková proměnná je synchronizační nástroj používaný v operačních systémech pro řešení problémů souběžných datových závislostí, který umožňuje vláknům efektivně čekat na splnění určité podmínky před pokračováním v provádění kódu. Operace `wait` slouží k zablokování vlákna, dokud jiné vlákno neprovede operaci `signal`, která toto čekající vlákno odblokuje a umožní mu pokračovat v běhu.",incorrect:"Podmínková proměnná je synchronizační nástroj používaný v operačních systémech výhradně pro řešení problémů vzájemného vyloučení a zabránění uváznutí, který primárně slouží k řízení přístupu více vláken ke sdíleným prostředkům. Operace `wait` slouží k aktivnímu čekání vlákna v nekonečné smyčce, dokud jiné vlákno neprovede operaci `signal`, která pouze nastaví interní příznak, ale nijak neovlivní stav čekajícího vlákna.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"b596e91b-9aec-4b6e-b6f0-d7b3edafcfc6",correct:"V kontextu podmínkových proměnných existují dvě sémantické verze popisu stavu: první verze reprezentuje stav jedním bitem, indikujícím čekající vlákno, kde operace `wait` je přípustná pouze pokud žádné vlákno nečeká; druhá verze chápe stav jako množinu čekajících vláken, umožňující operaci `signal` probudit jedno, všechna, nebo podmnožinu zablokovaných vláken.",incorrect:"V kontextu podmínkových proměnných existují dvě sémantické verze popisu stavu, které se liší pouze v implementačních detailech, ale nemají vliv na chování z pohledu programátora: první verze reprezentuje stav jako čítač čekajících vláken, druhá verze jako frontu FIFO. Obě verze však zaručují, že operace `signal` vždy probudí všechna čekající vlákna v pořadí, v jakém na proměnnou čekala.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"a101b498-2201-4961-98a6-67bd0f9bb1a8",correct:"Implementace operace `wait` u podmínkové proměnné typicky zahrnuje interakci s plánovačem operačního systému, podobně jako u uspávajícího mutexu, což znamená, že čekající vlákno uvolní procesor pro běh jiných vláken. Alternativní implementací je aktivní čekání, které se podobá spinlocku, avšak je méně obvyklé pro podmínkové proměnné z důvodu obtížnosti předvídání doby čekání na datové závislosti.",incorrect:"Implementace operace `wait` u podmínkové proměnné se zásadně liší od implementace uspávajícího mutexu, protože podmínková proměnná nikdy neinteraguje s plánovačem operačního systému a čekající vlákno neustále spotřebovává procesorový čas aktivním čekáním. Aktivní čekání je naopak preferovanou implementací podmínkových proměnných, protože minimalizuje režii přepínání kontextu.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"b748558e-67e9-4376-9ff9-aa21a73fe36b",correct:"Klasický semafor sám o sobě přímo neřeší problém producentů a konzumentů efektivněji než mutex, avšak s využitím dvou klasických semaforů, E a F, kde E reprezentuje volná místa a F obsazená místa, lze implementovat klasické řešení tohoto problému, přičemž operace wait a post na těchto semaforech koordinují produkci a konzumaci.",incorrect:"Klasický semafor sám o sobě přímo řeší problém producentů a konzumentů efektivněji než mutex, a k implementaci klasického řešení tohoto problému stačí pouze jeden klasický semafor, který kombinuje funkce semaforů E a F, reprezentujících volná a obsazená místa, přičemž operace wait a post na tomto jediném semaforu koordinují produkci a konzumaci.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"5b58cdb8-cf37-444f-89c5-064a0ae51fbc",correct:"Symetrický semafor je modifikací klasického semaforu, u kterého operace post, na rozdíl od klasického semaforu, blokuje v případě pokusu o překročení maximální povolené hodnoty počítadla n, čímž se dosahuje symetrie s operací wait, která blokuje při dosažení hodnoty 0, a tato úprava umožňuje přímější řešení problému producentů a konzumentů.",incorrect:"Symetrický semafor je modifikací klasického semaforu, u kterého operace wait, na rozdíl od klasického semaforu, neblokuje v případě dosažení hodnoty 0, ale pouze snižuje hodnotu počítadla, zatímco operace post zůstává stejná jako u klasického semaforu a neblokuje při překročení maximální hodnoty n, což zachovává asymetrii operací wait a post.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"c7ffc6f1-8971-4516-a60c-f9bbf1dc46ac",correct:"V klasickém řešení problému producentů a konzumentů s využitím dvou semaforů, semafor E s počáteční hodnotou n reprezentuje počet volných míst ve frontě a semafor F s počáteční hodnotou 0 reprezentuje počet zabraných míst, přičemž produkce je realizována sekvencí operací wait E; post F a konzumace sekvencí wait F; post E, a platí invariant E + F = n.",incorrect:"V klasickém řešení problému producentů a konzumentů s využitím dvou semaforů, semafor E s počáteční hodnotou 0 reprezentuje počet volných míst ve frontě a semafor F s počáteční hodnotou n reprezentuje počet zabraných míst, přičemž produkce je realizována sekvencí operací wait F; post E a konzumace sekvencí wait E; post F, a invariant je E - F = n.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"cf50c032-89fe-4e59-a15a-7e05c6a2fb6a",correct:"Bariéra v operačních systémech slouží k řešení problému rozvětvení a setkání vláken, přičemž se zaměřuje zejména na synchronizaci většího počtu vláken, která paralelně řeší dílčí problémy v rámci komplexnějšího výpočtu. Implementace bariéry často zahrnuje počítadlo a podmínkovou proměnnou pro efektivní řízení průchodu vláken synchronizačním bodem.",incorrect:"Bariéra v operačních systémech je primárně navržena pro řešení problémů spojených s exkluzivním přístupem k sdíleným zdrojům, podobně jako semafor, a její implementace se typicky opírá o mechanismy zámků a monitorů pro zajištění vzájemného vyloučení a prevenci uváznutí mezi vlákny.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"049885bd-e648-4394-bed6-44d2320748f3",correct:"Operace `wait` u bariéry v operačních systémech má za úkol atomicky snížit počítadlo bariéry o jedničku a v případě, že výsledná hodnota počítadla je větší než nula, vlákno je uspáno a čeká na signál. Pokud je výsledná hodnota nula, operace `wait` signalizuje podmínku, umožňující probuzení čekajících vláken.",incorrect:"Operace `wait` u bariéry v operačních systémech primárně slouží k aktivnímu čekání vláken v smyčce, dokud se nesplní určitá podmínka, jako je dosažení specifické hodnoty sdílené proměnné, přičemž se nevyužívá mechanismů uspávání a probouzení vláken operačním systémem.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"a94ff36e-09a9-471d-8817-d7d4437c1a14",correct:"Implementace bariéry s využitím aktivního čekání je teoreticky možná, avšak je považována za méně efektivní a praktickou v běžných scénářích použití bariér v operačních systémech, protože je vhodná pouze pro specifické případy, kdy je zaručeno, že všechna vlákna dosáhnou synchronizačního bodu přibližně ve stejný čas.",incorrect:"Implementace bariéry s využitím aktivního čekání je preferovaným a nejefektivnějším přístupem v moderních operačních systémech, jelikož minimalizuje režii spojenou s uspáváním a probouzením vláken a zajišťuje rychlejší synchronizaci vláken, i když časy příchodu vláken k bariéře nejsou synchronizované.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"}]},{uuid:"b16b3702-0b0a-43f9-a90d-bc8eeb46b965",sectionNumber:"7",sectionTitle:"Komunikace, uváznutí",statements:[{uuid:"6789833b-e433-4287-9a71-4b550766f48d",correct:"Každá komunikace mezi procesy v operačním systému představuje inherentní formu synchronizace, neboť operace čtení dat je logicky závislá na předchozím úspěšném zápisu těchto dat, což zaručuje, že příjemce nemůže obdržet informaci, která dosud nebyla odeslána, a tím se eliminuje riziko ztráty dat nebo nekonzistence.",incorrect:"Každá komunikace mezi procesy v operačním systému představuje formu synchronizace, avšak operace čtení dat může proběhnout i nezávisle na předchozím zápisu, jelikož moderní operační systémy jsou navrženy tak, aby dokázaly efektivně doručit zprávu i v případě, že odesílající proces data ještě plně nezapsal, čímž se maximalizuje rychlost komunikace.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"9aec6f80-aab1-4a8c-97f1-3f45af89b03c",correct:"Komunikační mechanismy v operačních systémech často implementují sofistikovanější synchronizační funkce, než jen pouhou závislost čtení na zápisu, například se mohou chovat jako symetrické semafory, což umožňuje jemnější řízení souběžného přístupu ke sdíleným zdrojům a koordinaci procesů, které se vzájemně ovlivňují.",incorrect:"Komunikační mechanismy v operačních systémech se omezují pouze na základní synchronizační funkci vyplývající z nutnosti zápisu dat před jejich čtením, a nikdy nepoužívají pokročilejší synchronizační techniky jako symetrické semafory, protože takovéto mechanismy by zbytečně komplikovaly implementaci a snižovaly výkon komunikačního subsystému.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"f622e8b8-270e-4a8e-a186-b28138e93784",correct:"Pro komunikaci mezi vlákny lze efektivně využít libovolnou datovou strukturu, pokud je řádně chráněna mutexem, což se dá přirovnat k poštovní schránce, kde čtení a zápis probíhají odděleně, aby se zabránilo konfliktům a zajistila integrita dat, ačkoli při intenzivní komunikaci může dojít k soutěži o zámek, která zpomaluje celkový výkon systému.",incorrect:"Pro komunikaci mezi vlákny je nejefektivnější využít pouze specializované datové struktury bez zámků, protože libovolná datová struktura chráněná mutexem, i když se dá přirovnat k poštovní schránce pro oddělené čtení a zápis, vždy způsobuje nepřijatelně vysokou soutěž o zámek a dramaticky snižuje výkon systému i při občasné komunikaci.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"3aba4952-6c9d-4ad1-b319-da0ca6299bdf",correct:"Specializované komunikační fronty představují pokročilejší přístup k meziprocesové komunikaci, neboť umožňují předávání dat v pevném pořadí a minimalizují nutnost synchronizace při každé jednotlivé operaci, čímž se dosahuje vyšší míry souběžnosti a efektivity, a jsou zvláště důležité v situacích, kde je vyžadována vysoká propustnost a nízká latence.",incorrect:"Specializované komunikační fronty jsou sice navrženy pro meziprocesovou komunikaci, ale ve skutečnosti vyžadují explicitní synchronizaci při každé jednotlivé operaci předání dat a neumožňují předávání dat v pevném pořadí, což vede k nižší míře souběžnosti a efektivity ve srovnání s jednoduššími datovými strukturami chráněnými mutexem.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"5fce6209-b2d6-423e-b950-93d2518ec138",correct:"V kontextu meziprocesové komunikace, i když mutexy a zámky obecně zajišťují ochranu sdílených dat, při vysoké frekvenci komunikace se soutěž o tyto zámky stává významným úzkým hrdlem, které může negativně ovlivnit celkovou propustnost a dobu odezvy systému, a proto je důležité zvážit alternativní metody synchronizace pro intenzivní komunikační scénáře.",incorrect:"V kontextu meziprocesové komunikace, mutexy a zámky představují ideální řešení i pro vysoce frekventovanou komunikaci, protože soutěž o tyto zámky nikdy nepředstavuje významné úzké hrdlo a nemá žádný měřitelný negativní dopad na celkovou propustnost a dobu odezvy systému, a proto jsou mutexy vždy preferovanou metodou synchronizace.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"5f022182-1281-4984-b280-e5450c25fec4",correct:"Kruhová fronta s pevnou velikostí, určená pro komunikaci mezi jedním producentem a jedním konzumentem, využívá dva ukazatele, čtecí a zapisovací, přičemž efektivní kapacita fronty je o jednu buňku menší než celkový počet buněk alokovaných pro frontu, což je nutné pro rozlišení stavu plné a prázdné fronty za použití těchto ukazatelů.",incorrect:"Kruhová fronta s pevnou velikostí, určená pro komunikaci mezi jedním producentem a jedním konzumentem, využívá dva ukazatele, čtecí a zapisovací, přičemž efektivní kapacita fronty je stejná jako celkový počet buněk alokovaných pro frontu, protože nevyužití jedné buňky by zbytečně snižovalo výkon systému a nebylo by efektivní.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"b86b214b-1a8d-4655-85ed-7b3b223aa24e",correct:"V algoritmu pro vkládání do kruhové fronty, pokud zapisovací ukazatel (W) dohoní čtecí ukazatel (R), operace vkládání se pozastaví, dokud se čtecí ukazatel nepohne, což indikuje stav plné fronty a zamezuje přepsání dat, která by ještě nebyla konzumentem zpracována.",incorrect:"V algoritmu pro vkládání do kruhové fronty, pokud zapisovací ukazatel (W) dohoní čtecí ukazatel (R), operace vkládání pokračuje přepsáním nejstarších dat ve frontě, aby se zajistilo, že producent nikdy nebude blokován a mohl neustále vkládat nová data.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"64ddf916-4b40-4329-b58a-cfbdf341ef7a",correct:"Zásadní výhodou implementace kruhové fronty pro jednoho producenta a jednoho konzumenta je, že operace vkládání a vybírání mohou být implementovány bez použití explicitního zamykání (mutexu) za předpokladu, že každá strana (producent a konzument) modifikuje výhradně svůj určený ukazatel (zapisovací a čtecí).",incorrect:"Zásadní výhodou implementace kruhové fronty pro jednoho producenta a jednoho konzumenta je, že operace vkládání a vybírání vždy vyžadují použití explicitního zamykání (mutexu) pro zajištění datové integrity a prevenci závodních podmínek, i když každá strana modifikuje jen svůj ukazatel.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"9836942d-e3a7-464d-82be-dc83a6abd962",correct:"V algoritmu pro odebrání z kruhové fronty se prázdná fronta detekuje porovnáním hodnot čtecího ukazatele (R) a zapisovacího ukazatele (W), konkrétně když výraz `(R + 1) % S` je roven `W`, kde `S` je velikost fronty, což signalizuje, že ve frontě nejsou k dispozici žádná data ke čtení.",incorrect:"V algoritmu pro odebrání z kruhové fronty se prázdná fronta detekuje jednoduše porovnáním, zda se čtecí ukazatel (R) rovná zapisovacímu ukazateli (W),  což je přímější a efektivnější metoda pro zjištění prázdného stavu fronty bez nutnosti složitějších výpočtů modulo.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"b6366f5f-6a09-4ef2-b25d-2ef4eddc4462",correct:"Roura představuje specializovanou komunikační frontu, která je primárně navržena pro efektivní práci s bajty a je optimalizována pro dávkové operace, což umožňuje hromadné čtení a zápis dat pro zvýšení výkonu a snížení režie spojené s jednotlivými operacemi, a je běžně poskytována operačním systémem jako základní mechanismus pro meziprocesovou komunikaci.",incorrect:"Roura představuje univerzální komunikační frontu, která je navržena pro práci s různými datovými typy kromě bajtů a není optimalizována pro dávkové operace, což neumožňuje hromadné čtení a zápis dat a zvyšuje režii spojenou s jednotlivými operacemi, a není běžně poskytována operačním systémem, ale implementována uživatelskými aplikacemi pro specifické účely.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"01584fb1-115d-44c1-8b32-45a09d9040b8",correct:"Implementace roury, jakožto omezené fronty, s sebou nese specifické synchronizační chování, které je analogické chování symetrického semaforu, což znamená, že operace zápisu do plné roury nebo čtení z prázdné roury vyžadují synchronizaci a potenciální čekání na uvolnění kapacity pro zápis nebo dostupnost dat pro čtení, čímž se zajišťuje integrita dat a řízení toku informací.",incorrect:"Implementace roury, jakožto omezené fronty, s sebou nenese žádné specifické synchronizační chování, a proto operace zápisu do plné roury nebo čtení z prázdné roury nevyžadují synchronizaci ani čekání, což umožňuje okamžité operace bez ohledu na stav fronty a potenciálně vede k ztrátě dat nebo nekonzistenci v případě plné nebo prázdné roury.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"230fe1cc-9a64-4f6a-b8ed-0b6c6bf7dd90",correct:"Zobecněná komunikační fronta, jak je popsána v kontextu sdílení úloh mezi procesy, umožňuje současný přístup více vláken pro vkládání a vybírání dat, což odlišuje tento typ fronty od tradičních komunikačních mechanismů, kde je přístup často omezen na jedno vlákno pro každou operaci.",incorrect:"Zobecněná komunikační fronta, jak je popsána v kontextu sdílení úloh mezi procesy, je navržena tak, aby umožňovala výhradní přístup pouze jednoho vlákna pro vkládání a vybírání dat v daném okamžiku, což zajišťuje konzistenci dat a předchází konfliktům mezi souběžnými operacemi.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"fe9bbc86-a6a3-4dc1-aa4e-01e0b19ada1d",correct:"Implementace zobecněné komunikační fronty, která je navržena pro prostředí s více producenty a konzumenty, se často realizuje pomocí zřetězeného seznamu a atomické operace compare-and-exchange (cmpxchg), což umožňuje dosáhnout bezblokujícího chování a vyhnout se tak režii spojené se zámky.",incorrect:"Implementace zobecněné komunikační fronty, určená pro více producentů a konzumentů, typicky vyžaduje použití zámků pro synchronizaci přístupu k datové struktuře fronty, aby se zajistila integrita dat a zabránilo se závodním podmínkám mezi souběžnými vlákny.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"af1d1f8b-948a-44bd-93c2-b5f8bb39990f",correct:"Mezi typické aplikace zobecněné komunikační fronty patří efektivní správa společného seznamu úloh v operačním systému, kde různé procesy nebo vlákna mohou přidávat a odebírat úkoly, a také se tato fronta uplatňuje v algoritmech paralelního prohledávání stromových a grafových struktur.",incorrect:"Zobecněná komunikační fronta se primárně používá pro synchronizaci běhu jednoho vlákna s přerušením v jednoprocesorovém systému a není vhodná pro aplikace vyžadující sdílení úloh mezi více procesy nebo pro paralelní zpracování datových struktur, jako jsou stromy a grafy.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"b0334b17-c842-4ff0-9da2-2951ac56eadb",correct:"Pro implementaci datové struktury určené pro operace dotazování a vkládání, která se používá pro správu ukončených úloh v operačním systému, je možné efektivně využít mechanismus Read-Copy-Update (RCU), který minimalizuje režii spojenou se synchronizací čtení a zápisu, a tím zvyšuje celkovou výkonnost systému, zejména v prostředí s vysokým počtem čtení.",incorrect:"Pro implementaci datové struktury určené pro operace dotazování a vkládání, která se používá pro správu běžících úloh v operačním systému, je nutné výhradně využít mechanismus semaforů, jelikož mechanismus Read-Copy-Update (RCU) není vhodný pro dynamicky se měnící množiny úloh a vyžaduje exkluzivní přístup pro operace zápisu, což by omezovalo souběžnost.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"6946c3e0-1312-4b89-9d9a-a4d2072fdb84",correct:"Pro implementaci datové struktury, která efektivně podporuje operace dotazování a vkládání a je vhodná pro uzavřené množiny prvků, jako jsou například množiny stránek určených k zápisu na disk, lze s výhodou použít hashovací tabulku, doplněnou o spinlock pro každou buňku, čímž se zajistí atomický přístup k jednotlivým buňkám a minimalizují se konflikty při souběžných operacích.",incorrect:"Pro implementaci datové struktury, která efektivně podporuje operace dotazování a vkládání a je vhodná pro dynamicky se měnící množiny prvků, nelze použít hashovací tabulku, protože hashovací tabulky nejsou vhodné pro operace vkládání a vyhledávání v reálném čase a vyžadují složitou reorganizaci při každé změně velikosti množiny prvků, proto je nutné použít složitější stromové struktury.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"53a2dbd4-e6be-4282-a0d2-193f1254d348",correct:'Text uvádí, že datová struktura implementovaná pomocí technik jako Read-Copy-Update,  spinlocků nebo atomických operací cmpxchg, je vhodná pro správu takzvaných "dirty" stránek, tedy stránek v paměti, které byly modifikovány a je potřeba je zapsat zpět do souboru, aby se zajistila konzistence dat a trvalost změn v souborovém systému.',incorrect:"Text uvádí, že datová struktura implementovaná pomocí technik jako Read-Copy-Update, spinlocků nebo atomických operací cmpxchg, je primárně určena pro správu volného místa na disku, tedy pro sledování bloků disku, které nejsou aktuálně využívány soubory, a to za účelem efektivního alokování nových souborů a minimalizace fragmentace diskového prostoru.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"acf8bb83-039a-46d4-abed-557c640f8003",correct:"Z pohledu systému pro předávání zpráv je obsah zprávy typicky považován za neprůhledný, skládající se pouze z bajtů, přičemž klíčová metadata, zejména informace o adresátovi, hrají zásadní roli pro správné doručení a zpracování zprávy. Způsob adresace je to, co primárně odlišuje předávání zpráv od mechanismu front, ačkoli pro pevnou dvojici komunikujících vláken mohou být tyto dva koncepty v podstatě ekvivalentní.",incorrect:"Z pohledu systému pro předávání zpráv je obsah zprávy klíčový a transparentní, umožňující systému detailně analyzovat a interpretovat data před doručením. Metadata, ačkoliv přítomná, hrají pouze doplňkovou roli, a hlavní rozdíl mezi předáváním zpráv a frontami spočívá v metodě serializace dat, nikoliv v adresaci. Pro pevnou dvojici komunikujících vláken je předávání zpráv zásadně odlišné od komunikačních front a nelze je považovat za ekvivalentní.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"285c2b8f-a1d4-4b07-b16a-7de01b71c356",correct:"Při předávání zpráv v operačních systémech se zprávy doručují jako nedělitelné celky, což znamená, že příjemce obdrží buď kompletní zprávu, nebo nic.  Metadata zpráv, zahrnující zejména adresu příjemce, jsou klíčová pro směrování a doručení zprávy na správné místo určení. Pro specifický případ komunikace mezi dvěma pevně stanovenými vlákny, se mechanismus předávání zpráv stává funkčně srovnatelným s použitím dvojice komunikačních front.",incorrect:"Při předávání zpráv se zprávy mohou doručovat po částech, umožňujíc příjemci zpracovávat data postupně, ještě před obdržením celé zprávy. Metadata zpráv, ačkoli existují, jsou irelevantní pro doručování zpráv a slouží pouze pro účely logování.  I pro komunikaci mezi dvěma pevně stanovenými vlákny zůstává mechanismus předávání zpráv zásadně odlišný od komunikačních front a nelze je považovat za funkčně srovnatelné.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"9cd278f1-f3d7-4f16-b741-b33e31749a53",correct:"Základním rozlišovacím prvkem mezi předáváním zpráv a frontami v operačních systémech je způsob adresace. Zatímco předávání zpráv explicitně definuje adresáta zprávy prostřednictvím metadat, fronty implicitně adresují zprávy příjemcům na základě principu FIFO (First-In, First-Out) bez nutnosti explicitní adresace v metadatech zprávy. V kontextu spolehlivosti doručení, předávání zpráv může podporovat jak spolehlivé, tak nespolehlivé doručení, v závislosti na implementaci.",incorrect:"Zásadní rozdíl mezi předáváním zpráv a frontami spočívá v tom, že fronty vyžadují explicitní definici adresáta zprávy v metadatech, zatímco předávání zpráv funguje na principu implicitní adresace, kde se zprávy doručují všem potenciálním příjemcům. Spolehlivost doručení není u předávání zpráv nikdy garantována a je vždy považováno za nespolehlivé, zatímco fronty vždy zajišťují spolehlivé doručení zpráv.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"32bee056-c490-4a9a-9422-c0ab6d566460",correct:"V kontextu systémů předávání zpráv, pokud je maximální kapacita systému pro uchování nedoručených zpráv nastavena na nulu, hovoříme o mechanismu setkání (rendezvous), kde se odesílající a přijímající vlákna musí synchronizovat, aby si mohly vzájemně předat zprávu, což zdůrazňuje synchronizační aspekt komunikace.",incorrect:"V systémech předávání zpráv, mechanismus setkání (rendezvous) nastává, když systém má neomezenou kapacitu pro uchování nedoručených zpráv, umožňující odesílajícímu vláknu pokračovat v činnosti bez nutnosti synchronizace s přijímajícím vláknem, a minimalizuje tak synchronizační aspekt komunikace.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"349837a8-e73a-4bdc-924e-8ad113ec3b2f",correct:"Pro systémy předávání zpráv, kde je klíčová vysoká propustnost a nízká latence, je možné implementovat operace odeslání i přijetí asynchronně, což může vést k úspoře jednoho kopírování zprávy, avšak za cenu zvýšené složitosti správy paměti v systému.",incorrect:"V systémech předávání zpráv, kde prioritou je snížení složitosti správy paměti, je nezbytné implementovat operace odeslání a přijetí asynchronně, což sice zjednodušuje správu paměti, ale současně vyžaduje dodatečné kopírování zpráv, čímž se snižuje propustnost systému.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"4c684705-0dc6-400e-b7d9-011258bcc35f",correct:"V nejjednodušších systémech předávání zpráv operace 'odešli' zprávu a 'přijmi' zprávu mohou volitelně blokovat. Operace 'přijmi' blokuje, pokud není dostupná žádná zpráva, zatímco operace 'odešli' může blokovat kvůli omezené kapacitě systému pro uchování odeslaných zpráv.",incorrect:"V nejjednodušších systémech předávání zpráv operace 'odešli' zprávu a 'přijmi' zprávu jsou vždy neblokující. Operace 'přijmi' nikdy neblokuje, místo toho okamžitě vrací informaci o nedostupnosti zprávy, a operace 'odešli' nikdy neblokuje, i když je systém plně zatížen odeslanými zprávami.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"ff5d311d-2595-4863-9ee5-c9170fbe6898",correct:"V systémech pro předávání zpráv se pro fyzické doručení zpráv mezi klientem a zprostředkovatelem používají různé komunikační kanály, jako je sdílená paměť, speciální systémová volání nebo síťové spojení, přičemž je logicky vyloučeno, aby se samotné předávání zprávy klientem k předání zprávy zprostředkovateli používalo jako komunikační kanál, neboť by to vytvářelo cyklickou závislost a neumožnilo by to efektivní předávání zpráv.",incorrect:"V systémech pro předávání zpráv se pro fyzické doručení zpráv mezi klientem a zprostředkovatelem používají výhradně síťové spoje, přičemž sdílená paměť a speciální systémová volání nejsou pro tento účel vhodné, a logicky je možné, aby se samotné předávání zprávy klientem k předání zprávy zprostředkovateli používalo jako komunikační kanál, jelikož by to zjednodušilo architekturu systému a zvýšilo efektivitu předávání zpráv.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"1da63ac2-dd39-468a-b505-5de44fdc333a",correct:"V asynchronním režimu odesílání zpráv, kdy systém doručení zpráv není spolehlivý a klient potřebuje mít zajištěné doručení zprávy, je nutné, aby odesílající klient uchovával zprávu v paměti až do doby, než mu příjemce doručení zprávy potvrdí, typicky odesláním potvrzovací zprávy zpět odesílateli, což zajišťuje, že i v nespolehlivém prostředí bude zpráva nakonec doručena a zpracována.",incorrect:"V asynchronním režimu odesílání zpráv, kdy systém doručení zpráv je spolehlivý a klient nepotřebuje mít zajištěné doručení zprávy, je nutné, aby odesílající klient uchovával zprávu v paměti až do doby, než mu příjemce doručení zprávy potvrdí, a to i přesto, že systém doručení je již spolehlivý a potvrzení by nebylo nutné, což je zbytečné plýtvání systémovými zdroji a pamětí.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"b53cb460-f1e3-4c0c-b8e7-94f2ed31ed46",correct:"Při asynchronním příjmu zpráv, kdy klient zpracovává větší počet zpráv souběžně, se zpracování nově příchozí zprávy iniciuje na základě výzvy od zprostředkovatele, a to může být realizováno buď s využitím klasických vláken operačního systému, nebo s použitím takzvaných fibrů, což jsou uživatelská vlákna s kooperativním plánováním, umožňující efektivnější správu souběžnosti.",incorrect:"Při asynchronním příjmu zpráv, kdy klient zpracovává pouze jednu zprávu sekvenčně, se zpracování nově příchozí zprávy iniciuje na základě explicitního dotazu klienta zprostředkovatele, a to může být realizováno výhradně s využitím klasických vláken operačního systému, zatímco fibry s kooperativním plánováním pro tento účel nejsou vhodné a ani se v systémech pro předávání zpráv nepoužívají.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"170b7968-65ee-4123-a65d-ba946310287b",correct:"Zprostředkovatel v systému pro předávání zpráv může poskytovat nejen základní operace předávání zpráv, ale také složitější, odvozené operace, které rozšiřují funkcionalitu systému pro předávání zpráv a umožňují efektivnější a flexibilnější komunikaci mezi klienty, například filtrování zpráv, transformaci dat nebo směrování zpráv na základě obsahu.",incorrect:"Zprostředkovatel v systému pro předávání zpráv je omezen pouze na základní operace předávání zpráv a nemůže poskytovat žádné složitější, odvozené operace, protože jeho úkolem je výhradně zprostředkování komunikace bez jakékoliv přidané funkcionality nebo složitější logiky, což zaručuje jednoduchost a minimalizaci režie systému.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"0763d53a-5080-4ccf-bf30-badf67815c04",correct:"Operace broadcast, scatter/gather a all-to-all, které jsou klíčové pro efektivní komunikaci v distribuovaných systémech a umožňují procesům vyměňovat si data hromadně, lze teoreticky implementovat pouze za pomoci point-to-point zpráv, nicméně centralizovaný zprostředkovatel může výrazně zvýšit jejich výkonnost a snížit latenci tím, že přímo podporuje tyto komplexnější komunikační vzorce.",incorrect:"Operace broadcast, scatter/gather a all-to-all, jež jsou nezbytné pro hromadnou komunikaci v distribuovaných systémech, vyžadují pro svou funkčnost a efektivitu vždy přítomnost centralizovaného zprostředkovatele, jelikož implementace pouze s využitím point-to-point zpráv by byla v praxi příliš pomalá a neefektivní pro reálné aplikace.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"3d2d44bd-ad9f-4e04-81c1-a9d5ad9489c2",correct:"Zatímco operace jako broadcast, scatter/gather, all-to-all, synchronizace bariéra, remote procedure call a subscribe/publish, běžně používané v distribuovaných operačních systémech, mohou být v principu realizovány s využitím základní point-to-point komunikace, přímá podpora těchto operací centrálním zprostředkovatelem často přináší značné zvýšení efektivity a snižuje režii spojenou s jejich prováděním.",incorrect:"Operace jako broadcast, scatter/gather, all-to-all, synchronizace bariéra, remote procedure call a subscribe/publish jsou v moderních operačních systémech implementovány výhradně s využitím centrálního zprostředkovatele, neboť point-to-point komunikace se ukázala jako zcela neefektivní a nepraktická pro realizaci takto komplexních komunikačních úloh v náročných distribuovaných prostředích.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"b9f4637d-9df7-4d0c-976e-b7f22fca5b9d",correct:"V operačních systémech s mikrojádrovou architekturou je předávání zpráv klíčovým mechanismem pro meziprocesovou komunikaci, protože služby operačního systému jsou implementovány jako běžné procesy, a mikrojádro samo často funguje jako zprostředkovatel této komunikace, což zvyšuje modularitu a spolehlivost systému.",incorrect:"V monolitických operačních systémech je předávání zpráv klíčovým mechanismem pro meziprocesovou komunikaci, protože služby operačního systému jsou implementovány jako běžné procesy, a mikrojádro samo často funguje jako zprostředkovatel této komunikace, což zvyšuje modularitu a spolehlivost systému.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"24346ebf-7e19-43ca-ae50-98ab5529578f",correct:"V distribuovaných systémech je předávání zpráv považováno za standardní metodu komunikace, protože tyto systémy obvykle nemají k dispozici sdílenou paměť, což činí jiné mechanismy meziprocesové komunikace nepraktickými nebo nemožnými, a proto se efektivní předávání zpráv stává klíčovým pro funkčnost distribuovaných aplikací.",incorrect:"V distribuovaných systémech je sdílená paměť považována za standardní metodu komunikace, protože tyto systémy obvykle mají k dispozici sdílenou paměť, což činí předávání zpráv nepraktickým a pomalým, a proto se sdílená paměť stává klíčovým pro funkčnost distribuovaných aplikací.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"6acbda22-7374-47a2-bacb-cfe0dd82487b",correct:"Použití předávání zpráv jako mechanismu meziprocesové komunikace v operačních systémech, zvláště v mikrojádrových architekturách, přináší výhody v oblasti spolehlivosti a bezpečnosti, protože komunikující entity jsou slabě provázané, což snižuje rizika spojená se souběžností a usnadňuje izolaci komponent systému.",incorrect:"Použití sdílené paměti jako mechanismu meziprocesové komunikace v operačních systémech, zvláště v mikrojádrových architekturách, přináší výhody v oblasti spolehlivosti a bezpečnosti, protože komunikující entity jsou slabě provázané, což snižuje rizika spojená se souběžností a usnadňuje izolaci komponent systému.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"3c6bcddb-e7d5-46be-8725-d64c75fa99fc",correct:"Koncept distribuované sdílené paměti existuje a je předmětem výzkumu, avšak pro většinu praktických aplikací se potýká se zásadními problémy s výkonem, obzvláště při použití běžných vzorů komunikace, které jsou navrženy pro systémy se skutečnou sdílenou pamětí.",incorrect:"Koncept distribuované sdílené paměti je široce používán v praktických aplikacích a nevykazuje zásadní problémy s výkonem, a to i při použití běžných vzorů komunikace, které jsou navrženy pro systémy se skutečnou sdílenou pamětí.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"a587d3c2-db57-4746-ab0c-3287664b2139",correct:"Virtualizace hardwarových zdrojů, jako jsou procesory a paměť, je užitečná technika v operačních systémech, která umožňuje vytvářet iluzi většího množství zdrojů, než je fyzicky dostupné.  Tato metoda je efektivní, pokud každý uživatel zdroje využívá pouze část jeho celkové kapacity, například část procesorového jádra nebo operační paměti. Nicméně, virtualizace není neomezená a má své limity, zejména v situacích, kdy je fyzická kapacita zdroje vyčerpána.",incorrect:"Virtualizace hardwarových zdrojů, jako jsou procesory a paměť, je univerzální technika v operačních systémech, která umožňuje vytvářet neomezené množství zdrojů, bez ohledu na jejich fyzickou dostupnost. Tato metoda je efektivní i v situacích, kdy uživatelé vyžadují celou kapacitu zdroje najednou, a nemá prakticky žádné limity, protože fyzická kapacita zdroje není nikdy vyčerpána.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"07183c09-76d8-4a2b-88e6-698575af3d88",correct:"Podle textu, virtualizace zdrojů v operačních systémech není všelék a má svá omezení. Některé hardwarové periferie nelze efektivně virtualizovat a virtualizace sama o sobě neumí fyzicky znásobit zdroje, ale pouze umožňuje jejich sdílení mezi více uživateli nebo procesy.  V případech, kdy fyzická kapacita virtualizovaného zdroje, jako je operační paměť nebo diskový prostor, dosáhne svého limitu, operace vyžadující tento zdroj mohou selhat. Alternativou k virtualizaci může být rezervace a uvolňování zdrojů.",incorrect:"Podle textu, virtualizace zdrojů v operačních systémech je univerzální řešení bez omezení. Všechny hardwarové periferie lze efektivně virtualizovat a virtualizace sama o sobě dokáže fyzicky znásobit zdroje, čímž umožňuje neomezené množství uživatelů nebo procesů.  V případech, kdy fyzická kapacita virtualizovaného zdroje, jako je operační paměť nebo diskový prostor, dosáhne svého limitu, operace vyžadující tento zdroj nikdy neselžou, protože virtualizace zajišťuje neomezenou kapacitu.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"3d468592-cc28-46d2-8920-15bb72ac5303",correct:"Rezervace zdrojů představuje alternativní přístup k virtualizaci, který se uplatňuje zejména v situacích, kdy povaha daného zdroje, jako například páskové jednotky, neumožňuje virtualizaci, nebo v případech, kdy je selhání zdroje nepřípustné z důvodu potenciálního ohrožení zdraví či majetku.  Důležité je, že rezervace a virtualizace se vzájemně nevylučují a mohou koexistovat v rámci operačního systému.",incorrect:"Rezervace zdrojů je primární a výhradní metoda správy hardwarových prostředků v moderních operačních systémech, která plně nahrazuje virtualizaci.  V situacích, kde je k dispozici virtualizace, se rezervace nikdy nepoužívá, protože tyto dva přístupy jsou v operačních systémech striktně vzájemně vylučující.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"df9eec55-ac55-4509-b662-4e1c38623d1d",correct:"Proces rezervace zdrojů se skládá ze dvou klíčových fází. První fází je samotná rezervace, kdy program požádá operační systém o exkluzivní přístup ke zdroji. Po úspěšné rezervaci se zdroj stává vlastnictvím programu. Druhou fází je uvolnění zdroje, kdy program oznamuje systému, že již zdroj nepotřebuje, a ten se vrací zpět do systému pro další použití.",incorrect:"Rezervace zdrojů je jednofázový proces, ve kterém program okamžitě získá exkluzivní přístup ke zdroji ihned po podání požadavku. Systém nepočítá s fází uvolnění zdroje, protože se předpokládá, že zdroje rezervované programem zůstávají vyhrazené po celou dobu běhu programu a po jeho ukončení se automaticky uvolní.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"3220efab-e775-48e3-82cb-0b4ebf832e12",correct:"V případě, že požadovaný zdroj není v době rezervace dostupný, operační systém má dvě možnosti, jak situaci řešit. Může požadavek na rezervaci odmítnout, čímž donutí program se s nedostupností zdroje vyrovnat, nebo může program nechat čekat, dokud se zdroj neuvolní jiným programem a stane se dostupným pro rezervaci.",incorrect:"Pokud zdroj není dostupný v okamžiku požadavku na rezervaci, operační systém vždy zvolí možnost okamžitého zamítnutí požadavku. Čekání na uvolnění zdroje není v mechanismu rezervace implementováno, protože by to mohlo vést k neefektivnímu využití zdrojů a zdržení jiných programů čekajících na stejný zdroj.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"39daae91-8783-40af-a3e0-ea5e74ae910a",correct:"Mutex lze chápat jako abstraktní zdroj, který nereprezentuje výpočetní prostředky, ale umožňuje synchronizaci vláken tím, že poskytuje operace rezervace a uvolnění, které odpovídají zamčení a odemčení kritické sekce, čímž zajišťuje vzájemné vyloučení přístupu ke sdíleným zdrojům.",incorrect:"Mutex je konkrétní zdroj výpočetního výkonu, který operační systém alokuje procesům pro výhradní použití, a jeho operace rezervace a uvolnění slouží k přidělování a vracení tohoto výpočetního výkonu, nikoliv k synchronizaci vláken nebo ochraně kritických sekcí.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"6957d17b-399c-4a67-9eb5-1c858ee8f33c",correct:'Podle textu lze i samotnou kritickou sekci považovat za abstraktní zdroj, i když definice kritické sekce v literatuře bývá nejednoznačná a často se operuje s pojmem kritické sekce volně, obvykle ve smyslu třídy ekvivalence vztažené k pojmu "kritický vůči".',incorrect:"Text výslovně uvádí, že kritickou sekci nelze považovat za abstraktní zdroj, protože definice kritické sekce je v literatuře striktně daná a pojem kritické sekce se vždy operuje formálně, bez nejasností nebo volnosti ve výkladu, a proto se nemůže jednat o abstraktní zdroj.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"10923612-e178-4586-be8c-70f101b1ba47",correct:"V kontextu správy zdrojů v operačních systémech, pokud existuje více instancí určitého zdroje, je možné při rezervaci zdroje vybrat libovolnou z dostupných instancí, protože instance jsou v době rezervace volně zaměnitelné.",incorrect:"V kontextu správy zdrojů v operačních systémech, i po rezervaci konkrétní instance zdroje, je stále možné tuto instanci vyměnit za jinou dostupnou instanci stejného zdroje, pokud se objeví výhodnější alternativa.",sectionNumber:"7.3.4",sectionTitle:"Instance"},{uuid:"c33712d6-75b1-4c39-9d75-75b815afc289",correct:"V operačních systémech, kde jsou zdroje spravovány s ohledem na záměnnost instancí, platí, že rezervace zdroje se provádí tak, že systém vybere libovolnou dostupnou instanci a po provedení rezervace už není možné tuto instanci dodatečně vyměnit za jinou.",incorrect:"V operačních systémech, kde je kladen důraz na flexibilitu správy zdrojů, je běžné, že i po rezervaci určité instance zdroje existuje mechanismus pro její výměnu za jinou instanci, a to i dodatečně, pokud se objeví potřeba optimalizace využití zdrojů.",sectionNumber:"7.3.4",sectionTitle:"Instance"},{uuid:"0faac1fd-d825-45e1-9104-b626afeef00b",correct:"Protože komunikace v operačních systémech je chápána jako forma synchronizace, lze ji také považovat za abstraktní zdroj, kde rezervace zdroje odpovídá odeslání zprávy a uvolnění zdroje přijetí zprávy, přičemž předání zprávy může implikovat i předání vlastnictví tohoto abstraktního zdroje mezi různými vlákny nebo procesy.",incorrect:"Komunikace v operačních systémech je sice formou synchronizace, ale nelze ji považovat za abstraktní zdroj, protože rezervace a uvolnění zdroje jsou výhradně vázány na fyzické zdroje, jako je paměť nebo procesorový čas, a předání zprávy nikdy nepředstavuje předání vlastnictví zdroje, ale pouze dočasné sdílení.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"69e3eb6a-4506-4e27-9311-b587565f55ac",correct:"V kontextu problému producentů a konzumentů v operačních systémech, uložení mezivýsledku producentem představuje formu rezervace abstraktního zdroje s omezenou kapacitou, přičemž počet uložených mezivýsledků je konečný a musí být producentovi přidělen, a tento zdroj je uvolněn až konzumentem, který mezivýsledek zpracuje a použije.",incorrect:"V paradigmatu producentů a konzumentů operačních systémů, uložení mezivýsledku producentem nepředstavuje rezervaci zdroje, ale pouze dočasné uložení dat v paměti, která není považována za omezený zdroj, a uvolnění tohoto prostoru nastává automaticky operačním systémem, nezávisle na činnosti konzumenta, například prostřednictvím garbage collection.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"ec8cceca-64b0-47a9-a1ec-7404a7222c6c",correct:"Princip abstrakce zdrojů v operačních systémech se rozšiřuje i na scénáře, kde programy si navzájem předávají zdroje, přičemž program, který zdroj obdrží, je zodpovědný za jeho následné uvolnění, což vyžaduje součinnost operačního systému pro správu vlastnictví a životního cyklu takto sdílených abstraktních zdrojů mezi různými programy.",incorrect:"V operačních systémech je sdílení zdrojů mezi programy striktně omezeno na zdroje spravované výhradně jedním programem a operační systém neumožňuje přímé předávání vlastnictví zdrojů mezi různými programy, a tedy program nemůže předat zodpovědnost za uvolnění zdroje jinému programu.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"2011f969-4e34-4430-ba7d-8ed27a41564c",correct:"Podle textu se v operačních systémech zdroje implicitně považují za neodnímatelné, což znamená, že k jejich uvolnění dochází typicky dobrovolným vrácením vlastníkem. Násilné odebrání neodnímatelných zdrojů, jako jsou mutexy, může mít vážné negativní dopady na běh programu a jeho stabilitu, což zdůrazňuje důležitost řádného řízení zdrojů.",incorrect:"V rozporu s principy uvedenými v textu se v operačních systémech zdroje běžně považují za snadno odnímatelné, což umožňuje časté a násilné odebírání i neodnímatelných zdrojů, jako jsou mutexy, bez významných dopadů na běh programu nebo jeho stabilitu. Text naznačuje, že operační systémy jsou navrženy tak, aby zvládaly i nečekané odebrání klíčových zdrojů.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"0ebcc0f7-e123-4882-a062-5bd252f3298d",correct:"Dle poskytnutého textu, zatímco odebrání fyzických prostředků ve virtualizovaném prostředí je obvykle zvládnutelné, jak dokládá příklad plánovače odebírajícího procesor běžícímu vláknu nebo správce paměti přesouvajícího stránky do externí paměti, důsledky pro neodnímatelné zdroje, jako jsou 3D tiskárny nebo optické mechaniky, jsou mnohem kritičtější a potenciálně škodlivé.",incorrect:"Jak je popsáno v textu, odebrání fyzických prostředků, bez ohledu na to, zda se nacházejí ve virtualizovaném nebo nevirtualizovaném prostředí, má vždy zvládnutelné důsledky. Například násilné odebrání kontroly nad 3D tiskárnou je stejně bezvýznamné jako plánovač odebírající procesor běžícímu vláknu a nepředstavuje žádné významné riziko poškození nebo narušení provozu.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"dc3580f6-cd4f-483d-8a9f-5b1d9e6aa135",correct:"Text objasňuje, že odnímatelnost zdroje není pouze inherentní vlastností samotného zdroje, ale může významně záviset na kontextu jeho použití. Například úložné zařízení může být odnímatelné ve virtualizovaném prostředí, ale neodnímatelné, pokud je konfigurováno jako zaručený zdroj ve specifické konfiguraci systému, což ukazuje na flexibilitu správy zdrojů v operačních systémech.",incorrect:"Podle textu je odnímatelnost zdroje striktně inherentní vlastností samotného zdroje a je zcela nezávislá na provozním kontextu. To, zda je zdroj používán ve virtualizovaném prostředí nebo jako zaručený zdroj, nemá žádný vliv na to, zda může být operačním systémem násilně odebrán, protože odnímatelnost je předem daná vlastnost zdroje.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"adc4df80-7e1a-4359-a3ed-8a19c90fdfe6",correct:"Jak ilustruje příklad zpracování síťových paketů v textu, v systémech využívajících mechanismus 'ulož a přepošli' slouží paměťové buňky vyrovnávací paměti jako zdroje. Pokud se tyto vyrovnávací paměti zaplní v důsledku vysoké rychlosti příchodu paketů, systém může přistoupit ke ztrátě příchozích paketů, což efektivně demonstruje scénář odebrání zdroje v situaci, kdy alokace není možná z důvodu vyčerpání zdrojů.",incorrect:"Text vysvětluje, že v síťových systémech 'ulož a přepošli' paměťové buňky vyrovnávací paměti, i když dočasně ukládají příchozí pakety, nejsou považovány za zdroje. Proto, když se tyto vyrovnávací paměti zaplní, systém nikdy neztrácí příchozí pakety; místo toho používá blokovací mechanismus, aby zajistil, že všechny pakety budou zpracovány bez ztráty dat nebo odebrání zdrojů, bez ohledu na rychlost příchodu paketů.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"f65b6c69-1cd6-43f9-bedb-3d46258114ac",correct:"V situaci uváznutí, kdy máme dvě vlákna P a Q a dva zdroje A a B, může vlákno P držet zdroj A a žádat o zdroj B, zatímco vlákno Q drží zdroj B a žádat o zdroj A. Tato vzájemná závislost vede k situaci, kdy ani jedno vlákno nemůže pokračovat v činnosti, dokud nezasáhne vnější mechanismus, například operační systém.",incorrect:"V situaci uváznutí, kdy máme dvě vlákna P a Q a dva zdroje A a B, může vlákno P držet zdroj A a žádat o zdroj B, zatímco vlákno Q drží zdroj B a žádat o zdroj A. Tato vzájemná závislost vede k situaci, kdy obě vlákna automaticky uvolní držené zdroje a systém se sám z uváznutí zotaví bez vnějšího zásahu.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"7d12be15-5c36-4ccc-b6dd-e98292b46601",correct:"Uváznutí mezi dvěma vlákny a dvěma zdroji nastává tehdy, když každé vlákno drží jeden zdroj a současně čeká na přidělení druhého zdroje, který drží druhé vlákno. Tento cyklický stav čekání způsobí, že se obě vlákna zablokují na neurčito, a nemohou tak dokončit svou práci, což vyžaduje externí intervenci pro obnovení provozu.",incorrect:"Uváznutí mezi dvěma vlákny a dvěma zdroji nastává tehdy, když každé vlákno drží oba zdroje a současně čeká na přidělení dalších zdrojů. Tento stav čekání je však pouze dočasný a operační systém automaticky uvolní zdroje a obnoví normální provoz systému bez jakéhokoli vnějšího zásahu.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"89a421a0-a75b-4623-bb68-5f58bc1cc041",correct:"I když požadavky vláken P a Q na zdroje A a B nejsou zcela souběžné, může dojít k uváznutí, pokud časování přidělování zdrojů a následných požadavků vytvoří cyklickou závislost. To znamená, že uváznutí není výhradně závislé na přesné souběžnosti požadavků, ale spíše na celkovém stavu přidělení zdrojů a požadavků vláken.",incorrect:"Uváznutí může nastat pouze tehdy, když jsou požadavky vláken P a Q na zdroje A a B dokonale souběžné. Pokud požadavky nejsou souběžné, operační systém je schopen efektivně řídit přidělování zdrojů a zamezit tak vzniku uváznutí v jakékoli situaci, čímž se souběžnost stává jediným faktorem pro uváznutí.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"b72a1c8d-0e26-4309-b4db-7197e5e1ca3b",correct:"Podmínka vzájemného vyloučení, která je jednou ze čtyř nutných podmínek pro vznik uváznutí v operačních systémech, je přímým důsledkem mechanismu rezervace zdrojů.  Tato podmínka je splněna, když je zdroj v daném okamžiku přidělen maximálně jednomu vláknu, což znamená, že ostatní vlákna, která o tento zdroj usilují, musí nutně vyčkat, dokud se zdroj neuvolní.",incorrect:"Podmínka vzájemného vyloučení, která je klíčová pro prevenci uváznutí v operačních systémech, je založena na principu sdílení zdrojů mezi více vlákny současně. Tato podmínka je splněna, když je zdroj v daném okamžiku přidělen více vláknům, což umožňuje maximalizovat paralelizmus a minimalizovat čekací doby vláken.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"786e95a0-68f0-405d-b632-fedea6b3c812",correct:"Podmínka „čekající vlastník“, nezbytná pro vznik uváznutí, nastává v situaci, kdy vlákno drží již přidělený zdroj a současně čeká na přidělení dalšího zdroje, který je momentálně držen jiným vláknem. Tato situace je obtížně řešitelná, protože predikce budoucích požadavků vláken na zdroje je komplexní a statická alokace všech potenciálně potřebných zdrojů by vedla k neefektivnímu využití systému.",incorrect:"Podmínka „čekající vlastník“, která zabraňuje uváznutí, nastává, když vlákno nemůže držet žádný zdroj, pokud současně nečeká na přidělení jiného zdroje.  Tímto se zajišťuje, že vlákna uvolňují zdroje ihned, jakmile na ně přestanou aktivně čekat, což eliminuje možnost vzniku cyklického čekání a uváznutí.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"0767bee3-90c4-482d-8b5c-1fbfbe7cc290",correct:"Podmínka neodnímatelnosti, která přispívá k uváznutí, definuje, že již přidělený zdroj nemůže být vláknu odebrán bez závažných důsledků. Tato vlastnost často vyplývá z povahy samotného zdroje, například u zámků mutex, kde násilné odebrání zdroje může vést k nekonzistenci dat nebo narušení integrity kritické sekce, kterou chrání.",incorrect:"Podmínka neodnímatelnosti, která je klíčová pro efektivní správu zdrojů, zajišťuje, že operační systém může dynamicky odebírat zdroje vláknům, která je momentálně nevyužívají. Tato flexibilita umožňuje optimalizovat využití zdrojů a předcházet situacím, kdy by vlákna držela zdroje zbytečně dlouho, a tím blokovala ostatní vlákna.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"b5bc9b12-0fe3-42a9-905d-71441c95ee64",correct:"Podmínka kruhového čekání, esenciální pro vznik uváznutí, je detekovatelná pomocí statického grafu závislostí zdrojů, kde hrana z R do S indikuje, že existuje vlákno, které může požadovat zdroj S, když už drží zdroj R. Kruhové čekání je splněno, pokud v tomto grafu existuje cyklus, což signalizuje vzájemnou blokaci vláken čekajících na zdroje držené jinými vlákny v cyklu.",incorrect:"Podmínka kruhového čekání, která efektivně předchází uváznutí, je založena na dynamickém grafu alokace zdrojů, kde cyklus v grafu indikuje, že systém aktivně detekuje a řeší potenciální uváznutí. Operační systém pravidelně analyzuje tento graf a v případě detekce cyklu dynamicky přerozděluje zdroje, čímž proaktivně zabraňuje vzniku uváznutí.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"1b3e27f6-9a64-4171-b51e-f68695c5f080",correct:"Uváznutí, jakožto důsledek hazardu souběhu, se může projevovat velmi zřídka, což je vlastnost, kterou Pštrosí algoritmus cíleně využívá ve svém přístupu k řešení tohoto problému tím, že v případě detekce uváznutí jednoduše restartuje celý systém nebo ukončí dotčené procesy, a spoléhá se na nízkou pravděpodobnost výskytu uváznutí v reálném provozu.",incorrect:"Uváznutí, jakožto důsledek chyb v kódu, se projevuje velmi často, což je vlastnost, kterou Pštrosí algoritmus cíleně využívá ve svém přístupu k řešení tohoto problému tím, že v případě detekce uváznutí se snaží uváznutí elegantně vyřešit sofistikovanými mechanismy, a spoléhá se na vysokou pravděpodobnost výskytu uváznutí v reálném provozu.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"f3dfb8d9-fa94-4b37-9ddf-e320c576c6b9",correct:"Pštrosí algoritmus, efektivní strategie pro řešení uváznutí, se opírá o předpoklad, že výskyt uváznutí je v praxi relativně vzácný jev, a proto v případě, kdy uváznutí nastane, se uchyluje k radikálnímu řešení, jako je restart celého systému, namísto implementace složitých mechanismů pro detekci a obnovu z uváznutí.",incorrect:"Pštrosí algoritmus, efektivní strategie pro řešení uváznutí, se opírá o předpoklad, že výskyt uváznutí je v praxi velmi častý jev, a proto v případě, kdy uváznutí nastane, se uchyluje k sofistikovanému řešení, jako je detailní analýza stavu systému a následná obnova z uváznutí bez nutnosti restartu systému.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"d1eb53a8-889d-4fe2-a963-c00446f9dfd9",correct:"Rozhodnutí, zda v systému skutečně došlo k uváznutí, může být v mnoha případech obtížné a nejednoznačné, a proto se Pštrosí algoritmus záměrně vyhýbá složité detekci uváznutí a spoléhá se na externí indikaci problému, například nereagující systém, kdy je rozhodnutí o existenci uváznutí delegováno na uživatele, který může systém restartovat.",incorrect:"Rozhodnutí, zda v systému skutečně došlo k uváznutí, je obvykle triviální a jednoznačné, a proto se Pštrosí algoritmus aktivně snaží o automatickou a spolehlivou detekci uváznutí pomocí komplexních algoritmů, přičemž se zcela vyhýbá spoléhání na externí indikaci problému nebo delegování rozhodnutí o uváznutí na uživatele.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"3d80c4a7-ec4c-464d-9921-695fdc5b5a1f",correct:"Detekce uváznutí v systémech s operačním systémem se často provádí pomocí dynamické varianty grafu závislostí zdrojů, který modeluje vztahy mezi vlákny a zdroji. V tomto grafu existují dva typy uzlů: vlákna a zdroje. Hrana směřující od zdroje k vláknu indikuje, že vlákno vlastní zdroj, zatímco hrana od vlákna ke zdroji značí, že vlákno čeká na přidělení daného zdroje.",incorrect:"Detekce uváznutí v systémech s operačním systémem se obvykle provádí kontrolou grafu závislostí zdrojů, který je statický a nemění se v průběhu běhu systému. Tento graf obsahuje pouze uzly reprezentující zdroje a hrany mezi nimi indikují, které zdroje jsou navzájem závislé. Cyklus v tomto grafu indikuje potenciální uváznutí, ale pro detekci aktuálního uváznutí je nutné provést další analýzu běhu systému.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"beafb338-c324-4ae1-b0e8-339ea577cce2",correct:"V grafu závislostí zdrojů, používaném pro detekci uváznutí, cyklus představuje stav uváznutí. Konkrétně, pokud graf obsahuje cyklus, všechna vlákna, která jsou součástí tohoto cyklu, jsou uvázlá. Tento detekční mechanismus je efektivní pro zdroje s jedinou instancí, jako jsou mutexy chránící kritické sekce, protože pro zdroje s více instancemi je nutné použít složitější algoritmy, které se v praxi ale běžně nepoužívají.",incorrect:"Graf závislostí zdrojů pro detekci uváznutí je účinný pro všechny typy zdrojů, včetně těch s více instancemi. Cyklus v tomto grafu vždy indikuje uváznutí, a to bez ohledu na to, zda zdroje v cyklu mají jednu nebo více instancí. Pro zdroje s více instancemi je detekce uváznutí dokonce jednodušší, protože graf se stává méně komplexním a cykly jsou snáze identifikovatelné.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"e7f9c81b-b22c-4495-ad2c-29a3c33b36d4",correct:"Dynamický graf závislostí zdrojů, používaný pro detekci uváznutí, se skládá z uzlů reprezentujících vlákna a zdroje. Hrana směřující od vlákna k zdroji indikuje, že vlákno čeká na tento zdroj, zatímco hrana od zdroje k vláknu indikuje, že vlákno zdroj vlastní. Existence cyklu v tomto grafu je spolehlivým indikátorem uváznutí, a platí, že každý cyklus v grafu závislostí zdrojů musí mít sudou délku a obsahovat minimálně čtyři hrany.",incorrect:"V kontextu detekce uváznutí pomocí grafu závislostí zdrojů, hrana směřující od vlákna k zdroji indikuje, že vlákno vlastní daný zdroj, a hrana od zdroje k vláknu značí, že vlákno o zdroj žádá. Cyklus v tomto grafu naznačuje potenciální problém s alokací zdrojů, ale nemusí nutně znamenat uváznutí. Pro potvrzení uváznutí je nutné analyzovat další faktory, jako je priorita vláken a dostupnost dalších systémových zdrojů.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"62686539-74ba-491e-9e56-2df7220ac183",correct:"Účastní-li se cyklického čekání alespoň jeden odnímatelný zdroj, systém se může z uváznutí zotavit dočasným odebráním tohoto zdroje, čímž se přeruší cyklus čekajících vláken a umožní se pokračování systému bez nutnosti násilného ukončování procesů, což je efektivnější řešení než restart celého systému.",incorrect:"Účastní-li se cyklického čekání alespoň jeden odnímatelný zdroj, systém se nemůže z uváznutí zotavit bez násilného ukončení alespoň jednoho procesu účastnícího se cyklu, protože odebrání odnímatelného zdroje nepřeruší cyklus čekajících vláken a situace vyžaduje radikálnější zásah, jako je restart celého systému.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"4cfff62b-5e66-4c9b-97e2-e0eadc8cae65",correct:"Pokud se cyklického čekání účastní pouze neodnímatelné zdroje a nelze provést rollback transakcí, jediným zbývajícím efektivním způsobem, jak se z uváznutí zotavit bez restartování celého systému, je násilné ukončení jednoho z procesů, které se cyklu účastní, a uvolnění tak alespoň jednoho zdroje pro další procesy.",incorrect:"Pokud se cyklického čekání účastní pouze neodnímatelné zdroje, nejefektivnějším a preferovaným způsobem zotavení z uváznutí je vždy restart celého systému, protože násilné ukončování jednotlivých procesů je příliš riskantní a může vést k nestabilitě systému a ztrátě dat, zatímco rollback transakcí je vždy dostupný a spolehlivý mechanismus.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"140786b4-462b-4a74-a994-44e15e86ce1c",correct:'Strategie vyhýbání se uváznutí, jako je bankéřův algoritmus, se primárně zaměřuje na prevenci potenciálních uváznutí strategickým zamítáním některých požadavků na rezervaci zdrojů, i když jsou zdroje momentálně dostupné. Klíčovým principem je udržování systému v "bezpečném stavu", kde je zaručeno, že alespoň jedno vlákno může dokončit svůj běh a uvolnit zdroje, čímž se zajistí celková systémová stabilita a zabrání se vzniku uváznutí.',incorrect:"Strategie vyhýbání se uváznutí, jako je bankéřův algoritmus, se primárně zaměřuje na maximalizaci využití zdrojů tím, že přijímá co nejvíce požadavků na rezervace, dokud nejsou zdroje zcela vyčerpány. I když jsou zdroje momentálně dostupné, algoritmus upřednostňuje jejich okamžité přidělení, aby se zvýšila propustnost systému a minimalizovalo se čekání vláken, bez ohledu na potenciální budoucí riziko uváznutí.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"54028c04-08bd-4ad2-a4c4-abce6d5d11af",correct:"Bankéřův algoritmus, coby reprezentant techniky vyhýbání se uváznutí, klade zásadní důraz na znalost maximálních požadavků každého vlákna na zdroje ještě před samotným zahájením jeho běhu. Tato vstupní informace o maximálních nárocích je pro algoritmus klíčová, neboť mu umožňuje ex ante analyzovat potenciální dopad každé alokace zdrojů a posoudit, zda by přidělení zdrojů danému vláknu neohrozilo bezpečnost systému a nemohlo vést k uváznutí v budoucnu.",incorrect:"Bankéřův algoritmus pro vyhýbání se uváznutí se obejde bez předchozí znalosti maximálních požadavků vláken na zdroje. Algoritmus operuje dynamicky, alokuje zdroje na základě aktuální dostupnosti a bezprostředních potřeb vláken, a spoléhá se na kontinuální monitorování stavu systému a adaptabilní predikci budoucího využití zdrojů, aniž by vyžadoval pevnou znalost maximálních požadavků vláken předem.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"7e62476f-31a1-4c49-a695-d52e8621fe73",correct:"Mechanismus vyhýbání se uváznutí, jak je popsán v předchozí sekci, je v mnoha praktických situacích obtížně použitelný, zejména proto, že mnoho systémových zdrojů má pouze jednu instanci, což v kombinaci s bankéřovým algoritmem může vést k omezení souběžného využívání zdrojů více vlákny.",incorrect:"Mechanismus vyhýbání se uváznutí, založený na principu bankéřova algoritmu, je ve většině praktických situací velmi efektivní a široce používaný, protože umožňuje optimálně alokovat zdroje a maximalizovat souběžnost běhu vláken v operačním systému.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"971e88b1-3a88-4a3f-bf8e-a6ed9ca5774c",correct:'Pro vznik uváznutí v operačním systému je nutné, aby současně platily čtyři specifické podmínky, a to "čekající vlastník", "vzájemné vyloučení", "kruhové čekání" a ještě jedna další podmínka, která z textu bohužel není přímo zmíněna, ale je součástí standardního výčtu podmínek uváznutí.',incorrect:'K uváznutí v operačním systému může dojít i v případě, že jsou splněny pouze tři z nutných podmínek, konkrétně "čekající vlastník", "vzájemné vyloučení" a "kruhové čekání", přičemž čtvrtá podmínka, i když obvykle přítomná, není pro samotný vznik uváznutí kritická.',sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"21a0f7b6-9a83-4edf-aabe-367fa2fc4e0d",correct:'Zamezení uváznutí v operačním systému je možné dosáhnout eliminací alespoň jedné ze čtyř nutných podmínek, které musí být splněny současně, aby k uváznutí došlo.  Konkrétně, pokud se nám podaří zamezit podmínce "kruhové čekání" globálním uspořádáním zdrojů, uváznutí se vyhneme.',incorrect:"Zamezení uváznutí v operačním systému vyžaduje eliminaci alespoň dvou ze čtyř nutných podmínek současně, protože pouhé odstranění jedné podmínky obvykle nestačí k prevenci uváznutí v komplexních systémech s mnoha vzájemně závislými procesy.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"2bff2823-df5f-4a85-80f0-0e1d9c629176",correct:"Myšlenka předrezervace zdrojů v operačních systémech spočívá v zamezení situace, kdy vlákno, které již vlastní nějaký zdroj, musí čekat na přidělení dalšího zdroje, čímž se předchází potenciálnímu uváznutí systému a zajišťuje se efektivnější využití systémových prostředků.",incorrect:"Myšlenka předrezervace zdrojů v operačních systémech spočívá v umožnění situace, kdy vlákno, které již vlastní nějaký zdroj, může čekat na přidělení dalšího zdroje, což je běžná praxe pro optimalizaci využití zdrojů a minimalizaci režie spojené s uvolňováním a opětovným získáváním zdrojů.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"561d2690-7255-49c6-89dd-1e73d6b2599c",correct:"V kontextu předrezervace zdrojů operační systém povolí rezervaci požadovaných zdrojů pouze za předpokladu, že žádající vlákno aktuálně nevlastní žádné jiné zdroje, což je klíčový mechanismus pro zjednodušení správy zdrojů a prevenci vzniku cyklických závislostí mezi vlákny a zdroji.",incorrect:"V kontextu předrezervace zdrojů operační systém povolí rezervaci požadovaných zdrojů i v případě, že žádající vlákno aktuálně vlastní jiné zdroje, za předpokladu, že nové zdroje nejsou v konfliktu s již vlastněnými zdroji, což umožňuje flexibilnější a efektivnější správu zdrojů v systému.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"688dee45-d7ba-4d27-9b0a-6d38a06922e4",correct:"Pro praktické využití předrezervace zdrojů operační systémy často implementují dávkovou rezervaci, která umožňuje vláknu vyžádat si všechny potřebné zdroje najednou v rámci jediné atomické operace, ačkoliv uvolňování těchto zdrojů může probíhat postupně dle aktuální potřeby vlákna.",incorrect:"Pro praktické využití předrezervace zdrojů operační systémy vyžadují, aby vlákno vyžadovalo zdroje postupně, jeden po druhém, a to i v případě, že vlákno dopředu ví, že bude potřebovat více zdrojů, přičemž atomická operace pro vyžádání více zdrojů najednou není v tomto modelu podporována.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"a12b39e1-bdbf-45e3-9440-154d577b8756",correct:"Virtualizace zdrojů, jako je tiskárna, typicky využívá mechanismu fronty požadavků, kde aplikace přistupuje k virtuální tiskárně, která ukládá tiskové úlohy do souborů a následně je postupně odesílá skutečné tiskárně, což umožňuje sdílení tiskového zařízení mezi více programy a zamezuje přímému konfliktu o tiskárnu.",incorrect:"Virtualizace zdrojů, jako je tiskárna, typicky obchází mechanismus fronty požadavků a namísto toho aplikace přímo přistupují k fyzické tiskárně s výhradním přístupem, což zajišťuje okamžitý tisk, ale zároveň efektivně umožňuje sdílení tiskového zařízení mezi více programy a minimalizuje potenciální konflikty o tiskárnu.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"8d2256fa-089a-4ea6-97ac-8f227f10e15a",correct:"Podle textu, virtualizované zdroje, jako například procesor nebo paměť, nepoužívají systém výlučné rezervace a samy o sobě nemohou přímo způsobit uváznutí systému, protože nesplňují podmínku vzájemného vyloučení, která je nutná pro vznik klasického uváznutí, jak bylo popsáno v úvodních kapitolách.",incorrect:"Podle textu, virtualizované zdroje, jako například procesor nebo paměť, běžně používají systém výlučné rezervace a samy o sobě mohou přímo a snadno způsobit uváznutí systému, protože plně splňují podmínku vzájemného vyloučení, která je klíčová pro vznik uváznutí, jak je detailně popsáno v úvodních kapitolách.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"07df7112-c3de-4b49-a7a2-09f2523f9836",correct:"Text uvádí, že virtualizace tiskárny, založená na ukládání tiskových úloh do souborů, je teoreticky náchylná na vyčerpání místa na pevném disku, ale tento problém je považován za relativně snadno řešitelný, zejména ve srovnání s potenciálními problémy spojenými s uváznutím tiskárny samotné a nutností rušit částečně vytištěné úlohy.",incorrect:"Text uvádí, že virtualizace tiskárny, založená na ukládání tiskových úloh do souborů, je zcela imunní vůči vyčerpání místa na pevném disku a tento problém se v praxi nikdy nevyskytuje, což činí virtualizaci tiskáren absolutně bezproblémovou z hlediska správy úložného prostoru a eliminuje jakékoli starosti o dostupné místo.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"fda67569-dc3b-4596-a685-8c270ccb0d5c",correct:"Zavedení globálního lineárního uspořádání zdrojů efektivně předchází uváznutí v systémech tím, že cíleně eliminuje podmínku kruhového čekání. Tato metoda spočívá v zavedení striktního pořadí, ve kterém musí vlákna žádat o zdroje, čímž se zamezí vzniku cyklických závislostí v grafu alokace zdrojů a tím i potenciálnímu uváznutí.",incorrect:"Zavedení globálního lineárního uspořádání zdrojů je sice jednou z metod prevence uváznutí, avšak neřeší primárně problém kruhového čekání.  Tato metoda se zaměřuje spíše na omezení souběžného přístupu ke zdrojům a i když může v některých případech snížit pravděpodobnost uváznutí, kruhové čekání jako základní příčinu uváznutí přímo neeliminuje.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"},{uuid:"9f8e4302-e06d-4be2-aace-5a6ee040da40",correct:"Přestože je koncept globálního uspořádání zdrojů užitečný a prakticky aplikovatelný v rámci uzavřených systémů, jako jsou jednotlivé programy či monolitická jádra operačních systémů, jeho implementace v rozsáhlém operačním systému jako celku naráží na problémy škálovatelnosti a administrativní složitosti spojené s udržením globálního pořadí zdrojů napříč celým systémem.",incorrect:"Koncept globálního uspořádání zdrojů představuje ideální a plně škálovatelné řešení pro prevenci uváznutí i v rozsáhlých operačních systémech. Jeho implementace v celém operačním systému je snadná a efektivní, neboť globální pořadí zdrojů lze centrálně spravovat a dynamicky přizpůsobovat aktuálním potřebám systému bez složitostí a administrativní zátěže.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"},{uuid:"23e48f0a-0a98-4c78-8588-1468d52feab5",correct:'V systému s globálním lineárním uspořádáním zdrojů je klíčovým pravidlem, že vlákno smí alokovat pouze takový zdroj, který se v globálním uspořádání nachází "za" aktuálně největším zdrojem, který již dané vlákno drží.  Toto pravidlo zajišťuje, že statický graf závislostí zdrojů nemůže obsahovat cykly, a tím je uváznutí efektivně zabráněno.',incorrect:"V systému s globálním lineárním uspořádáním zdrojů se vlákna mohou řídit doporučeným pořadím pro alokaci zdrojů, avšak toto pořadí není striktně vynucováno systémem. Vlákna tak mají stále možnost alokovat zdroje i mimo stanovené pořadí, což sice zvyšuje flexibilitu alokace, ale současně ponechává systém zranitelný vůči uváznutí způsobenému cyklickými závislostmi.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"}]},{uuid:"28f24d2f-fc48-4012-a7e9-bad847f0eb09",sectionNumber:"8",sectionTitle:"Přerušení a periferie",statements:[{uuid:"f278bed9-b78e-4d4c-bfbe-8af240f2436a",correct:"Přerušení v operačních systémech slouží jako synchronizační mechanismus, který umožňuje koordinaci mezi hardwarem, konkrétně periferiemi, a softwarem, zejména operačním systémem. V abstraktní rovině je možné přerušení chápat jako specifický typ synchronizačního nástroje, který se odlišuje od běžných mechanismů pro synchronizaci softwarových vláken tím, že zprostředkovává interakci mezi hardwarem a softwarem, a nikoli pouze mezi dvěma softwarovými entitami.",incorrect:"Přerušení v operačních systémech slouží primárně jako mechanismus pro optimalizaci výkonu procesoru, umožňující operačnímu systému efektivněji spravovat procesy a přidělovat systémové zdroje.  Ačkoli přerušení mohou mít vedlejší efekt synchronizace softwarových vláken, jejich hlavní účel spočívá v řízení toku instrukcí a správě hardwarových událostí, nikoli v synchronizaci periferií a operačního systému, jak je tomu u jiných synchronizačních zařízení.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"ac667f28-d50e-479a-a326-f1f62d47adf1",correct:"Asymetrie přerušení v kontextu operačních systémů se projevuje tím, že přerušení je vždy iniciováno periferií směrem k operačnímu systému, a nikoli naopak. Tato asymetrická povaha znamená, že operační systém je pasivním příjemcem signálů přerušení, které signalizují události z hardwarového prostředí, a nemůže aktivně vyvolat přerušení směrem k periferii jako formu synchronizace nebo řízení hardwaru.",incorrect:"Asymetrie přerušení v operačních systémech spočívá v tom, že přerušení mohou být iniciována jak periferiemi směrem k operačnímu systému, tak operačním systémem směrem k periferiím. Tato obousměrná povaha umožňuje operačnímu systému aktivně řídit a synchronizovat periferie prostřednictvím mechanismu přerušení, čímž se zvyšuje flexibilita a kontrola nad hardwarovými komponentami systému.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"e910a4f1-ecfc-4099-9268-2141860d1cd1",correct:"Přestože se přerušení v operačních systémech liší od tradičních synchronizačních mechanismů, jako jsou podmínkové proměnné, v mnoha ohledech se jim funkčně podobají. Stejně jako podmínková proměnná, i přerušení slouží k signalizaci události – v případě přerušení se jedná o událost hardwarovou, iniciovanou periferií, která vyžaduje reakci operačního systému. Toto signalizační chování umožňuje operačnímu systému efektivně reagovat na asynchronní události z periferií.",incorrect:"Přerušení v operačních systémech se zásadně liší od synchronizačních mechanismů, jako jsou podmínkové proměnné, a nemají s nimi funkční paralely. Zatímco podmínkové proměnné slouží k synchronizaci softwarových vláken a čekání na splnění určitých podmínek, přerušení představují zcela odlišný mechanismus pro zpracování hardwarových událostí a nemají žádnou roli v synchronizaci softwarových procesů nebo vláken v operačním systému.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"fa2baad5-6cc7-4758-bf70-d79997eded72",correct:"Přerušení je hardwarový mechanizmus, který je iniciován periferiemi nebo jinými hardwarovými komponentami a slouží k signalizaci procesoru o událostech, které vyžadují okamžitou pozornost, jako je dokončení I/O operace nebo výskyt chyby, a jeho implementace je nezbytná pro efektivní fungování moderních operačních systémů.",incorrect:"Přerušení je softwarový mechanizmus operačního systému, který je iniciován běžícími procesy a slouží k plánování úloh a správě systémových prostředků, přičemž se jedná o plně softwarovou abstrakci implementovanou výhradně na úrovni operačního systému bez nutnosti hardwarové podpory.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"d35fb843-6903-4aed-b535-1dd4c622df75",correct:"Operační systém, jakožto komplexní programový systém, je vykonáván centrální procesorovou jednotkou (CPU), která provádí jeho instrukce a zajišťuje tak veškerou funkčnost systému, od správy paměti a procesů až po obsluhu periferií a poskytování uživatelského rozhraní, což je klíčové pro běh aplikací a interakci uživatele s počítačem.",incorrect:"Operační systém je primárně vykonáván v operační paměti (RAM) a je nezávislý na centrální procesorové jednotce (CPU), která pouze zajišťuje provádění jednotlivých aplikací a periferních zařízení, přičemž operační systém funguje jako pasivní správce zdrojů uložený v paměti.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"1d6ab62a-c7fa-43b8-9aa3-f6331f38069d",correct:"Realizace přerušení je klíčovou funkcí centrální procesorové jednotky (CPU), která po obdržení signálu přerušení z periferie nebo jiného zdroje musí přerušit aktuálně prováděný program, uložit jeho stav a spustit obslužnou rutinu přerušení, čímž zajistí rychlou a efektivní reakci na události vyžadující okamžitou pozornost.",incorrect:"Realizace přerušení je plně v kompetenci operačního systému, který na základě signálu z periferie sám obslouží přerušení bez přímého zásahu centrální procesorové jednotky (CPU), přičemž CPU je pouze informováno o dokončení obsluhy přerušení operačním systémem.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"009a87af-f4fa-4dfe-ad3c-82022446254b",correct:"Přerušení v operačních systémech jsou implementována jako preemptivní mechanismus, což znamená, že v okamžiku výskytu přerušení je aktuálně běžící procesorová činnost okamžitě pozastavena, stav aktuálního vlákna je uložen a procesor začne vykonávat obsluhu přerušení, aby se minimalizovala latence a zajistila rychlá reakce na důležité události.",incorrect:"Přerušení v operačních systémech jsou obvykle implementována jako nepreemptivní mechanismus, což znamená, že aktuálně běžící procesorová činnost není okamžitě pozastavena, ale obsluha přerušení je odložena až do dokončení aktuální instrukce nebo bloku instrukcí, aby se minimalizovalo režijní náklady spojené s přepínáním kontextu.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"b45a8e7b-9873-44d5-9d9e-3e8b8c56e3ec",correct:"Přerušení v operačních systémech existují v instancích, jejichž počet je omezen hardwarovými specifikacemi a typicky dosahuje maximálního počtu 256, přičemž každá instance přerušení je identifikována unikátním číslem, což umožňuje operačnímu systému rozlišovat mezi různými zdroji přerušení a efektivně spravovat asynchronní události vyvolané hardwarem nebo softwarem.",incorrect:"Přerušení v operačních systémech existují pouze v jedné globální instanci, která není omezena hardwarovými specifikacemi, a není identifikována unikátním číslem, což zjednodušuje správu asynchronních událostí, ale omezuje schopnost operačního systému efektivně rozlišovat mezi různými zdroji přerušení a spravovat specifické požadavky jednotlivých periferií.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"9b55aef3-330d-4455-b864-f5ec5acfaca3",correct:"Obsluha přerušení je v operačních systémech realizována prostřednictvím specializovaných podprogramů, jejichž adresy jsou uloženy v tabulce obsluhy přerušení, což umožňuje systému rychle a efektivně reagovat na přerušení; tato tabulka funguje jako klíčový mechanismus pro směrování řízení k odpovídající obslužné rutině na základě čísla přerušení.",incorrect:"Obsluha přerušení je v operačních systémech realizována přímo v jádře operačního systému bez použití podprogramů nebo tabulek obsluhy přerušení, což eliminuje režii spojenou s vyhledáváním adres obslužných rutin, ale zároveň činí reakci na přerušení méně flexibilní a hůře škálovatelnou pro systémy s velkým množstvím periferií a typů přerušení.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"6cfc9f3e-5a4e-4ef6-8f5c-0155128c9187",correct:"Přestože přerušení v operačních systémech mohou být chápána jako synchronizační mechanismy podobné podmínkovým proměnným, jsou implementována hardwarově na nízké úrovni, což znamená, že počet instancí přerušení je fixní a omezený hardwarovou architekturou systému, na rozdíl od softwarových synchronizačních mechanismů, které mohou být dynamicky vytvářeny a rušeny.",incorrect:"Přestože přerušení v operačních systémech mohou být chápána jako synchronizační mechanismy podobné semaforům, jsou implementována softwarově na vysoké úrovni, což znamená, že počet instancí přerušení je dynamický a neomezený hardwarovou architekturou systému, podobně jako softwarové synchronizační mechanismy, které mohou být flexibilně vytvářeny a rušeny podle potřeby.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"a225d903-75d1-4763-b3ba-352aee711c9d",correct:"Obslužný podprogram přerušení se podobá standardnímu podprogramu v tom, že může být implementován v jazyce vysoké úrovně, jako je C, a je schopen volat další podprogramy, což mu umožňuje provádět komplexnější operace a využívat existující knihovny a funkce pro zpracování přerušení.",incorrect:"Obslužný podprogram přerušení se zásadně liší od standardního podprogramu v tom, že nemůže být implementován v jazyce vysoké úrovně, jako je C, a není schopen volat další podprogramy, což ho omezuje na velmi jednoduché operace a vyžaduje implementaci ve strojovém kódu.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"609a997b-1a0b-47f1-b406-82b47e973540",correct:"Pro zajištění správné funkčnosti obsluhy přerušení a zabránění kolizím se stávajícím kontextem procesu se stav procesoru při vstupu do obslužného podprogramu ukládá do operační paměti RAM a běžně dochází k přepnutí na vyhrazený zásobník, čímž se izoluje paměťový prostor obsluhy přerušení.",incorrect:"Pro urychlení zpracování přerušení a minimalizaci režie se stav procesoru při vstupu do obslužného podprogramu neukládá a nikdy nedochází k přepnutí na vyhrazený zásobník, čímž obsluha přerušení sdílí paměťový prostor s aktuálně běžícím procesem.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"f1078049-8043-4045-8df2-4dd0ddedabfe",correct:"Ačkoliv se obsluha přerušení chová podobně jako aktivace vlákna v operačním systému, s ohledem na krátkodobost jejího běhu a fakt, že po jejím ukončení se stav procesoru neukládá pro pozdější pokračování, je přesnější chápat obsluhu přerušení spíše jako formu krátkodobého vlákna s omezenou životností.",incorrect:"Obsluha přerušení se chová zcela identicky jako aktivace standardního vlákna v operačním systému, včetně dlouhodobého charakteru jejího běhu a faktu, že po jejím ukončení se stav procesoru ukládá pro pozdější pokračování, což umožňuje obsluze přerušení běžet na pozadí.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"8f9402a7-dfe0-41ec-8669-7e184ba65a47",correct:"Obsluha přerušení musí řešit synchronizaci s ostatními procesorovými jádry, kde mohou běžet jiné části systému včetně obsluh přerušení, a pro tento scénář je možné použít spinlocky nebo nezamykající komunikační mechanismy, protože procesorová jádra pracují paralelně a mohou se synchronizovat běžnými prostředky pro víceprocesorové systémy.",incorrect:"Obsluha přerušení se nikdy nemusí synchronizovat s ostatními procesorovými jádry, protože přerušení jsou vždy zpracovávána izolovaně na jádře, na kterém vznikla, a proto se nemůže stát, že by obsluha přerušení běžící na jednom jádře ovlivnila běh obsluhy přerušení nebo jiného kódu jádra běžícího na jiném jádře.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"465e6f78-5971-4bd0-aa8f-190438af03cd",correct:"Pro synchronizaci obsluhy přerušení se zbytkem systému běžícím na stejném procesorovém jádře, který byl přerušen, nelze použít spinlocky, protože přerušený kód nemůže pokračovat v běhu, dokud obsluha přerušení neskončí, což by vedlo k uváznutí (deadlocku), pokud by se přerušený kód pokoušel získat stejný spinlock.",incorrect:"Pro synchronizaci obsluhy přerušení se zbytkem systému běžícím na stejném procesorovém jádře je spinlock ideálním řešením, protože zaručuje exkluzivní přístup k sdíleným zdrojům a zároveň umožňuje obsluze přerušení efektivně čekat na uvolnění zámku, aniž by musela přepínat kontext nebo blokovat plánovač.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"8208739f-22d7-4a71-8495-2582c5c0e42a",correct:"Pokud dojde k souběžnému přerušení na stejném procesorovém jádře, synchronizace obsluh těchto přerušení se řeší zákazem přerušení, což odloží obsluhu nově příchozího přerušení až do doby, kdy je aktuálně obsluhované přerušení dokončeno a přerušení jsou opětovně povolena, čímž se zajistí vzájemné vyloučení.",incorrect:"Při souběžném přerušení na stejném procesorovém jádře se synchronizace obsluh přerušení provádí pomocí semaforů, které umožňují obsluhám přerušení vzájemně se blokovat a uvolňovat, a tím koordinovat přístup ke sdíleným zdrojům a zajistit správné pořadí zpracování událostí, aniž by bylo nutné zakazovat přerušení.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"665d4982-7976-4f84-8fed-3884ff6732c4",correct:"Zákaz přerušení v operačním systému je záměrně navržen jako asymetrický mechanismus, kde obslužný podprogram přerušení může zakázat přerušení, aby ochránil kritickou sekci kódu před konkurenčním přístupem ze strany jiných částí jádra, ale nemůže tímto zákazem ovlivnit chování jiných částí jádra, které by se mohly pokoušet o zakázání přerušení z jiných důvodů.",incorrect:"Zákaz přerušení v operačním systému je symetrický mechanismus, kde jak obslužný podprogram přerušení, tak i jiné části jádra mohou vzájemně ovlivňovat své schopnosti zakazovat přerušení, což zajišťuje flexibilní a vyvážený přístup k synchronizaci kritických sekcí v jádře operačního systému a umožňuje komplexní koordinaci mezi různými komponentami systému.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"bd66511b-4608-4d67-b7b8-1881d511cae5",correct:"Přestože je zákaz přerušení efektivní technikou pro ochranu kritických sekcí v jádře operačního systému, je zásadní, aby doba trvání zákazu přerušení byla minimalizována, protože prodloužený zákaz přerušení může negativně ovlivnit odezvu systému na externí události a způsobit zpoždění v obsluze dalších, potenciálně důležitých přerušení.",incorrect:"Dlouhodobý zákaz přerušení v operačním systému je běžnou a doporučenou praxí pro zajištění maximální bezpečnosti a integrity kritických sekcí, protože delší doba zákazu poskytuje větší jistotu, že nedojde ke konkurenčnímu přístupu nebo narušení kritické operace, a minimalizuje tak riziko chyb a nestability systému.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"97f4cc00-f0c8-4249-9ebe-6923204d33c4",correct:"V kontextu synchronizace mezi obsluhou přerušení a zbytkem jádra operačního systému je klíčové rozlišovat dva scénáře kritických sekcí: první, kdy obsluha přerušení obsahuje kritickou sekci vůči zbytku jádra, a druhý, kdy jiná část jádra je kritická vůči akcím prováděným v obsluze přerušení, přičemž každý scénář vyžaduje specifický přístup k synchronizaci a ochraně sdílených zdrojů.",incorrect:"V kontextu synchronizace mezi obsluhou přerušení a zbytkem jádra operačního systému není nutné rozlišovat různé scénáře kritických sekcí, protože mechanismy synchronizace, jako je zákaz přerušení, jsou univerzální a efektivně řeší všechny potenciální konflikty a konkurenční přístupy ke sdíleným zdrojům bez ohledu na specifickou povahu kritické sekce nebo interakce mezi obsluhou přerušení a zbytkem jádra.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"06e28da4-ab67-4485-9e16-2cc936d89064",correct:"Vlákno, v kontextu operačních systémů, je definováno jako sekvenční výpočetní jednotka reprezentující posloupnost změn stavu, která vzniká nepřerušenou činností procesoru řízeného programem, přičemž klíčovým rysem vláken je jejich nezávislost na adresním prostoru, což umožňuje existenci více vláken v rámci jednoho procesu, sdílejících společný adresní prostor a systémové zdroje.",incorrect:"Vlákno je v operačních systémech chápáno jako zcela izolovaná výpočetní jednotka, která je striktně vázána na adresní prostor procesu, což znamená, že každý proces může obsahovat výhradně jedno vlákno, které má exkluzivní a izolovaný přístup k adresnímu prostoru daného procesu, a sdílení adresního prostoru mezi vlákny v jednom procesu není možné.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"efab0ccb-3854-40d7-b946-c5bde2991fda",correct:"Aktivace obsluhy přerušení v operačním systému vykazuje podobnosti s aktivací vlákna, zejména v kontextu minimalizace režijních nákladů spojených s přepínáním procesů, jelikož obsluha přerušení je aktivována bez nutnosti přepnutí procesu a běží v adresním prostoru aktuálně aktivního procesu, čímž se zásadně odlišuje od aktivace nového procesu, která vyžaduje nákladnou změnu mapování paměti.",incorrect:"Aktivace obsluhy přerušení se v operačních systémech zásadně liší od aktivace vlákna a je analogická aktivaci nového procesu, protože obsluha přerušení vždy vyžaduje kompletní přepnutí procesu, včetně změny mapování paměti a kontextu, což vede k tomu, že obsluha přerušení běží v izolovaném adresním prostoru, odděleném od adresního prostoru procesu, který přerušení vyvolal.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"ced905c1-db7f-4b0e-a78e-ea62ec3d960a",correct:"Pro zajištění efektivní a rychlé obsluhy přerušení v operačním systému je nezbytné, aby paměťové struktury využívané obsluhou přerušení byly mapovány do všech virtuálních adresních prostorů spuštěných procesů a současně byly dostupné na identických virtuálních adresách v rámci těchto prostorů, což umožňuje obsluze přerušení být spuštěna okamžitě v kontextu jakéhokoliv aktuálně běžícího procesu bez nutnosti složitého přepínání paměťových map.",incorrect:"Z důvodu zvýšení bezpečnosti a izolace procesů v operačním systému jsou paměťové struktury obsluhy přerušení mapovány dynamicky a výhradně do adresního prostoru procesu, který aktuálně vyvolal přerušení, a nejsou sdíleny mezi adresními prostory různých procesů, což zajišťuje, že obsluha přerušení má přístup pouze k paměti relevantního procesu a minimalizuje riziko neoprávněného přístupu k paměti jiných procesů.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"7cab4758-2914-4c5d-9670-82b540e53ce8",correct:"Obsluha přerušení operačního systému běží v provizorních podmínkách, což znamená, že se vykonává v specifickém kontextu s omezenými možnostmi, a z tohoto důvodu může blokovat přerušené vlákno, čímž se zabrání jeho souběžnému běhu na jiném procesoru a efektivní duplikaci po návratu z obsluhy přerušení.",incorrect:"Obsluha přerušení operačního systému běží v plně standardních podmínkách, což umožňuje neomezené operace a synchronizaci, a proto nikdy neblokuje přerušené vlákno, což umožňuje jeho okamžitý souběžný běh na jiném procesoru a efektivní paralelizaci po návratu z obsluhy přerušení.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"989aed34-a0e3-437c-ad10-6903d1c6e820",correct:"Kvůli provizorním podmínkám, ve kterých obsluha přerušení běží, a faktu, že blokuje přerušené vlákno, je synchronizace obsluhy přerušení s přerušeným vláknem běžnými synchronizačními mechanismy operačního systému prakticky nemožná, zvláště pokud se přerušené vlákno a obsluha přerušení týkají stejné části jádra operačního systému.",incorrect:"Díky standardním podmínkám, ve kterých obsluha přerušení běží, a faktu, že neblokuje přerušené vlákno, je synchronizace obsluhy přerušení s přerušeným vláknem pomocí běžných synchronizačních mechanismů operačního systému snadno proveditelná, a to i v případech, kdy se přerušené vlákno a obsluha přerušení týkají různých částí uživatelského prostoru.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"59874674-daac-4885-b8a3-6ea42fd9f87d",correct:"Při vstupu do obsluhy přerušení se jako běžná strategie používá zákaz dalšího přerušování, a to minimálně toho typu, které obsluhu vyvolalo, v systémech s prioritami přerušení i všech přerušení s nižší prioritou, a někdy dokonce všech přerušení úplně, což slouží k ochraně kritických sekcí obsluhy před sebou navzájem a k prevenci vyčerpání zásobníku vlivem nadměrného počtu rychle přicházejících přerušení.",incorrect:"Při vstupu do obsluhy přerušení se nikdy nepoužívá zákaz dalšího přerušování, protože moderní operační systémy jsou navrženy tak, aby efektivně zvládaly souběžné obsluhy přerušení pomocí sofistikovaných mechanismů synchronizace, jako jsou semafory a mutexy, a zákaz přerušení by zbytečně snižoval výkon systému a zvyšoval latenci zpracování událostí.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"5fa5e799-7a70-442d-89bc-6efae0890679",correct:"Obsluha přerušení typicky vykonává pouze minimální nutnou akci, která zajistí, že systém zůstane v provozuschopném stavu; to zahrnuje například vyprázdnění hardwarových mezipamětí, které by mohly přetéct, a provedení nezbytných operací plánovače, přičemž datové struktury sdílené s jinými částmi jádra musí být buď bez zámků, nebo chráněny zákazem přerušení na straně zbytku jádra.",incorrect:"Obsluha přerušení je navržena tak, aby provedla kompletní a detailní obsluhu události okamžitě a v kontextu přerušení, včetně všech operací, které by mohly být potenciálně odloženy, s cílem maximalizovat okamžitou odezvu systému na vnější události a minimalizovat latenci zpracování, i za cenu delší doby běhu obsluhy přerušení.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"4c131d0d-22cd-4f59-b6c4-4caf9f73f2c1",correct:"Běžnou součástí strategie obsluhy přerušení je naplánování zbývajících, méně časově kritických akcí na pozdější dobu, což vyžaduje explicitní komunikaci a synchronizaci s jinými částmi operačního systému, aby jádro mohlo převzít kontrolu nad těmito odloženými akcemi a zajistit jejich následné provedení v jiném kontextu, typicky mimo režim přerušení.",incorrect:"Po provedení minimální nutné akce v obsluze přerušení se veškeré zbývající operace související s přerušením provádějí okamžitě a v kontextu obsluhy přerušení, bez jakéhokoli plánování odložených akcí nebo komunikace s jinými částmi jádra, aby se zajistila co největší jednoduchost a minimalizovala režie spojená s obsluhou přerušení.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"3d5d231c-e89a-4611-88f3-0b5f511ea720",correct:"Nejzákladnější formou přerušení v operačních systémech je notifikace, která slouží jako upozornění na obecné události, jako je například synchronizační signál VSync, a je charakteristická svou relativní nezávazností, kdy zpoždění nebo i úplné vynechání její obsluhy obvykle neohrozí systém ani zpracovávaná data, což se projevuje například u vykreslování obrazu na displeji, kde zpoždění o jednu periodu VSync není kritické.",incorrect:"Nejzásadnější formou přerušení v operačních systémech je notifikace, která slouží jako upozornění na kritické události, jako je například signál plné vyrovnávací paměti, a je charakteristická svou absolutní závazností, kdy zpoždění nebo i úplné vynechání její obsluhy vždy ohrozí systém i zpracovávaná data, což se projevuje například u operací čtení dat z disku, kde zpoždění o jednu periodu notifikace je kritické.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"3e63e527-4b1d-4187-8c52-9df912152aa2",correct:"Pro periferie s nízkou přenosovou rychlostí, jako je například sériová linka UART s rychlostmi do 115200 bitů za sekundu a vyrovnávací pamětí o velikosti 128 bitů, se v operačních systémech běžně používá mechanismus předávání dat pomocí přerušení, kdy periferie upozorní systém na připravená data, a obsluha těchto přerušení není obvykle časově kritická, s frekvencí přerušení v rozmezí 75–900Hz při plném vytížení linky.",incorrect:"Pro periferie s vysokou přenosovou rychlostí, jako je například moderní grafická karta s rychlostmi v řádu gigabitů za sekundu a vyrovnávací pamětí o velikosti megabytů, se v operačních systémech běžně používá mechanismus předávání dat pomocí přerušení, kdy periferie upozorní systém na připravená data, a obsluha těchto přerušení je obvykle časově kritická, s frekvencí přerušení v rozmezí kHz-MHz při plném vytížení linky.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"02f1c5a7-d38b-4cf3-8384-75acb8a0883c",correct:"Zařízení s větší šířkou pásma, jako jsou moderní síťové karty, typicky využívají pro přenos dat mechanismus DMA, který umožňuje periferii přesouvat data přímo do operační paměti. Nicméně, i když DMA umožňuje souběžný přenos dat s chodem systému, je nezbytné tyto přenosy synchronizovat s operačním systémem, konkrétně s ovladačem zařízení, aby se zajistila správná a efektivní správa dat a systémových zdrojů.",incorrect:"Zařízení s větší šířkou pásma, jako jsou moderní síťové karty, typicky využívají pro přenos dat mechanismus DMA, který umožňuje periferii přesouvat data přímo do operační paměti.  Přestože DMA umožňuje souběžný přenos dat s chodem systému, synchronizace těchto přenosů s operačním systémem a ovladačem zařízení není nutná, protože DMA operace jsou plně autonomní a operační systém do nich nijak nezasahuje.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"272fa7bb-9ab8-44fa-80cd-928082ef9bc3",correct:"Synchronizace přenosu dat mezi operačním systémem a periferií probíhá odlišně v závislosti na směru přenosu. Směrem k periferii se synchronizace typicky realizuje zápisem do specifického registru zařízení, zatímco v opačném směru, tedy od periferie k operačnímu systému, se používá mechanismus přerušení, kdy periferie signalizuje operačnímu systému dokončení přenosu nebo potřebu další akce.",incorrect:"Synchronizace přenosu dat mezi operačním systémem a periferií probíhá jednotně, nezávisle na směru přenosu dat.  Jak směrem k periferii, tak i od periferie k operačnímu systému se synchronizace realizuje výhradně zápisem do specifických registrů zařízení, což je univerzální a dostatečný mechanismus pro všechny typy datových přenosů a periferií.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"40480540-940a-4b6e-8160-1ba3748e4a8d",correct:"Vysoké přenosové rychlosti u moderních periferií, dosahující řádově gigabitů za vteřinu, kladou značné nároky na operační systém a obsluhu přerušení. Například, při přenosové rychlosti 1 Gb/s a frekvenci přerušení 1 kHz je nutné při každém přerušení zpracovat relativně velké množství dat, konkrétně až 1 megabit, což ilustruje výzvy spojené s rychlými datovými přenosy a nutnost efektivní obsluhy přerušení.",incorrect:"Vysoké přenosové rychlosti u moderních periferií, dosahující řádově gigabitů za vteřinu, nemají zásadní vliv na nároky kladené na operační systém a obsluhu přerušení.  I při přenosové rychlosti 1 Gb/s a frekvenci přerušení 1 kHz je nutné při každém přerušení zpracovat pouze malé množství dat, srovnatelné s pomalejšími periferiemi, což ukazuje, že moderní systémy efektivně maskují dopady vysokých rychlostí přenosu dat.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"7e093252-6383-4f21-b5c3-90411ecf236a",correct:"Obsluha přerušení časovače je z pohledu operačního systému považována za obzvláště komplexní, a to zejména kvůli jejímu úzkému propojení s plánovačem vláken. Na rozdíl od většiny ostatních typů přerušení, obsluha časovače nemůže efektivně využít rozdělení na první a druhou úroveň, protože řídí plánovač, a proto musí veškeré kritické operace, jako je výběr vlákna a přepnutí kontextu, provádět přímo v první úrovni obsluhy.",incorrect:"Obsluha přerušení časovače je z pohledu operačního systému považována za jednoduchou rutinu, jelikož se primárně zaměřuje pouze na aktualizaci systémového času. Díky své jednoduchosti může obsluha časovače efektivně využívat rozdělení na první a druhou úroveň, přičemž kritické operace, jako je výběr vlákna a přepnutí kontextu, jsou odloženy do druhé úrovně, což minimalizuje zátěž první úrovně obsluhy.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"e68176d0-6b17-4d61-aa21-49b5fe78af6e",correct:"Manipulace s frontami vláken v operačním systému, která zahrnuje výběr vlákna ke spuštění a jeho odstranění z fronty, vyžaduje důslednou synchronizaci. Tyto operace musí být chráněny jak proti souběžnému přístupu z jiných procesorových jader, tak proti přerušení, a proto se obvykle používají mechanismy jako spinlocky v kombinaci se zákazem přerušení, aby se zajistila atomičnost a konzistence datových struktur plánovače.",incorrect:"Manipulace s frontami vláken v operačním systému nevyžaduje žádnou speciální synchronizaci, protože operační systém zajišťuje, že k frontám vláken přistupuje vždy pouze jedno procesorové jádro v daném okamžiku. Díky této implicitní exkluzivitě mohou být operace s frontami vláken prováděny bez obav z konfliktů nebo nekonzistencí dat, což zjednodušuje implementaci plánovače a zvyšuje jeho výkon.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"7b285ea7-e739-42bd-af25-e3d2ffa1f531",correct:"Přepnutí kontextu mezi vlákny v rámci jednoho procesu je relativně přímočaré, protože zahrnuje především obnovení uloženého kontextu cílového vlákna. Nicméně, situace se stává složitější, pokud původní a nové vlákno patří různým procesům, protože v takovém případě je kromě kontextu vlákna nutné přepnout i stránkovací tabulky, což představuje dodatečnou režii a komplikuje proces přepínání kontextu.",incorrect:"Přepnutí kontextu mezi vlákny, bez ohledu na to, zda patří ke stejnému nebo různým procesům, je v moderních operačních systémech vždy stejně jednoduché a rychlé. Operační systémy efektivně spravují paměť a kontext vláken, takže přepnutí kontextu nevyžaduje přepínání stránkovacích tabulek ani jiné složité operace, čímž se minimalizuje latence a maximalizuje výkon systému.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"f885b273-c023-4452-ad3e-bf6a877fa11e",correct:"Přerušení časovače se v operačních systémech liší od většiny ostatních přerušení tím, že obvykle nemůže efektivně delegovat časově kritické operace plánování vláken do obsluhy přerušení druhé úrovně. Důvodem je fakt, že samotný plánovač, který spouští obsluhu druhé úrovně, je řízen právě přerušením časovače, což vytváří cyklickou závislost a vyžaduje, aby klíčové plánovací operace probíhaly přímo v obsluze první úrovně přerušení časovače.",incorrect:"Přerušení časovače se v operačních systémech vyznačuje tím, že na rozdíl od většiny ostatních přerušení efektivně využívá obsluhu přerušení druhé úrovně pro všechny časově kritické operace plánování vláken. Tato architektura umožňuje, aby obsluha první úrovně přerušení časovače byla co nejkratší a nejjednodušší, zatímco komplexní plánovací algoritmy a přepínání kontextu jsou odloženy do druhé úrovně, což zvyšuje celkovou efektivitu systému.",sectionNumber:"8.3.3",sectionTitle:"Časovač"}]},{uuid:"a969f0f0-d5f2-4a79-869f-8eb945d6588e",sectionNumber:"9",sectionTitle:"Interacting with the World",statements:[{uuid:"adf4799a-12c4-4576-97e4-3999186b10b8",correct:"Zásadním posunem od pouhého ručního zapisování příkazů k spustitelným skriptům v shellu bylo zavedení konceptu řízení toku programu. To umožnilo do skriptů zahrnout podmínky, cykly a další konstrukce, které dovolují automatizovat složitější úlohy a reagovat na různé situace, čímž se shell skripty staly mnohem flexibilnějšími než pouhý seznam lineárně prováděných příkazů.",incorrect:"Zásadním posunem od pouhého ručního zapisování příkazů k spustitelným skriptům v shellu bylo zavedení striktního typového systému pro proměnné. To umožnilo lépe kontrolovat datové typy a předcházet chybám při manipulaci s daty, čímž se shell skripty staly robustnějšími pro vývoj komplexních aplikací s vysokými nároky na bezpečnost.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"0cab4425-11cd-4ab4-b032-b1006e2f07e6",correct:"Koncept proměnných v shell skriptech vychází z potřeby zástupných symbolů, které se v době běhu skriptu nahrazují konkrétními hodnotami. Tato myšlenka, inspirovaná používáním zástupných jmen souborů v ručně psaných poznámkách, umožnila vytvářet univerzálnější skripty, které lze snadno adaptovat pro různé vstupy a kontexty, aniž by bylo nutné modifikovat samotný kód skriptu.",incorrect:"Koncept proměnných v shell skriptech byl inspirován moderními programovacími jazyky a jejich silnými typovými systémy. Cílem bylo zavést do shell skriptů mechanismus pro definování složitých datových struktur a objektově orientované programování, což mělo vést k větší modularitě a znovupoužitelnosti kódu a umožnit vývoj rozsáhlých softwarových systémů.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"a07fd6ae-cf5e-41c7-84fa-d1e2d5f219c9",correct:"Jedním z rysů shell skriptů, který se do značné míry přenesl z manuálního přístupu k zápisu příkazů, je nedostatečné explicitní zpracování chyb. Stejně jako v papírových poznámkách, kde se nepředpokládá detailní instrukce pro případ selhání, i shell skripty tradičně postrádají robustní mechanismy pro zachytávání a řešení chyb, což klade větší nároky na pozornost programátora při návrhu a testování skriptů.",incorrect:"Shell skripty se vyznačují propracovaným systémem pro explicitní zpracování chyb, který byl implementován s cílem zvýšit spolehlivost a robustnost skriptů. Tento systém umožňuje programátorům definovat detailní reakce na různé typy chyb, včetně mechanismů pro obnovu z chybových stavů a logování, což činí shell skripty vhodnými pro kritické aplikace vyžadující vysokou úroveň odolnosti proti chybám.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"3158a331-c477-4690-bc36-74e3397496ce",correct:"Většina shellů, jak je uvedeno v materiálech, nabízí interaktivní režim, který umožňuje uživateli zadávat jednotlivé příkazy nebo i komplexnější konstrukce, jako jsou smyčky, přímo z klávesnice. Po potvrzení zadaného příkazu dojde k jeho okamžitému provedení. Tento interaktivní přístup tvoří základ pro ovládání operačního systému prostřednictvím příkazové řádky a umožňuje rychlé testování a spouštění jednotlivých operací.",incorrect:"Pouze menšina shellů disponuje interaktivním režimem, který by umožňoval zadávání jednotlivých příkazů z klávesnice. Většina shellů vyžaduje předem napsané skripty a interaktivní režim je dostupný jen pro velmi omezený soubor operací. Potvrzení příkazu v interaktivním režimu neznamená jeho okamžité provedení, ale zařazení do fronty úloh, což zdržuje interaktivní práci a testování jednotlivých funkcí.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"a094e6cc-0110-42fc-be27-a338128cb25a",correct:"Interaktivní režim shellu a shell skripty sdílejí naprosto stejnou syntaxi a sadu dostupných příkazů a konstrukcí. To znamená, že jakákoliv syntax, kterou lze použít v shell skriptu, je plně platná a funkční i v interaktivním režimu příkazové řádky. Tato jednotnost umožňuje uživatelům snadno přecházet mezi interaktivním testováním příkazů a vytvářením komplexnějších skriptů bez nutnosti učit se odlišné syntaktické pravidla.",incorrect:"Syntaxe a dostupné příkazy se významně liší mezi interaktivním režimem shellu a shell skripty. Interaktivní režim je značně omezen na základní sadu příkazů a nepodporuje pokročilé konstrukce, které jsou běžně dostupné v shell skriptech, jako jsou například složitější řídicí struktury nebo uživatelsky definované funkce. Kvůli těmto rozdílům je nutné se učit odlišná pravidla pro interaktivní práci a pro psaní skriptů.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"84500c67-ec02-4d10-bee1-672e7a97bc56",correct:'Možnost psaní krátkých skriptů přímo v příkazové řádce, takzvaných "one-liners", je v interaktivním shellu plně podporována a představuje efektivní nástroj pro automatizaci jednoduchých, ale opakujících se úkolů. Tato dovednost umožňuje uživatelům rychle kombinovat příkazy a konstrukce shellu pro řešení ad hoc problémů bez nutnosti vytvářet samostatné skriptové soubory, což významně šetří čas a zefektivňuje práci.',incorrect:'Psaní krátkých skriptů "one-liners" v interaktivním režimu shellu je sice technicky možné, ale považuje se za nevhodné a neefektivní. Interaktivní režim je primárně určen pro spouštění jednotlivých příkazů a nikoliv pro vytváření skriptů, i když krátkých. Pro automatizaci úkolů by vždy měly být preferovány samostatné skriptové soubory, které jsou lépe čitelné a udržovatelné, než "one-liners" psané v příkazové řádce.',sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"07e9eb88-2eb2-412e-a5d6-771ecaef1da8",correct:"V kontrastu k interaktivnímu provádění příkazů je shell skript soubor obsahující seznam příkazů, které jsou prováděny sekvenčně, přičemž základní konstrukce řízení toku programu umožňují tuto sekvenční posloupnost v případě potřeby modifikovat a proměnné umožňují substituci částí příkazů.",incorrect:"V kontrastu k interaktivnímu provádění příkazů je shell skript interaktivní prostředí, které neobsahuje seznam předdefinovaných příkazů, ale umožňuje uživateli zadávat a provádět příkazy v libovolném pořadí bez možnosti sekvenčního provádění nebo použití proměnných.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"258badaa-97fd-48ea-872d-20de307844ca",correct:"Shell script je spustitelný soubor obsahující sekvenci příkazů, které jsou prováděny sekvenčně, podobně jako při přímém zadávání příkazů do shellu, ale nabízí také možnost použití prvků strukturovaného programování pro řízení toku provádění a proměnných pro dynamickou modifikaci příkazů.",incorrect:"Shell script je soubor, který na rozdíl od spustitelných souborů neobsahuje sekvenci příkazů pro sekvenční provádění, ale slouží pouze jako úložné místo pro jednotlivé příkazy, které jsou prováděny interaktivně a nepodporuje strukturované programování nebo proměnné.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"2adb1645-551a-4111-9888-8add5e245236",correct:"V nejjednodušší formě shell skript sestává z posloupnosti příkazů, kde každý příkaz je umístěn na samostatném řádku, a jeho spuštění se podobá postupnému zadávání těchto příkazů přímo v příkazové řádce, avšak shell skripty mohou být rozšířeny o konstrukce strukturovaného programování.",incorrect:"V nejjednodušší formě shell skript sestává z jediného příkazu na jediném řádku a jeho spuštění se liší od přímého zadávání příkazů v příkazové řádce, jelikož shell skripty zásadně nepodporují strukturované programování ani posloupnost více příkazů.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"5ea8face-4caa-4671-9843-8898b656d999",correct:"Shell skriptování se ukazuje jako velmi produktivní a snadné k použití, zejména v situacích, kde se nejedná o rozsáhlé programování, ale spíše o automatizaci jednoduchých úkolů, které by uživatel jinak musel provádět manuálně, například zadáváním příkazů v terminálu.",incorrect:"Shell skriptování je navrženo pro vývoj rozsáhlých a komplexních aplikací, a proto se vyznačuje robustností a snadnou údržbou i v případě rozsáhlých projektů s mnoha funkcemi a složitou logikou, čímž překonává i specializované skriptovací jazyky.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"25b95ff2-8b99-4c76-b34d-8363af96271f",correct:"Pro rozsáhlejší programy se omezení shell skriptování stávají významnými, jelikož větší programy se nemohou jednoduše zastavit při každé chybě, ani nemohou ignorovat chyby, což jsou dvě základní strategie dostupné v shell skriptech, což vede k problémům s robustností a údržbou.",incorrect:"Pro rozsáhlejší programy je shell skriptování ideální volbou, neboť jeho robustnost a schopnost efektivně zpracovávat chyby z něj činí preferované řešení pro komplexní aplikace, kde je klíčová spolehlivost a minimalizace rizika selhání i v nečekaných situacích.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"1d39fdaf-1b15-4798-87a1-c13b57e3c15d",correct:"Bourne shell, vytvořený v roce 1976, zásadně ovlivnil vývoj shellů tím, že kodifikoval jejich interaktivní i programovatelnou povahu, a jeho základní model a syntaxe se dodnes používají v mnoha kompatibilních shellech, včetně široce rozšířeného bash.",incorrect:"Přestože Bourne shell, který vznikl až po roce 1980, měl určitý vliv na programování shellů, jeho interaktivní aspekty a syntaxe jsou dnes již zastaralé a moderní shelly jako bash se v mnoha ohledech odlišují od jeho původního návrhu.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"e88bc172-d999-4277-8d46-331f3eb1d9fe",correct:"Ačkoli standard POSIX specifikuje pouze požadavek na existenci shellu s názvem 'sh' v systému a explicitně neurčuje jeho umístění, v praxi drtivá většina operačních systémů, které jsou kompatibilní s POSIX, umisťuje spustitelný soubor 'sh' do adresáře '/bin', vedle ostatních klíčových systémových nástrojů.",incorrect:"Standard POSIX kategoricky nařizuje, že shell s názvem 'sh' musí být bezpodmínečně umístěn v adresáři '/bin' na všech systémech, které se hlásí k POSIX kompatibilitě, což je striktní požadavek pro zajištění jednotné struktury systémových utilit.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"f2a2d88b-261e-4c3a-ac46-90f9e4583dd2",correct:"Historicky druhým známým UNIXovým shellem byl C shell, známý také jako csh, který byl poprvé vydán v roce 1978 a přinesl vylepšení interaktivního režimu oproti shellu Bourne z roku 1976, včetně historie příkazů a aliasů, přičemž syntaxe C shellu je popisována jako více C-like než Bourne Shell, i když ne zcela C-like.",incorrect:"Historicky prvním známým UNIXovým shellem byl C shell, známý také jako csh, který byl poprvé vydán v roce 1976 a nepřinesl vylepšení interaktivního režimu oproti shellu Bourne z roku 1978, včetně historie příkazů a aliasů, přičemž syntaxe C shellu je popisována jako méně C-like než Bourne Shell a je zcela C-like.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"2003a469-f6b3-4db0-898b-2f818177d444",correct:"Varianta shellu C shell, známá jako tcsh, je větví s dodatečnými funkcemi, která je udržována souběžně s původním C shell od počátku 80. let a je stále distribuována s mnoha operačními systémy, například jako výchozí shell pro uživatele root v systému FreeBSD, přičemž tcsh přidává například dokončování příkazů a názvů souborů.",incorrect:"Varianta shellu C shell, známá jako tcsh, je starší verzí bez dodatečných funkcí, která byla nahrazena původním C shell v polovině 70. let a již není distribuována s žádnými operačními systémy, a to ani jako výchozí shell pro uživatele root v systému FreeBSD, přičemž tcsh neobsahuje například dokončování příkazů a názvů souborů.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"5c42708d-db65-4e23-9e88-bba2df78a087",correct:"Korn shell, známý také jako ksh a poprvé vydaný v roce 1983, představuje hybridní přístup kombinující vlastnosti Bourne shell (sh) a C shell (csh) s cílem nabídnout vylepšenou interakci s uživatelem, přičemž syntaxe skriptování zůstala věrná Bourne shell.",incorrect:"Korn shell, známý také jako ksh a poprvé vydaný v roce 1983, je primárně založen na syntaxi C shell (csh) a tcsh, a integruje vybrané prvky z Bourne shell (sh) s důrazem na vylepšenou interakci s uživatelem a moderní skriptovací funkce.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"241000e6-7229-49b8-a843-940bf92e001d",correct:"Specifikace POSIX.2, která definuje standardy pro operační systémy typu UNIX, vychází z Korn shell (ksh) jako modelového příkladu pro implementaci shellu /bin/sh, což zdůrazňuje význam ksh v standardizaci a vývoji unixových prostředí.",incorrect:"Specifikace POSIX.2, která definuje standardy pro operační systémy typu UNIX, vychází z C shell (csh) jako modelového příkladu pro implementaci shellu /bin/sh, a Korn shell (ksh) je považován za alternativní shell s odlišnými standardy.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"7b886738-569c-4df2-b9a4-aa55d420bcf5",correct:"Příkaz v shellu může být jméno spustitelného souboru, řídicí struktura nebo vestavěný příkaz. Pokud se jedná o jméno spustitelného souboru, shell nejprve ověří, zda se nejedná o vestavěný příkaz nebo řídicí strukturu, a pokud ne, hledá spustitelný soubor v adresářích určených proměnnou prostředí PATH.",incorrect:"Příkaz v shellu je vždy jméno spustitelného souboru. Shell provádí příkazy přímo ve stávajícím procesu shellu bez nutnosti vytvářet nový proces, což minimalizuje režii spojenou s prováděním příkazů a zajišťuje maximální efektivitu.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"485b2caf-cc67-4ff2-b173-d832c83e0b01",correct:"Pro spuštění příkazu, který je jménem spustitelného souboru, shell typicky používá systémové volání `fork` pro vytvoření nového procesu a následně v tomto novém procesu volání `exec` pro spuštění zadaného spustitelného souboru. Původní proces shellu poté čeká na dokončení spuštěného programu pomocí volání `wait`.",incorrect:"Pro spuštění příkazu shell používá systémové volání `exec` v aktuálním procesu shellu, čímž nahradí stávající proces shellu procesem spouštěného příkazu. Původní proces shellu se nerozděluje a nečeká na dokončení spuštěného programu v samostatném procesu.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"843c4679-f696-45f6-aaf0-72d75de34b5e",correct:"Vytváření nového procesu pro každý spouštěný příkaz pomocí systémových volání `fork` a `exec` je relativně nákladné z hlediska systémových zdrojů. Tato režie se může stát znatelnou, zejména při provádění velkého množství krátkých příkazů, kdy samotné spouštění příkazů trvá méně času než vytváření procesů.",incorrect:"Vytváření nového procesu pro každý spouštěný příkaz pomocí systémových volání `fork` a `exec` je velmi nenáročné na systémové zdroje a nepředstavuje významnou režii, a to ani při provádění velkého množství příkazů, protože moderní operační systémy jsou optimalizovány pro rychlé vytváření procesů.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"56a10c9f-d5e0-4298-a99e-a0487b0c5399",correct:"Příkaz `exec` se v shellu interpretuje speciálním způsobem, který se liší od standardního spouštění programů pomocí `fork` a `exec`.  Hlavním důvodem pro tuto odlišnou interpretaci je funkčnost, protože příkaz `exec` je navržen tak, aby nahradil stávající shell proces novým procesem bez nutnosti vytvářet nový proces pomocí `fork`, což je klíčové pro operace, které vyžadují změny v samotném shellu, a nikoliv v jeho potomcích.",incorrect:"Příkaz `exec` je v shellu interpretován standardním způsobem, tedy pomocí volání `fork` a následně `exec`, stejně jako většina externích programů. Důvodem této standardní interpretace je optimalizace výkonu, jelikož `exec` je často používán v skriptech a vytváření nových procesů by bylo neefektivní. Tato interpretace zajišťuje, že `exec` provádí svou funkci nahrazení procesu efektivně a bez zbytečné režie.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"d5aa30ae-28b6-4275-9470-e9b68b23e79b",correct:"Příkazy `cd` a `export` jsou v shellu interpretovány speciálně z důvodu funkčnosti, protože jejich účelem je provádět změny, které ovlivňují přímo hlavní shell proces.  Změna pracovního adresáře pomocí `cd` a úprava prostředí pomocí `export` musí být provedeny v kontextu hlavního shell procesu, aby byly trvalé a měly vliv na další operace prováděné v shellu. Standardní spouštění pomocí `fork` a `exec` by nebylo vhodné, protože změny by se projevily pouze v dceřiném procesu.",incorrect:"Příkazy `cd` a `export` jsou v shellu interpretovány speciálně z důvodu optimalizace výkonu, jelikož se jedná o často používané příkazy, zejména v skriptech. Speciální interpretace těchto příkazů zabraňuje vytváření nových procesů pomocí `fork` a `exec`, což snižuje režii a zrychluje provádění těchto operací. Hlavním cílem je tedy zvýšit efektivitu shellu při zpracování těchto běžných příkazů, a nikoli nutnost funkčnosti.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"cfd3205a-2153-4df0-aaeb-d495872d37fb",correct:"Příkaz `echo` je v shellu často interpretován jako vestavěný příkaz, což je optimalizace z hlediska efektivity.  Důvodem je, že `echo` je velmi frekventovaně používaný příkaz, zejména v shell skriptech, a spouštění `echo` jako externího programu pomocí mechanismu `fork` a `exec` by bylo neefektivní kvůli režii spojené s vytvářením nových procesů pro tak jednoduchou operaci. Vestavěná implementace `echo` umožňuje rychlejší provedení bez nutnosti vytvářet nový proces.",incorrect:"Příkaz `echo` je v shellu interpretován speciálně z důvodu funkčnosti, protože jeho účelem je provádět operace, které by nebyly možné nebo snadné provést v dceřiném procesu. Vestavěná interpretace příkazu `echo` je nutná pro zajištění, že výstup příkazu `echo` je správně přesměrován a zobrazen v hlavním shell procesu.  Standardní spouštění pomocí `fork` a `exec` by způsobilo problémy s výstupem a jeho správným zobrazením v shellu.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"6a4596f4-ebae-4aa6-b26b-a5de4f256ddb",correct:'V shellu, proměnné, označované v oficiální terminologii jako parametry, fungují jako zástupné symboly, kde shell udržuje mapování jmen, skládajících se z písmen a číslic, na libovolné řetězcové hodnoty, a pro vytvoření nebo aktualizaci tohoto mapování se používá příkaz ve formátu `variable="some text"`, přičemž mezery kolem rovnítka nejsou povoleny a uvozovky jsou vyžadovány pouze v případě, že hodnota obsahuje mezery.',incorrect:'V shellu, proměnné, označované v oficiální terminologii jako parametry, fungují jako zástupné symboly, kde shell udržuje mapování jmen, skládajících se z písmen a číslic, na celočíselné hodnoty, a pro vytvoření nebo aktualizaci tohoto mapování se používá příkaz ve formátu `$variable="some text"`, přičemž mezery kolem rovnítka jsou povoleny a uvozovky nejsou nikdy vyžadovány, i když hodnota obsahuje mezery.',sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"816acd68-4ed7-4e5d-b3e7-5b7ce9f9eba7",correct:"V shell skriptech, definice proměnné se provádí bez použití prefixu dolaru ($), zatímco pro použití hodnoty proměnné je nutné proměnnou prefixovat dolarem, což je v souladu s konceptem placeholderů, kde proměnné slouží jako zástupná jména pro stringové hodnoty, které jsou globální v rámci shellu s výjimkou subshellů, kde mají proměnné lokální scope.",incorrect:"V shell skriptech, definice proměnné se provádí s použitím prefixu dolaru ($), zatímco pro použití hodnoty proměnné není nutné proměnnou prefixovat dolarem, což je v rozporu s konceptem placeholderů, kde proměnné slouží jako zástupná jména pro celočíselné hodnoty, které jsou lokální v rámci shellu bez výjimky subshellů, kde mají proměnné globální scope.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"5081d899-d10e-4a98-88e7-829c3d7899e9",correct:"V shell skriptech, pokud chceme provést aritmetickou operaci s proměnnými, například sečíst dvě proměnné `a` a `b`, pouhé napsání `$a + $b` nebude fungovat, protože shell to interpretuje jako příkaz `7` s argumenty `+` a `3`, pokud `a=7` a `b=3`. Pro správné provedení aritmetického sčítání musíme použít syntaxi `$((a + b))`, kde shell provede aritmetické vyhodnocení výrazu uvnitř dvojitých závorek.",incorrect:"V shell skriptech, pokud chceme provést aritmetickou operaci s proměnnými, například sečíst dvě proměnné `a` a `b`, můžeme jednoduše napsat `$a + $b` a shell automaticky rozpozná, že se jedná o aritmetickou operaci a správně sečte hodnoty proměnných `a` a `b`.  Použití syntaxe `$((a + b))` je zbytečné a má stejný efekt jako `$a + $b` v kontextu aritmetických operací.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"0848ce61-100b-4724-bd45-c6a9804df828",correct:"V shell skriptech, při použití aritmetické expanze `$((...))`, existuje rozdíl v chování substitucí s a bez dolaru `$`. Pokud proměnné uvnitř `$((...))` nejsou prefixovány dolarem, substituce se chovají, jako by byly uzavřeny v závorkách pro účely precedence operátorů. Například, pokud `a=3+1` a `b=7`, výraz `$((a * b))` se vyhodnotí jako `$(((3+1) * 7))`, což vede k výsledku 28.",incorrect:"V shell skriptech, při použití aritmetické expanze `$((...))`, chování substitucí s a bez dolaru je identické. Bez ohledu na to, zda proměnné uvnitř `$((...))` jsou prefixovány dolarem nebo ne, substituce se vždy chovají stejně a neexistuje žádný rozdíl v precedenci operátorů. Například, pokud `a=3+1` a `b=7`, výrazy `$((a * b))` a `$(( $a * $b ))` se vyhodnotí naprosto stejně.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"7356d7ce-44fd-423b-963c-c3291723d61a",correct:'Substituce proměnných v shell skriptech je čistě textová operace. To znamená, že po nahrazení proměnné její hodnotou shell zapomene na původ proměnné a s textem pracuje, jako by byl zadán přímo. Například, pokud proměnná `command="ls -l"`, pak `$command` bude interpretováno jako příkaz `ls -l`, nikoliv jako textová hodnota, a shell provede příkaz `ls -l`.',incorrect:'Substituce proměnných v shell skriptech je textová operace, ale shell si pamatuje původ textu z proměnné. Díky tomu, i když proměnná `command` obsahuje text "ls -l", `$command` nebude nikdy interpretováno jako příkaz, ale vždy pouze jako textová hodnota "ls -l", kterou lze například vypsat pomocí `echo $command`. Shell nikdy nespustí kód uložený v proměnné, pokud to není explicitně nařízeno jiným mechanismem.',sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"57e90051-fb83-4d2a-913d-e572d96c64b3",correct:"Příkazová substituce v shellu umožňuje vykonat příkaz a použít jeho standardní výstup jako argumenty pro jiný příkaz. Například, v příkazu `cat $(ls)` se nejprve vykoná příkaz `ls`, který vypíše seznam souborů v aktuálním adresáři, a tento seznam se poté použije jako argumenty pro příkaz `cat`, který následně zobrazí obsah všech vypsaných souborů.",incorrect:"Příkazová substituce v shellu umožňuje vykonat příkaz a použít jeho standardní chybový výstup jako argumenty pro jiný příkaz. Například, v příkazu `cat $(ls)` se nejprve vykoná příkaz `ls`, který vypíše seznam souborů v aktuálním adresáři na standardní chybový výstup, a tento seznam se poté použije jako argumenty pro příkaz `cat`, který následně zobrazí obsah všech vypsaných souborů.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"4a6e696f-6783-491c-9b2b-8c0aaca4605d",correct:"Syntaxe `$(command)` pro příkazovou substituci nejprve provede příkaz `command` jako běžný shell příkaz, zachytí jeho standardní výstup do bufferu a následně nahradí konstrukci `$(command)` obsahem tohoto bufferu.  Tento mechanismus umožňuje dynamicky generovat části příkazů na základě výstupu jiných programů, což je užitečné pro automatizaci a skriptování v shellu.",incorrect:"Syntaxe `$(command)` pro příkazovou substituci nejprve nahradí konstrukci `$(command)` prázdným řetězcem a až poté provede příkaz `command` jako běžný shell příkaz. Standardní výstup tohoto příkazu se nikam neukládá a nepoužije, čímž příkazová substituce v tomto případě nemá žádný vliv na výsledný příkaz.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"e1e632db-e8b9-4244-abcd-240103a0506e",correct:"V shellu se pro oddělení jednotlivých argumentů příkazové řádky používají bílé znaky, jako je mezera nebo tabulátor. Pokud argument příkazu obsahuje více slov a má být interpretován jako jediný argument, je nutné jej uzavřít do uvozovek. Shell podporuje dva typy uvozovek: jednoduché apostrofy a dvojité uvozovky, přičemž dvojité uvozovky navíc umožňují provádět substituci proměnných přímo v řetězci.",incorrect:"V shellu se pro oddělení jednotlivých argumentů příkazové řádky používají bílé znaky, jako je mezera nebo tabulátor. Pokud argument příkazu obsahuje více slov, **není** nutné jej uzavřít do uvozovek, protože shell automaticky rozpozná více slov jako jeden argument.  Shell podporuje dva typy uvozovek: jednoduché apostrofy a dvojité uvozovky, přičemž dvojité uvozovky navíc umožňují provádět substituci proměnných přímo v řetězci.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"d6d74f92-7f5f-4ef4-96f9-f54ac38915a8",correct:"Pro správné zpracování argumentů v shellu je klíčové použití uvozovek v případě, že argument obsahuje bílé znaky.  Jednoduché apostrofy a dvojité uvozovky slouží k uvození řetězců, avšak s rozdílnou funkcionalitou. Zatímco jednoduché apostrofy interpretují řetězec doslovně, dvojité uvozovky umožňují expanzi proměnných a speciálních znaků, což je důležité pro dynamické sestavování příkazů.",incorrect:"Pro správné zpracování argumentů v shellu je klíčové použití uvozovek v případě, že argument obsahuje bílé znaky.  Jednoduché apostrofy a dvojité uvozovky slouží k uvození řetězců, avšak **s naprosto identickou** funkcionalitou. Zatímco jednoduché apostrofy interpretují řetězec doslovně, **stejně tak i** dvojité uvozovky **interpretují řetězec doslovně a neumožňují** expanzi proměnných a speciálních znaků, což **není** důležité pro dynamické sestavování příkazů.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"3cb3e605-8d51-4668-907f-0ffcd9d80bd1",correct:'Substituce parametrů se provádí před rozdělením argumentů. Pokud proměnná obsahující bílé znaky není správně uzavřena do uvozovek, bude po substituci interpretována jako více argumentů. To může vést k neočekávanému chování, například příkaz `cat $file`, kde `$file` obsahuje "foo bar", se rozbalí na `cat foo bar` a program `cat` obdrží "foo" a "bar" jako samostatné argumenty.',incorrect:'Rozdělení argumentů probíhá před substitucí parametrů. To znamená, že i když proměnná substituovaná v příkazu obsahuje bílé znaky a není správně uzavřena do uvozovek, bude stále považována za jeden argument. Rozdělení argumentů, které proběhne dříve než substituce, zabrání problémům, kdy by se například v příkazu `cat $file` s `$file` obsahujícím "foo bar" nesprávně interpretovaly "foo" a "bar" jako oddělené argumenty.',sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"c4b0f359-3d95-4cb4-b116-7b07eac2016f",correct:'Pokud proměnná obsahující bílé znaky, například "hello world", je použita v příkazu bez uvozovek, jako například `ls $foo`, kde `$foo` je "hello world", shell ji rozbalí na `ls hello world`. Příkaz `ls` se pak spustí s argumenty "hello" a "world" jako samostatnými argumenty, což způsobí, že se budou hledat dva samostatné soubory "hello" a "world" namísto jednoho souboru "hello world".',incorrect:'Jestliže proměnná obsahující bílé znaky, například "hello world", je použita v příkazu bez uvozovek, například `ls $foo`, kde `$foo` je "hello world", shell inteligentně interpretuje bílé znaky jako součást jediného argumentu. Příkaz `ls` se spustí korektně a bude s "hello world" zacházet jako s jediným názvem souboru nebo argumentem, čímž se předejde rozdělení na více argumentů.',sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"9e6fd124-1529-4a9b-891e-b77d8ffcb82a",correct:'Aby se zajistilo, že proměnná obsahující bílé znaky bude v příkazu považována za jediný argument i po substituci parametrů, je nutné proměnnou uzavřít do uvozovek, například v příkazu `ls "$foo"`. To zabrání rozdělení argumentů na základě bílých znaků v hodnotě proměnné a zajistí, že příkaz `ls` obdrží "hello world" jako jediný argument, pokud `$foo` je nastaveno na "hello world".',incorrect:'I když použijeme uvozovky kolem proměnné obsahující bílé znaky v příkazu, například `ls "$foo"`, kde `$foo` je "hello world", shell stále rozdělí argumenty na základě bílých znaků v hodnotě proměnné. Příkaz `ls` tak obdrží "hello" a "world" jako samostatné argumenty, protože uvozovky ovlivňují pouze substituci, nikoli následný proces rozdělení argumentů.',sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"668c6ef9-2925-473d-937f-8146557a6f63",correct:"Speciální proměnné `$@` a `$*` v shellu slouží k expanzi pozičních parametrů, které jsou argumenty příkazové řádky skriptu.  Rozdíl mezi nimi spočívá v chování při použití v dvojitých uvozovkách; proměnná `$@` expanduje každý parametr zvlášť, zatímco `$*` expanduje všechny parametry jako jedno slovo. Tato vlastnost proměnné `$@` je klíčová pro správné iterování skrze argumenty, zvláště pokud obsahují mezery.",incorrect:"Speciální proměnné `$@` a `$*` v shellu slouží k expanzi pozičních parametrů, avšak jejich chování je identické bez ohledu na použití dvojitých uvozovek. Obě proměnné expandují všechny poziční parametry jako jedno slovo i v případě, že jsou uzavřeny v dvojitých uvozovkách, což znamená, že iterace skrze jednotlivé argumenty s mezerami by byla přímočará a bezproblémová.  Tato interpretace zjednodušuje manipulaci s argumenty v shell skriptech.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"c17b919b-aaec-48e5-8d4d-d9f7ef2104e4",correct:"Proměnná `$#` v shellu je speciální proměnná, která uchovává počet pozičních parametrů, jež byly předány shell skriptu při jeho spuštění.  Tyto poziční parametry jsou reprezentovány proměnnými `$1`, `$2`, `$3` a tak dále, a `$#` poskytuje dynamický způsob, jak v rámci skriptu zjistit, kolik argumentů bylo zadáno, což je užitečné pro validaci vstupu a řízení toku skriptu na základě počtu argumentů.",incorrect:"Proměnná `$#` v shellu je speciální proměnná, která uchovává PID aktuálního shellu, podobně jako proměnná `$$`.  Tato proměnná `$#` tedy poskytuje alternativní způsob, jak zjistit identifikátor procesu běžícího shellu, což může být užitečné v situacích, kdy potřebujeme identifikovat shell proces pro účely monitorování nebo správy procesů. Nicméně, primární a doporučený způsob pro získání PID shellu je použití proměnné `$$`.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"d8329aba-dfca-4f0d-ad0e-91fcf765ab80",correct:"Shell poskytuje kromě uživatelsky definovaných proměnných i speciální proměnné, které slouží k poskytování informací o aktuálním prostředí a stavu shellu. Mezi tyto speciální proměnné patří například `$?` pro návratový kód posledního příkazu, `$$` pro PID aktuálního shellu a `$0` pro jméno shellu. Tyto proměnné jsou předdefinované a automaticky aktualizovány shellem.",incorrect:"Shell poskytuje pouze uživatelsky definované proměnné a speciální proměnné jsou v shellu konceptem, který neexistuje. Veškeré proměnné, se kterými uživatel v shellu pracuje, musí být explicitně definovány uživatelem a shell sám neposkytuje žádné předdefinované proměnné s předem určeným významem nebo automatickou aktualizací hodnot, což dává uživateli plnou kontrolu nad proměnnými v prostředí.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"a1a82915-c7f3-40a8-805a-73510a35ebe2",correct:"Proměnné prostředí v systémech POSIX jsou nezávislé na konkrétním shellu a jsou předávány z rodičovského procesu do jeho potomků prostřednictvím systémových volání `fork` i `exec`, čímž je zajištěno, že nově spuštěné programy zdědí prostředí svého rodiče.",incorrect:"Proměnné prostředí v systémech POSIX jsou pevně svázány s shellem, ve kterém jsou definovány, a jsou primárně předávány potomkům pouze prostřednictvím systémového volání `exec`; změny proměnných prostředí v potomkovském procesu se mohou šířit zpět do rodičovského procesu.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"2c5b2881-8f82-48c7-bdcc-46741a099277",correct:"Když proces v systému POSIX vytvoří potomka pomocí systémového volání `fork`, potomek obdrží kompletní kopii proměnných prostředí rodiče, což znamená, že změny provedené proměnnými prostředí potomkem neovlivní proměnné prostředí rodiče ani žádné jiné již běžící procesy.",incorrect:"Když proces v systému POSIX vytvoří potomka pomocí systémového volání `fork`, potomek sdílí proměnné prostředí s rodičem, což umožňuje, aby změny provedené potomkem přímo ovlivnily proměnné prostředí rodiče a všech ostatních procesů v rámci stejné skupiny procesů.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"92340ada-36ba-4cba-8d98-356b84187ec6",correct:"Ačkoli jsou proměnné prostředí formálně nezávislé na shellu, shelly často poskytují funkce pro jejich správu, jako je substituce proměnných pomocí prefixu dolaru (např. `$VARIABLE_NAME`) a příkazy pro nastavení nebo úpravu jejich hodnot, což ovlivňuje shell proces a následně všechny potomkovské procesy vytvořené tímto shellem.",incorrect:"Proměnné prostředí jsou striktně spravovány pouze jádrem operačního systému a shelly nemají žádný přímý způsob, jak s nimi interagovat nebo je modifikovat. Jakýkoli pokus shellu nastavit nebo přistupovat k proměnným prostředí pomocí konstruktů jako `$VARIABLE_NAME` ovlivní pouze shell-interní proměnné a nikoli skutečné proměnné prostředí předávané potomkům.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"8680c29e-2736-4b6b-817e-790571a7dbeb",correct:"Proměnná prostředí `$PATH` v operačních systémech slouží jako seznam adresářů, které systém prohledává při hledání spustitelných souborů, když uživatel zadá příkaz bez udání absolutní cesty. Tato proměnná umožňuje uživatelům spouštět programy umístěné v různých adresářích bez nutnosti zadávat jejich úplnou cestu, což zjednodušuje práci v příkazové řádce a skriptech.",incorrect:"Proměnná prostředí `$PATH` v operačních systémech slouží výhradně pro ukládání dočasných souborů a nemá žádný vliv na vyhledávání spustitelných souborů. Systém při spouštění programů prohledává pouze pevně dané systémové adresáře, které nejsou konfigurovatelné uživatelskými proměnnými prostředí, a `$PATH` se používá jen pro interní procesy systému.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"ccdb9d46-875b-4a3a-b555-b2011433b24d",correct:"Proměnná prostředí `$HOME` je v operačních systémech definována jako domovský adresář aktuálně přihlášeného uživatele a programy ji využívají k ukládání uživatelských konfiguračních souborů a dat. Tato proměnná je obvykle nastavena systémem při přihlášení uživatele a poskytuje standardizované umístění pro uživatelské soubory, nezávislé na konkrétním programu.",incorrect:"Proměnná prostředí `$HOME` je v operačních systémech používána pouze pro dočasné uložení systémových logů a nemá žádný vztah k domovskému adresáři uživatele ani k ukládání uživatelských dat a konfigurací. Domovský adresář uživatele je určen jinými systémovými mechanismy, které nejsou ovlivněny proměnnou `$HOME`.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"79d95959-6ba4-452d-bef8-693e6922f1b3",correct:"V operačních systémech existuje konvence, že názvy proměnných prostředí se zapisují velkými písmeny, jako například `$PATH`, `$HOME` a `$EDITOR`. Tato konvence usnadňuje čitelnost a odlišení proměnných prostředí od jiných proměnných a klíčových slov v konfiguracích a skriptech, ačkoli technicky systémy obvykle nerozlišují velikost písmen v názvech proměnných prostředí.",incorrect:"V operačních systémech je striktně vyžadováno, aby názvy všech proměnných prostředí byly psány malými písmeny, a jakékoli použití velkých písmen v názvu proměnné prostředí by způsobilo, že systém tuto proměnnou prostředí nerozpoznal a ignoroval. Konvence používání velkých písmen pro proměnné prostředí je pouze doporučení pro programátory, ale nemá vliv na funkčnost systému.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"cb052428-670d-48ec-9611-e1d1bfd9be70",correct:"Globbing, jak je popsán v kontextu shellu, představuje mechanismus pro zjednodušení práce se soubory, kdy speciální metaznaky jako hvězdička '*' a otazník '?' umožňují reprezentovat skupiny názvů souborů pomocí jediného vzoru. Hvězdička '*' se v těchto vzorech chová jako zástupný symbol pro libovolný počet znaků, zatímco otazník '?' zastupuje právě jeden libovolný znak, což uživatelům usnadňuje manipulaci s více soubory najednou.",incorrect:"Globbing, jak je popsán v kontextu shellu, představuje mechanismus pro zjednodušení práce se soubory, kdy speciální metaznaky jako hvězdička '*' a otazník '?' umožňují reprezentovat skupiny názvů souborů pomocí jediného vzoru. Hvězdička '*' se v těchto vzorech chová jako zástupný symbol pro právě jeden znak, zatímco otazník '?' zastupuje libovolný počet znaků, což uživatelům usnadňuje manipulaci s více soubory najednou.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"284c9008-cde6-4266-b497-1042a1186c96",correct:"Expanzi globbing vzorů provádí přímo shell, nikoliv až spouštěný program. To znamená, že když uživatel zadá příkaz jako například `ls *.c`, shell nejprve sám vyhodnotí vzor `*.c` a nahradí ho seznamem všech souborů odpovídajících tomuto vzoru. Teprve poté shell spustí program `ls` s tímto seznamem souborů jako argumenty, přičemž samotný program `ls` o globbing expanzi neví a pracuje již jen s konkrétními názvy souborů.",incorrect:"Expanzi globbing vzorů provádí až spouštěný program, nikoliv přímo shell. To znamená, že když uživatel zadá příkaz jako například `ls *.c`, shell předá vzor `*.c` programu `ls` a ten až následně vyhodnotí vzor a provede expanzi na seznam souborů. Program `ls` je tedy zodpovědný za globbing expanzi a shell pouze předává nezpracovaný vzor a přijímá výsledný seznam souborů.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"7ae69447-89da-4fa1-8fe6-255d9077eb35",correct:"Použití uvozovek, ať už jednoduchých nebo dvojitých, má v shellu za následek potlačení globbing expanze. Pokud je řetězec obsahující metaznaky jako '*' nebo '?' uzavřen do uvozovek, shell ho nebude interpretovat jako globbing vzor, ale doslovně ho předá jako argument příslušnému programu. Tato vlastnost uvozovek je užitečná v situacích, kdy je potřeba předat řetězec obsahující tyto metaznaky jako literální hodnotu a nikoliv jako vzor pro expanzi souborů.",incorrect:"Použití uvozovek, ať už jednoduchých nebo dvojitých, nemá v shellu žádný vliv na globbing expanzi. I když je řetězec obsahující metaznaky jako '*' nebo '?' uzavřen do uvozovek, shell ho stále interpretuje jako globbing vzor a provede expanzi na seznam souborů. Uvozovky slouží pouze k jiným účelům, například k seskupování slov do jednoho argumentu, ale nikoliv k potlačení globbing expanze.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"cca6c76b-b3e6-4472-acf2-92faa456e91a",correct:"Podmíněné provádění příkazů v shellu je základní konstrukce řízení toku programu, která umožňuje spouštět nebo přeskočit blok příkazů na základě výsledku předchozího příkazu. Klíčové slovo `if` se používá pro zahájení podmíněného bloku, a volitelně může být doplněno klauzulemi `elif` a `else` pro složitější rozhodovací struktury. Důležité je, že `cond` v konstrukci `if cond; then ... fi` není výraz, ale standardní příkaz, jehož návratový kód 0 indikuje pravdivostní hodnotu pro vyhodnocení podmínky.",incorrect:"Podmíněné provádění příkazů v shellu se liší od tradičních programovacích jazyků tím, že klíčové slovo `if` vyžaduje jako podmínku složitý booleovský výraz, nikoliv standardní příkaz. Shell interpretuje výsledek tohoto výrazu, kde nenulový návratový kód značí pravdu a nulový návratový kód nepravdu, a na základě toho provede buď `then` větev, nebo `else` větev. Klauzule `elif` se používá pro vnořené podmínky a umožňuje vytvářet komplexnější rozhodovací struktury, podobně jako v jiných programovacích jazycích.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"5d719431-3daa-44aa-8023-7991c856579a",correct:"V shell skriptech, konstrukce `if cond; then cmd1; else cmd2; fi` realizuje podmíněné provádění, kde `cond` je interpretován jako příkaz. Úspěšné provedení příkazu `cond`, indikované návratovým kódem 0, způsobí provedení příkazu `cmd1` v bloku `then`. Pokud příkaz `cond` selže, tedy vrátí nenulový návratový kód, a existuje klauzule `else`, provede se příkaz `cmd2`. V případě použití klauzule `elif cond2; then cmd3; fi`, se `cond2` vyhodnocuje pouze pokud předchozí podmínka `cond` selhala.",incorrect:"V shell skriptech, konstrukce `if cond; then cmd1; else cmd2; fi` implementuje podmíněné provádění, kde `cond` musí být logický výraz, podobně jako v jazycích jako C nebo Java.  Pokud se tento výraz vyhodnotí jako pravdivý, shell provede příkaz `cmd1` v bloku `then`. V opačném případě, kdy je výraz `cond` nepravdivý, se provede příkaz `cmd2` v `else` bloku. Klauzule `elif` slouží k definování alternativních podmínek, které se vyhodnocují paralelně s hlavní podmínkou `cond`.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"d9b1bd99-66ed-4d27-9134-41364925b733",correct:"Příkaz `test`, původně externí program, je v moderních operačních systémech obvykle integrován přímo do shellu, což umožňuje efektivnější vyhodnocování logických výrazů a kontrolu stavu systému bez nutnosti spouštění samostatného procesu pro každý testovací příkaz.",incorrect:"Příkaz `test`, původně interní součást shellu, je v moderních operačních systémech obvykle implementován jako externí program, což zajišťuje modularitu a oddělení funkcí testování od základní funkcionality shellu, a umožňuje tak snadnější údržbu a aktualizace testovacích funkcí.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"5baf3c5a-24a3-4849-ac9a-3d8641511b18",correct:"Příkaz `test` v operačních systémech dle standardu POSIX slouží k vyhodnocování podmínek a výrazů, které by shell jinak obtížně zpracovával kvůli omezené podpoře výrazů, a vrací návratový kód indikující pravdivost či nepravdivost vyhodnoceného výrazu, což se následně využívá v řídicích strukturách jako `if` a `while`.",incorrect:"Příkaz `test` v operačních systémech dle standardu ISO slouží primárně k manipulaci s řetězci a textovými daty v shell skriptech, a vrací textový výstup popisující výsledek operace, který je nutné dále parsovat pro použití v řídicích strukturách jako `if` a `while`.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"f6e47d2a-20a3-48ee-ba19-e31b07343eee",correct:"Ačkoli příkaz `if` v shellu akceptuje jako podmínku jakýkoli spustitelný příkaz, příkaz `test` byl zaveden pro usnadnění a zpřehlednění zápisu složitějších podmínek zahrnujících porovnávání proměnných, kontrolu existence souborů a další logické operace, přičemž jeho výstupem je booleovská hodnota reprezentovaná návratovým kódem.",incorrect:"Ačkoli příkaz `if` v shellu vyžaduje jako podmínku výhradně specifické klíčové slovo `condition`, příkaz `test` byl zaveden pro obcházení tohoto omezení a umožňuje definovat vlastní podmínky pomocí komplexních konstrukcí a interních shell funkcí, přičemž jeho výstupem je textový řetězec interpretovaný příkazem `if`.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"364419f5-5ade-4b18-a90f-b58b05a33b12",correct:"Příkaz `test` v shell skriptování slouží k vyhodnocování podmínek a hraje klíčovou roli při rozhodování o toku provádění skriptu na základě různých kritérií, jako je existence souborů, porovnávání čísel a řetězců.",incorrect:"Příkaz `test` v shell skriptování slouží primárně k manipulaci se soubory a adresáři, ačkoli může okrajově sloužit i k vyhodnocování jednoduchých podmínek, ale jeho hlavní funkcí není řízení toku skriptu.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"466fe67c-2d42-4d69-8ed8-6b40096e0373",correct:"Příkaz `test` nabízí tři hlavní kategorie predikátů: pro kontrolu existence a vlastností souborů, pro porovnávání celých čísel a pro porovnávání řetězců, což umožňuje komplexní testování různých aspektů systému a dat v shell skriptech.",incorrect:"Příkaz `test` nabízí pouze dvě hlavní kategorie predikátů: pro porovnávání celých čísel a pro porovnávání řetězců, přičemž možnosti kontroly existence a vlastností souborů jsou v příkazu `test` zcela opomenuty.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"d25df184-1295-485d-9916-a8b22d1cce5b",correct:"Mezi predikáty příkazu `test` pro soubory patří například `-nt`, který slouží k porovnání, zda je soubor novější než jiný soubor, což je užitečné v situacích, kdy skript má provádět akce pouze pokud se soubor aktualizoval.",incorrect:"Mezi predikáty příkazu `test` pro soubory patří například `-nt`, který slouží k porovnání, zda je soubor starší než jiný soubor, a primárně se používá k identifikaci zastaralých souborů, které je třeba odstranit.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"b819426d-24d5-4210-aa46-7995a1b4eeb7",correct:"Predikáty pro porovnávání celých čísel a řetězců v příkazu `test` se do jisté míry podobají funkcím, které poskytují běžné programovací jazyky, i když s odlišnou syntaxí, a umožňují tak programátorům shell skriptů používat známé logické operace.",incorrect:"Predikáty pro porovnávání celých čísel a řetězců v příkazu `test` jsou navrženy tak, aby se maximálně lišily od funkcí běžných programovacích jazyků a záměrně komplikují provádění standardních logických operací.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"15e8b8ba-a66b-4363-b2bb-51e46c8841cd",correct:"Příkaz `while` v shell skriptech se používá pro opakované provádění bloku příkazů, dokud zadaná podmínka, která je sama o sobě příkazem, neselže. Podmínkou může být jakýkoliv spustitelný příkaz, nejen `test`, a cyklus pokračuje, dokud tento příkaz vrací úspěšný návratový kód.",incorrect:"Příkaz `while` v shell skriptech se používá pro opakované provádění bloku příkazů, dokud zadaná podmínka, která musí být výhradně příkazem `test`, neuspěje. Jiné příkazy než `test` nemohou být použity jako podmínka v cyklu `while`.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"f38b6c09-286c-4455-83ad-56d11b25c0a8",correct:"Příkaz `for` v shell skriptech iteruje přes seznam hodnot, který lze definovat různými způsoby. Kromě explicitního výčtu hodnot, `for` podporuje glob patterny pro snadné zpracování skupin souborů a command substitution, umožňující dynamické generování seznamu, například pomocí nástroje `seq` pro číselné sekvence.",incorrect:"Příkaz `for` v shell skriptech iteruje pouze přes explicitně definovaný seznam hodnot.  Glob patterny a command substitution nejsou podporovány pro generování seznamu prvků, přes které má cyklus `for` iterovat, a je nutné vždy manuálně vypsat všechny hodnoty.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"6612e54f-0022-4674-8549-0b596dd98ed6",correct:"Konstrukce `case` v shell skriptech slouží k provádění analýzy případů a umožňuje výběr příkazů na základě porovnávání vzorů.  Využívá se pro řízení toku programu a umožňuje provádět různé akce v závislosti na hodnotě zadaného řetězce, přičemž se pro porovnávání vzorů používá syntaxe podobná globbingu, ale bez expanze jmen souborů.",incorrect:"Konstrukce `case` v shell skriptech slouží k provádění analýzy případů a umožňuje výběr příkazů na základě porovnávání vzorů.  Využívá se pro řízení toku programu a umožňuje provádět různé akce v závislosti na hodnotě zadaného řetězce, přičemž se pro porovnávání vzorů používá standardní globbing expanze, která automaticky rozšiřuje vzory na seznam existujících souborů.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"2f5d19f7-2965-40d0-af05-31f69a81bceb",correct:"V rámci syntaxe konstrukce `case` v shell skriptech se pro oddělení jednotlivých větví, tedy bloků kódu spojených s konkrétním vzorem, používá dvojice středníků `;;`. Tato dvojice středníků signalizuje konec aktuální větve `case` a umožňuje pokračování v dalším vyhodnocování, pokud by předchozí větev nebyla vybrána.",incorrect:"V rámci syntaxe konstrukce `case` v shell skriptech se pro oddělení jednotlivých větví, tedy bloků kódu spojených s konkrétním vzorem, používá jednoduchý středník `;`.  Dvojice středníků `;;` se používá pro jiný účel, konkrétně pro ukončení celého `case` bloku a návrat z něj.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"153231ea-092a-4102-b617-db4c644e3405",correct:'Podle uvedené dokumentace, konstrukce `case` v shell skriptech používá pro definici vzorů v rámci jednotlivých větví takzvané "unbalanced parentheses", tedy nevyvážené závorky. Konkrétně je vidět použití otevírací závorky `(` bez odpovídající uzavírací závorky `)` v příkladu `case $x in *.c) cc $x;; *) ls $x;; esac`.',incorrect:'Podle uvedené dokumentace, konstrukce `case` v shell skriptech používá pro definici vzorů v rámci jednotlivých větví standardní "balanced parentheses", tedy vyvážené závorky, podobně jako je tomu u jiných programovacích jazyků.  Použití nevyvážených závorek by bylo syntakticky nesprávné a vedlo by k chybě.',sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"a2490e16-71f7-47fb-9af3-2d37490393ad",correct:"Operátor `&&` v shellu funguje jako zkratka pro `if` příkaz a spouští následující příkaz pouze v případě, že předchozí příkaz byl úspěšný, což je užitečné pro vytváření sekvencí příkazů, které se zastaví při prvním neúspěchu.",incorrect:"Operátor `&&` v shellu funguje jako zkratka pro `if` příkaz a spouští následující příkaz pouze v případě, že předchozí příkaz selhal, což je užitečné pro vytváření sekvencí příkazů, které se zastaví při prvním neúspěchu.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"e0bf387f-7467-4f98-8792-0b3143214b26",correct:"Příkazový operátor `||` v shellu se používá k provedení druhého příkazu pouze tehdy, když první příkaz selže, což umožňuje definovat alternativní akce v případě neúspěchu předchozího příkazu.",incorrect:"Příkazový operátor `||` v shellu se používá k provedení druhého příkazu pouze tehdy, když první příkaz uspěje, což umožňuje definovat alternativní akce v případě neúspěchu předchozího příkazu.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"39ec7d38-4bf1-4872-b289-f346f16530dc",correct:"Operátor ``;` v shellu umožňuje sekvenční spouštění příkazů, kde se druhý příkaz spustí bez ohledu na výsledek prvního příkazu, a je považován za základní operátor pro řetězení příkazů.",incorrect:"Operátor ``;` v shellu umožňuje podmíněné spouštění příkazů, kde se druhý příkaz spustí pouze pokud první příkaz uspěje, a je považován za základní operátor pro řetězení příkazů.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"d2d2ebee-49b2-413e-a8b4-451d552e6432",correct:"Kombinace operátorů `&&` a `||` s příkazy vytváří opět platné příkazy, což umožňuje jejich flexibilní použití nejen v podmínkách `if` nebo `while` cyklů, ale také samostatně v interaktivním režimu shellu pro různé účely.",incorrect:"Kombinace operátorů `&&` a `||` s příkazy vytváří neplatné konstrukce v shellu a nelze je použít v podmínkách `if` nebo `while` cyklů, ani samostatně v interaktivním režimu shellu.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"9463a800-8de9-40d9-8855-6acd9a75a84e",correct:"Operátor `&&` je zvláště užitečný v interaktivním režimu shellu, protože umožňuje uživateli zadat sekvenci příkazů, která se automaticky zastaví, pokud některý z příkazů selže, čímž se snižuje celková latence interakce s systémem.",incorrect:"Operátor `&&` je zvláště užitečný v dávkovém režimu shellu, protože umožňuje uživateli zadat sekvenci příkazů, která se automaticky zastaví, pokud některý z příkazů selže, čímž se zvyšuje celková latence interakce s systémem.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"cb361ecc-6bff-40dd-b48c-f4fd3758787c",correct:"Shell pipelines jsou mocným nástrojem, který umožňuje kombinovat příkazy. Jsou implementovány pomocí operátoru pipe, který přesměrovává standardní výstup předchozího příkazu na standardní vstup následujícího příkazu, což umožňuje sekvenční zpracování dat mezi příkazy v pipeline. Tento mechanismus usnadňuje komplexní operace zřetězením jednoduchých utilit.",incorrect:"Shell pipelines jsou funkcí, která provádí příkazy sekvenčně, kde každý příkaz čeká na úplné dokončení předchozího, než začne. Operátor pipe, v tomto chybném výkladu, zahazuje standardní výstup prvního příkazu a standardní vstup druhého příkazu zůstává nepřipojený, čímž se zabrání toku dat mezi příkazy v pipeline a omezuje se komplexnost dosažitelných operací.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"971b9369-8788-4549-9a71-e81c4b46b67c",correct:"Při použití shell pipelines jako `cmd1 | cmd2 | cmd3` jsou všechny příkazy (cmd1, cmd2 a cmd3) spuštěny souběžně nebo paralelně. Operátor pipe zajišťuje, že standardní výstup `cmd1` je přesměrován jako standardní vstup pro `cmd2`, a podobně, standardní výstup `cmd2` se stává standardním vstupem pro `cmd3`, což usnadňuje tok dat mezi příkazy, když běží paralelně.",incorrect:"V shell pipelines jako `cmd1 | cmd2 | cmd3` jsou příkazy spouštěny sekvenčně, což znamená, že `cmd2` začne až po úplném dokončení `cmd1` a `cmd3` začne po dokončení `cmd2`. Operátor pipe, v této nesprávné interpretaci, slouží pouze k přesměrování chybových proudů, nikoli standardního výstupu, a proto neumožňuje předávání dat mezi příkazy během jejich sekvenčního provádění.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"0bf3d224-3e55-4cff-a549-c8329eb6f601",correct:"Shell funkce představují odlehčenou alternativu ke skriptům, avšak na rozdíl od skriptů, které mohou být spouštěny i ne-shell programy, shell funkce jsou určené výhradně pro volání v rámci shell prostředí a nemohou být spuštěny externími programy.",incorrect:"Shell funkce jsou plnohodnotnou náhradou za skripty a nabízejí stejnou flexibilitu spouštění, což znamená, že stejně jako skripty, i shell funkce mohou být bez omezení volány jak shell programy, tak i programy, které nejsou součástí shell prostředí.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"65acac98-b6f8-466a-90bf-5670a44c65d2",correct:"Při definování shell funkce není nutné explicitně exportovat proměnné, aby byly dostupné v kontextu funkce, a na rozdíl od běžných shell skriptů, změny proměnných provedené uvnitř shell funkce jsou viditelné a mají vliv i v prostředí, ze kterého byla funkce volána.",incorrect:"Stejně jako u shell skriptů, i u shell funkcí je nezbytné proměnné, které mají být sdíleny s volajícím prostředím, explicitně exportovat. Změny proměnných uvnitř shell funkce nikdy nemají vliv na prostředí, ze kterého byla funkce volána, protože prostředí je vždy předáváno pouze směrem dolů, nikoliv zpět.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"83e9e187-9ff5-47f3-9886-87438ee7811f",correct:"Běžné spuštění shell skriptu způsobí, že změny proměnných v něm provedené neovlivní proměnné v rodičovském shellu, avšak pokud je skript spuštěn pomocí příkazu '.', chová se podobně jako funkce a umožňuje, aby změny proměnných uvnitř skriptu byly viditelné i v rodičovském shellu.",incorrect:"Bez ohledu na způsob spuštění shell skriptu, ať už běžným způsobem nebo pomocí příkazu '.', změny proměnných uvnitř skriptu nikdy nemají vliv na proměnné v rodičovském shellu. Chování skriptů je v tomto ohledu konzistentní a nezávislé na způsobu jejich volání.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"1282f909-b995-4b73-9003-90024f2c55ba",correct:"Hostname slouží k identifikaci počítačů v síti a jsou navrženy tak, aby byly čitelné pro člověka. Existují ve dvou hlavních formách: jednoduché jméno počítače a plně kvalifikované doménové jméno (FQDN), které explicitně zahrnuje síť, do které počítač patří. FQDN poskytuje úplnou a jednoznačnou adresu pro počítač v rámci síťové hierarchie.",incorrect:"Hostname slouží k identifikaci počítačů v síti, ale jsou primárně navrženy pro čitelnost strojem, nikoli pro lidské porozumění. Existují ve dvou hlavních formách: jednoduché jméno počítače a částečně kvalifikované doménové jméno (PQDN), které implicitně zahrnuje síť, do které počítač patří. PQDN poskytuje úplnou a jednoznačnou adresu pro počítač v rámci síťové hierarchie.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"0fb21b65-febd-4e21-837d-7dd1241c2a01",correct:"Plně kvalifikovaná doménová jména (FQDN) jsou strukturována hierarchicky a jsou prezentována v little-endian formátu, jak je ilustrováno na příkladu 'www.fi.muni.cz'. Tato hierarchická struktura, čtená zprava doleva, začíná nejkonkrétnější částí (hostitelem) a postupuje k nejobecnější části (doméně), což zajišťuje jedinečnou a globálně rozpoznatelnou adresu pro každý počítač v síti.",incorrect:"Plně kvalifikovaná doménová jména (FQDN) jsou strukturována lineárně a jsou prezentována v big-endian formátu, jak je ilustrováno na příkladu 'www.fi.muni.cz'. Tato lineární struktura, čtená zleva doprava, začíná nejobecnější částí (doménou) a postupuje k nejkonkrétnější části (hostiteli), což zajišťuje jedinečnou a globálně rozpoznatelnou adresu pro každý počítač v síti.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"fd730754-1023-4ab4-9679-b69e9603a6b6",correct:"Při práci v lokálním síťovém prostředí je často přípustné vynechat lokální příponu z hostname. Například, namísto použití plně kvalifikovaného doménového jména, lze jednoduše použít samotné jméno počítače, jako 'aisa' v kontextu 'ping aisa', spoléhajíc se na konfiguraci lokální domény sítě pro vyřešení adresy.",incorrect:"Při práci v globálním síťovém prostředí je vždy nutné vynechat lokální příponu z hostname. Například, namísto použití plně kvalifikovaného doménového jména, se musí jednoduše použít samotné jméno počítače, jako 'aisa' v kontextu 'ping aisa', spoléhajíc se na globální DNS systém pro vyřešení adresy.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"eaf2f18a-aa48-4bd7-a025-195aa0ac612f",correct:"Pro vzájemnou komunikaci v počítačových sítích se upřednostňují číselné adresy, které jsou strojově čitelné a efektivní pro směrování a doručování datagramů, na rozdíl od lidsky čitelných jmen, která jsou sice uživatelsky přívětivější, ale vyžadují složitější mechanismy pro překlad na adresy strojové, přičemž délka a formát těchto číselných adres se liší v závislosti na síťovém protokolu, například IPv4 adresa je tvořena 4 oktety.",incorrect:"Pro vzájemnou komunikaci v počítačových sítích se upřednostňují lidsky čitelné adresy, které jsou univerzální a efektivní pro směrování a doručování datagramů, přičemž číselné adresy jsou sice strojově čitelné, ale jsou považovány za zastaralé a neefektivní, délka a formát těchto adres jsou jednotné napříč všemi síťovými protokoly a  IPv4 adresa je tvořena 8 oktety.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"600d322a-7fa5-4690-b1f7-bc460bfb3080",correct:"Zatímco pro uživatele je pohodlnější odkazovat se na počítače pomocí jmen sémanticky srozumitelných pro člověka, například doménových jmen, pro samotnou komunikaci mezi počítači v síti se využívají výhradně numerické adresy, jejichž struktura a délka se odvíjí od použitého komunikačního protokolu, přičemž například moderní protokol IPv6 definuje adresy o délce 16 oktetů, což umožňuje adresovat mnohem větší množství zařízení než starší IPv4.",incorrect:"Zatímco pro uživatele je pohodlnější odkazovat se na počítače pomocí jmen sémanticky srozumitelných pro člověka, pro samotnou komunikaci mezi počítači v síti se primárně využívají textové adresy, které jsou univerzálnější a lépe škálovatelné, struktura a délka těchto adres je pevně daná a nemění se v závislosti na komunikačním protokolu, přičemž protokol IPv6 definuje adresy o délce pouze 8 oktetů, což je méně než u staršího IPv4.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"3e715383-a37a-4440-8287-2c4349068605",correct:"Lokální sítě (LAN), jako například Ethernet a WiFi, jsou charakteristické svou geografickou omezeností na prostor kanceláře, domácnosti nebo budovy a fungují typicky jako jediná broadcast doména, což znamená, že každý počítač v síti může přímo oslovit všechny ostatní počítače připojené k dané LAN.",incorrect:"Rozsáhlé sítě (WAN), jako například Ethernet a WiFi, jsou charakteristické svou geografickou rozsáhlostí přesahující hranice států a kontinentů a fungují typicky jako oddělené broadcast domény, což znamená, že počítač v síti může oslovit pouze omezený počet ostatních počítačů připojených k dané WAN.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"9812a523-6eeb-4307-934c-ebf535693c83",correct:"Technologie Ethernet a WiFi, běžně používané v lokálních sítích (LAN), dosahují rychlostí přenosu dat až 1 Gb/s, přičemž Ethernet nabízí i méně běžné, avšak dostupné varianty s rychlostí 10 Gb/s, zatímco WiFi se typicky pohybuje okolo rychlosti do 1 Gb/s.",incorrect:"Technologie Ethernet a WiFi, běžně používané v rozsáhlých sítích (WAN), dosahují rychlostí přenosu dat pouze do 10 Mb/s, přičemž Ethernet nenabízí žádné varianty s rychlostí 10 Gb/s a WiFi je omezena maximální rychlostí 100 Mb/s.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"bb4f4bdf-6064-41b7-be0f-6093401184fb",correct:"Zatímco lokální sítě (LAN) a rozsáhlé sítě (WAN) se liší geografickým rozsahem a typickými technologiemi nízkých vrstev, je důležité poznamenat, že technologie běžně používané v LAN, konkrétně Ethernet a WiFi, se mohou uplatnit i v rámci rozsáhlých sítí (WAN).",incorrect:"Zatímco lokální sítě (LAN) a rozsáhlé sítě (WAN) se neliší geografickým rozsahem a typickými technologiemi nízkých vrstev, je důležité poznamenat, že technologie běžně používané v LAN, konkrétně Ethernet a WiFi, se nikdy nemohou uplatnit v rámci rozsáhlých sítí (WAN).",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"3152d519-2b93-43c8-b7f0-2f7cef9407aa",correct:"Standardní model sítí OSI (Open Systems Interconnection) rozděluje síťovou komunikaci do sedmi vrstev. Zjednodušený TCP/IP model, který se často používá v praxi, kombinuje některé z těchto vrstev do čtyř hlavních: Link, Internet, Transport a Application. Konkrétně, linková vrstva TCP/IP zhruba odpovídá fyzické a datové vrstvě modelu OSI, zatímco aplikační vrstva TCP/IP zahrnuje vrstvy 5 až 7 modelu OSI.",incorrect:'Standardní model sítí OSI (Open Systems Interconnection) rozděluje síťovou komunikaci do sedmi vrstev. Zjednodušený TCP/IP model, který se často používá v praxi, rozšiřuje tento model na pět vrstev přidáním nové "Session" vrstvy mezi Transport a Application vrstvu. Linková vrstva TCP/IP přesně odpovídá pouze fyzické vrstvě modelu OSI, a datová vrstva je zahrnuta do Internet vrstvy.',sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"4e870846-1ba2-459f-bef1-7cd9931bb6eb",correct:"Přestože TCP/IP model definuje pouze čtyři vrstvy, při odkazování na konkrétní vrstvy podle čísel se běžně používá číslování vrstev modelu OSI. To znamená, že i v kontextu TCP/IP modelu se IP protokol označuje jako vrstva 3 a TCP protokol jako vrstva 4, což odpovídá jejich pozici v sedmivrstvém OSI modelu.",incorrect:"V TCP/IP modelu se číslování vrstev liší od OSI modelu a začíná od 1 pro linkovou vrstvu až po 4 pro aplikační vrstvu. Tudíž, protokol IP, který je v OSI modelu vrstva 3, je v TCP/IP modelu označován jako vrstva 2, a protokol TCP, vrstva 4 v OSI, se v TCP/IP modelu stává vrstvou 3.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"916fd368-b1ff-48b8-8846-63b33ab082d3",correct:"Linková vrstva v TCP/IP modelu, která zahrnuje technologie jako Ethernet a WiFi, v sobě sdružuje funkcionalitu jak fyzické vrstvy, která se stará o fyzický přenos dat, tak i datové vrstvy, která zajišťuje spolehlivý přenos dat mezi dvěma přímo spojenými uzly, jak je definováno v sedmivrstvém OSI modelu.",incorrect:"Linková vrstva v TCP/IP modelu se striktně omezuje pouze na funkce fyzické vrstvy OSI modelu, tedy na definování fyzických médií a přenosových charakteristik. Funkcionalita datové vrstvy, jako je rámcování a řízení přístupu k médiu, je v TCP/IP modelu přesunuta do internetové vrstvy.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"0477773d-4131-4fbe-9a16-3022ee31b8ed",correct:"V posledních dvou dekádách se stalo síťování standardní službou poskytovanou operačními systémy pro všeobecné použití. V systémech s monolitickým jádrem je významná část síťového zásobníku, konkrétně vrstvy až po transportní vrstvu včetně, integrována přímo do jádra a zpřístupněna uživatelským programům prostřednictvím rozhraní sockets API.",incorrect:"Síťování je volitelná služba v moderních operačních systémech pro všeobecné použití. V systémech s monolitickým jádrem je pouze malá část síťového zásobníku, konkrétně jen fyzická vrstva, integrována přímo do jádra a zpřístupněna uživatelským programům prostřednictvím speciálního síťového API, odlišného od sockets API.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"ab788b82-7486-4ac9-89f8-7881a47a116c",correct:"V operačních systémech založených na monolitické architektuře jádra je síťový zásobník, zahrnující vrstvy až po transportní vrstvu, typicky implementován v prostoru jádra. Tato konstrukční volba umožňuje přímou a efektivní komunikaci mezi základními funkcemi operačního systému a síťovými operacemi a je zpřístupněna uživatelským programům prostřednictvím rozhraní sockets API.",incorrect:"V operačních systémech založených na monolitické architektuře jádra je celý síťový zásobník, včetně aplikační vrstvy, vždy implementován v prostoru jádra. Tato konstrukční volba je povinná z bezpečnostních důvodů a zabraňuje uživatelským programům v přímé interakci se síťovými operacemi, které jsou místo toho spravovány samostatným, specializovaným API.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"bc46f480-3ad9-4bbe-b6c3-4a64adc80f58",correct:"Operační systémy založené na mikrokernelu často používají odlišný přístup k síťování ve srovnání s monolitickými jádry. V mikrokernelech jsou síťové funkce typicky přesunuty z jádra a implementovány v uživatelském prostoru, což může nabídnout výhody, jako je zvýšená modularita a potenciálně zlepšená stabilita systému izolací selhání síťového kódu od jádra.",incorrect:"Operační systémy založené na mikrokernelu vždy používají stejný přístup k síťování jako monolitická jádra. V mikrokernelech jsou síťové funkce vždy ponechány uvnitř jádra a implementovány v prostoru jádra, což je nezbytné z výkonnostních důvodů a umožňuje přímý přístup k hardwarovým zdrojům, čímž je zajištěn efektivní provoz sítě.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"a4912f56-5549-4848-8fb9-cc45fe099d98",correct:"Přestože název Transport Layer Security (TLS) naznačuje, že funguje na transportní vrstvě, ve skutečnosti je považován za technologii aplikační vrstvy.  Funkcionalita pro TLS, spolu s dalšími aplikačními službami, jako je překlad názvů domén (DNS), je běžně poskytována systémovými knihovnami v moderních operačních systémech, které aplikacím nabízejí snadno dostupné síťové služby.",incorrect:"Transport Layer Security (TLS), navzdory svému názvu bezpečnost transportní vrstvy, ve skutečnosti funguje výhradně na vrstvě datového spoje. Funkcionalita pro TLS, spolu se službami nižších vrstev, jako jsou ovladače síťových karet, je běžně poskytována přímo jádrem operačního systému, které aplikacím nabízí nízkoúrovňový síťový přístup a kontrolu.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"06dc411f-a878-4d3b-9628-caca82055294",correct:"Implementace linkové vrstvy v operačních systémech je typicky zajištěna ovladači zařízení, zatímco klientská a serverová strana protokolů TCP/IP jsou zpřístupněny prostřednictvím rozhraní socket API, což umožňuje aplikacím komunikovat po síti.",incorrect:"Implementace síťové vrstvy v operačních systémech je typicky zajištěna ovladači zařízení, zatímco klientská a serverová strana protokolů UDP jsou zpřístupněny prostřednictvím rozhraní pro souborové operace, což primárně slouží pro lokální diskové operace.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"106b3ded-8526-48ff-9be7-e781b4582566",correct:"Funkce jako směrování a filtrování paketů, které jsou klíčové pro správnou funkci sítí a implementaci firewallů, mohou být často realizovány softwarově v rámci operačního systému, a v takovém případě jsou obvykle implementovány přímo v jádře systému pro zajištění výkonu a integrace.",incorrect:"Funkce jako směrování a filtrování paketů, ačkoliv jsou důležité pro síťovou komunikaci, jsou vždy implementovány výhradně hardwarově na specializovaných síťových zařízeních a nikdy nejsou realizovány softwarově v jádře operačního systému z důvodu výkonostních omezení a složitosti implementace.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"5872546a-b7a9-4b48-8d42-0828bc3b0d75",correct:"Některé síťové služby aplikační vrstvy, jako například síťové souborové systémy typu SMB nebo NFS, mohou být implementovány přímo v jádře operačního systému, což přináší výhody v podobě vyššího výkonu a nižší latence, a je efektivní pro sdílení souborů v rozsáhlých síťových prostředích.",incorrect:"Síťové služby aplikační vrstvy, včetně síťových souborových systémů jako SMB nebo NFS, jsou vždy implementovány výhradně v uživatelském prostoru operačního systému, aby se zajistila bezpečnost a stabilita systému, a nikdy nejsou implementovány v jádře.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"5193c2f5-e873-43aa-8cbc-ed783a2f3c2a",correct:"Rozhraní socket API, ačkoliv je formálně doménou systémových knihoven, v monolitických jádrech operačních systémů často vykazuje přímý vztah 1:1 k systémovým voláním, což znamená, že funkce C knihoven pro práci se socketem přímo odpovídají systémovým voláním jádra. Nicméně v mikrokernech, kde je síťový zásobník rozdělen odlišně, systémové knihovny přebírají větší podíl zodpovědnosti za implementaci socket API.",incorrect:"Rozhraní socket API je výhradně doménou systémových volání operačního systému, a to platí jak pro monolitická jádra, tak pro mikrokernelové architektury. V obou typech jader je zajištěno, že funkce C knihoven pro práci se socketem vždy přímo odpovídají systémovým voláním jádra, a systémové knihovny tak hrají minoritní roli v implementaci socket API.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"507d9464-d418-4962-b83b-66eae07c7748",correct:"Služba překladu hostitelských jmen na IP adresy, známá jako DNS klient, je v operačních systémech obvykle poskytována systémovými knihovnami. Důvodem je, že téměř všechny programy, které pracují se sítí, potřebují tuto funkcionalitu pro převod lidsky čitelných jmen na adresy srozumitelné pro síťovou komunikaci.",incorrect:"Služba překladu hostitelských jmen na IP adresy, známá jako DNS klient, je typicky implementována přímo v jádře operačního systému jako součást síťového subsystému. Systémové knihovny se o tuto funkcionalitu nestarají, protože implementace DNS klienta v jádře zajišťuje vyšší výkon a efektivitu pro všechny síťové aplikace.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"743abb61-5f60-4f7c-b502-7bfa3e3b8a1a",correct:"V moderním internetu je šifrování klíčové, a proto většina operačních systémů poskytuje SSL/TLS stack, který zahrnuje i správu certifikátů. Tato implementace šifrování je obvykle součástí systémových knihoven operačního systému, což umožňuje aplikacím snadno využívat šifrované spojení.",incorrect:"V moderním internetu je šifrování sice důležité, ale SSL/TLS stack, včetně správy certifikátů, je obvykle implementován výhradně na úrovni aplikací, nikoliv v operačním systému. Operační systémy obvykle neposkytují nativní podporu pro SSL/TLS a správu certifikátů, a aplikace si musí tuto funkcionalitu implementovat samy.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"72ee929f-8ee3-44a4-a00d-e7c6cad2e889",correct:"Síťové nástroje a služby, jako například konfigurace síťových rozhraní pomocí `ifconfig` nebo automatická konfigurace adres pomocí DHCP, jsou klíčovou součástí síťového stacku operačního systému a nacházejí se v systémových utilitách a službách, které jsou implementovány jako systémové daemony běžící na pozadí.",incorrect:"Síťové nástroje a služby, jako například konfigurace síťových rozhraní pomocí `ifconfig` nebo automatická konfigurace adres pomocí DHCP, jsou okrajovou součástí síťového stacku operačního systému a nacházejí se v aplikační vrstvě, která je implementována jako uživatelské aplikace s grafickým rozhraním.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"746501cd-7523-42e7-914f-a5af0226c6ba",correct:"Konfigurační nástroje, mezi které patří `dhclient` a `dhcpd`, se v operačních systémech starají o automatickou konfiguraci síťových rozhraní, včetně přidělování IP adres a správy dalších síťových parametrů, což je klíčové pro správnou funkčnost síťové komunikace a je nezbytné pro moderní sítě.",incorrect:"Konfigurační nástroje, mezi které patří `dhclient` a `dhcpd`, se v operačních systémech starají výhradně o manuální konfiguraci síťových rozhraní administrátorem, přičemž automatické přidělování IP adres a správa síťových parametrů je prováděna výhradně hardwarovými komponentami routeru.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"332fbe00-c552-49a2-a976-cdea48c0cbb7",correct:"Nástroje pro správu směrování, jako jsou `route` a `bgpd`, hrají zásadní roli v operačních systémech, zejména pro softwarové směrovače a systémy s více síťovými rozhraními (multi-homed systems), kde umožňují definovat a spravovat směrovací tabulky pro efektivní doručování síťových paketů mezi různými sítěmi.",incorrect:"Nástroje pro správu směrování, jako jsou `route` a `bgpd`, hrají okrajovou roli v operačních systémech a jsou relevantní pouze pro jednoduché koncové stanice s jedním síťovým rozhraním, zatímco pro softwarové směrovače a systémy s více rozhraními se správa směrování provádí výhradně na hardwarové úrovni a operační systém do toho nezasahuje.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"f5eb80f6-3a51-40af-8a3b-e89b9ebad4bd",correct:"Diagnostické nástroje, například `ping` a `traceroute`, jsou nezbytnou součástí operačních systémů pro ověřování síťové konektivity a trasování síťových paketů, zatímco nástroj `tcpdump` umožňuje detailní inspekci síťového provozu zachytáváním a analýzou paketů procházejících síťovým rozhraním pro účely ladění a bezpečnosti.",incorrect:"Diagnostické nástroje, například `ping` a `traceroute`, jsou v operačních systémech pouze doplňkovou součástí pro monitorování zátěže sítě a nemají žádný vliv na ověřování síťové konektivity nebo trasování paketů, přičemž nástroj `tcpdump` slouží pouze k blokování síťového provozu na základě definovaných pravidel.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"f8932ba4-0941-40d3-ae38-1a7402ec10a9",correct:"Mezi další síťové služby, které jsou typicky součástí operačních systémů a implementovány jako daemony, patří například `ntpd` pro synchronizaci času systému s přesnými časovými servery, `sshd` pro zabezpečený vzdálený přístup k systému a `inetd` jako meta-server pro správu a spouštění méně frekventovaných síťových služeb.",incorrect:"Mezi další síťové služby, které jsou typicky součástí operačních systémů, patří například `ntpd` pro správu tiskových úloh v síti, `sshd` pro správu a konfiguraci hardwarových ovladačů síťových zařízení a `inetd` jako nástroj pro monitorování a správu hardwarových zdrojů systému, jako je procesor a paměť.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"56f67371-15a5-46e3-95f6-61b10f838f5c",correct:"Síťové protokoly jsou zásadně strukturovány kolem tří klíčových aspektů: definování komunikační jednotky jako paketů, zavedení mechanismů adresování pro identifikaci příjemců komunikace a implementace metod doručování paketů, které zajišťují přesun zpráv mezi síťovými uzly, potenciálně zahrnující procesy směrování a překladu adres.",incorrect:"Síťové protokoly se primárně zabývají dvěma hlavními aspekty: definováním velikosti datových bloků a zajištěním šifrování dat pro bezpečnou komunikaci. Adresování a doručování paketů, i když jsou důležité, jsou považovány za druhořadé k základním aspektům velikosti dat a bezpečnosti v návrhu síťových protokolů.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"e18e5f90-37b1-4aa3-971f-7af593a73ba1",correct:"Podle základních principů síťových protokolů je ústředním konceptem pojem 'paket', který představuje základní komunikační jednotku.  Proces 'adresování' navíc hraje klíčovou roli v síťové komunikaci tím, že jasně určuje zamýšlené příjemce těchto paketů, a tím zajišťuje, že zprávy dorazí na správná místa určení.",incorrect:"V kontextu síťových protokolů slouží 'pakety' primárně jako kontejnery pro kódy pro kontrolu chyb, nikoli jako základní komunikační jednotky samotné. Zatímco adresování je relevantní, jeho hlavní funkcí je upřednostňovat síťový provoz na základě naléhavosti, spíše než jednoduše identifikovat příjemce zpráv, což je druhořadý zájem.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"13ea35bb-77dd-49f2-8f2b-33e252472a2f",correct:"Doručování paketů, jako klíčový aspekt síťových protokolů, zahrnuje mechanismy a postupy potřebné k efektivnímu přenosu paketů ze zdrojové adresy na cílovou adresu v síti. Tento proces doručování může vyžadovat složité operace, jako je směrování pro určení optimální cesty a překlad adres pro překlenutí různých schémat adresování v rámci sítě.",incorrect:"Doručování paketů v síťových protokolech se zaměřuje výhradně na zajištění, aby pakety dorazily v přesném pořadí, v jakém byly odeslány, a zanedbává aspekty, jako je směrování nebo překlad adres. Primárním zájmem je zachování integrity sekvence a jakékoli mechanismy nad rámec jednoduchého sekvenčního doručování jsou považovány za mimo hlavní rámec protokolů doručování paketů.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"71e9323a-d250-4d58-a76c-3a937afcd9f9",correct:"V kontextu síťového protokolu stacku, protokoly fungují hierarchicky, kde protokoly vyšších vrstev, jako je například HTTP, využívají abstrakce a funkce poskytované protokoly nižších vrstev, jako je TCP, které zase využívají abstrakce poskytované protokolem IP. Tato vrstvená architektura umožňuje modularitu a zjednodušuje návrh komplexních síťových systémů.",incorrect:"V kontextu síťového protokolu stacku, protokoly fungují nezávisle na sobě a protokoly nižších vrstev, jako je TCP a IP, poskytují služby protokolům vyšších vrstev, jako je HTTP, avšak HTTP nevyužívá funkčnost TCP ani IP a funguje zcela autonomně. Tato architektura maximalizuje flexibilitu, ale komplikuje návrh síťových systémů.",sectionNumber:"9.2.10",sectionTitle:"Protocol Nesting"},{uuid:"89255278-6a27-49a7-96b5-bf523f78027a",correct:"Struktura paketů v síťové komunikaci se podobá matrjošce, kde ethernetový rámec obaluje IP paket, který dále může obalovat TCP paket, a tak dále, přičemž každý obal představuje nižší vrstvu protokolu a vnitřní část data z vyšší vrstvy.",incorrect:"Struktura paketů v síťové komunikaci je lineární, kde se pakety jednotlivých protokolů řadí vedle sebe bez vnořování, přičemž ethernetový rámec a IP paket se posílají odděleně a TCP paket je zcela nezávislý na předchozích vrstvách.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"d0b4619d-7da4-4911-87d8-7d59bf7b8414",correct:"Z pohledu horních vrstev síťového modelu je velikost paketu důležitým parametrem, jelikož optimalizace velikosti paketů mezi různými vrstvami přispívá k efektivnějšímu přenosu dat a minimalizaci fragmentace, zvláště když jsou paketově orientované protokoly vnořeny do sebe.",incorrect:"Velikost paketů je irelevantní pro horní vrstvy síťového modelu, protože nižší vrstvy automaticky fragmentují a skládají pakety bez ohledu na původní velikost dat z horních vrstev, takže horní vrstvy se nemusí zabývat optimalizací velikosti paketů.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"a1704a82-385b-4976-bbe9-9e2905b94889",correct:"Abstrakce doručení v síťových vrstvách je typicky point-to-point, což znamená, že každá vrstva se stará o doručení dat jen k nejbližšímu sousednímu uzlu, a složitější směrování na delší vzdálenosti je skryto a řešeno nižšími vrstvami.",incorrect:"Abstrakce doručení v síťových vrstvách je typicky broadcast, což znamená, že každá vrstva se stará o doručení dat všem uzlům v síti, a složitější směrování na delší vzdálenosti je explicitně odhaleno a řešeno vyššími vrstvami.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"027bbf11-95af-4e29-862c-d25ec8081362",correct:"Směrování v síťových vrstvách je převážně skryto před vyššími vrstvami, protože cílem abstrakce vrstev je oddělit zodpovědnosti, a vyšší vrstvy se tak mohou soustředit na logiku aplikace, aniž by se musely zabývat detaily směrování paketů v síti.",incorrect:"Směrování v síťových vrstvách je explicitně odhaleno vyšším vrstvám, protože cílem abstrakce vrstev je umožnit vyšším vrstvám plně kontrolovat tok dat v síti, a vyšší vrstvy se tak musí aktivně zabývat detaily směrování paketů v síti.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"a6fdd5a4-c905-4b64-a7af-c5e82dca0c99",correct:"Vyšší vrstva v síťovém modelu požaduje doručení dat na určitou adresu, přičemž konkrétní mechanismy doručení a směrování jsou obvykle implementovány v nižších vrstvách, které poskytují službu doručení jako abstrakci pro vyšší vrstvu.",incorrect:"Vyšší vrstva v síťovém modelu požaduje přímé spojení bez adresování, přičemž konkrétní mechanismy doručení a směrování jsou obvykle implementovány ve vyšších vrstvách, které poskytují službu doručení jako abstrakci pro nižší vrstvu.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"8242d699-5e92-4e3b-b52d-19620af5c034",correct:"Nižší vrstvy síťového modelu, jako je linková vrstva, jsou obvykle orientované na pakety, což znamená, že data jsou pro přenos rozdělena do menších jednotek zvaných pakety, které se nezávisle přenášejí a skládají na cílové straně.",incorrect:"Nižší vrstvy síťového modelu, jako je linková vrstva, jsou obvykle orientované na stream, což znamená, že data jsou pro přenos považována za souvislý proud bytů, které se přenášejí v sekvenci bez dělení na menší jednotky.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"6088029a-fad8-4aa8-b887-36ffcacda684",correct:"Paket dat může překračovat hranice mezi různými doménami nízkých vrstev, což je běžné například v internetovém protokolu, kde jeden IP paket může projít několika různými linkovými vrstvami a sítěmi během své cesty k cíli.",incorrect:"Paket dat je striktně omezen na jednu doménu nízké vrstvy a nemůže překračovat hranice mezi různými doménami, což zajišťuje izolaci a bezpečnost v rámci jedné sítě, ale omezuje možnosti pro rozsáhlejší sítě.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"dc2d4cc6-2f8a-42aa-88c5-efd7511bfb43",correct:"Adresní vztahy v síťových vrstvách operačních systémů nejsou vždy přímočaré a jednoduché, a vyžadují složitější mechanismy než pouhé vnořování paketů. Tato složitost pramení z nutnosti překládat adresy mezi různými vrstvami a protokoly, což vyžaduje specializované protokoly pro mapování adres, jako například DNS a ARP.",incorrect:"Adresní vztahy v síťových vrstvách operačních systémů jsou naopak často jednodušší a přímočařejší než pouhé vnořování paketů. Tato jednoduchost je dána absencí nutnosti složitých překladů adres mezi různými vrstvami a protokoly, což eliminuje potřebu specializovaných protokolů pro mapování adres, jako například DNS a ARP.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"cf43bd3a-afa6-4849-b6d1-19dcb31af7ba",correct:"Adresa transportní vrstvy, například adresa TCP, v sobě zahrnuje adresu internetové vrstvy jako jedno z polí. Konkrétně se typická TCP adresa skládá z IP adresy, která identifikuje síťové rozhraní, a čísla portu, které specifikuje konkrétní aplikaci nebo službu běžící na daném hostiteli.",incorrect:"Adresa transportní vrstvy, například adresa TCP, v sobě nezahrnuje adresu internetové vrstvy jako jedno z polí. Naopak, TCP adresa je zcela nezávislá na IP adrese a skládá se pouze z čísla portu, které specifikuje konkrétní aplikaci nebo službu běžící na daném hostiteli, bez ohledu na síťovou vrstvu.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"fd27fc6a-efd6-499d-bb1d-ef40c7a550bf",correct:"Protokol DNS (Domain Name System), který slouží k překladu doménových jmen na IP adresy, je považován za speciální protokol, který logicky spadá do aplikační vrstvy. Ačkoli DNS operuje s adresami transportní vrstvy pro komunikaci, jeho primární funkcí je podpora aplikací na nejvyšší vrstvě síťového modelu tím, že jim umožňuje používat srozumitelné názvy namísto číselných IP adres.",incorrect:"Protokol DNS (Domain Name System), který slouží k překladu doménových jmen na IP adresy, je považován za speciální protokol, který logicky spadá do transportní vrstvy.  DNS primárně operuje a je řízen transportní vrstvou, protože jeho hlavní funkcí je zajištění spolehlivé komunikace mezi transportními vrstvami různých systémů, a překlad doménových jmen je pouze vedlejší funkcí pro usnadnění adresace.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"b529f0f1-58cd-4c6b-be03-7fe6955bfac7",correct:"ARP protokol se používá k nalezení MAC adresy odpovídající IP adrese v lokální síti, což je nezbytné pro doručování paketů, protože IP protokol využívá linkovou vrstvu, která vyžaduje MAC adresy pro doručení dat. Operační systém vytváří mapu těchto překladů IP adres na MAC adresy pro efektivní směrování komunikace v síti.",incorrect:"ARP protokol se používá k nalezení IP adresy odpovídající MAC adrese v lokální síti, což je nezbytné pro doručování paketů, protože MAC protokol využívá internetovou vrstvu, která vyžaduje IP adresy pro doručení dat. Operační systém vytváří mapu těchto překladů MAC adres na IP adresy pro efektivní směrování komunikace v síti.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"98114721-7cdb-43fc-ac20-ff6c450e49f6",correct:"Pro úspěšné doručení paketu v lokální síti je klíčové znát MAC adresu cílového zařízení, protože IP protokol využívá služeb linkové vrstvy, a ta pro doručení vyžaduje MAC adresy. ARP protokol je mechanismus, který umožňuje získat tuto nezbytnou MAC adresu na základě znalosti IP adresy cílového zařízení v dané lokální síti.",incorrect:"Pro úspěšné doručení paketu v lokální síti je klíčové znát IP adresu cílového zařízení, protože MAC protokol využívá služeb internetové vrstvy, a ta pro doručení vyžaduje IP adresy. ARP protokol je mechanismus, který umožňuje získat tuto nezbytnou IP adresu na základě znalosti MAC adresy cílového zařízení v dané lokální síti.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"e9b47beb-0ccb-466c-b308-b0209fde81d1",correct:"Adresní rozlišovací protokol (ARP) se nachází na pomezí linkové a internetové vrstvy a hraje zásadní roli v umožnění internetové vrstvě doručovat pakety s využitím služeb linkové vrstvy. I když IP paket obsahuje pouze IP adresu, ARP zajistí, že se získá odpovídající MAC adresa, která je nezbytná pro doručení paketu v lokální síti.",incorrect:"Adresní rozlišovací protokol (ARP) se nachází na pomezí transportní a internetové vrstvy a hraje zásadní roli v umožnění transportní vrstvě doručovat pakety s využitím služeb internetové vrstvy. I když IP paket obsahuje pouze MAC adresu, ARP zajistí, že se získá odpovídající IP adresa, která je nezbytná pro doručení paketu v lokální síti.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"684a0467-296e-4d04-a04f-5f96cecf2fb7",correct:"Ethernet protokol, který spadá do linkové vrstvy síťové komunikace, je z velké části implementován přímo v hardwaru síťových zařízení, což umožňuje operačnímu systému využívat jednotné a dobře definované rozhraní, které poskytují ovladače těchto zařízení, pro efektivní odesílání a příjem ethernetových rámců, přičemž pro adresaci v rámci lokální sítě se používají MAC adresy.",incorrect:"Ethernet protokol, který spadá do síťové vrstvy síťové komunikace, je z velké části implementován přímo v softwaru operačního systému, což umožňuje aplikacím využívat specifické rozhraní pro odesílání a příjem IP paketů, přičemž pro adresaci v rámci internetu se používají IP adresy.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"93c06fe6-704d-482d-a0cf-ac0ac08f894b",correct:"Vysokorychlostní sítě, jako je Ethernet, jsou typicky přepojované paketově, což znamená, že uzly odesílají datové pakety přepínači, který je obvykle realizován jako hardwarové zařízení, ačkoli existují i softwarové implementace, zejména v prostředí virtualizace, přičemž přepínač udržuje informace o MAC adresách dosažitelných na jednotlivých fyzických portech a na základě cílové MAC adresy pakety směruje.",incorrect:"Vysokorychlostní sítě, jako je Token Ring, jsou typicky přepojované okruhově, což znamená, že uzly si předem rezervují spojení přes směrovač, který je obvykle realizován jako softwarová aplikace, ačkoli existují i hardwarové implementace pro specifické účely, přičemž směrovač udržuje informace o IP adresách dosažitelných v různých sítích a na základě cílové IP adresy data směruje pomocí směrovacích tabulek.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"02d5fc72-0ede-4514-ad9f-ec498c8b4ab8",correct:"Mosty a přepínače jsou zařízení pracující na linkové vrstvě, přičemž most je koncipován jako zařízení se dvěma porty, optimalizované pro propojení dvou lokálních sítí (LAN), kde na každé straně mostu se typicky nachází více MAC adres, zatímco přepínač je navržen pro práci s větším počtem portů, kde ke každému portu je obvykle přiřazena jediná MAC adresa, s potenciální výjimkou vyhrazeného uplink portu.",incorrect:"Mosty a směrovače jsou zařízení pracující na síťové vrstvě, přičemž most je koncipován jako zařízení s jedním portem, optimalizované pro propojení dvou rozlehlých sítí (WAN), kde na každé straně mostu se typicky nachází více IP adres, zatímco směrovač je navržen pro práci s menším počtem portů, kde ke každému portu je obvykle přiřazena celá podsíť IP adres, s potenciální výjimkou portu pro bránu.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"4c5514c4-734d-475f-82b5-2c7695b46d44",correct:"Kromě Ethernetu, který je široce používán v lokálních sítích, existují i další významné linkové protokoly, jako například PPP (Point-to-Point Protocol) a WiFi, jež se liší svými specifickými vlastnostmi a jsou navrženy pro odlišné typy sítí a způsob připojení.",incorrect:"Kromě Ethernetu, který je široce používán v lokálních sítích, existují i další linkové protokoly, jako například PPP (Point-to-Point Protocol) a WiFi, avšak tyto protokoly jsou v podstatě jen variantami Ethernetu a nenabízejí žádné zásadní odlišnosti v charakteristikách nebo způsobu použití.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"316a774c-0bb8-4656-83d8-cc8aca3d8f4f",correct:"Protokol PPP, označovaný jako Point-to-Point Protocol, je koncipován jako linková vrstva pro sítě s přímým spojením mezi dvěma uzly a je navržen tak, aby fungoval s různými fyzickými médii, včetně telefonních linek, mobilních sítí, DSL a dokonce i Ethernetu, což z něj činí velmi adaptabilní protokol pro různé síťové konfigurace.",incorrect:"Protokol PPP, označovaný jako Point-to-Point Protocol, je koncipován jako síťová vrstva pro komplexní sítě s mnoha uzly a je navržen tak, aby fungoval výhradně s optickými kabely, vylučuje použití telefonních linek, mobilních sítí a DSL, což omezuje jeho adaptabilitu pouze na specifické síťové konfigurace.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"a6e6ce9f-6c14-407f-97ab-e5c922449952",correct:"WiFi, ačkoli je často vnímáno jako bezdrátová alternativa Ethernetu, se ve skutečnosti liší v mnoha aspektech, včetně nižší spolehlivosti a rychlosti přenosu dat, a vyžaduje implementaci šifrování a autentizace z důvodu otevřenosti bezdrátového média a potenciálního odposlouchávání komunikace.",incorrect:"WiFi, ačkoli je často vnímáno jako bezdrátová alternativa Ethernetu, se ve skutečnosti neliší v zásadních aspektech, včetně srovnatelné spolehlivosti a rychlosti přenosu dat, a nevyžaduje implementaci šifrování ani autentizace, protože bezdrátové médium je inherentně zabezpečené proti odposlouchávání komunikace.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"b9ed7a19-4641-40f4-9891-8a2c52fe81fa",correct:"Z pohledu vyšších vrstev síťového modelu je WiFi vnímáno jako varianta Ethernetu s horšími parametry, především co se týče spolehlivosti a propustnosti, nicméně interní implementace protokolu WiFi je značně komplexnější než u Ethernetu, zahrnující mechanismy pro řešení interference a kolizí v bezdrátovém prostředí.",incorrect:"Z pohledu vyšších vrstev síťového modelu je WiFi vnímáno jako identická kopie Ethernetu s naprosto srovnatelnými parametry ve všech ohledech, a interní implementace protokolu WiFi je zjednodušenou verzí Ethernetu, neobsahující žádné složitější mechanismy pro řešení specifických problémů bezdrátového prostředí.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"cdc4d4ca-7117-4ddb-969c-7184102087eb",correct:"Tunelování je technika, která umožňuje vnoření provozu nižších vrstev do aplikační vrstvy existující sítě, typicky za účelem propojení fyzicky vzdálených počítačů do jedné broadcastové domény linkové vrstvy nebo směrovací domény internetové vrstvy.",incorrect:"Tunelování je technika, která umožňuje vnoření provozu vyšších vrstev do aplikační vrstvy existující sítě, typicky za účelem propojení fyzicky blízkých počítačů do jedné broadcastové domény linkové vrstvy nebo směrovací domény internetové vrstvy.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"3bb9963e-4c90-4d1a-ba09-36cafdb3c38b",correct:"V kontextu tunelování implementuje VPN software aplikační protokol běžící ve vnější síťové vrstvě a současně funguje jako rozhraní linkové vrstvy nebo podsíť internetové vrstvy, která je chápána jako běžné fyzické rozhraní.",incorrect:"V kontextu tunelování implementuje VPN software linkový protokol běžící ve vnější síťové vrstvě a současně funguje jako rozhraní aplikační vrstvy nebo podsíť internetové vrstvy, která je chápána jako běžné fyzické rozhraní.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"509bc57b-b3e9-4dd0-94c3-ef74ff0d007b",correct:"Tunely, často používané ve virtuálních privátních sítích (VPN), jsou virtuální zařízení druhé nebo třetí vrstvy, které zapouzdřují síťový provoz do protokolu vyšší vrstvy, přičemž tunel bývá obvykle šifrovaný pro zajištění bezpečnosti přenášených dat.",incorrect:"Tunely, zřídka používané ve virtuálních privátních sítích (VPN), jsou fyzická zařízení druhé nebo třetí vrstvy, která zapouzdřují síťový provoz do protokolu nižší vrstvy, přičemž tunel nebývá obvykle šifrovaný, protože šifrování zbytečně zatěžuje síť.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"87cbc193-2279-42b2-89de-dbaa383f9558",correct:'IP protokol je nespolehlivý protokol pracující na principu "best-effort", což znamená, že negarantuje doručení paketů, integritu dat ani pořadí doručení, a pakety se mohou ztratit, být přeuspořádány nebo poškozeny během přenosu, což klade důraz na mechanismy vyšších vrstev pro zajištění spolehlivosti, pokud je vyžadována.',incorrect:'IP protokol je spolehlivý protokol pracující na principu "best-effort", což znamená, že garantuje doručení paketů, integritu dat i pořadí doručení, a pakety se nemohou ztratit, být přeuspořádány nebo poškozeny během přenosu, což eliminuje potřebu mechanismů vyšších vrstev pro zajištění spolehlivosti.',sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"4ebca8a4-e60b-46b9-a0cf-2602360bd549",correct:"IP adresy, ať už 4-bytové (v4) nebo 16-bytové (v6), jsou logicky rozděleny na dvě části: síťovou a hostitelskou, přičemž hranice mezi těmito částmi je flexibilně definována pomocí síťové masky (netmask), která umožňuje různé velikosti podsítí v závislosti na počtu potřebných hostitelů a efektivním využití adresního prostoru.",incorrect:"IP adresy, ať už 4-bytové (v4) nebo 16-bytové (v6), jsou fyzicky rozděleny na dvě části: síťovou a hostitelskou, přičemž hranice mezi těmito částmi je pevně definována výrobcem síťového zařízení a nelze ji měnit pomocí síťové masky (netmask), což omezuje flexibilitu a efektivitu využití adresního prostoru.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"7db3b4b9-31c2-4878-83be-0f333ea61ef3",correct:"Směrovače (routers) fungují na třetí vrstvě síťového modelu a jsou zodpovědné za přeposílání paketů mezi různými IP sítěmi na základě směrovacích tabulek, které jsou mnohem komplexnější než informace udržované přepínači (switches) na druhé vrstvě, a vyžadují dynamickou údržbu a aktualizaci pro zajištění optimálního směrování v rozsáhlých sítích.",incorrect:"Směrovače (routers) fungují na druhé vrstvě síťového modelu a jsou zodpovědné za přeposílání paketů v rámci jedné IP sítě na základě MAC adres, které jsou jednodušší než směrovací tabulky používané přepínači (switches) na třetí vrstvě, a vyžadují statickou konfiguraci a minimální údržbu pro zajištění základního směrování v lokálních sítích.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"89abc60a-9092-4622-acdf-88cbafcd5e35",correct:"V transportní vrstvě adresování se používají dvě klíčové komponenty: IP adresa cílového počítače, identifikující síťové rozhraní, a číslo portu, což je 16bitové číslo sloužící k rozlišení a identifikaci konkrétní služby nebo aplikace běžící na daném hostiteli, umožňující tak multiplexování služeb na jednom IP rozhraní.",incorrect:"V transportní vrstvě adresování se používá pouze IP adresa cílového počítače, přičemž číslo portu je irelevantní a nepoužívá se pro identifikaci služeb, protože každá služba nebo aplikace běžící na cílovém hostiteli je automaticky identifikována operačním systémem na základě IP adresy a protokolů aplikační vrstvy.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"8a06f080-ceac-4b14-a414-1e97eef24724",correct:"Protokol ICMP (Internet Control Message Protocol) je považován za servisní protokol, který se využívá pro diagnostiku sítí, hlášení chyb a správu sítě, přičemž jeho role byla významně rozšířena s příchodem protokolu IPv6, například o automatickou konfiguraci sítě prostřednictvím router advertisement a router solicitation paketů.",incorrect:"Protokol ICMP (Internet Control Message Protocol) je považován za aplikační protokol, který se využívá pro diagnostiku sítí, hlášení chyb a správu sítě, přičemž jeho role byla významně rozšířena s příchodem protokolu IPv6, například o automatickou konfiguraci sítě prostřednictvím router advertisement a router solicitation paketů.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"83c113b3-471f-4840-9ffe-62a08f4797c2",correct:"Mezi hlavní funkce protokolu ICMP patří zasílání řídicích zpráv, jako jsou zprávy o nedosažitelnosti cílového hostitele nebo sítě, překročení doby životnosti paketu (time to live exceeded) a nutnosti fragmentace, a také diagnostické funkce, které se využívají například v příkazu ‹ping› pro testování dostupnosti sítě.",incorrect:"Mezi hlavní funkce protokolu ICMP patří výhradně zasílání diagnostických zpráv, které se využívají například v příkazu ‹ping› pro testování dostupnosti sítě, přičemž řídicí zprávy jako zprávy o nedosažitelnosti cílového hostitele nebo sítě nejsou součástí funkcionality protokolu ICMP.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"b9c8f62c-fb0a-4520-9214-4e51d255a2f7",correct:"Příkaz ‹ping›, který je běžně používán pro diagnostiku síťového připojení, využívá protokol ICMP tím, že odesílá zprávy typu ‹echo request› a očekává odpovědi typu ‹echo reply›, což umožňuje ověřit, zda je cílový hostitel dosažitelný a reaguje na síťové požadavky.",incorrect:"Příkaz ‹ping›, který je běžně používán pro diagnostiku síťového připojení, využívá protokol TCP tím, že odesílá zprávy typu ‹SYN› a očekává odpovědi typu ‹SYN-ACK›, což umožňuje ověřit, zda je cílový hostitel dosažitelný a reaguje na síťové požadavky.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"2a0bc66d-1287-4530-8d8f-f5087a29bce8",correct:"Protokol TCP je streamově orientovaný protokol postavený nad protokolem IP. Aby bylo zajištěno spolehlivé doručení dat, TCP musí udržovat pořadí doručených bajtů a implementovat mechanismy pro opakované odesílání ztracených paketů v případě ztráty paketů během přenosu přes IP. Před zahájením přenosu dat musí koncové body TCP navázat spojení pomocí specifického handshaku.",incorrect:"Protokol TCP je paketově orientovaný protokol postavený nad protokolem IP. Aby bylo zajištěno nespolehlivé doručení dat, TCP nemusí udržovat pořadí doručených bajtů a neimplementuje mechanismy pro opakované odesílání ztracených paketů v případě ztráty paketů během přenosu přes IP. Před zahájením přenosu dat koncové body TCP nemusí navazovat spojení a mohou začít odesílat data okamžitě.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"f31cf8f9-5d6e-42ad-a3de-f7a5ac3b61bb",correct:"Protokol TCP, navržený pro poskytování streamové sémantiky nad paketově orientovanou sítí, toho dosahuje navázáním spojení mezi koncovými body. Toto spojení, které je obousměrné a slouží jako oddělený datový proud, je iniciováno pomocí třífázového handshaku zahrnujícího pakety SYN, SYN/ACK a ACK k synchronizaci a dohodnutí parametrů spojení před jakýmkoli přenosem dat.",incorrect:"Protokol TCP, navržený pro poskytování paketové sémantiky nad paketově orientovanou sítí, toho dosahuje bez navázání spojení mezi koncovými body. Toto spojení, které je jednosměrné a slouží jako jediný datový proud, je iniciováno pomocí dvoufázového handshaku zahrnujícího pakety SYN a ACK k synchronizaci a dohodnutí parametrů spojení před jakýmkoli přenosem dat.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"5a717612-7d7c-45ef-9ced-b8fedd871ce1",correct:"TCP protokol využívá sekvenční čísla, která jsou klíčovou součástí stavu spojení, aby umožnil správné sestavení datového proudu na straně příjemce, i když IP pakety, které tento proud přenášejí, dorazí v jiném pořadí, než byly odeslány. Tato sekvenční čísla zajišťují, že i při případném přeuspořádání paketů během doručení je možné obnovit původní pořadí dat.",incorrect:"TCP protokol využívá sekvenční čísla výhradně pro detekci ztracených paketů a následnou retransmisi, ale nemá žádný vliv na sestavení datového proudu v případě, že IP pakety dorazí v jiném pořadí. Sestavení datového proudu v správném pořadí je zajištěno jinými mechanismy na nižších vrstvách síťového modelu.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"0a523ebb-7c69-4e53-9f32-8690cd85d62e",correct:"V protokolu TCP, pokud odesílatel neobdrží potvrzení o doručení paketu (ACK) v dynamicky upraveném časovém limitu od odeslání původního paketu, je tento paket automaticky znovu odeslán. Tento mechanismus retransmise zajišťuje spolehlivost přenosu dat i v sítích, kde dochází ke ztrátě paketů v důsledku například zahlcení bufferů na směrovacích zařízeních.",incorrect:"V protokolu TCP, pokud odesílatel neobdrží potvrzení o doručení paketu (ACK) v pevném, předem definovaném časovém limitu od odeslání původního paketu, je paket považován za ztracený, ale automatická retransmise se neprovádí. Ztráta paketu v TCP spojení vyžaduje manuální zásah administrátora sítě pro obnovení přenosu dat.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"64ab4cd0-af64-40d8-aae8-0b681200141a",correct:"Ztráta paketu v síti, kde se používá protokol TCP, může být detekována příjemcem jako mezera v sekvenčních číslech přijatých paketů. Nicméně, je zodpovědností odesílatele, aby se o ztrátě paketu dozvěděl a mohl provést retransmisi, což se typicky děje na základě absence potvrzení o doručení (ACK) od příjemce v stanoveném časovém intervalu.",incorrect:"Ztráta paketu v síti s protokolem TCP je detekována výhradně příjemcem, který následně iniciuje retransmisi ztraceného paketu odesláním speciálního požadavku na odesílatele. Odesílatel sám nemá mechanismy pro detekci ztráty paketu a spoléhá se plně na zpětnou vazbu od příjemce pro zajištění spolehlivosti přenosu, avšak retransmisi provádí vždy příjemce.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"e73e42a8-5b84-4969-b2e5-331f9a1ab0ea",correct:"TCP protokol se vyznačuje značnou režií kvůli mechanismům zajišťujícím spolehlivé a seřazené doručení dat, což může být zbytečné a vést k latenci v aplikacích, které nevyžadují striktní garance spolehlivosti a pořadí doručení dat.",incorrect:"TCP protokol je navržen s minimální režií, srovnatelnou s UDP, a je proto ideální pro aplikace citlivé na latenci, přičemž jeho mechanismy pro spolehlivé a seřazené doručení dat jsou volitelné a lze je deaktivovat pro snížení zátěže sítě.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"d2c5cbc7-9bf4-47aa-a6c6-fdd4aa23d0da",correct:"UDP protokol představuje zjednodušenou a odlehčenou vrstvu nad IP protokolem s minimální režií, která spočívá v přidání portových čísel a 16bitového kontrolního součtu do hlavičky paketu, přičemž celková délka hlavičky UDP je pouhých 64 bitů.",incorrect:"UDP protokol je komplexní protokol s rozsáhlou hlavičkou o délce 128 bitů, který kromě portových čísel a kontrolního součtu zahrnuje i sofistikované mechanismy pro řízení toku a spolehlivé doručení dat, srovnatelné s protokolem TCP, avšak s menší režií.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"a18e6a16-be5b-4802-9a12-0be730ffeed8",correct:"Firewall je zařízení, které odděluje dvě sítě, přičemž typicky funguje jako jediný router mezi nimi, a jeho úkolem je zkoumat pakety a odmítat ty, které se zdají být škodlivé nebo se pokoušejí o využití služeb, které by neměly být zvenčí dostupné, přičemž jednou z těchto sítí je často veřejný internet.",incorrect:"Firewall je zařízení, které sice odděluje dvě sítě, ale primárně funguje jako pasivní monitorovací nástroj, který pouze zaznamenává podezřelé aktivity a neaktivně nezasahuje do síťového provozu, přičemž jeho hlavním účelem je generování reportů o potenciálních hrozbách pro administrátory sítě.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"1e291818-cbdd-444e-8a8d-c414de096980",correct:"Implementací firewallu může být packet filtering, který je možné realizovat buď na routeru, čímž se chrání celá síť centralizovaně, nebo na koncovém bodě, jako je například server či pracovní stanice, čímž se poskytuje dodatečná ochrana konkrétního zařízení, a dedikované routery s packet filtry obvykle zvyšují bezpečnost celé sítě.",incorrect:"Implementací firewallu je výhradně packet filtering, který je možné efektivně realizovat pouze na koncových bodech sítě, jako jsou servery a pracovní stanice, jelikož centralizovaná implementace packet filtering na routerech je z hlediska celkové bezpečnosti sítě považována za méně efektivní a obtížněji spravovatelnou.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"041743f4-f1fe-4fd0-8d75-4b1983ef3703",correct:"Packet filtry pracují na základě předem definovaných pravidel, která obvykle nastavuje administrátor sítě, a každý příchozí paket je následně klasifikován podle těchto pravidel, přičemž na základě klasifikace může být paket odeslán na další místo určení, tiše zahozen, odmítnut s odesláním ICMP zprávy o odmítnutí, nebo před odesláním dále upraven, například pomocí NAT.",incorrect:"Packet filtry fungují na principu automatického učení a adaptace na síťový provoz, bez nutnosti definování explicitních pravidel administrátorem, přičemž každý příchozí paket je analyzován a na základě heuristické analýzy je buď propuštěn, nebo automaticky zahozen bez možnosti další manipulace či notifikace o odmítnutí odesílateli.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"0849c2c0-88cd-4a31-b5c9-4241e62db155",correct:"Pro snazší zapamatování a orientaci v síťové komunikaci se místo numerických adres, které jsou pro člověka obtížně zapamatovatelné, používají hostitelská jména. Tato jména mohou být uložena v souboru, například ‹/etc/hosts›, což je však praktické pouze pro velmi malé sítě s maximálně několika počítači, jelikož internet se skládá z milionů zařízení.",incorrect:"Pro snazší zapamatování a orientaci v síťové komunikaci se místo hostitelských jmen, která jsou pro člověka obtížně zapamatovatelná, používají numerické adresy.  Tato jména se obvykle neukládají v souboru, například ‹/etc/hosts›, jelikož tento soubor je praktický pro rozsáhlé sítě s miliony počítačů, což je typické pro moderní internetovou infrastrukturu.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"9b52ac42-f2fd-40e1-9649-2fafca4f3ba0",correct:'Pro efektivní správu a vyhledávání hostitelských jmen v rozsáhlých sítích, jako je internet s miliony počítačů, je nezbytný systém, který umožňuje rychlé aktualizace a dotazy. Tento systém, často označovaný jako adresář nebo "žluté stránky" pro počítače, musí být škálovatelný, aby zvládl obrovské množství jmen a neustálé změny v síťové infrastruktuře.',incorrect:"Pro efektivní správu a vyhledávání hostitelských jmen v rozsáhlých sítích, jako je internet s miliony počítačů, je nezbytný systém, který vyžaduje manuální a pomalé aktualizace a dotazy. Tento systém, často označovaný jako statický seznam jmen, nemusí být škálovatelný a je vhodný pro správu malého množství jmen a stabilní síťové infrastruktury.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"4d658fd5-e733-4222-bbc0-978ffc0caad8",correct:"Systém DNS (Domain Name System) je založen na hierarchickém protokolu pro překlad jmen, který funguje nad protokoly TCP nebo UDP, přičemž doménová jména jsou rozdělena na části oddělené tečkami, což vytváří distribuovanou databázovou strukturu, která umožňuje efektivní správu a škálovatelnost na internetu.",incorrect:"Systém DNS (Domain Name System) je založen na plošném protokolu pro překlad jmen, který funguje výhradně nad protokolem TCP, přičemž doménová jména jsou rozdělena na části oddělené čárkami, což vytváří centralizovanou databázovou strukturu, která vyžaduje okamžitou aktualizaci dat pro zajištění konzistence.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"383fdf01-1602-41a1-9308-313330cd8ff2",correct:"Proces překladu doménového jména na IP adresu v DNS začíná dotazem na kořenové servery, které následně odkazují na servery pro doménu nejvyšší úrovně, a tento hierarchický proces se opakuje postupně směrem doleva, dokud se nedosáhne autoritativního serveru pro danou doménu, který poskytne hledanou IP adresu.",incorrect:"Proces překladu doménového jména na IP adresu v DNS začíná dotazem na lokální servery, které přímo obsahují kompletní databázi všech doménových jmen, a v případě, že záznam není nalezen, dotaz se šíří plošně mezi všechny DNS servery v síti, dokud se nenajde server s požadovaným záznamem.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"781221bf-ea31-4f41-89d7-9d3a8af746bb",correct:"Rekurzivní DNS servery hrají klíčovou roli v DNS tím, že provádějí rekurzivní dotazy jménem klientů, čímž klienti nemusí sami procházet celou hierarchii DNS serverů, a tyto servery také efektivně ukládají výsledky dotazů do cache, což výrazně zrychluje odezvu na opakované dotazy a snižuje zátěž autoritativních serverů.",incorrect:"Iterativní DNS servery hrají klíčovou roli v DNS tím, že provádějí iterativní dotazy jménem klientů, čímž klienti musí sami aktivně procházet celou hierarchii DNS serverů a skládat odpověď z dílčích informací, a tyto servery záměrně neukládají výsledky dotazů do cache, aby byla zajištěna maximální aktuálnost dat za cenu pomalejší odezvy.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"d5903991-ca43-4771-b503-a7af78f0ef9b",correct:"Původní koncept uživatele v operačních systémech vznikl z potřeby oddělit účty pro různé lidi, přičemž každý uživatel reprezentoval konkrétní osobu. V moderních systémech se však pojem uživatele rozšířil a stal se obecnější abstrakcí, která zahrnuje nejen lidské uživatele, ale i jiné entity vyžadující vlastnictví a řízení přístupu.",incorrect:"Původní koncept uživatele v operačních systémech byl vždy zamýšlen jako obecná abstrakce pokrývající různé entity, a nikdy nebyl primárně spojen s reprezentací jednotlivých lidských uživatelů. Moderní systémy pouze zdůraznily tuto původní myšlenku, aniž by došlo k významnému rozšíření konceptu uživatele nad rámec jeho původního záměru.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"ff01d752-3994-41bb-9548-1cffc6db0d58",correct:"V moderních operačních systémech je koncept uživatele klíčový pro správu vlastnictví a řízení přístupu k systémovým zdrojům. Uživatel slouží jako základní jednotka, na kterou se vztahují vlastnická práva a přístupová oprávnění, což umožňuje detailní kontrolu nad tím, kdo a jakým způsobem může s danými zdroji pracovat.",incorrect:"V moderních operačních systémech koncept uživatele nemá žádný vztah ke správě vlastnictví a řízení přístupu k systémovým zdrojům. Vlastnictví a přístupová oprávnění jsou řízeny výhradně na úrovni procesů a samotný koncept uživatele slouží pouze k identifikaci spuštěných aplikací, nikoliv k definování práv spojených s daty a zdroji.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"9f23834e-7839-4e53-917c-e188c2cec240",correct:"Z pohledu operačních systémů je počítač často vnímán jako nákladný zdroj, a proto je efektivita jeho využití klíčovým aspektem. Vzhledem k tomu, že jeden uživatel zřídkakdy plně využije výpočetní kapacitu moderního počítače, stává se sdílení zdrojů mezi více uživateli zásadním. Toto sdílení dat a zdrojů v prostředí s více uživateli pak přirozeně vyžaduje implementaci mechanismů pro řízení přístupu, aby se zajistila ochrana dat a soukromí jednotlivých uživatelů před neoprávněným přístupem.",incorrect:"Z pohledu operačních systémů je počítač vnímán jako levný a snadno dostupný zdroj, a proto efektivita jeho využití není klíčovým aspektem.  Vzhledem k tomu, že jeden uživatel typicky plně využije výpočetní kapacitu moderního počítače, sdílení zdrojů mezi více uživateli se stává zbytečným. Proto sdílení dat a zdrojů v prostředí s více uživateli nevyžaduje implementaci mechanismů pro řízení přístupu, jelikož se předpokládá plná důvěra mezi všemi uživateli systému.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"151461b0-9d02-44da-9e10-c8c16b1d10fa",correct:"Zatímco efektivní využití počítačových zdrojů bylo významným hnacím motorem pro zavedení multi-tenancy v počítačových systémech, klíčovým faktorem, který nakonec vyvolal potřebu robustního řízení přístupu, byl nástup globálních sdílených souborových systémů. Uživatelé totiž nemají nutně důvod důvěřovat všem ostatním uživatelům systému, pokud jde o přístup k jejich souborům a datům uloženým v těchto sdílených systémech.",incorrect:"Zatímco efektivní využití počítačových zdrojů bylo okrajovým hnacím motorem pro zavedení multi-tenancy v počítačových systémech, klíčovým faktorem, který nakonec vyvolal potřebu robustního řízení přístupu, nebyl nástup globálních sdílených souborových systémů, ale spíše snaha o centralizovanou správu uživatelských účtů. Uživatelé totiž plně důvěřují všem ostatním uživatelům systému, pokud jde o přístup k jejich souborům a datům uloženým v těchto sdílených systémech.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"2e603721-1fbf-4b3f-a010-d91aed12a133",correct:"Standardní model řízení přístupu v operačních systémech se točí kolem konceptu vlastnictví objektů, přičemž mezi objekty, které mohou být vlastněny, patří primárně soubory a procesy, a vlastník objektu má práva s objektem manipulovat a zároveň nese určité povinnosti spojené s kvótami.",incorrect:"Standardní model řízení přístupu v operačních systémech se točí kolem konceptu vlastnictví objektů, přičemž mezi objekty, které mohou být vlastněny, patří primárně pouze procesy, a vlastník objektu má práva s objektem manipulovat, ale nenese žádné povinnosti spojené s kvótami.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"f5267187-452f-4511-8b99-5d4d6f135c18",correct:"Procesy v operačním systému jsou úzce spjaty s uživateli, protože každý proces patří určitému uživateli a jedná jeho jménem, přičemž proces má stejná oprávnění jako jeho vlastník, což pro proces představuje jak omezení, tak i možnosti v závislosti na kontextu.",incorrect:"Procesy v operačním systému jsou úzce spjaty s uživateli, protože každý proces patří určitému uživateli a jedná jeho jménem, přičemž proces má vždy vyšší oprávnění než jeho vlastník, což pro proces představuje pouze další možnosti a žádná omezení.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"07fab90c-91c7-4a40-b849-ed6ff60ecec7",correct:"Stejně jako procesy, i soubory v operačním systému jsou objekty, které podléhají vlastnictví, avšak na rozdíl od procesů jsou soubory pasivní, a proto vlastnictví souboru dává vlastníkovi specifická práva, zejména právo číst soubor, zapisovat do něj a měnit přístupová práva nebo vlastnictví souboru.",incorrect:"Stejně jako procesy, i soubory v operačním systému jsou objekty, které podléhají vlastnictví, a stejně jako procesy jsou soubory aktivní, a proto vlastnictví souboru dává vlastníkovi práva spouštět kód v kontextu souboru a měnit vlastnictví procesu, který soubor vytvořil.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"5be11710-a14e-4f66-9a6d-0b0dd436cfa0",correct:"V modelu diskreční kontroly přístupu, který je běžně používán v mnoha operačních systémech, mají vlastníci objektů, jako jsou soubory, pravomoc rozhodovat o tom, kdo a jakým způsobem může s těmito objekty interagovat, což jim dává značnou flexibilitu v řízení přístupu k jejich datům.",incorrect:"V modelu diskreční kontroly přístupu, který je běžně používán v mnoha operačních systémech, má centrální autorita pravomoc rozhodovat o tom, kdo a jakým způsobem může s objekty interagovat, což jim dává značnou flexibilitu v řízení přístupu k datům.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"c5df5735-237b-494b-b03a-29c6573d4f7a",correct:"V modelu povinné kontroly přístupu, který se často uplatňuje v prostředích s vysokými nároky na bezpečnost, je rozhodování o přístupových právech svěřeno centrální autoritě, nikoli jednotlivým uživatelům, což zajišťuje jednotnou a vynucenou bezpečnostní politiku v celém systému.",incorrect:"V modelu diskreční kontroly přístupu, který se často uplatňuje v prostředích s vysokými nároky na bezpečnost, je rozhodování o přístupových právech svěřeno vlastníkům objektů, nikoli centrální autoritě, což vede k bezpečnostní politice, která je spíše sbírkou pravidel definovaných různými uživateli než jednotným dokumentem.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"057499f4-6d7d-496e-85c5-253b2deedabe",correct:"Zatímco v obou modelech, diskrečním i povinném, operační systém rozhoduje o udělení nebo zamítnutí přístupu na základě politiky řízení přístupu, pouze v případě povinné kontroly přístupu lze tuto politiku považovat za koherentní a ucelený dokument, na rozdíl od diskreční kontroly, kde je politika spíše souhrnem pravidel stanovených jednotlivými vlastníky.",incorrect:"Zatímco v obou modelech, diskrečním i povinném, operační systém rozhoduje o udělení nebo zamítnutí přístupu na základě politiky řízení přístupu, pouze v případě diskreční kontroly přístupu lze tuto politiku považovat za koherentní a ucelený dokument, na rozdíl od povinné kontroly, kde je politika spíše souhrnem pravidel stanovených jednotlivými vlastníky.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"cdd8e7e3-4507-4593-b07b-4567137c5482",correct:"V moderních operačních systémech se uživatelská abstrakce ukázala jako velmi užitečná koncepce, umožňující systémovým službám a aplikacím běžet pod specifickými, dedikovanými uživatelskými účty. Tato praxe dovoluje službám vlastnit soubory a procesy pod vlastní identitou a zároveň umožňuje omezit jejich přístup k dalším systémovým zdrojům a funkcím pomocí stejných mechanismů, které se aplikují na standardní uživatele, čímž se zvyšuje bezpečnost a stabilita celého systému.",incorrect:"V moderních operačních systémech se uživatelská abstrakce považuje za zastaralou a nepraktickou, protože komplikuje správu systému a zbytečně omezuje výkon systémových služeb a aplikací. Systémové služby by měly běžet s maximálními právy pro optimální funkčnost a efektivitu, a omezování jejich přístupu k systémovým zdrojům a funkcím je kontraproduktivní a snižuje celkovou výkonnost a flexibilitu operačního systému, přičemž bezpečnost by měla být řešena výhradně na úrovni jádra.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"0412d65d-d21a-4ff9-b064-3927dbc2bdcd",correct:"Běžnou praxí v operačních systémech je, že systémové služby, ať už se jedná o služby na úrovni systému nebo aplikací, jsou spouštěny pod speciálně vytvořenými uživatelskými účty. Toto řešení umožňuje, aby tyto služby vlastnily soubory a další systémové zdroje, a spouštěly procesy pod svou vlastní identitou. Dále to znamená, že tyto služby mohou být omezeny v přístupu k dalším částem operačního systému pomocí stejných mechanismů, které se používají pro standardní uživatelské účty, čímž se zvyšuje modularita a bezpečnost systému.",incorrect:"V operačních systémech se systémové služby spouštějí výhradně pod privilegovaným uživatelským účtem root, aby se zajistila maximální možná kontrola a přístup ke všem systémovým zdrojům. Používání speciálních uživatelských účtů pro služby je považováno za zbytečné komplikování správy systému a za potenciální bezpečnostní riziko, protože by mohlo vést k nekonzistencím v oprávněních a přístupových právech, a proto se preferuje jednotný přístup s využitím účtu root pro všechny systémové procesy.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"b5860cf6-75bf-4e57-b445-5e670d58d0a2",correct:"Princip nejmenšího privilegia, aplikovatelný jak na softwarové komponenty, tak na lidské uživatele, je klíčovou zásadou návrhu bezpečných systémů, která zdůrazňuje, že by subjektům měla být udělena pouze ta oprávnění, která jsou nezbytně nutná pro vykonávání jejich specifických úkolů, a to bez ohledu na kombinaci subjektu a objektu, čímž se minimalizuje potenciální rozsah škod způsobených chybami nebo bezpečnostními incidenty.",incorrect:"Princip nejmenšího privilegia se týká výhradně softwarových komponent a nebere v úvahu lidské uživatele systému, přičemž se zaměřuje na udělování co nejširších oprávnění všem subjektům, aby se maximalizovala flexibilita a efektivita systému, i když to může vést k potenciálně většímu rozsahu škod v případě chyb nebo bezpečnostních kompromitací, protože přístup k objektům by měl být co nejméně omezen.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"fa90dfa4-bf4f-4457-92e7-a7798d1b88d7",correct:"Základním zdůvodněním principu nejmenšího privilegia je proaktivní omezení dopadu chyb, ať už se jedná o neúmyslné chyby uživatelů nebo o úspěšné průniky do systému, a to tím, že se zajistí, aby i v případě selhání nebo útoku byl rozsah škod omezen pouze na ty objekty a zdroje, ke kterým měl daný subjekt skutečně legitimní a nezbytný přístup, čímž se minimalizují celkové škody.",incorrect:"Základním cílem principu nejmenšího privilegia je zvýšení uživatelského komfortu a zjednodušení správy systému tím, že se uživatelům a softwarovým komponentám automaticky udělují široká oprávnění ke všem objektům, což eliminuje potřebu složitého řízení přístupových práv a umožňuje rychlejší a efektivnější práci, ačkoli se tím potenciálně zvyšuje riziko rozsáhlejších škod v případě bezpečnostních incidentů.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"8bdf9196-629b-4733-8c4c-2f88e9f8b92e",correct:"Princip principu nejmenšího privilegia v operačních systémech vede k návrhovému vzoru známému jako oddělení privilegií. Tento přístup spočívá v rozdělení systému na několik nezávislých komponent, z nichž každá plní specifickou a z hlediska bezpečnosti autonomní funkci. Tyto moduly jsou izolovány v sandboxech a komunikují skrze úzce definovaná rozhraní, často založená na interprocesní komunikaci.",incorrect:"Princip principu nejmenšího privilegia v operačních systémech vede k návrhovému vzoru známému jako oddělení privilegií. Tento přístup spočívá v integraci systému do monolitického celku, kde všechny komponenty sdílejí stejná privilegia a úzce spolupracují.  Komponenty nejsou izolovány a komunikují skrze široce otevřená rozhraní, což maximalizuje výkon systému na úkor bezpečnosti a modularity.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"43507596-318f-4e6d-991d-423561e6cdf2",correct:"Oddělení privilegií, jakožto návrhový vzor vycházející z principu nejmenšího privilegia, se zaměřuje na rozdělení operačního systému do samostatných modulů. Každý modul má jasně definovanou funkci a je navržen tak, aby byl bezpečnostně soběstačný. To umožňuje minimalizovat potenciální škody v případě kompromitace jednoho modulu, protože ostatní moduly zůstávají izolované a chráněné.",incorrect:"Oddělení privilegií, jakožto návrhový vzor vycházející z principu nejmenšího privilegia, se zaměřuje na centralizaci operačního systému do jediného modulu. Tento modul má komplexní funkci a je navržen tak, aby maximalizoval výkon.  To umožňuje maximalizovat efektivitu systému, avšak v případě kompromitace tohoto centrálního modulu jsou ohroženy všechny části systému, protože neexistuje izolace.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"977ea031-df3a-49a2-8ed4-bb2f07118a02",correct:"V systémech s oddělením privilegií, komponenty operačního systému komunikují pomocí interprocesní komunikace (IPC) skrze úzce definovaná rozhraní. Tato rozhraní jsou navržena tak, aby umožňovala pouze nezbytnou výměnu dat a řízení mezi moduly, čímž se minimalizuje možnost zneužití komunikace pro neautorizovaný přístup nebo šíření chyb a zranitelností mezi komponentami.",incorrect:"V systémech s oddělením privilegií, komponenty operačního systému komunikují přímo sdílenou pamětí bez definovaných rozhraní. Tato přímá komunikace je optimalizována pro maximální výkon a minimalizaci latence, avšak umožňuje libovolnou výměnu dat a řízení mezi moduly, čímž se maximalizuje možnost zneužití komunikace pro neautorizovaný přístup nebo šíření chyb a zranitelností mezi komponentami.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"e516d67c-477a-4777-876c-62ee08bdf192",correct:"Procesy v operačním systému pracují v oddělených adresních prostorech, což znamená, že každý proces má přidělen vlastní izolovaný paměťový prostor. Sdílení paměti mezi procesy je možné pouze na základě explicitní žádosti a souhlasu obou zúčastněných procesů, typicky prostřednictvím mechanismů jako je sdílená paměť, které operační systém poskytuje a kontroluje.",incorrect:"Procesy v operačním systému standardně sdílejí jeden globální adresní prostor, což umožňuje implicitní a neomezený přístup k paměti všech procesů. Sdílení paměti je implicitní a nevyžaduje žádnou speciální konfiguraci nebo souhlas, což usnadňuje komunikaci mezi procesy, ale zároveň eliminuje potřebu mechanismů pro řízení přístupu k paměti.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"fbd5a99d-74c0-4342-80e5-5d00a826b7f6",correct:"Souborový systém v operačním systému je navržen jako globální a sdílený jmenný prostor, což znamená, že všechny soubory a adresáře jsou uspořádány do jednotné hierarchické struktury, která je viditelná a přístupná všem uživatelům a procesům v systému. Tato sdílená povaha umožňuje snadné sdílení dat a zdrojů, ale vyžaduje efektivní mechanismy pro řízení přístupových práv.",incorrect:"Souborový systém v operačním systému je implementován jako sada izolovaných jmenných prostorů pro každého uživatele, kde každý uživatel má vlastní privátní hierarchii souborů a adresářů, která není implicitně sdílena s ostatními uživateli. Sdílení souborů mezi uživateli vyžaduje explicitní a složitou konfiguraci a je omezeno na specifické případy, aby se maximalizovala bezpečnost a izolace dat.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"e8c9a74e-5050-4683-ac22-f8f6fe6655b1",correct:"Cesty k souborům v operačním systému nejsou samy o sobě považovány za bezpečnostní tokeny a jejich znalost automaticky nezaručuje přístup k danému souboru. I když uživatel zná cestu k souboru, operační systém stále provádí kontrolu přístupových práv, aby ověřil, zda má uživatel oprávnění k provedení požadované operace s daným souborem, což zajišťuje bezpečnost a kontrolu přístupu.",incorrect:"Cesty k souborům v operačním systému fungují jako primární a jediné bezpečnostní tokeny, a pokud uživatel zná cestu k souboru, má automaticky neomezený přístup k tomuto souboru. Operační systém nepoužívá další mechanismy pro kontrolu přístupových práv, a znalost cesty je dostačující pro provedení jakékoli operace se souborem, což zjednodušuje správu přístupu, ale snižuje celkovou bezpečnost systému.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"7ff0b21d-fe18-48a8-9066-d4a4fa21b5b5",correct:"Politika řízení přístupu v operačních systémech je založena na trojici subjekt, akce a objekt, kde subjekt představuje entitu žádající o přístup, akce je operace, která má být provedena, a objekt je zdroj, ke kterému se přistupuje. Tato politika určuje, zda je konkrétnímu subjektu povoleno provést danou akci s daným objektem, a může být zakódována různými způsoby, čímž tvoří soubor pravidel pro rozhodování o přístupu v systému.",incorrect:"Politika řízení přístupu v operačních systémech je založena na trojici subjekt, akce a objekt, kde subjekt představuje zdroj, ke kterému se přistupuje, akce je operace, která má být provedena, a objekt je entita žádající o přístup. Tato politika určuje, zda je konkrétnímu subjektu povoleno provést danou akci s daným objektem, a může být zakódována různými způsoby, čímž tvoří soubor pravidel pro rozhodování o přístupu v systému.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"cd9dbd08-990a-4f47-8258-a7de560602bc",correct:"V typických operačních systémech jsou subjekty v politikách řízení přístupu primárně uživatelé, kteří mohou být buď reální osoby, nebo virtuální entity reprezentující služby. Dále mohou subjekty zahrnovat i dílčí uživatelské jednotky, jako jsou jednotlivé programy, a širší kategorie, jako jsou role a skupiny, které všechny vyžadují mechanismus pojmenování nebo identifikace, zejména v síťových prostředích, aby mohly být efektivně odkazovány v pravidlech řízení přístupu.",incorrect:"V typických operačních systémech jsou objekty v politikách řízení přístupu primárně uživatelé, kteří mohou být buď reální osoby, nebo virtuální entity reprezentující služby. Dále mohou objekty zahrnovat i dílčí uživatelské jednotky, jako jsou jednotlivé programy, a širší kategorie, jako jsou role a skupiny, které všechny vyžadují mechanismus pojmenování nebo identifikace, zejména v síťových prostředích, aby mohly být efektivně odkazovány v pravidlech řízení přístupu.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"ba4f00a6-b513-40f8-a32c-2c9714296e8c",correct:"Přípustné akce v politice řízení přístupu jsou vnitřně spjaty s typem objektu, ke kterému se přistupuje. Například, zatímco objekt typu soubor typicky nabízí akce jako čtení, zápis a spuštění, objekt typu adresář poskytuje odlišnou sadu akcí, jako je prohledávání, výpis a změna. Tato sada akcí specifická pro objekt zajišťuje, že dostupné operace jsou relevantní a smysluplné pro každý typ zdroje spravovaný operačním systémem.",incorrect:"Přípustné akce v politice řízení přístupu jsou nezávislé na typu objektu, ke kterému se přistupuje. Například, zatímco objekt typu soubor typicky nabízí akce jako čtení, zápis a spuštění, objekt typu adresář nabízí stejnou sadu akcí, jako je čtení, zápis a spuštění. Tato sada akcí agnostická k objektu zajišťuje, že dostupné operace jsou univerzálně aplikovatelné pro každý typ zdroje spravovaný operačním systémem.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"a7111f20-980b-4c95-9a7a-3dd319291438",correct:"Vynucování politik řízení přístupu se nemusí nutně odehrávat přesně v okamžiku vyvolání akce, jako je například volání 'read' na soubor. Namísto toho se kontroly, například ověření oprávnění 'read', často provádějí dříve, například v okamžiku operace 'open'. Tento přístup, který vyžaduje, aby programy deklarovaly své záměry při 'open', zajišťuje, že následné akce jsou prováděny v mezích stanovené politiky řízení přístupu.",incorrect:"Vynucování politik řízení přístupu se vždy odehrává přesně v okamžiku vyvolání akce, jako je například volání 'read' na soubor. Kontroly, například ověření oprávnění 'read', se provádějí v okamžiku operace 'read'. Tento přístup, který vyžaduje, aby programy deklarovaly své záměry při 'read', zajišťuje, že akce jsou okamžitě validovány proti stanovené politice řízení přístupu.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"47353ef5-14a0-4e24-8555-93514d3fe108",correct:"Schopnost operačního systému vynucovat bezpečnost je zásadně založena na hardwarových funkcích, jako je MMU a kontrola obsluhy přerušení, protože samotný software nemůže dostatečně omezit jiný software běžící na stejném počítači.",incorrect:"Schopnost operačního systému vynucovat bezpečnost je primárně založena na softwarových mechanismech a algoritmech implementovaných v jádře, bez významného spoléhání se na základní hardwarové funkce pro robustní vynucování bezpečnosti.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"28412c56-d67b-435b-a71c-c80c34e72b39",correct:"Běh jádra v privilegovaném režimu CPU je klíčový pro bezpečnost OS, protože mu umožňuje spravovat hardwarové zdroje, vynucovat zásady řízení přístupu pomocí MMU a zprostředkovávat interakce procesů prostřednictvím systémových volání, aby byla zajištěna integrita systému a izolace procesů.",incorrect:"Běh jádra v uživatelském režimu CPU je dostatečný pro bezpečnost OS, protože moderní operační systémy se primárně spoléhají na softwarové bezpečnostní mechanismy a nevyžadují privilegovaný hardwarový přístup k efektivnímu vynucování bezpečnostních zásad.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"5f45eec6-c460-422d-944d-17c73ba2d111",correct:"Přímý přístup do paměti (DMA) a vstupně/výstupní (IO) operace jsou omezeny a spravovány jádrem operačního systému, aby byla zachována bezpečnost systému a zabráněno neoprávněnému přístupu nebo narušení hardwarových zdrojů procesy na uživatelské úrovni.",incorrect:"Přímý přístup do paměti (DMA) a vstupně/výstupní (IO) operace jsou obvykle přímo přístupné procesům na uživatelské úrovni v moderních operačních systémech, což umožňuje efektivní interakci s hardwarem bez zásahu jádra z důvodů výkonu.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"a6ed0103-ef3d-4fd2-a101-f03f8db9b441",correct:"Jednotka správy paměti (MMU) hraje klíčovou roli při zajišťování izolace procesů vytvářením oddělených adresních prostorů pro každý proces, čímž zabraňuje vzájemnému rušení paměti a zajišťuje bezpečné a stabilní výpočetní prostředí.",incorrect:"Jednotka správy paměti (MMU) je primárně zodpovědná za optimalizaci paměti a správu virtuální paměti, ale nehraje významnou roli v izolaci procesů, která je dosahována hlavně softwarovými technikami správy procesů.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"720f252d-9636-4e93-b3c2-e2a1b83bc7b4",correct:"Uživatelské procesy, konkrétně systémové služby poskytující IPC API, mohou implementovat vlastní mechanismy řízení přístupu k datům, i když běží v uživatelském prostoru. Tato kontrola přístupu je založena na schopnosti těchto služeb ověřovat identitu klienta, například pomocí systémového volání `getpeereid()`, a následně aplikovat vlastní politiky pro povolení nebo zamítnutí operací s daty, která spravují. I když uživatelské procesy nemají přímý přístup k hardwarovým zdrojům, mohou efektivně řídit přístup k datům s využitím služeb jádra operačního systému.",incorrect:"Uživatelské procesy, konkrétně systémové služby poskytující IPC API, mohou implementovat vlastní mechanismy řízení přístupu k datům zcela nezávisle na jádru operačního systému. Tato kontrola přístupu je založena výhradně na schopnostech uživatelského prostoru, bez nutnosti interakce s jádrem pro ověření identity klienta nebo uplatnění politik řízení přístupu. Jádro operačního systému nehraje žádnou roli v prosazování přístupových práv definovaných uživatelskými procesy.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"8d4521cc-4cc1-4c67-87e6-623f80cdec34",correct:"Příklad relační databáze ilustruje, jak může uživatelský proces řídit přístup k datům. Databázový engine běží pod dedikovaným uživatelem a ukládá data do souborů s omezenými přístupovými právy nastavenými jádrem operačního systému. Klienti se k databázi připojují přes UNIX socket a databázový server, s využitím systémového volání `getpeereid()`, může ověřit identitu klienta a na základě vlastní politiky řízení přístupu selektivně povolit nebo zakázat operace s daty.",incorrect:"Příklad relační databáze ilustruje, jak může uživatelský proces řídit přístup k datům bez jakékoliv podpory ze strany jádra operačního systému. Databázový engine běží pod dedikovaným uživatelem, ale přístupová práva k souborům s daty jsou irelevantní, protože databáze si řídí přístup zcela sama. Klienti se k databázi připojují přes TCP socket a databázový server ignoruje identitu klienta, protože řízení přístupu je založeno pouze na interních mechanismech databáze.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"31ed5521-6d40-4c44-aadf-b80b77e2f884",correct:"V systémech POSIX jsou pro řízení přístupových práv definovány dva základní typy subjektů: uživatelé a skupiny, přičemž toto řízení přístupu se primárně týká souborového systému a objektů, jejichž oprávnění jsou vázána na i-nody.",incorrect:"V systémech POSIX, ačkoli se pro řízení přístupových práv rozlišují uživatelé a skupiny, toto rozlišení se nevztahuje na souborový systém, ale spíše na síťové služby a procesy, kde objekty vyžadují explicitní pojmenování pro správu oprávnění.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"92399d99-f8e9-4ce4-abbe-776e691bf211",correct:"Systémy POSIX umožňují, aby uživatelé byli členy více skupin současně, což rozšiřuje možnosti správy přístupových práv a umožňuje flexibilnější konfiguraci oprávnění na základě různých rolí a projektů, na kterých se uživatel podílí.",incorrect:"V systémech POSIX je uživatel omezen na členství pouze v jedné primární skupině, což zjednodušuje správu přístupových práv, ale zároveň omezuje flexibilitu v komplexnějších scénářích, kde by uživatel měl patřit do více rolí.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"ce2346aa-55bb-46b8-b840-2ed89409a0ec",correct:"V systémech POSIX je speciální uživatel root, známý také jako superuživatel, který představuje administrátora systému a má výsadní postavení, neboť nepodléhá standardním kontrolám oprávnění a může provádět akce, které jsou běžným uživatelům zapovězeny, jako například restartování systému.",incorrect:"V systémech POSIX, uživatel root, ačkoli má rozšířená oprávnění oproti běžným uživatelům a je určen pro administrativní úkoly, stále podléhá standardním mechanismům řízení přístupu a musí explicitně žádat o oprávnění pro provádění systémových operací.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"c888f790-6012-402b-bc80-5c9820c0b9db",correct:"V systémech správy uživatelů a skupin v operačních systémech se pro interní reprezentaci a identifikaci uživatelů a skupin používají číselné identifikátory, známé jako UID a GID, což přispívá k efektivitě operací a kompaktnímu uložení informací v i-nodech, a historicky hrálo významnou roli v optimalizaci výkonu systému.",incorrect:"V moderních operačních systémech se pro reprezentaci uživatelů a skupin výhradně používají textové řetězce, které umožňují flexibilnější a čitelnější správu identit, a číselné identifikátory UID a GID se již nepoužívají kvůli jejich neefektivnosti a složitosti při správě v rozsáhlých sítích.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"636a86e4-f51e-4b3f-9ff1-124e1bd66ea4",correct:"Číselné identifikátory uživatelů (UID) a skupin (GID) jsou obvykle platné a jedinečné v rámci jednoho počítače nebo maximálně v lokální síti, což znamená, že pro rozsáhlé sítě nebo distribuované systémy je nutné zajistit mechanismy pro synchronizaci a správu identit uživatelů napříč různými systémy.",incorrect:"Číselné identifikátory uživatelů (UID) a skupin (GID) jsou globálně platné a jedinečné napříč celým internetem, což umožňuje snadnou identifikaci a správu uživatelů v jakémkoli systému bez potřeby dalších mechanismů pro synchronizaci identit v distribuovaných prostředích.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"2e1bd1e2-a7e7-483e-b07f-ce97c861e56e",correct:"Uživatelská databáze v operačním systému plní dvě základní funkce: autorizaci uživatelů, která určuje, kteří uživatelé mají přístup do systému, a mapování mezi lidsky čitelnými uživatelskými jmény a interně používanými číselnými identifikátory, což umožňuje systému efektivně pracovat s uživatelskými identitami.",incorrect:"Uživatelská databáze v operačním systému slouží primárně k ukládání hesel uživatelů v šifrované podobě a nemá žádnou roli v mapování uživatelských jmen na číselné identifikátory, ani v autorizaci uživatelů, protože tyto funkce jsou řízeny výhradně jádrem operačního systému.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"e316f12a-0659-4263-9824-6044fd4f5d23",correct:"Implementace uživatelské databáze se může lišit v komplexnosti, od jednoduchých textových souborů, jako jsou `/etc/passwd` a `/etc/group`, které se hodí pro menší systémy, až po složité distribuované databáze, jako jsou LDAP a Active Directory, které jsou navrženy pro centralizovanou správu uživatelů v rozsáhlých sítích.",incorrect:"Uživatelská databáze v operačním systému musí být vždy implementována jako složitá distribuovaná databáze typu LDAP nebo Active Directory, a použití jednoduchých textových souborů, jako `/etc/passwd` a `/etc/group`, je v moderních operačních systémech zcela nepřípustné kvůli nedostatečné bezpečnosti a škálovatelnosti.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"5b1a93ea-a300-43e3-867b-9c8266ab07d2",correct:"V lokálních sítích je často žádoucí, aby všechny počítače sdílely stejný pohled na uživatele a používaly stejné mapování mezi uživatelskými jmény a ID, což se řeší centralizovanými řešeními pro správu uživatelských identit na úrovni sítě, jako jsou LDAP a Active Directory.",incorrect:"V lokálních sítích je nezbytné, aby každý počítač měl zcela nezávislou a oddělenou správu uživatelů a mapování mezi uživatelskými jmény a ID, protože centralizovaná správa identit, jako LDAP a Active Directory, je v lokálních sítích příliš složitá a neefektivní.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"931a6bd4-def5-43e5-bd05-e33d5dce00bc",correct:"Procesy v operačním systému jsou vždy spojeny s konkrétním uživatelem a při volání `fork()` potomek dědí vlastnictví procesu od rodiče, což znamená, že potomek bude patřit stejnému uživateli jako rodičovský proces, zatímco vlastnictví rodičovského procesu zůstává nezměněno.",incorrect:"Procesy v operačním systému jsou vždy spojeny s konkrétním uživatelem, ale při volání `fork()` potomek nedědí vlastnictví procesu od rodiče, což znamená, že potomek bude patřit jinému uživateli než rodičovský proces, zatímco vlastnictví rodičovského procesu zůstává nezměněno.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"291fac7c-4ef3-40c3-8a73-4967673ed9ce",correct:"Pouze procesy s oprávněním superuživatele mají možnost změnit vlastnictví procesu pomocí systémového volání `setuid()`, což umožňuje superuživatelským procesům modifikovat uživatelskou identitu, pod kterou proces běží, a tím i jeho přístupová práva a oprávnění v systému.",incorrect:"Jakýkoli proces v operačním systému, bez ohledu na jeho oprávnění, má možnost změnit vlastnictví procesu pomocí systémového volání `setuid()`, což umožňuje libovolným procesům modifikovat uživatelskou identitu, pod kterou proces běží, a tím i jeho přístupová práva a oprávnění v systému.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"49648ece-aad9-4e2f-85f6-bcdc98bf3c3b",correct:"Systémové volání `exec()` může v některých případech změnit vlastníka procesu prostřednictvím takzvaného `setuid` bitu, který není totožný se systémovým voláním `setuid()`, ale umožňuje, aby se proces po spuštění spustitelného souboru provedl s vlastnictvím určeným tímto bitem.",incorrect:"Systémové volání `exec()` nikdy nemůže změnit vlastníka procesu, a to ani prostřednictvím takzvaného `setuid` bitu, protože `exec()` slouží pouze k nahrazení aktuálního procesu novým programem, aniž by ovlivnilo vlastnictví nebo uživatelskou identitu procesu.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"e656a03f-f588-4cc2-842e-866016fc1e6c",correct:"Proces `init`, který je v operačních systémech typicky prvním spuštěným procesem po startu jádra, je standardně vlastněn superuživatelem, což mu umožňuje provádět kritické systémové operace a spravovat další procesy v systému.",incorrect:"Proces `init`, který je v operačních systémech typicky prvním spuštěným procesem po startu jádra, je standardně vlastněn běžným uživatelem, což omezuje jeho schopnost provádět kritické systémové operace a vyžaduje eskalaci práv pro správu dalších procesů v systému.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"ccdbebe5-9c3e-49ec-9f2e-9672646e3073",correct:"Tradiční implementace přihlašovacího procesu, spouštěného na konci procesu bootování, nejprve vyzve uživatele k zadání uživatelského jména a hesla, které následně ověří oproti databázi uživatelů. Pokud se přihlašovací údaje shodují, program `login` nastaví základní prostředí, změní vlastníka procesu na přihlášeného uživatele a spustí preferovaný shell uživatele.",incorrect:"Tradiční implementace přihlašovacího procesu, spouštěného na začátku procesu bootování, nejprve vyzve uživatele k zadání uživatelského jména a hesla, které následně ověří oproti databázi hesel uložené v paměti ROM. Pokud se přihlašovací údaje shodují, program `login` nastaví základní prostředí, ponechá vlastníka procesu nezměněného a spustí preferovaný shell systému.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"bb6ef497-f37e-4f6c-bb57-26332070e816",correct:"Proces `login`, který je spravován procesem superuživatele, slouží k autentizaci uživatelů a zahájení jejich relace. Po zadání uživatelského jména a hesla program `login` ověří tyto údaje a v případě úspěšné autentizace změní vlastníka procesu pomocí funkce `setuid()` a následně spustí uživatelský shell pomocí funkce `exec()`.",incorrect:"Proces `login`, který je spravován uživatelským procesem, slouží k autentizaci uživatelů a zahájení jejich relace. Po zadání uživatelského jména a hesla program `login` ověří tyto údaje a v případě úspěšné autentizace změní vlastníka procesu pomocí funkce `exec()` a následně spustí uživatelský shell pomocí funkce `setuid()`.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"f9d76b97-8736-4ecd-b39c-bfadc878bec8",correct:"V ideálním případě operační systém neukládá heslo uživatele přímo, ale uchovává informace, které umožňují ověřit, zda zadané heslo je správné, přičemž se často používají kryptografické hashovací funkce s přídavkem soli pro zvýšení bezpečnosti.",incorrect:"V ideálním případě operační systém ukládá heslo uživatele přímo v zašifrované podobě pomocí složitých šifrovacích algoritmů, což zajišťuje maximální možnou bezpečnost a zároveň umožňuje rychlé ověření hesla při přihlášení.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"abbe9320-8e9e-4ab0-9b4e-00a7654b36d0",correct:"Kromě hesel existují i jiné metody autentizace uživatelů v operačních systémech, mezi které patří například kryptografické tokeny a biometrické metody, které se stávají stále populárnějšími v moderních systémech.",incorrect:"Jedinou spolehlivou a široce používanou metodou autentizace uživatelů v moderních operačních systémech jsou výhradně hesla, jelikož alternativní metody jako kryptografické tokeny a biometrické metody jsou stále považovány za experimentální a nespolehlivé.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"af54ab57-97f4-45cc-a3db-93fae1ab457b",correct:"Pro zvýšení bezpečnosti uživatelského účtu by měl operační systém umožňovat uživateli změnu hesla, což minimalizuje riziko neoprávněného přístupu v případě kompromitace hesla.",incorrect:"Z důvodu zvýšení bezpečnosti operační systémy obvykle uživatelům neumožňují měnit hesla, protože časté změny hesel zvyšují riziko zapomenutí a kompromitace účtu.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"14bf2d7f-8c8a-4b6a-b29d-69ec79abd98b",correct:"Autentizace přes síť představuje větší bezpečnostní výzvu než lokální autentizace, protože síťová komunikace je náchylnější k odposlechu, což znamená, že hesla, i když jsou šifrovaná, mohou být zranitelná vůči útokům typu man-in-the-middle, pokud není ověřena identita vzdáleného počítače.",incorrect:"Autentizace přes síť je obecně považována za bezpečnější než lokální autentizace, protože moderní sítě automaticky šifrují veškerou komunikaci, čímž eliminují riziko odposlechu hesel a zajišťují, že hesla jsou vždy chráněna před neoprávněným přístupem, i když identita vzdáleného počítače není ověřena.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"9b206f42-98aa-46dd-af03-5e4b631aaf79",correct:"Pro bezpečnou autentizaci heslem přes síť je nezbytné použít šifrování k ochraně hesla během přenosu, avšak samotné šifrování nestačí, protože je také nutné ověřit identitu vzdáleného počítače, aby se zabránilo odeslání hesla útočníkovi, který se vydává za legitimní systém.",incorrect:"Pro bezpečnou autentizaci heslem přes síť stačí pouze šifrování hesla během přenosu, protože jakmile je heslo zašifrováno, je nemožné, aby útočník získal přístup k původnímu heslu, a ověření identity vzdáleného počítače je zbytečné pro zajištění bezpečnosti hesla.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"a32222b0-6572-46de-b19e-de23e7feb01b",correct:"Vzhledem k zvýšenému riziku útoků při autentizaci přes síť, kdy útočník nemusí být fyzicky přítomen, je klíčové používat silná hesla a zvážit implementaci dvoufaktorové autentizace jako dodatečné vrstvy zabezpečení pro ochranu proti neoprávněnému přístupu.",incorrect:"I když autentizace přes síť zvyšuje riziko útoků, použití dvoufaktorové autentizace zcela eliminuje potřebu silných hesel, protože i v případě kompromitace hesla útočník nemůže získat přístup k systému bez druhého faktoru, což činí silná hesla nadbytečná.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"2f9b10c9-6769-45bd-ba15-a2b27a68517f",correct:"Dvoufaktorová autentizace se stává populární pro vzdálenou autentizaci, jelikož v síťovém prostředí jsou útoky levnější a frekventovanější. Prvním faktorem bývá obvykle heslo, zatímco druhým faktorem se často volí kryptografický token, což je malé zařízení generující sekvenci unikátních kódů, z nichž jeden uživatel opisuje pro prokázání vlastnictví tokenu.",incorrect:"Dvoufaktorová autentizace se pro vzdálenou autentizaci nikdy nepoužívá, protože je považována za příliš komplikovanou a uživatelsky nepříjemnou. Vzdálená autentizace se spoléhá výhradně na jednofaktorové heslo, a kryptografické tokeny se pro vzdálenou autentizaci nepoužívají z důvodu vysokých nákladů na jejich implementaci a správu.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"98661d64-3323-4e7a-8a94-8364897d6a32",correct:"V kontextu lokální autentizace se dvoufaktorová autentizace také uplatňuje, přičemž biometrická autentizace se stává atraktivnější volbou oproti vzdálené autentizaci. Kromě biometrických metod se pro lokální dvoufaktorovou autentizaci běžně využívají i kryptografické tokeny a čipové karty, které s počítačem komunikují přímo, eliminujíc nutnost manuálního opisování kódu uživatelem.",incorrect:"Pro lokální autentizaci se dvoufaktorová autentizace nikdy nepoužívá, jelikož lokální přístup vyžaduje pouze jednofaktorové ověření heslem. Biometrická autentizace a kryptografické tokeny jsou pro lokální autentizaci zcela nepoužitelné a nepraktické, a v lokálním scénáři se vždy vyžaduje manuální opisování kódu i u čipových karet.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"59fdce82-c30d-4ff6-a45c-b43076790f0d",correct:"Pro zajištění bezpečné komunikace se vzdáleným počítačem je zásadní ověřit jeho identitu, přičemž se nejedná pouze o ochranu hesel, ale i o prevenci úniku citlivých dat v důsledku neúmyslného odeslání na neautorizovaný systém. Tento problém se stává kritickým zejména v prostředích s vysokými nároky na důvěrnost informací.",incorrect:"Pro zajištění bezpečné komunikace se vzdáleným počítačem je zásadní ověřit jeho identitu, primárně z důvodu ochrany hesel, zatímco prevence úniku citlivých dat odesláním na neautorizovaný systém je považována za méně kritický aspekt bezpečnosti, obzvláště v prostředích s nízkými nároky na důvěrnost informací.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"8211e4e5-7a77-4da4-968e-b63962c2cf64",correct:"Autentizace vzdáleného počítače se typicky opírá o asymetrickou kryptografii, kde každý počítač disponuje unikátním soukromým klíčem, který je držen v tajnosti, a veřejně dostupným veřejným klíčem, případně jen jeho kryptografickým otiskem, který je distribuován mezi potenciální klienty pro ověření identity.",incorrect:"Autentizace vzdáleného počítače se typicky opírá o symetrickou kryptografii, kde se pro ověření identity používá sdílené tajemství mezi klientem a serverem, a asymetrická kryptografie s veřejnými a soukromými klíči se v tomto kontextu identity počítačů obvykle neuplatňuje, preferuje se jednodušší správa klíčů.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"2c2f8d1a-17e4-440d-8c68-12e89865d463",correct:"Během navazování spojení s vzdáleným počítačem klient iniciuje autentizační proces generováním náhodné výzvy (challenge), kterou následně odešle serveru s požadavkem na její digitální podpis pomocí soukromého klíče serveru, což slouží jako kryptografický důkaz identity serveru a zamezuje impersonaci.",incorrect:"Během navazování spojení s vzdáleným počítačem klient iniciuje autentizační proces generováním náhodné výzvy (challenge), kterou následně odešle serveru s požadavkem na její digitální podpis pomocí veřejného klíče serveru, což slouží jako kryptografický důkaz identity serveru a je efektivní i proti útokům typu man-in-the-middle.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"}]},{uuid:"74333849-3545-459c-a723-7b6ffa1dead2",sectionNumber:"10",sectionTitle:"POSIX a jazyk C",statements:[{uuid:"d482e7aa-5ae4-4fe7-bc5a-0a70f4ec3196",correct:"Jazyk C je v kontextu vývoje operačních systémů považován za jazyk se zvláštním postavením, což ho odlišuje od mnoha jiných programovacích jazyků díky jeho specifickým vlastnostem a historickému významu v této oblasti.",incorrect:"Jazyk C je považován za jeden z mnoha rovnocenných jazyků ve vývoji operačních systémů, přičemž nemá žádné zvláštní postavení ani historický význam ve srovnání s moderními jazyky, jako jsou Java nebo Python, které jsou pro vývoj operačních systémů upřednostňovány.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"5a171ddf-d377-4593-9f18-1bfdff99f1be",correct:"Ačkoli existuje mnoho programovacích jazyků používaných v informatice, jazyk C si drží unikátní pozici ve vývoji operačních systémů, často je upřednostňován pro své nízkoúrovňové schopnosti a efektivitu.",incorrect:"Ačkoli existuje mnoho programovacích jazyků, jazyk C se zřídka používá při vývoji moderních operačních systémů, přičemž jazyky jako Java a Python jsou výrazně rozšířenější díky svým pokročilým funkcím.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"e371d7e7-05fa-4891-bc01-1f7dc49b4dd6",correct:"V kontextu operačních systémů a systémového programování je jazyk C často upřednostňován před vysokoúrovňovými jazyky, jako je Java nebo Python, protože C nabízí přímější kontrolu nad hardwarem a správou paměti, což je klíčové pro vývoj OS.",incorrect:"Pro vývoj operačních systémů jsou vysokoúrovňové jazyky jako Java nebo Python obecně upřednostňovány před jazykem C, protože nabízejí automatickou správu paměti a vyšší úroveň abstrakce, což zjednodušuje proces vývoje a zlepšuje bezpečnost kódu.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"6bf4cb95-6a27-453f-bd1b-be1bff53cda6",correct:"Poskytnutý text naznačuje, že v rámci kurzu operačních systémů bude primární zaměření na programovací jazyk C a skriptování v POSIX shellu, což implikuje jejich důležitost pro pochopení konceptů a funkcí operačních systémů.",incorrect:"Na základě poskytnutého textu pro kurz operačních systémů budou primárními jazyky vysokoúrovňové jazyky jako Java a Python, přičemž jazyku C a POSIX shell skriptování bude věnována jen minimální pozornost kvůli jejich klesajícímu významu v moderních operačních systémech.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"3bd626b0-4644-4d6e-8248-55c657f298af",correct:"Programovací jazyk C je často považován za „přenosný assembler“ díky své schopnosti poskytovat abstrakci od strojových instrukcí a zároveň si zachovat vysokou míru kontroly nad hardwarem, což umožňuje programátorům psát efektivní a relativně přenositelné systémové programy, které se snadno integrují s různými hardwarovými platformami.",incorrect:"Programovací jazyk C je považován za vysoce specializovaný jazyk pro vývoj aplikací s grafickým uživatelským rozhraním a nemá žádnou souvislost s assemblerem ani s programováním na úrovni hardwaru, protože jeho abstrakce je příliš vysoká a neumožňuje efektivní kontrolu nad systémovými zdroji a hardwarovými operacemi.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"0b4bfa15-0c8b-4cab-be5b-68b23964de25",correct:"Mezi hlavní výhody programovacího jazyka C oproti assembleru patří abstrakce od strojových instrukcí, která programátorům umožňuje soustředit se na logiku programu spíše než na detaily konkrétního procesoru, dále strukturované řízení toku programu a automatické lokální proměnné, což usnadňuje vývoj komplexních systémových programů, jako jsou operační systémy.",incorrect:"Mezi hlavní výhody programovacího jazyka C oproti assembleru patří pouze složitější syntaxe a absence přímého přístupu k paměti, což ve skutečnosti programátorům ztěžuje vývoj efektivních programů a omezuje jejich kontrolu nad hardwarem, a proto se C nikdy nepoužíval pro vývoj operačních systémů.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"71342012-a983-452b-b68c-44932717e17e",correct:"Popularita jazyka C v systémovém programování pramení z jeho schopnosti snadno propojovat se s kódem napsaným v jiných programovacích jazycích, neboť téměř jakýkoli jazyk dokáže volat C funkce a pracovat s C datovými strukturami, což z něj činí ideální volbu pro vytváření modulárních a interoperabilních systémů, kde různé komponenty mohou být implementovány v různých jazycích.",incorrect:"Popularita jazyka C v systémovém programování je dána výhradně jeho složitostí a obtížností, což zaručuje vysokou efektivitu a bezpečnost napsaného kódu, avšak jeho propojitelnost s jinými jazyky je velmi omezená a komplikovaná, což značně ztěžuje integraci různých softwarových komponent a modulů v rámci jednoho systému.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"c017e56a-d3f5-45f9-81f4-c1281cc93931",correct:"Většina operačních systémů, s několika málo výjimkami, poskytuje standardní knihovnu jazyka C a je schopna spouštět programy napsané v jazyce C, a poskytuje jim tak klíčové služby. To z jazyka C činí dominantní jazyk v oblasti vývoje operačních systémů.",incorrect:"Všechny operační systémy jsou kompletně napsány v jazyce C, včetně jádra a systémových knihoven, což znamená, že jiné programovací jazyky se pro vývoj moderních operačních systémů nepoužívají a jazyk C je naprosto nezbytný pro jakýkoliv operační systém.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"3da83e1a-5544-4717-9880-762744849705",correct:"Jazyk C se stal klíčovým jazykem pro operační systémy, protože naprostá většina kernelů a značná část operačních systémů je napsána v C. Dokonce i operační systémy, které nejsou primárně napsány v C, obvykle poskytují C API pro programátory, což usnadňuje vývoj aplikací.",incorrect:"Jazyk C je pouze jedním z mnoha jazyků používaných pro vývoj operačních systémů a jeho význam v moderním vývoji operačních systémů klesá. Většina nových operačních systémů se vyvíjí v jazycích jako Java, Python nebo Go a C ustupuje do pozadí, protože je považován za zastaralý.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"961598d7-818a-41e4-aeef-57c1a2ca2f90",correct:"Přestože existují výjimky, kde operační systémy nejsou primárně napsány v jazyce C, drtivá většina kernelů operačních systémů je napsána v C. Spolu s rozsáhlým využitím jazyka C pro systémové knihovny a API to činí z jazyka C dominantní volbu pro vývoj operačních systémů v současné době.",incorrect:"Jazyk C se sice dříve používal pro operační systémy, ale v současné době se již nepoužívá pro vývoj kernelů ani systémových knihoven. Moderní operační systémy se vyvíjejí výhradně v jazycích s vyšší úrovní abstrakce, jako je například Python nebo JavaScript, které jsou bezpečnější a efektivnější.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"4bc03d64-c522-4882-ad00-11ec9025122f",correct:"Céčkové knihovny se skládají z hlavičkových souborů, které definují rozhraní, a z kompilovaného kódu, který implementuje tato rozhraní. Kompilovaný kód může být uložen ve statických nebo sdílených knihovnách, přičemž hlavičkové soubory poskytují deklarace funkcí a datových struktur, ale ne jejich implementaci.",incorrect:"Céčkové knihovny se skládají pouze z hlavičkových souborů, které obsahují kompletní implementaci funkcí, bez potřeby samostatných souborů s kompilovaným kódem. Hlavičkové soubory tak slouží jako jediné místo pro deklaraci i definici funkcí a datových struktur v Céčkových knihovnách.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"1d42cb53-3b57-4d68-bf86-c8ebe2a7d564",correct:"Hlavičkové soubory v Céčkových knihovnách primárně slouží jako deklarace funkcí a datových struktur, definující API bez odhalení detailů implementace, které jsou obsaženy v kompilovaném kódu knihovny. Tyto deklarace specifikují 'co' funkce dělá, tedy její vstupní a výstupní parametry, ale ne 'jak' to dělá.",incorrect:"Hlavičkové soubory v Céčkových knihovnách obsahují jak deklarace, tak i kompletní implementace funkcí, poskytující veškeré potřebné informace pro použití knihovny bez nutnosti samostatného kompilovaného kódu knihovny. Hlavičkové soubory tak definují 'co' i 'jak' funkce dělá, včetně detailů implementace.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"afb7b9c1-c906-41f1-a425-fa5ebcad8ada",correct:"Statické knihovny v C, jako například ty s příponou '.a' nebo '.lib', a sdílené knihovny, jako ty s '.so' nebo '.dll', obě obsahují kompilovaný kód, ale sdílené knihovny jsou dynamicky linkovány až za běhu programu, na rozdíl od statických knihoven, které jsou linkovány již během kompilace, což má vliv na velikost výsledného spustitelného souboru a sdílení kódu mezi procesy.",incorrect:"Statické a sdílené knihovny v C, rozlišené příponami jako '.a', '.lib', '.so' a '.dll', fungují identicky; obě jsou dynamicky linkovány až za běhu programu, jediným rozdílem jsou jejich přípony souborů. Statické i sdílené knihovny se chovají stejně z hlediska linkování a dopadu na spustitelný soubor a sdílení kódu.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"239cad5a-016d-4b99-8b1a-35761d9ac153",correct:"Knihovna `libc` v systémech typu UNIX tradičně kombinuje funkce standardní knihovny jazyka C definované normou ISO C, jako například `printf`, `fopen` a `fread`, spolu s funkcemi standardu POSIX, které zahrnují obálky systémových volání, například `open`, `read` a `gethostbyname`, přičemž tyto obálky slouží jako rozhraní pro vyvolání odpovídajících systémových volání.",incorrect:"Knihovna `libc` v systémech typu UNIX je moderní knihovna, která odděluje funkce standardní knihovny jazyka C definované normou ISO C, jako například `printf`, `fopen` a `fread`, od funkcí standardu POSIX, které zahrnují obálky systémových volání, například `open`, `read` a `gethostbyname`, přičemž tyto obálky slouží jako rozhraní pro přímé provádění systémových volání bez nutnosti jejich vyvolání.",sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"468308b5-14a5-4ac7-a8f8-809f6411a405",correct:'Mezi klíčové komponenty knihovny `libc` v systémech UNIX patří takzvané "system call wrappers", což jsou speciální funkce v jazyce C, jejichž primárním účelem je zprostředkování a vyvolání odpovídajících systémových volání operačního systému, čímž poskytují programátorům rozhraní pro interakci s jádrem systému na nízké úrovni.',incorrect:'Mezi klíčové komponenty knihovny `libc` v systémech UNIX patří takzvané "system call wrappers", což jsou sofistikované funkce v jazyce C, jejichž primárním účelem je optimalizace a přímé provádění systémových volání operačního systému bez nutnosti jejich vyvolání, čímž poskytují programátorům rozhraní pro vysoce výkonnou interakci s jádrem systému.',sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"1f310fbb-28f7-4737-a091-78f03b717f09",correct:"Kromě centrální knihovny `libc` existuje v systémech UNIX mnoho dalších knihoven, z nichž například `libm` poskytuje implementace matematických funkcí s plovoucí desetinnou čárkou, jako jsou `sin`, `cos` a `exp`.",incorrect:"Knihovna `libc` je jedinou knihovnou, která je součástí systému UNIX, a zahrnuje všechny matematické funkce, včetně funkcí s plovoucí desetinnou čárkou, jako jsou `sin`, `cos` a `exp`, které se nacházejí v knihovně `libm`.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"ff557651-f458-449b-95d2-088936ee2b5e",correct:"Pro psaní multi-vláknových programů v systémech UNIX se používá knihovna `libpthread`, která zahrnuje funkce jako `pthread_create` pro spouštění nových vláken a synchronizační primitivy jako `pthread_mutex_lock` pro řízení souběžného přístupu ke sdíleným zdrojům.",incorrect:"Knihovna `libpthread` v systémech UNIX se používá pouze pro správu paměti a neobsahuje funkce pro vytváření a synchronizaci vláken, jako jsou `pthread_create` a `pthread_mutex_lock`, které jsou součástí knihovny `libc`.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"ea000652-f117-4983-ba41-604b53886b38",correct:"Standardní knihovna C++ je často součástí systémů UNIX, ačkoli není určena pro použití z jazyka C. Mezi běžné implementace patří `libstdc++` nebo `libc++`, které poskytují funkce a třídy pro programování v C++.",incorrect:"Standardní knihovna C++ je primárně určena pro použití z jazyka C v systémech UNIX a je obvykle implementována jako jediná knihovna `libstdC`, která je kompatibilní s oběma jazyky.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"5e70fa3b-3b52-4c1e-881b-d5288f9c9e29",correct:"Kryptografické primitivy v systémech UNIX jsou poskytovány knihovnou `libcrypto`, která zahrnuje symetrické šifry jako AES, asymetrickou kryptografii jako RSA a ECDH, certifikáty X.509, autentizační kódy a hašovací funkce jako SHA2 a HMAC.",incorrect:"Knihovna `libcrypto` v systémech UNIX se zaměřuje výhradně na správu digitálních certifikátů a neposkytuje implementace symetrických šifer, asymetrické kryptografie ani hašovacích funkcí, které jsou dostupné v knihovně `libssl`.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"c26cbdb1-21e4-4c80-837f-177ebb3751ff",correct:"Knihovna `libcurses` v systémech UNIX umožňuje programům pracovat s širokou škálou hardwarových a softwarových terminálů přenosným způsobem, což zjednodušuje vývoj textových uživatelských rozhraní, která fungují na různých typech terminálů.",incorrect:"Knihovna `libcurses` v systémech UNIX je zastaralá a již se nepoužívá pro práci s terminály. Moderní programy pro textová uživatelská rozhraní spoléhají výhradně na knihovnu `libterm` a přímý přístup k hardwaru terminálu.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"5def1a15-e69a-47aa-821d-735e51ca1914",correct:"Na většině UNIXových systémů se systémové knihovny nacházejí v adresářích `/usr/lib` a potenciálně `/lib`, zatímco knihovny specifické pro uživatele nebo aplikace jsou obvykle umístěny v adresáři `/usr/local/lib`, což umožňuje oddělení systémových a uživatelských knihoven.",incorrect:"Na většině UNIXových systémů se uživatelské knihovny nacházejí výhradně v adresáři `/usr/lib`, zatímco systémové knihovny jsou vždy umístěny v adresáři `/usr/local/lib`, což zajišťuje jasné oddělení uživatelských a systémových knihoven.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"9095b908-da94-4d01-9123-7a912ee6feef",correct:"V systémech založených na Linuxu se často stává, že se uživatelské knihovny mísí se systémovými knihovnami, a proto mohou být všechny uloženy v jediném adresáři, konkrétně v `/usr/lib`, což je odlišný přístup od některých jiných UNIXových systémů.",incorrect:"V systémech založených na Linuxu se striktně dodržuje oddělení uživatelských a systémových knihoven, přičemž uživatelské knihovny jsou vždy uloženy v `/usr/local/lib` a systémové knihovny výhradně v `/usr/lib`, což zajišťuje maximální přehlednost.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"71d3f4bf-5be3-4286-a4b1-8919e42b667b",correct:"V operačním systému Windows jsou jak systémové, tak aplikační knihovny typicky instalovány do společného umístění, konkrétně do adresáře `C:\\Windows\\System32`, a navíc mohou být sdílené knihovny instalovány společně s aplikací, což je běžná praxe pro Windows a macOS.",incorrect:"V operačním systému Windows jsou systémové knihovny instalovány výhradně do adresáře `C:\\Windows\\System32`, zatímco aplikační knihovny jsou vždy instalovány odděleně v adresáři `C:\\Program Files`, a sdílené knihovny se nikdy neinstalují společně s aplikací.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"ed1fc50a-c056-49a7-b700-bf1e13a8d64c",correct:"Statické knihovny, uložené v souborech jako 'libfile.a' nebo 'file.lib' ve Windows, se primárně používají během fáze linkování kompilace programů. Při linkování programu se statickou knihovnou se potřebný kód z knihovny zkopíruje přímo do spustitelného souboru, čímž vznikne statický spustitelný soubor. Tento proces usnadňuje operačnímu systému správu spustitelného souboru, ale může vést k většímu využití diskového prostoru kvůli duplikaci kódu v různých programech.",incorrect:"Statické knihovny, uložené v souborech jako 'libfile.a' nebo 'file.lib' ve Windows, se primárně používají během fáze běhu kompilovaných programů. Při spuštění programu se statickou knihovnou se potřebný kód z knihovny dynamicky načte do paměti, čímž vznikne dynamicky linkovaný spustitelný soubor. Tento proces ztěžuje operačnímu systému správu spustitelného souboru a snižuje využití diskového prostoru díky sdílení kódu mezi různými programy.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"770ef2e2-a277-4fee-bb22-5748fe9fbb47",correct:"Po linkování programu se statickou knihovnou již samotná knihovna není nutná pro běh programu, protože veškerý potřebný kód z knihovny byl začleněn přímo do spustitelného souboru. Tento přístup, i když zjednodušuje spouštění a správu programů pro operační systém, vede k duplikaci kódu, protože každý program obsahuje vlastní kopii kódu knihovny, což může být neefektivní z hlediska diskového prostoru a využití paměti, zejména u běžně používaných systémových knihoven.",incorrect:"Po linkování programu se statickou knihovnou zůstává původní soubor knihovny nezbytný pro běh programu, protože spustitelný soubor obsahuje pouze odkazy na kód knihovny, nikoli samotný kód. Tento přístup, i když komplikuje spouštění a správu programů pro operační systém, zabraňuje duplikaci kódu, protože programy sdílejí jedinou kopii kódu knihovny, což je efektivní z hlediska diskového prostoru a využití paměti, zejména u běžně používaných systémových knihoven.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"bac4aca8-0f38-4973-8a2f-5357c83b8397",correct:"Použití statických knihoven může vést k významné duplikaci kódu nejen v souborovém systému, kde každý spustitelný soubor obsahuje kopii potřebných funkcí knihovny, ale také v RAM, když je souběžně spuštěno více programů používajících stejnou statickou knihovnu. Ačkoli linkery mohou optimalizovat tento proces kopírováním pouze požadovaných částí knihovny, základní problém duplikace kódu a jeho dopad na spotřebu paměti zůstává významnou charakteristikou statického linkování.",incorrect:"Použití statických knihoven vede k minimální duplikaci kódu v souborovém systému, kde spustitelné soubory obsahují pouze odkazy na funkce knihovny, a k žádné duplikaci v RAM, protože programy dynamicky sdílejí kód knihovny, když jsou spuštěny souběžně. Linkery zcela eliminují duplikaci kódu tím, že zajistí, že se používá pouze jedna instance knihovny, a problém duplikace kódu a jeho dopad na spotřebu paměti není charakteristikou statického linkování.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"3d442f0e-ec55-489b-84fe-0d8747623ef7",correct:"Dynamické knihovny jsou nezbytné pro běh programů, protože na rozdíl od statických knihoven linker nevkládá strojový kód knihovny přímo do spustitelného souboru. Místo toho pouze zaznamená nutnost načíst knihovnu spolu s programem při jeho spuštění, což je klíčové pro správnou funkčnost programu za běhu.",incorrect:"Dynamické knihovny nejsou nezbytné pro běh programů; jsou pouze způsobem, jak snížit duplikaci kódu během kompilace. Linker vkládá veškerý potřebný kód z dynamických knihoven do spustitelného souboru, podobně jako statické knihovny, a soubor dynamické knihovny není nutný za běhu programu pro jeho funkčnost.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"a04ae430-6937-454f-9412-4f21fe8e56f6",correct:"Jednou z klíčových výhod dynamických knihoven je snížení duplikace kódu na disku i v paměti. Protože kód knihovny není kopírován do každého spustitelného souboru, více programů může sdílet stejnou instanci knihovny za běhu, což šetří místo na disku a paměť, zejména pokud mnoho programů využívá stejné funkce knihovny.",incorrect:"Dynamické knihovny, i když umožňují oddělené aktualizace, ve skutečnosti zvyšují duplikaci kódu na disku, protože každý program musí obsahovat kopii potřebného kódu knihovny ve svém spustitelném souboru. To se děje proto, aby byly programy soběstačné a nespoléhaly se na externí soubory knihoven za běhu, čímž se zvyšuje využití diskového prostoru.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"edd04057-5ab6-4b17-ace3-b3297cf4cd98",correct:"Dynamické knihovny nabízejí výhodu nezávislých aktualizací, což znamená, že knihovnu lze aktualizovat bez nutnosti rekompilace aplikací, které ji používají. To zjednodušuje údržbu, zejména pokud jsou v široce používané knihovně nalezeny bezpečnostní zranitelnosti, protože je potřeba vyměnit pouze knihovnu, nikoli každou aplikaci, která na ní závisí.",incorrect:"Dynamické knihovny neumožňují nezávislé aktualizace, což znamená, že pokud je knihovna aktualizována, každá aplikace, která ji používá, musí být rekompilována a znovu linkována s novou verzí knihovny. Důvodem je, že kód knihovny je staticky linkován do každého spustitelného souboru v době kompilace, což znemožňuje nezávislé aktualizace.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"57277219-1bd8-49d5-b908-800cec017e50",correct:"Významnou nevýhodou dynamických knihoven jsou potenciální problémy se závislostmi, někdy označované jako DLL peklo. Tyto problémy vznikají z obtíží při udržování binární kompatibility mezi verzemi knihoven, což vede k situacím, kdy programy sestavené proti starší verzi nemusí správně fungovat s novější, nekompatibilní verzí.",incorrect:"Významnou výhodou dynamických knihoven je úplná absence problémů se závislostmi, známých také jako DLL peklo. Díky přísným standardům a dokonalé binární kompatibilitě mezi verzemi knihoven je zaručeno, že programy sestavené proti jakékoli verzi dynamické knihovny budou bezchybně fungovat s jakoukoli následující verzí stejné knihovny.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"b138727e-dc28-4341-bf63-bb2afced12bc",correct:"Header files v systémech UNIX, jako například Linux, typicky obsahují prototypy funkcí v jazyce C a definice datových struktur, které jsou nezbytné pro kompilaci programů v jazycích C a C++. Tyto soubory s hlavičkami jsou vyžadovány pouze během procesu sestavování softwaru, ale nejsou potřeba pro samotné spouštění již zkompilovaných programů.",incorrect:"Header files v systémech UNIX, jako například Linux, obsahují spustitelný kód funkcí v jazyce C a implementace datových struktur, které jsou nezbytné jak pro kompilaci programů v jazycích C a C++, tak i pro běh již zkompilovaných programů. Tyto soubory s hlavičkami jsou vyžadovány jak během procesu sestavování softwaru, tak i pro samotné spouštění programů.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"d22fd506-8921-4637-9f46-8903759ef4fd",correct:"Na systémech UNIX se systémové hlavičkové soubory tradičně nacházejí v adresáři `/usr/include`, zatímco uživatelsky instalované hlavičkové soubory, které nejsou součástí systémových knihoven, se obvykle umisťují do adresáře `/usr/local/include`. Nicméně, v systémech založených na Linuxu se často stává, že systémové i uživatelské hlavičkové soubory jsou promíchány v jediném adresáři `/usr/include`.",incorrect:"Na systémech UNIX se systémové hlavičkové soubory výhradně nacházejí v adresáři `/usr/local/include`, zatímco uživatelsky instalované hlavičkové soubory se vždy umisťují do adresáři `/usr/include`. V systémech založených na Linuxu se nikdy nestává, že by systémové a uživatelské hlavičkové soubory byly promíchány v jediném adresáři, protože jsou striktně odděleny.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"da356b13-4ef4-4bc3-bf9a-dbae81a2d4fb",correct:"Hlavičkové soubory, jako například `unistd.h` a `sys/time.h`, obsahují nejen deklarace funkcí, jako je `execv`, `fork`, `pipe`, `read`, `gettimeofday` a `settimeofday`, ale také definice datových typů, například struktury `timeval`, která definuje rozložení dat v paměti, což je klíčové pro binární kompatibilitu aplikací (ABI). Struktura `timeval` tak specifikuje pořadí polí a jejich typy, včetně případného paddingu.",incorrect:"Hlavičkové soubory, jako například `unistd.h` a `sys/time.h`, obsahují pouze implementace funkcí, jako je `execv`, `fork`, `pipe`, `read`, `gettimeofday` a `settimeofday`, a neobsahují žádné definice datových typů. Binární kompatibilita aplikací (ABI) není ovlivněna obsahem hlavičkových souborů, ale je definována pouze implementací knihoven. Struktura `timeval` se používá pouze pro dokumentaci a nemá vliv na rozložení dat v paměti.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"c28f86c0-4644-4af9-90cb-0876a0e39015",correct:"V operačních systémech typu UNIX je dokumentace pro programátory, známá jako manuálové stránky, obvykle integrována přímo do instalace operačního systému a je přístupná pomocí příkazu `man`, zatímco v systému Windows je dokumentace poskytována jako samostatný zdroj, dříve distribuovaný tištěně nebo na optických médiích a dnes převážně online.",incorrect:"V operačních systémech typu UNIX je dokumentace pro programátory, známá jako manuálové stránky, obvykle poskytována jako samostatný zdroj, dříve distribuovaný tištěně nebo na optických médiích a dnes převážně online, zatímco v systému Windows je integrována přímo do instalace operačního systému a je přístupná pomocí příkazu `man`.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"49053597-c99c-43c8-85af-428370737c34",correct:"Příkaz `man` v systémech UNIX slouží k prohlížení manuálových stránek, které jsou rozděleny do sekcí podle typu dokumentace, přičemž sekce 2 se specificky zaměřuje na dokumentaci systémových volání, zatímco sekce 3 je určena pro dokumentaci knihovních funkcí, což umožňuje programátorům efektivně vyhledávat informace o různých aspektech programování v UNIXovém prostředí.",incorrect:"Příkaz `man` v systémech UNIX slouží k prohlížení manuálových stránek, které jsou rozděleny do sekcí podle typu dokumentace, přičemž sekce 3 se specificky zaměřuje na dokumentaci systémových volání, zatímco sekce 2 je určena pro dokumentaci knihovních funkcí, což umožňuje programátorům efektivně vyhledávat informace o různých aspektech programování v UNIXovém prostředí.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"1c510233-bd0f-4884-b185-f2e123832981",correct:"Kompilátory transformují programy čitelné pro člověka, které jsou obvykle uloženy jako prostý text v kódování UTF-8 nebo ASCII v souborech se zdrojovým kódem s příponou .c, do binárních programů obsahujících strojové instrukce, avšak výstup kompilátoru, takzvaný objektový soubor, ještě nemůže být přímo spuštěn, protože mu chybí adresy a musí být napřed linkován.",incorrect:"Kompilátory transformují programy čitelné pro člověka do spustitelných programů, přičemž výstup kompilátoru, objektový soubor, je již plně spustitelný binární soubor obsahující všechny potřebné adresy pro přímé spuštění, jelikož kompilace zahrnuje i adresaci a linkování zdrojového kódu.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"c6cf683b-5198-466e-9209-b799a8ecc51d",correct:"V systémech POSIX se často používají překladače jazyka C, které přijímají zdrojové soubory s příponou .c, což jsou textové soubory obsahující lidsky čitelný kód, a produkují objektové soubory, což jsou binární soubory obsahující strojový kód, které však nejsou přímo spustitelné, jelikož jim chybí adresy paměťových lokací a vyžadují další krok linkování.",incorrect:"V systémech POSIX se používají překladače jazyka C, které přijímají objektové soubory, což jsou binární soubory obsahující strojový kód, a produkují zdrojové soubory s příponou .c, což jsou textové soubory obsahující lidsky čitelný kód, které jsou již přímo spustitelné, jelikož obsahují všechny potřebné adresy paměťových lokací a nevyžadují další krok linkování.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"88b77022-df74-45a3-a79c-3b0462a4eb0e",correct:'Objektové soubory obsahují nativní "strojový" (spustitelný) kód a statická data, jako například řetězcové literály použité v programu, a jsou rozděleny do několika "sekcí", například .text, .rodata a .data, a obsahují metadata, jako je seznam "symbolů" a jejich adres.',incorrect:"Objektové soubory obsahují pouze metadata a zdrojový kód ve vysokém programovacím jazyce, nikoliv strojový kód, a nejsou rozděleny do sekcí, ale tvoří jeden souvislý blok dat. Metadata objektových souborů popisují pouze autora programu a datum vytvoření, nikoliv symboly a adresy.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"06f5bc67-312a-4a6a-bbef-30681852e7a5",correct:'Účelem objektových souborů je ukládat částečně hotový strojový kód spolu se statickými daty, jako jsou řetězcové literály nebo číselné konstanty, které se objevují v programu. Vše je uspořádáno do "sekcí" – obvykle jedna sekce pro strojový kód (nazývaný text a v objektovém souboru .text), další pro data jen pro čtení (např. řetězcové literály), nazývaná .rodata, a další pro proměnlivé, ale staticky inicializované proměnné – .data.',incorrect:"Účelem objektových souborů je ukládat kompletní spustitelný kód, který je ihned připraven ke spuštění operačním systémem, a dynamická data, která se mění během běhu programu. Sekce v objektových souborech slouží k oddělení různých verzí kódu pro různé operační systémy, a metadata obsahují pouze informace o kompilátoru použitém k vytvoření souboru.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"b976779b-97ba-480f-b661-be7e494d8bd2",correct:'Jedním příkladem metadat v objektových souborech je "tabulka symbolů", která udává adresy funkcí vysoké úrovně, jež byly zkompilovány do objektového souboru, relativně k souboru. To znamená, že kompilátor vezme definici funkce, kterou jsme napsali v C, a vygeneruje strojový kód pro tuto funkci. Sekce .text objektového souboru se bude skládat z řady takových funkcí, jedna za druhou: tabulka symbolů nám pak říká, kde každá funkce začíná.',incorrect:"Tabulka symbolů v objektových souborech neobsahuje adresy funkcí, ale pouze názvy proměnných globálního rozsahu, které jsou sdíleny mezi různými objektovými soubory. Adresy funkcí jsou určeny až linkerem v konečné fázi sestavování programu, a sekce .text obsahuje pouze instrukce pro linker, jak má funkce umístit do paměti, nikoliv samotný strojový kód funkcí.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"87b4f539-dadb-439b-a488-c955d4438a4d",correct:"Formát ELF (Executable and Linkable Format) je v současnosti nejrozšířenějším formátem spustitelných a linkovatelných souborů v systémech typu POSIX, kam spadají například systémy Linux a různé varianty UNIXu. Naopak formát PE (Portable Executable) je standardem pro operační systémy Microsoft Windows, zatímco Mach-O je typický pro systémy macOS a další operační systémy od společnosti Apple.",incorrect:"Formát ELF (Executable and Linkable Format) je v současnosti nejméně rozšířeným formátem spustitelných a linkovatelných souborů v systémech typu POSIX, ačkoli se občas používá v systémech Linux. Formát PE (Portable Executable) je naopak standardem pro operační systémy Apple macOS, zatímco Mach-O dominuje v operačních systémech Microsoft Windows.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"5aa9c701-7720-42b9-87cd-43cb1f600487",correct:"Formát a.out představuje jeden z nejstarších formátů objektových souborů, který byl historicky používán v raných verzích systému UNIX. Formát COFF (Common Object File Format) vznikl jako jeho nástupce a přinesl významné vylepšení, především zavedením sekcí, které umožňují lépe strukturovat objektové soubory než prostý formát a.out.",incorrect:"Formát a.out je moderní formát objektových souborů, který je v současnosti široce používán v systémech UNIX a Windows. Formát COFF (Common Object File Format) naopak představuje zastaralou verzi formátu a.out, která postrádá moderní funkce a možnosti strukturování dat a kódu v objektových souborech.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"13d6e9c5-9c7d-4a99-96dd-ee755a6df801",correct:"Statické knihovny v systémech UNIX, označované jako archivy a mající příponu `.a`, fungují jako sbírky objektových souborů, které se podobají komprimovaným archivům typu ZIP, avšak s klíčovým rozdílem v podobě přidané tabulky symbolů, která urychluje proces linkování tím, že linkeru umožňuje efektivně vyhledávat definice funkcí bez nutnosti sekvenčního prohledávání každého objektového souboru v archivu.",incorrect:"Statické knihovny v systémech UNIX, označované jako archivy a mající příponu `.a`, fungují jako sbírky objektových souborů, které se podobají komprimovaným archivům typu ZIP, avšak s klíčovým rozdílem v podobě přidané tabulky symbolů, která zpomaluje proces linkování tím, že linkeru musí sekvenčně prohledávat každý objektový soubor v archivu, aby vyhledal definice funkcí.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"dc093659-50dd-49a2-af64-2a0abe361e0e",correct:"Archivy, používané jako statické knihovny v systémech UNIX, obsahují kromě samotných objektových souborů i doplňkovou sekci metadat, konkrétně tabulku symbolů, která slouží jako index pro linker. Díky tomuto indexu linker efektivněji nachází definice funkcí potřebné pro linkování, protože se může nejprve podívat do tohoto indexu a zjistit, ve kterém objektovém souboru se daný symbol nachází, namísto zdlouhavého prohledávání všech objektových souborů v archivu.",incorrect:"Archivy, používané jako statické knihovny v systémech UNIX, obsahují kromě samotných objektových souborů i doplňkovou sekci metadat, konkrétně tabulku symbolů, která slouží jako jediný obsah archivu. Díky tomuto jedinému obsahu linker musí  prohledávat všechny objektové soubory v archivu, aby našel definice funkcí potřebné pro linkování, což zefektivňuje proces linkování oproti použití indexu.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"ba3a58b2-4a87-493d-8e65-d0407e80b69d",correct:"Zásadní odlišností archivů, používaných jako statické knihovny, od běžných datových archivů, jako jsou například formáty TAR nebo ZIP, spočívá v přítomnosti speciální sekce metadat, kterou je tabulka symbolů. Tato tabulka symbolů funguje jako index, umožňující linkeru rychle lokalizovat definice symbolů, což zefektivňuje proces sestavování programů, jelikož eliminuje nutnost zdlouhavého prohledávání každého objektového souboru v archivu zvlášť.",incorrect:"Zásadní odlišností archivů, používaných jako statické knihovny, od běžných datových archivů, jako jsou například formáty TAR nebo ZIP, spočívá v absenci speciální sekce metadat, kterou je tabulka symbolů. Tato tabulka symbolů chybí, což nutí linker sekvenčně prohledávat každý objektový soubor v archivu zvlášť, aby lokalizoval definice symbolů, a to zefektivňuje proces sestavování programů.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"5ca22457-f059-4392-a03c-1e1af3ec42f5",correct:"Linker je nástroj, jehož hlavním úkolem je spojovat dohromady různé objektové soubory a knihovny, aby vytvořil jediný spustitelný soubor nebo sdílenou knihovnu. Objektové soubory slouží jako vstupy pro linker a obsahují nekompletní kód, který může odkazovat na symboly definované v jiných souborech nebo knihovnách.",incorrect:"Linker je nástroj, jehož hlavním úkolem je rozdělovat spustitelné soubory na menší objektové soubory pro lepší organizaci kódu. Objektové soubory slouží jako výstupy linkeru a obsahují kompletní kód, který je připravený k přímému spuštění bez nutnosti dalších knihoven nebo externích definic symbolů.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"ae8f4ff6-1c08-4803-ac0e-a561de7f542d",correct:"Objektové soubory, které jsou předány linkeru přímo jako vstupy, se stanou nedílnou součástí výsledného spustitelného souboru. Naopak, objektové soubory umístěné v archivních knihovnách jsou linkerem zahrnuty do spustitelného souboru pouze v případě, že poskytují symboly, které jsou nezbytné pro dokončení sestavení programu a vyřešení všech odkazů.",incorrect:"Objektové soubory, ať už jsou předány linkeru přímo nebo jsou součástí archivních knihoven, jsou vždy bezpodmínečně zahrnuty do výsledného spustitelného souboru. Linker nerozlišuje mezi těmito dvěma typy vstupů a zahrnuje všechny objektové soubory bez ohledu na to, zda jsou jejich symboly skutečně potřeba pro sestavení programu.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"6bed4951-1fdd-4886-a7ca-38227f50c03b",correct:"Programátoři používají symbolická jména pro funkce a data, zatímco strojové instrukce vyžadují adresy. Linker je zodpovědný za přiřazení těchto adres symbolům, což umožňuje, aby spustitelný kód programu mohl být správně umístěn a spuštěn v paměti. Tato automatizace adresace symbolů je klíčová, protože manuální správa adres by byla pro programátory velmi obtížná a náchylná k chybám, zvláště u větších programů.",incorrect:"Programátoři používají adresy pro funkce a data, zatímco strojové instrukce vyžadují symbolická jména. Linker je zodpovědný za překlad adres na symboly, což umožňuje, aby spustitelný kód programu mohl být správně umístěn a spuštěn v paměti.  Tato automatizace symbolizace adres je klíčová, protože manuální správa symbolů by byla pro programátory velmi obtížná a náchylná k chybám, zvláště u větších programů.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"82e0930e-9b7e-4d98-8d32-151e8538cf92",correct:"Linker hraje klíčovou roli v procesu sestavování programů, jelikož je zodpovědný za přiřazení konkrétních paměťových adres symbolům, které programátoři používají pro označení funkcí a dat. Bez linkeru by bylo nutné adresy spravovat manuálně, což by bylo komplikované a neefektivní, a linker tak zajišťuje, že se různé části programu v paměti nepřekrývají a mohou spolu správně komunikovat.",incorrect:"Linker hraje okrajovou roli v procesu sestavování programů, jelikož je zodpovědný za optimalizaci kódu pro rychlejší běh. Linker se stará o symboly a jejich adresy pouze v omezené míře, a hlavním úkolem linkeru je zmenšit velikost spustitelného souboru, aby se program rychleji načítal z disku.  Manuální správa adres je stále preferovanou metodou v moderním programování.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"315b3004-9dd2-4869-a9d3-bf8961525f96",correct:"Manuální přiřazování adres funkcím a datům v programu by bylo pro programátory extrémně obtížné, protože by museli ručně sledovat délku strojového kódu každé funkce a zajistit, aby se paměťové prostory nepřekrývaly. Tento proces by byl náchylný k chybám a časově náročný, což podtrhuje význam automatizace adresace symbolů pomocí linkeru a překladače.",incorrect:"Manuální přiřazování adres funkcím a datům v programu je pro programátory poměrně snadné, zvláště u menších programů, kde je možné délku strojového kódu funkcí snadno odhadnout a paměťové prostory spravovat ručně. Tento proces je efektivní a rychlý, což snižuje význam automatizace adresace symbolů pomocí linkeru a překladače.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"a6f3d8a7-58eb-48e6-bf3b-89dd747f3cd5",correct:"Linker zpracovává objektové soubory postupně, jeden po druhém, a během tohoto procesu udržuje symbolovou tabulku, která mapuje symboly na adresy a je průběžně aktualizována s každým dalším zpracovaným objektovým souborem, přičemž relokace, tedy řešení symbolických odkazů, jsou zpracovány až na konci celého linkovacího procesu, po sloučení všech objektových souborů a symbolových tabulek.",incorrect:"Linker zpracovává všechny objektové soubory najednou a během tohoto procesu vytváří jednu globální symbolovou tabulku na začátku linkování, která se nemění, a relokace, tedy řešení symbolických odkazů, jsou zpracovány ihned po načtení každého objektového souboru, ještě před sloučením všech objektových souborů a symbolových tabulek, což urychluje proces linkování.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"dd9e32af-79a6-46b4-9623-d6ee149fd67e",correct:"Linker pracuje na principu postupného slučování sekcí z jednotlivých objektových souborů do vytvářeného spustitelného souboru, přičemž udržuje „nekompletní spustitelný soubor“ jako pracovní prostor. Sekce jako .text a .data jsou jednoduše připojovány k již existujícím sekcím stejného typu, čímž se postupně vytváří finální struktura spustitelného souboru.",incorrect:"Linker pracuje na principu rozdělení všech vstupních objektových souborů na jednotlivé instrukce a data, které jsou následně optimalizovány a přeskupeny do zcela nových sekcí spustitelného souboru. Původní sekce .text a .data z objektových souborů nejsou přímo používány, ale slouží pouze jako vstupní data pro generování finálního spustitelného souboru.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"dde7fa98-eddc-40f5-8281-1d52b6d22fce",correct:"Symbolové tabulky z jednotlivých objektových souborů jsou linkrem slučovány postupně, jedna po druhé, a adresy symbolů jsou upravovány v průběhu tohoto slučování tak, aby odpovídaly jejich pozici ve vytvářeném spustitelném souboru. Objektové soubory obsahují kromě definic symbolů také informace o jejich použitích, známé jako relokace, které jsou uloženy v relokační tabulce.",incorrect:"Symbolové tabulky z objektových souborů jsou linkrem ignorovány a vytváří se nová, globální symbolová tabulka na základě analýzy zdrojového kódu. Adresy symbolů jsou určovány až po kompletním sloučení všech objektových souborů a relokační tabulka se používá pouze pro kontrolu konzistence symbolů, nikoliv pro jejich adresování ve spustitelném souboru.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"f78b5c7e-2e92-4122-99a9-e8bdabc8150e",correct:"Relokační tabulka v objektových souborech obsahuje záznamy popisující místa v kódu nebo datech, která vyžadují úpravu po linkování, konkrétně adresy instrukcí a symboly, jejichž finální adresy mají být do těchto míst doplněny. Linker zpracovává relokace typicky až po sestavení kompletní výstupní symbolové tabulky, kdy jsou známy finální adresy všech symbolů.",incorrect:"Relokační tabulka v objektových souborech slouží pouze pro optimalizaci kódu a neobsahuje informace o nutných úpravách adres. Linker zpracovává relokace průběžně během slučování objektových souborů a finální adresy symbolů jsou určovány dynamicky během běhu programu, nikoliv staticky během linkování, což umožňuje větší flexibilitu a menší velikost spustitelného souboru.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"b75f6315-5c52-434a-8a5b-3629017cf188",correct:"Po dokončení linkovacího procesu mohou být relokační a symbolové tabulky z výsledného spustitelného souboru odstraněny, protože pro samotné spuštění programu již nejsou nezbytně nutné. Nicméně, v některých případech, zejména u ladících sestavení, může být symbolová tabulka zachována pro usnadnění ladění a analýzy chyb, zatímco relokační tabulka je obvykle odstraněna vždy.",incorrect:"Po dokončení linkovacího procesu musí být relokační i symbolové tabulky vždy zachovány ve výsledném spustitelném souboru, protože jsou nezbytné pro správné fungování programu a dynamické linkování knihoven během běhu. Odstranění těchto tabulek by vedlo k nefunkčnímu spustitelnému souboru, který by nebylo možné správně spustit a ladit.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"a0c4fa2c-82c8-4060-b2d1-2a905268fd4a",correct:"Výstupem linkeru je spustitelný soubor, který má obvykle stejný formát jako objektové soubory, ale je kompletní v tom smyslu, že všechny symboly a relokace jsou již vyřešeny. To platí zejména pro statické spustitelné soubory, které nepoužívají sdílené knihovny, a mohou být přímo načteny do paměti a spuštěny CPU bez dalších úprav.",incorrect:"Výstupem linkeru je spustitelný soubor, který má obvykle stejný formát jako objektové soubory, ale není kompletní v tom smyslu, že symboly a relokace nejsou nikdy vyřešeny. To platí zejména pro statické spustitelné soubory, které nepoužívají sdílené knihovny, a nemohou být přímo načteny do paměti a spuštěny CPU bez dalších úprav.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"9234c010-ca3c-4923-b9f6-3d3ab5de8def",correct:"Spustitelné soubory používají virtuální adresy pro odkazování na své části, což umožňuje, aby různé programy na stejném operačním systému používaly překrývající se adresy pro své instrukce a data. Virtuální adresy jsou soukromé pro každý proces, což znamená, že každá kopie spuštěného programu má své vlastní virtuální adresy.",incorrect:"Spustitelné soubory používají virtuální adresy pro odkazování na své části, což umožňuje, aby různé programy na stejném operačním systému používaly sdílené adresy pro své instrukce a data. Virtuální adresy jsou sdílené mezi procesy, což znamená, že každá kopie spuštěného programu sdílí stejné virtuální adresy.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"b76bbde3-e8f4-416d-a2c9-44865c0e05fa",correct:"Sdílené knihovny jsou do paměti systému načteny pouze jednou, což je v kontrastu se statickými knihovnami, které jsou vloženy do každého programu zvlášť a načítají se samostatně pro každý program, který je používá, což vede k neefektivitě ve využití paměti a diskového prostoru.",incorrect:"Sdílené knihovny jsou načítány samostatně pro každý program, který je využívá, podobně jako statické knihovny, které jsou vloženy do spustitelného souboru programu, a tudíž načítány do paměti pokaždé, když je program spuštěn, což vede k efektivnímu využití paměti.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"687e817e-b3f4-4451-a620-d7f31c2eb293",correct:"Závislosti mezi sdílenými knihovnami jsou typicky strukturovány jako orientovaný acyklický graf (DAG), což znamená, že ačkoli sdílené knihovny mohou záviset na jiných sdílených knihovnách, tyto závislosti nejsou cyklické, čímž se předchází nekonečným smyčkám během procesu načítání a linkování runtime linkerem.",incorrect:"Závislosti mezi sdílenými knihovnami obvykle tvoří cyklický graf, umožňující složité vzájemné závislosti a kruhové reference mezi knihovnami, což zjednodušuje proces řešení symbolických jmen a správu načítání knihoven runtime linkerem operačního systému.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"e7ad738c-8bab-44bf-96d9-eb1f07b54aef",correct:"Rozlišení relokací v programech, které používají sdílené knihovny, stejně jako relokací mezi samotnými sdílenými knihovnami, je řešeno runtime linkerem, což je součást operačního systému, která funguje odlišně od compile-time linkeru a je zodpovědná za dynamické linkování knihoven buď při načítání programu, nebo těsně před jejich prvním použitím.",incorrect:"Rozlišení relokací v programech využívajících sdílené knihovny a ve sdílených knihovnách samotných provádí compile-time linker, který vkládá veškerý potřebný kód knihoven přímo do spustitelného souboru programu ještě před běhovým prostředím, čímž zajišťuje, že všechny symboly jsou vyřešeny staticky a eliminuje potřebu runtime linkeru během běhu programu.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"debf9b0e-9115-4622-bc54-1a90bd26adbb",correct:"Sdílené knihovny se navrhují pro současné načítání do paměti s více programy. Aby se předešlo konfliktům adres, které by vznikly, kdyby knihovny používaly pevné paměťové adresy, jsou kompilovány s využitím position-independent code. Tento přístup, ačkoli zavádí mírnou režii při provádění, poskytuje runtime linkeru flexibilitu načíst knihovnu na libovolný dostupný adresový rozsah v rámci každého procesu, čímž se zvyšuje efektivita správy paměti a stabilita systému.",incorrect:"Sdílené knihovny se navrhují pro načítání do paměti pouze s jedním programem najednou, aby se optimalizovalo využití paměti a zjednodušila správa sdíleného kódu. Pro zajištění, že jsou knihovny vždy načteny na stejné adrese a pro zjednodušení linkování, jsou kompilovány s využitím position-dependent code. Tento přístup, který minimalizuje režii při provádění, omezuje runtime linker na načítání knihovny pouze na předem určené adresové rozsahy, což zjednodušuje správu paměti, ale snižuje flexibilitu.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"043eb74a-1aff-4987-8ebc-4ef79c5e2905",correct:"Zatímco spustitelné soubory a knihovny používají virtuální adresy pro interní odkazy, sdílené knihovny vyžadují specifický přístup z důvodu jejich opakovaného načítání do různých procesů. Aby se zabránilo kolizím adres, které by nastaly při použití absolutních adres v knihovnách, je implementována technika position-independent code. Ta umožňuje načtení knihovny na jakoukoli volnou adresu v paměti každého procesu, i když to s sebou nese menší výkonnostní dopad.",incorrect:"Zatímco spustitelné soubory a knihovny používají virtuální adresy pro interní odkazy, sdílené knihovny jsou načítány do paměti pouze jednou a sdíleny mezi všemi procesy, což efektivně šetří paměťové zdroje. Pro zajištění konzistentního umístění knihovny v paměti a zjednodušení procesu linkování, je nutné používat absolutní adresy a knihovna musí být načtena na fixní adresu v paměti, což zjednodušuje správu paměti, avšak omezuje flexibilitu rozmístění knihoven a může vést k fragmentaci paměti.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"aa6d3f44-17bd-4b9d-9411-283839c70602",correct:"V mnoha operačních systémech typu UNIX jsou kompilátor jazyka C, linker, archivátor a runtime linker standardizovanými nástroji, které jsou často dostupné přímo jako součást systému. Konkrétně, kompilátor jazyka C je obvykle označován jako ‹cc›, linker jako ‹ld›, archivátor jako ‹ar› a runtime linker jako ‹ld.so›, což usnadňuje vývoj a portabilitu softwaru mezi různými UNIXovými systémy.",incorrect:"Ve všech operačních systémech jsou kompilátor jazyka C, linker, archivátor a runtime linker standardizovanými nástroji s pevně danými názvy. Kompilátor jazyka C je vždy označován jako ‹cc›, linker jako ‹ld›, archivátor jako ‹ar› a runtime linker jako ‹ld.so›. Tato absolutní standardizace platí napříč všemi operačními systémy bez výjimky.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"2cb3fdce-0764-48c1-b6df-1bef523ea101",correct:"Standardizace názvů příkazů pro nástroje jako kompilátor (‹cc›), linker (‹ld›) a archivátor (‹ar›) je běžná v operačních systémech typu UNIX, což zjednodušuje práci vývojářů a zajišťuje určitou úroveň konzistence mezi různými implementacemi těchto systémů, i když existují drobné odchylky v detailech implementace a dostupnosti těchto nástrojů.",incorrect:"Standardizace názvů příkazů jako ‹cc› pro kompilátor, ‹ld› pro linker a ‹ar› pro archivátor je univerzální konvencí platnou pro všechny operační systémy, včetně Windows a macOS. Tato absolutní shoda v názvosloví nástrojů pro překlad a linkování je klíčovým prvkem pro zajištění plné přenositelnosti softwaru mezi libovolnými operačními systémy.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"f674c757-ea5d-48bb-be7a-42221a62979f",correct:"V souladu s designovou filozofií systému UNIX jsou adresáře považovány za soubory, což znamená, že s nimi můžeme pracovat podobným způsobem jako s běžnými soubory, například číst z nich bajty pro získání informací o obsažených souborech a potenciálně do nich zapisovat pro vytváření nových položek, ačkoli to není běžná implementace.",incorrect:"V souladu s designovou filozofií systému UNIX jsou adresáře považovány za speciální typy souborů, které se zásadně liší od běžných souborů a neumožňují čtení bajtů pro zjištění obsahu ani zápis bajtů pro vytváření nových položek, protože adresáře jsou spravovány odděleným subsystémem.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"871d7a97-0aea-4060-b854-93e6b20c841b",correct:"V operačních systémech inspirovaných UNIXem se mnoho periferních zařízení, jako jsou pevné disky, tiskárny a zvuková zařízení, chová jako soubory, což umožňuje programům s nimi pracovat pomocí standardních operací čtení a zápisu bajtů, čímž se sjednocuje přístup k různým typům hardwaru.",incorrect:"V operačních systémech inspirovaných UNIXem se periferní zařízení zásadně liší od souborů a vyžadují pro komunikaci specializovaná systémová volání, přičemž koncept souborů se používá pouze pro ukládání dat na disku a nikoliv pro interakci s hardwarem, což vede k fragmentovanému přístupu k systémovým zdrojům.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"8dee2b2b-118e-44f0-a223-e37d7f883a62",correct:"Koncept rour (pipes) v systémech typu UNIX je dalším příkladem abstrakce souboru, kde jeden proces zapisuje bajty do roury a jiný proces z ní bajty čte, což umožňuje meziprocesovou komunikaci prostřednictvím mechanismu, který je z programátorského hlediska podobný práci se soubory.",incorrect:"Roury (pipes) v systémech typu UNIX nejsou implementovány jako soubory, ale jako specializované datové struktury v paměti jádra, které vyžadují odlišné systémové volání pro čtení a zápis než běžné soubory, což programátorům komplikuje práci s meziprocesovou komunikací.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"87693d14-a65e-4422-ac1b-d241f6de4b2a",correct:"Síťová připojení v systémech inspirovaných UNIXem jsou koncipována tak, aby se do jisté míry podobala souborům, konkrétně rourám, což znamená, že programy mohou číst a zapisovat bajty do síťového spojení podobným způsobem, jakým pracují se soubory, i když s určitými rozdíly v chování a sémantice.",incorrect:"Síťová připojení v systémech inspirovaných UNIXem nemají žádnou souvislost s konceptem souborů a vyžadují pro komunikaci zcela odlišné programovací rozhraní, které se zásadně liší od práce se soubory, protože síťová komunikace je řešena na nižší úrovni síťového stacku.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"19e0726e-4099-4781-8668-8b2d825797de",correct:"Znovupoužití existujícího API souborového systému pro práci s objekty, které se chovají jako soubory, je výhodné, protože umožňuje flexibilnější a jednodušší systém. Tento přístup snižuje složitost vývoje a údržby operačního systému tím, že se využívají již existující a osvědčené mechanismy a nástroje, namísto vytváření nových řešení pro každý typ objektu.",incorrect:"Znovupoužití existujícího API souborového systému pro práci s objekty, které se chovají jako soubory, je primárně motivováno snahou o zvýšení výkonu a minimalizaci režie systému. Flexibilita a zjednodušení nejsou hlavními cíli tohoto přístupu, ačkoli mohou být vedlejšími produkty. Hlavním důvodem je optimalizace rychlosti operací se soubory a objekty.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"ed18edc2-6b10-4034-bab5-0e6d0b288133",correct:"Myšlenka znovupoužití API souborového systému se rozšiřuje i na úroveň programů příkazové řádky, což umožňuje konzistentní interakci s různými typy objektů. Díky tomu mohou být existující nástroje příkazové řádky, původně navržené pro práci se soubory, snadno adaptovány pro manipulaci s jinými entitami, jako jsou zařízení, což demonstruje princip simplicity a efektivity v návrhu OS.",incorrect:"Myšlenka znovupoužití API souborového systému je omezena pouze na interní funkce operačního systému a nemá žádný vliv na programy příkazové řádky. Pro interakci s objekty, které nejsou standardními soubory, je nutné vyvíjet zcela nové nástroje příkazové řádky, které specificky řeší manipulaci s těmito objekty, protože stávající nástroje založené na souborovém API nejsou použitelné.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"916228d5-0d92-46a2-b1bb-49c7f9dee9c3",correct:"Přestože znovupoužití souborového API pro zařízení a sokety přináší výhody v podobě flexibility a simplicity, existují i omezení. Některá zařízení vyžadují operace, které se obtížně mapují na standardní operace čtení a zápisu bytů, a sokety představují specifické výzvy, což naznačuje, že abstrakce souboru není vždy ideální pro všechny typy hardwaru a komunikačních kanálů.",incorrect:"Znovupoužití souborového API pro zařízení a sokety je zcela bezproblémové a efektivní, protože abstraktní model souboru je univerzální a dokonale pokrývá potřeby všech typů hardwaru a síťových komunikací. Neexistují žádná významná omezení ani komplikace spojené s tímto přístupem, a operační systém tak může jednotně spravovat všechny zdroje pomocí souborového API.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"9d1de25c-84c3-45a7-a92b-7ae35fb1723d",correct:"Cesty v souborových systémech slouží k jednoznačné identifikaci souborů a adresářů v rámci stromové struktury, přičemž počáteční znak lomítka `/` v cestě indikuje, že se cesta začíná od kořenového adresáře, který je nejvyšším bodem hierarchie souborového systému.",incorrect:"Cesty v souborových systémech slouží k jednoznačné identifikaci souborů a adresářů v rámci lineární struktury, přičemž počáteční znak lomítka `/` v cestě indikuje, že se cesta začíná od aktuálního adresáře, který je proměnlivým bodem v hierarchii souborového systému.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"ca5007a2-f5e6-455b-aa2a-2d22120003f1",correct:"Při zpracování cesty, jako například `/usr/include`, operační systém postupuje tak, že začíná od kořenového adresáře, označeného úvodním lomítkem, a následně v každém adresáři hledá položku se jménem odpovídajícím další části cesty, přičemž ověřuje, zda je každá nalezená položka skutečně adresářem, pokud cesta pokračuje dále.",incorrect:"Při zpracování cesty, jako například `/usr/include`, operační systém postupuje tak, že začíná od aktuálního adresáře, a následně v každém adresáři hledá položku se jménem odpovídajícím další části cesty, přičemž neověřuje, zda je každá nalezená položka skutečně adresářem, a předpokládá, že všechny položky v cestě jsou soubory.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"b5233ed2-666f-4e85-b62b-86b7722ca37e",correct:"V operačním systému Plan 9 je koncept souborového systému doveden do extrému, kdy téměř vše, co lze reprezentovat jako souborový systém, je skutečně souborovým systémem. Tento přístup zdůrazňuje centralitu souborového systému nad rámec běžných systémů typu UNIX a POSIX, kde souborový systém slouží nejen pro ukládání dat, ale i pro přístup k různým systémovým službám a zařízením.",incorrect:"Operační systém Plan 9 minimalizuje roli souborového systému, podobně jako moderní mobilní systémy Android a iOS. V Plan 9 je souborový systém omezen pouze na základní funkce správy dat a většina systémových služeb a zařízení je přístupná výhradně prostřednictvím specializovaných API, která obcházejí tradiční souborový systémové rozhraní.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"612ab286-a54f-492a-b1ff-c5af22c6c6f0",correct:"V systémech typu UNIX, jako je například Linux, je souborový systém koncipován centrálně, což vychází z principů POSIX. Kromě běžných souborů a adresářů se v souborovém systému objevují i speciální soubory, které poskytují rozhraní pro přístup k různým funkcím operačního systému. Například virtuální souborové systémy jako `/proc` a `/sys` slouží k získávání informací o procesech a zařízeních.",incorrect:"Systémy typu UNIX, i když historicky vycházejí z konceptu centrálního souborového systému, v moderní implementaci, jako je Linux, se od tohoto přístupu odklánějí. Důraz je kladen na specializovaná API pro správu procesů a zařízení, přičemž virtuální souborové systémy `/proc` a `/sys` hrají pouze doplňkovou roli a nejsou klíčové pro funkčnost systému.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"aaca018d-e454-40d5-a87a-d8235b9ff2b4",correct:"Operační systém Windows klade menší důraz na souborový systém ve srovnání se systémy POSIX. Ačkoli souborový systém je stále přítomen v API a uživatelském rozhraní, většina objektů a služeb má dedikovaná API, i když se některé z nich chovají podobně jako soubory. Tento přístup se liší od POSIXové filozofie, která upřednostňuje souborový systém jako jednotné rozhraní pro širokou škálu operací.",incorrect:"Operační systém Windows rozšiřuje koncept centrálního souborového systému POSIX a činí jej ještě klíčovějším pro chod systému. Většina systémových operací a přístup k objektům je v systému Windows realizován výhradně prostřednictvím souborového systému, a to i v případech, kdy by bylo možné použít specializovaná API, čímž se maximalizuje jednotnost rozhraní.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"136ee5c3-7833-45f2-b0b9-9d8fc02ee4c1",correct:"Moderní operační systémy jako Android a iOS, ačkoli jsou založeny na POSIXovém jádře, záměrně potlačují význam souborového systému pro běžné aplikace a uživatele. Přímý přístup k POSIX API a souborovému systému je pro standardní aplikace omezen a souborový systém je často skryt i v uživatelském rozhraní, což se liší od tradičního pojetí souborového systému v systémech typu UNIX a Windows.",incorrect:"Operační systémy Android a iOS plně zpřístupňují POSIXový souborový systém aplikacím a uživatelům, čímž navazují na tradiční koncept centrálního souborového systému známý z UNIXových systémů. Aplikace v Androidu a iOS běžně využívají POSIX API pro práci se soubory a adresáři, a souborový systém je klíčovou součástí uživatelského rozhraní těchto systémů.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"4db4e644-f692-41b2-97f3-09cb36726e10",correct:"Pro práci se souborem v POSIX systémech je obvykle nutné jej nejprve otevřít pomocí systémového volání `open()`, kterému se předává cesta k souboru a příznaky určující zamýšlenou operaci. Po dokončení práce se souborem je důležité uvolnit systémové zdroje spojené s otevřeným souborem zavoláním systémového volání `close()`, aby se předešlo potenciálním problémům s alokací zdrojů.",incorrect:"Pro práci se souborem v POSIX systémech není nutné jej otevírat pomocí systémového volání `open()`, protože operace čtení a zápisu lze provádět přímo s cestou k souboru.  Po dokončení práce se souborem není nutné uvolňovat systémové zdroje voláním `close()`, protože systém automaticky uvolní zdroje po ukončení procesu a explicitní uzavření souboru je nadbytečné.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"fbae91d0-537c-4de0-a013-2e37db598ff6",correct:"Operace jako přejmenování souboru, realizovaná systémovým voláním `rename()`, a odstranění souboru z hierarchie souborového systému pomocí `unlink()`, jsou v POSIX systémech považovány za operace na úrovni adresáře, nikoliv na úrovni samotného souboru, a ovlivňují tak adresářové záznamy, které mapují názvy souborů na jejich inody.",incorrect:"Operace jako přejmenování souboru, realizovaná systémovým voláním `rename()`, a odstranění souboru z hierarchie souborového systému pomocí `unlink()`, jsou v POSIX systémech považovány za operace na úrovni samotného souboru, nikoliv na úrovni adresáře, a operují přímo s obsahem souboru, nikoliv s adresářovými záznamy, což znamená, že adresářová struktura zůstává nezměněna.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"80413714-6409-4cde-bec8-4ee1c3c2e185",correct:"Pro práci s adresáři v POSIX systémech obvykle není nutné je explicitně otevírat pomocí systémového volání `open()`, ačkoli tato možnost existuje. Operace jako vytváření adresářů pomocí `mkdir()` nebo mazání souborů pomocí `unlink()` se provádějí přímo s adresářem bez nutnosti jeho explicitního otevření, což zjednodušuje manipulaci s adresářovou strukturou.",incorrect:"Pro práci s adresáři v POSIX systémech je vždy nutné je explicitně otevírat pomocí systémového volání `open()` před provedením jakýchkoli operací, jako je vytváření podadresářů pomocí `mkdir()` nebo mazání souborů pomocí `unlink()`, aby se zajistila konzistence a správná manipulace s adresářovou strukturou a předešlo se chybám v systému.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"a2b3a2d1-8f16-4220-9ed7-250d78ba5f01",correct:"Jádro operačního systému udržuje tabulku otevřených souborů, kde každý záznam obsahuje metadata souboru potřebná pro operace čtení a zápisu, a souborový deskriptor slouží jako index do této tabulky, umožňující rychlý a konstantní časový přístup k metadatům souboru.",incorrect:"Jádro operačního systému udržuje tabulku procesů, kde každý záznam obsahuje informace o procesu a jeho vláknech, a souborový deskriptor slouží jako index do této tabulky, umožňující rychlý přístup k informacím o procesu.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"b72bf0b0-3518-4d4d-afba-2b6eeeda208d",correct:"Při otevírání souboru operační systém vrací souborový deskriptor, což je malé celé číslo, které slouží jako index do tabulky spravované jádrem. V této tabulce jsou uložena metadata souboru, což umožňuje efektivní a rychlé provádění operací se souborem pomocí tohoto deskriptoru.",incorrect:"Při otevírání souboru operační systém vrací cestu k souboru, což je textový řetězec, který slouží k identifikaci souboru v souborovém systému. Tato cesta je pak používána pro všechny operace se souborem, a to i po přejmenování nebo přesunutí souboru.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"a33d6bfd-0328-48fc-841f-d09cbd330621",correct:"Souborový deskriptor je přímo asociován s konkrétním otevřeným souborem v systému, nezávisle na jeho umístění v adresářové struktuře. To znamená, že i když je soubor přesunut nebo dokonce odstraněn z adresářového stromu, souborový deskriptor stále zůstává platný a odkazuje na původní soubor.",incorrect:"Souborový deskriptor je úzce spojen s cestou k souboru v souborovém systému, a proto jakákoli změna cesty souboru, jako je přejmenování nebo přesunutí, způsobí, že se souborový deskriptor stane neplatným a nelze jej dále používat pro operace s tímto souborem.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"910fb95d-2204-4b8d-b42b-9accdb54a50c",correct:'Většina ne-POSIXových systémů souborů, včetně systémů Windows, implementuje koncept podobný souborovým deskriptorům pro správu otevřených souborů. Ačkoli se terminologie může lišit a v systémech Windows se používá termín "handle", základní princip funkčnosti a účel zůstávají v podstatě shodné.',incorrect:"Koncept souborových deskriptorů je specifický pouze pro POSIXové operační systémy, jako je Linux a macOS. V ne-POSIXových systémech, jako je Windows, se používá zcela odlišný přístup ke správě otevřených souborů, který nemá se souborovými deskriptory nic společného.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"9ecb1958-8ade-4964-a7b8-bf9e38871428",correct:"Strategie správy souborových systémů v UNIXu spočívá v integraci všech dostupných souborových systémů do jediné, sjednocené hierarchie adresářů, kde je každý další souborový systém připojen k hlavní hierarchii prostřednictvím připojovacího bodu, čímž se efektivně vytváří jediná stromová struktura přístupná z kořenového adresáře.",incorrect:"Strategie správy souborových systémů v UNIXu spočívá v prezentaci každého dostupného souborového systému jako samostatné, nezávislé hierarchie adresářů, podobně jako je tomu v systému Windows s písmeny jednotek, kde je každý souborový systém přístupný prostřednictvím odlišného kořene a není integrován do jednotného stromu.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"5b7ccd5b-6d15-4bed-8bd0-ccfe6d0a303c",correct:"V operačním systému UNIX zahrnuje proces připojování souborového systému výběr adresáře v rámci existujícího souborového systému, známého jako připojovací bod, a připojení kořenového adresáře jiného souborového systému k tomuto bodu, čímž se efektivně druhý souborový systém začlení do adresářové struktury prvního.",incorrect:"V operačním systému UNIX zahrnuje proces připojování souborového systému vytvoření symbolického odkazu z kořenového adresáře jednoho souborového systému na kořenový adresář jiného, což uživatelům umožňuje přistupovat k souborům z obou souborových systémů nezávisle, aniž by byly skutečně integrovány do jediné hierarchie.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"60bfe857-0679-453f-80f6-b4126ddc04e2",correct:"Koncept připojovacího bodu v systémech typu UNIX se vztahuje ke konkrétnímu adresáři v hierarchii souborového systému, ke kterému je připojen nebo „přimontován“ jiný souborový systém, čímž se obsah připojeného souborového systému stane přístupným prostřednictvím tohoto adresáře a potenciálně se skryje jakýkoli předchozí obsah v daném adresáři.",incorrect:"Koncept připojovacího bodu v systémech typu UNIX se vztahuje k adresáři, který je automaticky vytvořen operačním systémem při detekci nového pevného disku, sloužící jako samostatný přístupový bod pro nový souborový systém bez jeho integrace do stávající hierarchie souborového systému.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"4429ba09-4628-493f-9834-412f8dc1ad06",correct:"Zatímco systémy UNIX využívají sjednocenou hierarchii souborového systému pomocí připojovacích bodů, operační systémy Microsoft Windows používají odlišný přístup přidělováním písmen jednotkám, jako například 'C:' nebo 'D:', každému souborovému systému, čímž prezentují každý souborový systém jako odlišný a samostatný strom adresářů, nezávislý na ostatních souborových systémech.",incorrect:"Zatímco operační systémy Microsoft Windows prezentují souborové systémy jako samostatné stromy pomocí písmen jednotek, systémy UNIX také nabízejí možnost spravovat souborové systémy podobným způsobem, což uživatelům umožňuje přiřazovat písmena jednotek různým souborovým systémům a přistupovat k nim jako k nezávislým stromům namísto jejich integrace do jediné hierarchie.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"48ca1cb2-d573-417b-8002-6c19ad9c45d8",correct:"Socket API pochází z raných systémů BSD Unix a sockety reprezentují koncept „síťových spojení“, ačkoliv jsou složitější než běžné soubory, protože navazování spojení je obtížné a ztráta paketů je běžná. Pro otevřený socket získáte deskriptor souboru a můžete z něj číst a do něj zapisovat pomocí standardních funkcí read() a write(), podobně jako u běžných souborů.",incorrect:"Socket API je moderní technologie, která nemá žádný vztah k systémům BSD Unix, a sockety, i když se soubory souvisí, jsou ve skutečnosti jednodušší na použití, protože síťová spojení jsou spolehlivější než operace se soubory, a proto se problémy jako navazování spojení nebo ztráta paketů v podstatě nevyskytují.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"3cadad21-19f1-4de1-ab24-ddbd20fac327",correct:"Poslouchající socket ve skutečnosti nepřenáší data, ale umožňuje serveru přijímat připojení od mnoha klientů, čímž vytváří komunikační kanál. Pro každé takové spojení se vytvoří připojený socket, který se chová jako obousměrná roura, umožňující oběma stranám posílat a přijímat data. Datagramový socket je odlišný tím, že umožňuje posílat data bez nutnosti navazovat spojení.",incorrect:"Poslouchající socket aktivně přenáší data mezi klienty a serverem ihned po navázání spojení a funguje jako hlavní komunikační kanál pro veškerou datovou výměnu. Připojené sockety se na rozdíl od něj používají pouze pro jednosměrnou komunikaci od serveru ke klientovi a datagramové sockety vyžadují pro přenos dat neustálé potvrzování spojení, což je činí pomalejšími a méně efektivními pro rychlou komunikaci.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"91e86f3d-a3c3-49d2-952f-7bf3ae97ee30",correct:"Na rozdíl od rour, které vyžadují předchozí uspořádání a znalost komunikujících procesů, socketové spojení umožňuje serveru naslouchat na určité adrese a klientům, kteří znají tuto adresu, se k němu připojit. To představuje flexibilnější způsob komunikace, kde procesy nemusí být o sobě navzájem informovány předem, což je klíčový rozdíl oproti tradičním rourám, které vyžadují pevné propojení mezi procesy.",incorrect:"Stejně jako roury, i socketové spojení vyžaduje, aby oba komunikující procesy byly o sobě předem informovány a nakonfigurovány pro vzájemnou komunikaci. Server nemůže naslouchat na veřejné adrese pro neznámé klienty, protože socketová komunikace je primárně určena pro předem definované páry procesů, a jakákoli dynamická připojení klientů bez předchozí konfigurace nejsou v socketovém modelu možná.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"4f1cec14-6a78-4fe2-b5cd-47c2434d260a",correct:"Unixové doménové sockety se používají pro lokální komunikaci v rámci jednoho počítače a jsou implementovány jako soubory v systému souborů, což umožňuje procesům běžícím na stejném stroji komunikovat pomocí cest v souborovém systému, podobně jako pojmenované roury.",incorrect:"Unixové doménové sockety se primárně používají pro komunikaci mezi různými počítači v síti internet pomocí protokolu TCP/IP a jsou adresovány pomocí IP adres a portů, podobně jako standardní internetové sockety, avšak s přidanou vrstvou zabezpečení pro lokální komunikaci.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"a4afd4bb-63ff-414b-a809-10a2b93aa207",correct:"Internetové sockety umožňují komunikaci mezi procesy běžícími na různých počítačích prostřednictvím sítě, typicky internetu, a využívají k tomu protokol TCP/IP, který zajišťuje spolehlivý a uspořádaný přenos dat mezi vzdálenými systémy.",incorrect:"Internetové sockety jsou navrženy výhradně pro vysoce výkonnou lokální komunikaci mezi procesy na stejném počítači a nepodporují komunikaci přes síť, čímž se liší od unixových doménových socketů, které nabízejí omezenou podporu pro síťovou komunikaci.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"d6b192d3-1987-4d38-a9e0-654fdc7f0998",correct:"Stream sockety poskytují spolehlivý a uspořádaný tok dat, podobně jako roury, což znamená, že data jsou doručena v pořadí, v jakém byla odeslána, a jsou vhodné pro aplikace vyžadující souvislý přenos dat, například pro streamování videa nebo přenos souborů.",incorrect:"Stream sockety jsou navrženy pro nespolehlivý přenos dat po jednotlivých datagramech bez garance doručení nebo pořadí, což je činí ideální pro aplikace, kde je klíčová rychlost a ztráta dat je přijatelná, například pro online hry nebo hlasové hovory.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"408e6220-6fd3-418f-a87b-e18e5c6f599f",correct:"Datagramové sockety umožňují odesílání jednotlivých zpráv, přičemž každá zpráva je doručována nezávisle a bez záruky doručení nebo zachování pořadí, což je odlišuje od stream socketů, které poskytují souvislý a spolehlivý tok dat.",incorrect:"Datagramové sockety zajišťují spolehlivé doručení a uspořádání zpráv, podobně jako stream sockety, ale s přidanou funkcionalitou rozdělování dat do menších datagramů pro efektivnější přenos velkých objemů dat, čímž kombinují výhody obou typů socketů.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"}]},{uuid:"011c0e8f-c8b7-4ea9-8c7b-239ac4794871",sectionNumber:"11",sectionTitle:"The Kernel",statements:[{uuid:"59f981ec-5276-4c20-80b3-1ad2e2ece1bd",correct:"Moderní univerzální procesory, které se používají v běžných počítačích a serverech, typicky implementují dva základní režimy provozu: privilegovaný režim (označovaný také jako supervisor mode) a uživatelský režim. Tato architektura umožňuje operačnímu systému efektivně řídit přístup k hardwaru a chránit systémové zdroje před neoprávněným zásahem uživatelských aplikací.",incorrect:"Moderní mikrokontrolery, které se používají v embedded systémech a specializovaných zařízeních, typicky implementují dva základní režimy provozu: privilegovaný režim (označovaný také jako supervisor mode) a uživatelský režim. Tato architektura umožňuje operačnímu systému efektivně řídit přístup k hardwaru a chránit systémové zdroje před neoprávněným zásahem uživatelských aplikací.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"ad26cb34-de63-4146-a852-6b73b7386f10",correct:"Architektura x86, běžně používaná v osobních počítačích, nabízí celkem čtyři úrovně oprávnění, často označované jako kruhy 0, 1, 2 a 3.  Většina operačních systémů, jako například Linux nebo Windows, však pro zjednodušení správy a zvýšení výkonu využívá pouze dva z těchto kruhů, konkrétně kruh 0 pro jádro operačního systému a kruh 3 pro uživatelské aplikace.",incorrect:"Architektura x86, běžně používaná v osobních počítačích, nabízí celkem čtyři úrovně oprávnění, často označované jako kruhy 0, 1, 2 a 3. Většina moderních operačních systémů, jako například Linux nebo Windows, efektivně využívá všechny čtyři kruhy oprávnění pro detailní řízení přístupu a izolaci procesů, čímž maximalizuje bezpečnost a stabilitu systému.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"a164cef7-fb2a-4b53-b40e-9b9d54a71690",correct:"Operační systém využívá privilegovaný režim procesoru k implementaci bezpečnostních mechanismů a k zajištění stability systému. Operace, které mohou mít potenciálně škodlivý dopad na systém, jako je například přímý přístup k hardwaru nebo manipulace s pamětí jiných procesů, jsou povoleny pouze v privilegovaném režimu, čímž se zabrání neoprávněným zásahům ze strany uživatelských aplikací.",incorrect:"Operační systém se spoléhá výhradně na softwarové mechanismy a programátorskou disciplínu při zajišťování bezpečnosti a stability systému. Privilegovaný režim procesoru se používá pouze pro specifické hardwarové operace, ale nemá zásadní vliv na ochranu systému před chybami a škodlivými aktivitami uživatelských aplikací, které běží v uživatelském režimu.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"90393ae1-1c18-42e6-acda-e16f09110a8a",correct:"Většina operačního systému, včetně významné části kódu systémových služeb a uživatelských aplikací, je navržena pro běh v uživatelském režimu procesoru, který se vyznačuje záměrně omezenými oprávněními s cílem zvýšit bezpečnost a stabilitu systému tím, že zabraňuje neautorizovaným zásahům do hardwaru a paměti.",incorrect:"Většina operačního systému, včetně kernelu a kritických systémových služeb, je typicky implementována pro běh v privilegovaném režimu procesoru, což umožňuje neomezený přístup ke všem hardwarovým funkcím a paměťovým oblastem, a minimalizuje tak režii spojenou s přepínáním režimů pro systémové operace.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"593cbf23-b084-4e05-9277-3f9a0f7259e1",correct:"Kernel operačního systému představuje klíčovou součást softwarového vybavení, která je výhradně spouštěna v privilegovaném režimu procesoru, což mu umožňuje plný přístup ke všem hardwarovým zdrojům, včetně možnosti programovat jednotku správy paměti (MMU), a tím efektivně řídit alokaci a ochranu paměti pro všechny procesy v systému.",incorrect:"Kernel operačního systému je navržen tak, aby běžel v uživatelském režimu procesoru, čímž se zvyšuje bezpečnost systému omezením jeho přístupu k hardwarovým zdrojům a vyžaduje se, aby pro veškerou správu paměti a hardwaru využíval pouze systémová volání do privilegovaného režimu.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"c8b7f89e-dc80-47d8-bef5-d7756542e549",correct:"Zatímco kernel operačního systému nezbytně vyžaduje privilegovaný režim pro svůj nerušený a efektivní provoz s maximálními oprávněními, aplikační software, systémové knihovny a různé daemonské procesy jsou záměrně spouštěny v uživatelském režimu, kde jejich možnosti jsou striktně regulovány a omezeny konfigurací jednotky správy paměti (MMU) nastavenou kernelem.",incorrect:"Aplikační software, systémové knihovny a daemonské procesy jsou obvykle spouštěny v privilegovaném režimu procesoru, aby se maximalizoval výkon a umožnil jim přímý a neomezený přístup k hardwarovým zdrojům systému, čímž se zjednodušuje vývoj a správa aplikací.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"ff78f2aa-d3d5-4d24-9111-4390246f4eb2",correct:"MMU je subsystém procesoru, který se stará o překlad adres, což je proces, při kterém se virtuální adresy používané programy převádějí na fyzické adresy, jež odpovídají skutečným umístěním v paměti. Jádro operačního systému spravuje tyto překlady konfigurací překladových tabulek, které MMU používá během procesu překladu adres.",incorrect:"MMU je subsystém procesoru, který se stará o plánování procesů, což je proces, při kterém se virtuální adresy používané programy převádějí na fyzické adresy, jež odpovídají skutečným umístěním v paměti. Uživatel operačního systému spravuje tyto překlady přímou konfigurací MMU během procesu překladu adres.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"fa0320b9-7db1-4e9a-bcea-7dbc78f27504",correct:"Adresy, se kterými programy pracují, jsou virtuální adresy, které nepředstavují fixní fyzické lokace v paměťových čipech. Úkolem MMU je překládat tyto virtuální adresy na fyzické adresy, které mají pevnou vazbu na konkrétní paměťové buňky. Způsob, jakým jsou tyto adresy mapovány, je programovatelný a řízený jádrem operačního systému.",incorrect:"Adresy, se kterými programy pracují, jsou fyzické adresy, které přímo představují fixní fyzické lokace v paměťových čipech. Úkolem CPU je překládat tyto fyzické adresy na virtuální adresy, které mají pevnou vazbu na konkrétní paměťové buňky. Způsob, jakým jsou tyto adresy mapovány, je pevně daný a řízený hardwarem počítače.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"1bf3e377-1ccd-4465-a29f-e913ecf5a37f",correct:"Správa mapování mezi virtuálními a fyzickými adresami je plně v kompetenci jádra operačního systému. Jádro vytváří a konfiguruje překladové tabulky, které MMU používá k provádění překladu adres. To umožňuje operačnímu systému efektivně spravovat paměť a poskytovat programům izolovaný adresní prostor.",incorrect:"Správa mapování mezi virtuálními a fyzickými adresami je plně v kompetenci uživatelských programů. Uživatelské programy vytvářejí a konfigurují překladové tabulky, které MMU používá k provádění překladu adres. To umožňuje uživatelům přímo spravovat paměť a obcházet omezení operačního systému.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"ece7593e-ee6e-4cea-abd7-2f1165e7bfd4",correct:"Mapování jádra do všech procesů je běžně používaný trik, který zlepšuje výkon systému. Díky tomuto mapování se minimalizuje potřeba nákladné výměny tabulek stránek, zejména při systémových voláních, což vede k rychlejšímu provádění systémových operací a celkově efektivnějšímu chodu systému.",incorrect:"Mapování jádra do všech procesů je technika, která se používá výhradně pro zvýšení bezpečnosti operačního systému. Hlavním cílem tohoto mapování je izolovat procesy uživatelského prostoru od jádra, a i když to může mít mírný dopad na výkon, primárním záměrem je posílení bezpečnosti systému.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"e1f8fe0c-4591-4df6-9eec-d51952e55fb1",correct:"Stránky paměti jádra jsou speciálně chráněny pomocí příznaku supervizora, který zajišťuje, že k nim nemůže přistupovat kód běžící v uživatelském režimu. Tato ochrana je klíčová pro zabránění neoprávněné manipulaci s jádrem a pro zachování stability a integrity celého operačního systému.",incorrect:"Stránky paměti jádra jsou chráněny především složitými šifrovacími mechanismy, které zabraňují neoprávněnému přístupu z uživatelského prostoru. Příznak supervizora hraje v ochraně jádra pouze doplňkovou roli a hlavní důraz je kladen na kryptografické metody.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"5577ca85-f0a8-415c-bf02-f124a0a0d8bd",correct:"Výměna tabulek stránek je operace, která je z hlediska výkonu poměrně nákladná, a operační systémy se proto snaží minimalizovat její frekvenci. Zvláště nežádoucí je výměna tabulek stránek v kritických cestách, jako jsou systémová volání, kde by mohla výrazně zpomalit odezvu systému.",incorrect:"Výměna tabulek stránek je v moderních operačních systémech optimalizována a představuje velmi rychlou operaci s minimálním dopadem na výkon. Operační systémy se proto nemusí snažit omezovat výměnu tabulek stránek, a to ani v cestě systémových volání, kde je výkon stále zachován na vysoké úrovni.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"c73e10ca-330e-4791-867a-3133f45f4912",correct:"Po zapnutí počítače se systém nachází ve výchozím stavu, protože operační paměť RAM je volatilní a po vypnutí napájení rychle ztratí veškerý obsah, což znamená, že při opětovném zapnutí je RAM prázdná a CPU v implicitním stavu.",incorrect:"Po zapnutí počítače se systém nachází v plně funkčním stavu, protože operační paměť RAM si uchovává obsah i po vypnutí napájení, což znamená, že při opětovném zapnutí je RAM plná dat a CPU připraven k okamžitému použití.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"fb13f668-4945-435c-bcaf-3bc783568b17",correct:"Inicializace počítačové platformy po zapnutí zahrnuje primárně inicializaci centrální procesorové jednotky (CPU), dále pak periferních zařízení jako je konzolový hardware, včetně klávesnice a displeje, a následně i všech ostatních zařízení připojených k systému.",incorrect:"Inicializace počítačové platformy po zapnutí se omezuje pouze na kontrolu persistentního úložiště dat a operační paměti RAM, přičemž inicializace centrální procesorové jednotky (CPU) a periferních zařízení, jako je konzolový hardware, probíhá až v pozdější fázi spouštění operačního systému.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"097c44fb-8ffa-4e2e-858d-587f42559c32",correct:"Po vypnutí napájení a následném zapnutí počítače se stav systému, s výjimkou obsahu trvalého úložiště, vrací do stavu, v jakém byl počítač při opuštění továrny, což znamená, že počítač je v podstatě ve výchozím, nepoužitelném stavu, dokud neproběhne inicializace a zavedení operačního systému.",incorrect:"Po vypnutí a zapnutí počítače se stav systému, včetně operační paměti RAM, uchová v posledním funkčním stavu před vypnutím, díky čemuž je počítač ihned po zapnutí připraven k použití a není nutná žádná inicializace systému ani zavedení operačního systému.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"2a78e802-4fdc-484e-ac5e-c4f3d8a62ca9",correct:"Inicializace firmwaru předchází zavedení bootloaderu v sekvenci spouštění operačního systému, což zajišťuje, že hardware a firmware jsou v počátečním stavu připraveném pro načtení a spuštění bootloaderu z trvalého úložiště.",incorrect:"Inicializace firmwaru probíhá až po zavedení bootloaderu v sekvenci spouštění operačního systému, což znamená, že bootloader nejprve inicializuje hardware a firmware před načtením jádra.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"da83fc12-8644-4670-bdaf-898dcdfb099c",correct:"Bootloader je zodpovědný za nalezení a zavedení jádra operačního systému z trvalého úložiště, přičemž využívá služeb firmwaru k identifikaci a načtení dat z tohoto úložiště, což je klíčový krok v procesu spouštění systému.",incorrect:"Jádro operačního systému je zodpovědné za zavedení bootloaderu z trvalého úložiště, přičemž bootloader se aktivuje až po spuštění jádra a jeho hlavním úkolem je inicializace firmwaru.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"c651b890-f219-4f96-9215-f0d1f5d398df",correct:"Moderní firmware a bootloadery jsou často sofistikované a schopné zvládat komplexní úlohy, jako je práce s šifrovanými disky a porozumění složitým souborovým systémům, což umožňuje flexibilnější a bezpečnější proces spouštění systému.",incorrect:"Moderní firmware a bootloadery jsou navrženy tak, aby byly co nejjednodušší a nejprimitivnější, a záměrně nepodporují složité funkce, jako je práce s šifrovanými disky nebo porozumění souborovým systémům, aby se minimalizovala jejich složitost a potenciální chyby.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"cf376aeb-3a99-4812-8156-fc407266b875",correct:"Na architektuře x86 se CPU zpočátku spouští v 16bitovém režimu z důvodu požadavků na zpětnou kompatibilitu, a v případě 32bitových procesorů x86 je v této fázi také jednotka správy paměti (MMU) deaktivována.",incorrect:"Na architektuře x86 se CPU zpočátku spouští v 32bitovém režimu, aby byl od začátku zajištěn optimální výkon, a jednotka správy paměti (MMU) je okamžitě aktivována, aby efektivně spravovala paměť od spuštění systému.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"7cfb16db-c873-4ac1-a046-a83ae5da76b3",correct:"Zatímco moderní 64bitové procesory x86 se stále spouštějí v 16bitovém režimu kvůli kompatibilitě, firmware na těchto procesorech je dostatečně pokročilý, aby přepnul CPU do 64bitového režimu „long mode“ ještě před předáním řízení bootloaderu, čímž se zjednodušuje proces spouštění.",incorrect:"Ačkoli se moderní 64bitové procesory x86 spouštějí v 16bitovém režimu, firmware ponechává CPU v tomto 16bitovém režimu a je výhradní odpovědností bootloaderu přepnout procesor do 64bitového režimu „long mode“ před načtením jádra operačního systému.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"acbbe3f7-31d8-46dd-8c1a-c2699632d0a2",correct:"Nutnost, aby jádro operačního systému nebo bootloader konfigurovaly režim CPU při spuštění, vyplývá z výchozí inicializace CPU do režimu zpětné kompatibility, což je zásadní pro podporu staršího softwaru a hardwarových komponent, zejména v architektuře x86.",incorrect:"Nutnost, aby jádro operačního systému nebo bootloader konfigurovaly režim CPU při spuštění, je primárně způsobena bezpečnostními zranitelnostmi přítomnými v moderních architekturách CPU, což vyžaduje okamžité přepnutí do chráněných režimů k ochraně systému před potenciálními hrozbami.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"9f681d52-f1a5-4c42-a5ed-3869a36246e2",correct:"Historicky byl bootloader typicky velmi malý program, často o velikosti pouze desítek kilobajtů kódu, jehož hlavním úkolem bylo zavést operační systém z trvalého úložiště do operační paměti RAM a předat mu řízení. Tento minimalistický přístup byl nutný kvůli omezeným zdrojům a komplexitě tehdejších systémů.",incorrect:"Historicky byl bootloader typicky rozsáhlý program, často o velikosti stovek megabajtů kódu, jehož hlavním úkolem bylo spravovat veškerý hardware systému a poskytovat rozsáhlé služby operačnímu systému ještě před jeho zavedením. Tento komplexní přístup byl nutný pro pokročilé funkce tehdejších systémů.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"327d78f8-f21f-403c-a00f-94c1e9589456",correct:"V moderních x86 systémech se proces zavádění operačního systému zjednodušil díky standardizovanému rozhraní firmware, které rozumí souborovému systému FAT. To umožňuje firmwaru načítat soubory přímo z disku do paměti, což značně usnadňuje a urychluje celý proces bootování.",incorrect:"V moderních x86 systémech se proces zavádění operačního systému zkomplikoval kvůli nutnosti používat proprietární rozhraní firmware, které nerozumí běžným souborovým systémům.  To vyžaduje složité a zdlouhavé postupy pro načítání souborů a zavedení operačního systému z disku do paměti.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"f109f4a5-3b5c-491c-a6c3-30cbcef5be32",correct:"Po zavedení jádra bootloaderem inicializační sekvence jádra začíná nízkoúrovňovou inicializací CPU a základních periferií, jako je konzole a časovače, a teprve poté přechází k inicializaci ovladačů zařízení a připojení kořenového systému souborů před předáním řízení uživatelskému prostoru prostřednictvím procesu init.",incorrect:"Po zavedení jádra bootloaderem inicializační sekvence jádra začíná inicializací ovladačů zařízení a připojením kořenového systému souborů, a teprve poté se věnuje nízkoúrovňové inicializaci CPU a základních periferií, jako je konzole a časovače, přičemž předání řízení uživatelskému prostoru prostřednictvím procesu init probíhá ještě před inicializací periferií.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"98b0a374-8a0b-46f2-be42-696ff582403a",correct:"Inicializace ovladačů zařízení probíhá v jádře operačního systému poté, co jádro nastaví základní datové struktury a předtím, než začne hledat a připojovat kořenový systém souborů, což umožňuje jádru interagovat s hardwarovými periferiemi, včetně úložných zařízení, na kterých je uložen kořenový systém souborů, a zajistit tak jejich funkčnost před přístupem k datům.",incorrect:"Inicializace ovladačů zařízení probíhá v jádře operačního systému až poté, co je kořenový systém souborů připojen a proces init byl spuštěn, což znamená, že jádro spoléhá na předem existující ovladače pro vyhledání a přístup k úložným zařízením obsahujícím kořenový systém souborů, a inicializace ovladačů probíhá až v uživatelském prostoru po spuštění init.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"88e9bf5e-733f-4fd9-8ee5-ba58332ab798",correct:"Proces ‹init› hraje klíčovou roli při spouštění operačního systému, protože je zodpovědný za připojení všech ostatních souborových systémů po úvodním zavedení, inicializaci a spuštění systémových služeb, které jsou zásadní pro chod systému, a následně i aplikačních služeb, což jsou démoni, kteří rozšiřují funkcionalitu systému nad rámec základních operací, a nakonec spouští proces ‹login›, který uživateli umožňuje přihlásit se do systému.",incorrect:"Proces ‹init› se spouští až po dokončení bootovacího procesu a po přihlášení uživatele, přičemž jeho hlavním úkolem je správa uživatelských aplikací a monitorování systémových prostředků, zatímco spouštění systémových služeb a připojování souborových systémů je řízeno jinými procesy operačního systému, které běží paralelně s procesem ‹init›.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"17c61056-3d43-4150-90eb-ae1dddab34d1",correct:"V průběhu bootovacího procesu, po úvodní inicializaci systému procesem ‹init› a připojení základních souborových systémů, proces ‹init› postupně spouští systémové služby, které jsou nezbytné pro základní funkčnost operačního systému, a teprve poté, když jsou systémové služby připraveny, přistupuje ke spouštění aplikačních služeb, jako jsou webové servery, které rozšiřují funkcionalitu systému o uživatelsky orientované aplikace.",incorrect:"Aplikační služby, jako jsou webové servery, jsou spouštěny procesem ‹init› ještě před systémovými službami, protože aplikační služby jsou považovány za kritické pro základní funkčnost operačního systému a musí být k dispozici co nejdříve po spuštění systému, zatímco systémové služby se spouštějí až následně a jejich spuštění není časově kritické pro zahájení uživatelské interakce.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"e8637572-3228-40ee-ab9b-119adaf61eda",correct:"Bootovací proces operačního systému je považován za dokončený v okamžiku, kdy proces ‹init› úspěšně spustí proces ‹login› a uživateli se zobrazí přihlašovací obrazovka, která ho vyzývá k zadání uživatelského jména a hesla, což signalizuje, že systém je připraven k uživatelské interakci a všechny základní a esenciální systémové služby jsou spuštěny a funkční.",incorrect:"Bootovací proces operačního systému je dokončen již v momentě, kdy je proces ‹init› spuštěn a začne provádět úvodní inicializaci hardwaru, ještě před připojením souborových systémů a spuštěním jakýchkoliv systémových služeb, protože samotné spuštění procesu ‹init› indikuje, že jádro systému bylo úspěšně zavedeno a systém je v základním funkčním stavu.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"0f008c7b-0ce3-4809-9517-4b454b006efc",correct:"Přihlašovací proces uživatele začíná inicializací uživatelské relace, následně zavádí moduly desktopového prostředí a aplikační software a nakonec uživatele přepne do prostředí shellu, čímž umožní interakci s počítačem.",incorrect:"Přihlašovací proces uživatele začíná zavedením modulů desktopového prostředí a aplikačního softwaru, následně inicializuje uživatelskou relaci a nakonec uživatele přepne do prostředí shellu, ačkoli interakce s počítačem je možná až po dokončení všech kroků.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"76d50a80-0632-405a-adcb-87318b1da8a5",correct:"Po přihlášení uživatele systém nastaví relaci, což zahrnuje několik kroků, než je uživateli umožněna interakce s počítačem, jak je popsáno v dokumentaci k operačnímu systému.",incorrect:"Po přihlášení uživatele systém okamžitě umožní interakci s počítačem bez nutnosti nastavování relace nebo provádění jakýchkoliv dalších kroků, což zjednodušuje proces spuštění uživatelského prostředí.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"34f657c2-9a0b-4baf-8fd0-3a6a6137d1b6",correct:"Monolitické jádra, jako například Linux a *BSD, představují nejrozsáhlejší a nejinkluzivnější mainstreamový design kernelů. Naopak mikrokernelové systémy, jako Mach nebo L4, jsou navrženy s cílem minimalizace jádra, čímž se stávají nejmenšími a nejexkluzivnějšími z hlediska poskytovaných služeb a funkcí v porovnání s monolitickými jádry. Tento rozdíl v designu zásadně ovlivňuje architekturu a vlastnosti operačního systému.",incorrect:"Monolitické jádra, jako například Linux a *BSD, jsou navržena jako nejmenší a nejexkluzivnější mainstreamový design kernelů. Mikrokernelové systémy, jako Mach nebo L4, naopak představují nejrozsáhlejší a nejinkluzivnější přístup. Mikrokernele se snaží maximalizovat rozsah služeb a funkcí poskytovaných v jádře, čímž se liší od monolitických jader, která se zaměřují na minimalizaci jádra.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"3e0e24b6-7ee3-45b8-bae1-f57ca064ebfa",correct:'Hybridní jádra, například macOS, představují kompromis mezi monolitickými a mikrokernelemi. Skládají se z mikrokernelu a takzvaného "superserveru". Tento superserver je v podstatě ořezané monolitické jádro, z něhož byla odstraněna funkcionalita, kterou již pokrývá mikrokernel. Hybridní architektura se snaží kombinovat výhody obou extrémních přístupů.',incorrect:'Hybridní jádra, například macOS, jsou založena na kombinaci monolitického jádra a "mikromodulu". Tento mikromodul je rozšířená verze mikrokernelu, do kterého byla přidána funkcionalita typická pro monolitická jádra. Hybridní architektura se snaží oddělit co nejvíce funkcí do uživatelského prostoru, podobně jako čisté mikrokernele.',sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"48b079cb-f013-4ce5-8ee9-064535405140",correct:'Hypervisory typu 1, někdy označované jako bare-metal hypervisory, jako například Xen, lze považovat za specifický typ operačního systému. V tomto kontextu jsou "aplikacemi" virtuální stroje, což jsou plnohodnotné operační systémy. Hypervisor tak funguje jako základní vrstva, která spravuje a izoluje jednotlivé virtuální stroje běžící na hardwaru.',incorrect:'Hypervisory typu 1, jako například Xen, jsou specifickým typem aplikací běžících v uživatelském prostoru operačního systému. V tomto modelu jsou "operačními systémy" virtuální stroje, které fungují jako běžné aplikace spuštěné hypervisorem. Hypervisor v tomto případě poskytuje pouze omezené služby pro správu hardwaru pro tyto aplikace.',sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"324f1164-51f4-4a15-80a1-f1593852b083",correct:"Exokernelové operační systémy se vyznačují radikálním omezením služeb poskytovaných aplikacím. Cílem exokernelů je minimalizovat abstrakce a poskytnout aplikacím maximální kontrolu nad hardwarem. Aplikace v exokernelovém systému mají přímý přístup k hardwarovým zdrojům a samy si implementují vyšší úrovně operačního systému.",incorrect:"Exokernelové operační systémy se vyznačují rozsáhlým rozšířením služeb poskytovaných aplikacím. Cílem exokernelů je maximalizovat abstrakce a poskytnout aplikacím ucelené prostředí s bohatými funkcemi. Aplikace v exokernelovém systému jsou od hardwarových detailů zcela odstíněny a spoléhají se na širokou škálu služeb jádra.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"db393585-4b01-4626-91f8-04b3e5b2c7b4",correct:"Unikernely představují přístup, kde se operační systém stává specializovanou knihovnou. Tato knihovna je sestavena společně s aplikací a výsledkem je jediný spustitelný obraz, který běží v kernelovém režimu. Unikernely jsou navrženy pro specifické aplikace a cílem je maximalizovat výkon a minimalizovat režii operačního systému.",incorrect:"Unikernely představují přístup, kde se operační systém stává specializovanou knihovnou. Tato knihovna je sestavena společně s aplikací a výsledkem je spustitelný obraz, který běží v uživatelském režimu. Unikernely se zaměřují na zvýšení bezpečnosti spouštěním aplikací mimo kernelový režim a oddělením od kritických systémových funkcí.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"c9fac08a-1d78-4a82-b2c1-241a5bdc8471",correct:"Mikrokernelová architektura operačního systému se vyznačuje tím, že jádro systému obsluhuje pouze esenciální služby, které vyžadují privilegovaný režim CPU. Mezi tyto služby patří správa paměti prostřednictvím programování MMU, zpracování hardwarových přerušení, plánování úloh a procesů a mechanismy pro meziprocesovou komunikaci, typicky formou předávání zpráv. Všechny ostatní funkce operačního systému jsou navrženy tak, aby běžely mimo jádro.",incorrect:"Mikrokernelová architektura operačního systému se vyznačuje tím, že jádro systému obsluhuje všechny služby operačního systému, včetně neesenciálních služeb, kromě základních funkcí, jako je správa souborového systému, implementace síťového zásobníku a správa grafického uživatelského rozhraní, a také esenciální služby, jako je správa paměti, zpracování přerušení a plánování procesů.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"8ec2c5ff-d2f7-4168-9497-228f68267dff",correct:"Podle principů mikrokernelové architektury je jádro operačního systému záměrně udržováno minimální a zahrnuje pouze základní služby, které vyžadují běh v privilegovaném režimu CPU. To zahrnuje klíčové úkoly správy paměti pomocí programování MMU, počáteční zpracování hardwarových přerušení, přepínání úloh a procesů spolu s plánováním a meziprocesovou komunikaci, typicky implementovanou mechanismy pro předávání zpráv.",incorrect:"Na rozdíl od mikrokernelové architektury jsou monolitická jádra navržena tak, aby udržovala jádro minimální a zahrnovala pouze malou podmnožinu základních služeb prováděných v privilegovaném režimu CPU, přičemž se zaměřují primárně na meziprocesovou komunikaci a delegují správu paměti, zpracování přerušení a plánování procesů na procesy v uživatelském prostoru, aby se zvýšila modularita a stabilita systému.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"d8f0b069-d2aa-4278-9b97-1cf14036b4ee",correct:"V kontextu operačního systému založeného na mikrokernelu jsou povinnosti jádra striktně omezeny na správu ochrany paměti prostřednictvím konfigurace MMU, obsluhu hardwarových přerušení pro zahájení privilegovaných operací, řízení plánování úloh a procesů a umožnění meziprocesové komunikace prostřednictvím předávání zpráv, čímž je zajištěno, že všechny ostatní funkce operačního systému jsou implementovány jako samostatné moduly fungující mimo privilegovanou doménu jádra.",incorrect:"V operačním systému založeném na mikrokernelu je jádro zodpovědné za širokou škálu služeb, včetně nejen základních funkcí, jako je ochrana paměti, obsluha přerušení, plánování procesů a předávání zpráv, ale také rozšířených funkcí, jako je správa souborového systému, síťové protokolové sady, správa ovladačů zařízení a prostředí pro spouštění uživatelských aplikací, to vše funguje v privilegované doméně jádra.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"0ffbde85-af3f-4f98-8b37-4e9047b7a1b5",correct:"Monolitické jádro zahrnuje vše, co mikrokernel, a navíc integruje do jádra i ovladače zařízení, zejména ty, které vyžadují přerušení nebo DMA pro zajištění vysokého výkonu, dále souborové systémy a správu diskových svazků pro efektivní práci s daty.",incorrect:"Monolitické jádro se od mikrokernelu liší pouze tím, že nezahrnuje ovladače zařízení, souborové systémy a správu diskových svazků. Tyto komponenty jsou v monolitickém jádře ponechány mimo privilegovaný režim, aby se zvýšila bezpečnost a stabilita systému.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"66e8295f-f1ac-417e-8d96-fcdb887fc88d",correct:"Monolitické jádro obvykle integruje kompletní TCP/IP stack a různé doplňkové služby, jako je šifrování dat a filtrování paketů, přímo do jádra, což mu umožňuje efektivně spravovat síťovou komunikaci a bezpečnostní funkce, avšak veškerý tento kód běží v privilegovaném režimu.",incorrect:"Monolitické jádro se záměrně vyhýbá integraci kompletního TCP/IP stacku a doplňkových služeb, jako je šifrování dat a filtrování paketů. Tyto funkce jsou v monolitickém jádře realizovány výhradně v uživatelském prostoru, aby se minimalizovala zranitelnost jádra.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"f2a104e8-fcf1-45dd-af37-b3731b04bde4",correct:"V operačním systému s opravdovým mikrokernelem jsou ovladače zařízení implementovány jako samostatné procesy, což významně přispívá k modularitě systému. Tato architektura umožňuje snadnější vývoj, ladění a údržbu ovladačů, protože jejich potenciální selhání neohrozí stabilitu celého jádra systému.",incorrect:"V operačním systému s opravdovým mikrokernelem jsou ovladače zařízení integrovány přímo do mikrokernelu, čímž se zvyšuje jeho výkon a snižuje režie spojená s komunikací mezi procesy. Toto centralizované řešení je klíčové pro dosažení maximální efektivity a minimalizaci latence při obsluze hardwaru.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"e1e72163-2fcf-4086-954c-239b34dd6a88",correct:"V architektuře opravdového mikrokernelu jsou služby, které se tradičně nacházejí v monolitickém jádře, jako je správa souborů a síťování, poskytovány samostatnými serverovými procesy. Tyto procesy běží mimo mikrokernel a komunikují s ním pomocí mechanismů meziprocesové komunikace, což zvyšuje modularitu a odolnost systému.",incorrect:"V architektuře opravdového mikrokernelu jsou klíčové služby, jako je správa souborů a síťování, stále integrovány přímo do mikrokernelu, podobně jako v monolitických jádrech. Mikrokernel tak zajišťuje základní i pokročilé funkce operačního systému, minimalizujíc závislost na externích serverových procesech.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"6567277a-9a53-48dc-802e-364179b22d7c",correct:"Samotný mikrokernel operačního systému poskytuje pouze minimální sadu základních funkcí. Pro širší škálu služeb, jako jsou souborové systémy a síťové protokoly, se mikrokernel spoléhá na externí serverové procesy, které rozšiřují funkčnost systému a běží v uživatelském prostoru.",incorrect:"Mikrokernel operačního systému poskytuje komplexní sadu služeb, srovnatelnou s monolitickým jádrem, a minimalizuje potřebu externích serverových procesů. Díky tomu je mikrokernel schopen efektivně a autonomně spravovat všechny klíčové aspekty operačního systému, od správy paměti po síťovou komunikaci.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"6c805328-1708-434b-9315-6b040fc64055",correct:"Hybridní jádra operačních systémů se vyznačují architekturou založenou na mikrokernelu, kde většina systémových služeb je poskytována prostřednictvím jediného rozsáhlého serveru, často označovaného jako superserver, který je navržen tak, aby byl do jisté míry izolován od přímé interakce s hardwarem.",incorrect:"Hybridní jádra operačních systémů jsou charakteristická svou monolitickou architekturou, kde jsou všechny systémové služby integrovány do jednoho jádra, což eliminuje potřebu superserveru a přímé interakce s hardwarem je minimalizována.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"04205003-c28f-4020-abc4-fcd24029e6e1",correct:"Implementace hybridního jádra je obecně považována za méně náročnou a levnější ve srovnání s vývojem plnohodnotných mikrokernelových operačních systémů, které se snaží o maximální modularitu a oddělení služeb do více serverů.",incorrect:"Implementace hybridního jádra je obvykle složitější a nákladnější než vývoj plnohodnotných mikrokernelových operačních systémů, protože hybridní přístup vyžaduje integraci mikrokernelu s komplexním superserverem a správu mnoha oddělených služeb.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"6658f3ad-2d91-496b-ac7f-dca62c870b23",correct:"Hybridní jádra operačních systémů představují kompromisní řešení z hlediska výkonu, které se snaží nalézt rovnováhu mezi výkonnostními charakteristikami monolitických a mikrokernelových architektur, a teoreticky by měla dosahovat lepšího výkonu než čistě mikrokernelové systémy.",incorrect:"Hybridní jádra operačních systémů jsou navržena tak, aby dosahovala výrazně nižšího výkonu než čistě mikrokernelové systémy, jelikož superserver v hybridní architektuře představuje výkonnostní úzké hrdlo a zpomaluje celkovou odezvu systému kvůli nutnosti komunikace skrze mikrokernel.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"0a402f57-2851-4433-9d29-06ac5e57c91e",correct:"Mikrokernel jsou považovány za robustnější než monolitické jádra především proto, že jejich menší velikost jádra snižuje pravděpodobnost výskytu chyb v samotném jádře, a izolace serverových procesů minimalizuje dopad chyb pocházejících mimo jádro, což umožňuje obnovu systému restartováním serverů.",incorrect:"Mikrokernel jsou považovány za méně robustní než monolitické jádra, protože jejich větší velikost jádra zvyšuje pravděpodobnost výskytu chyb v samotném jádře, a izolace serverových procesů maximalizuje dopad chyb pocházejících mimo jádro, což znemožňuje obnovu systému restartováním serverů.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"2f88d433-1eef-4292-abbf-6ad9425fcecc",correct:"Monolitická jádra obvykle vykazují vyšší výkon ve srovnání s mikrokernelem díky optimalizaci přepínání kontextu, které, navzdory pokrokům v moderních procesorech, zůstává operací citlivou na výkon; nicméně tento výkonnostní rozdíl se zmenšuje, protože monolitická jádra začleňují bezpečnostní vylepšení, jako je izolace tabulek stránek jádra.",incorrect:"Monolitická jádra obvykle vykazují nižší výkon ve srovnání s mikrokernelem díky optimalizaci přepínání kontextu, které, navzdory pokrokům v moderních procesorech, zůstává operací necitlivou na výkon; nicméně tento výkonnostní rozdíl se zvětšuje, protože monolitická jádra začleňují bezpečnostní vylepšení, jako je izolace tabulek stránek jádra.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"a16fd160-0973-45ff-8107-637d7602134c",correct:"Z hlediska implementace nabízejí monolitická jádra často výhodu díky možnosti psaní kódu přímým, synchronním způsobem a snadnému sdílení datových struktur mezi různými komponentami jádra, zatímco systémy založené na mikrokernelu často vyžadují asynchronní komunikaci prostřednictvím předávání zpráv, což může komplikovat vývoj a pochopení kódu.",incorrect:"Z hlediska implementace nabízejí mikrokernel často výhodu díky možnosti psaní kódu přímým, synchronním způsobem a snadnému sdílení datových struktur mezi různými komponentami jádra, zatímco systémy založené na monolitickém jádře často vyžadují asynchronní komunikaci prostřednictvím předávání zpráv, což může zjednodušit vývoj a pochopení kódu.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"78302d12-347a-4b57-8022-30f53b68aa68",correct:"Exokernely a unikernely představují dva různé přístupy k minimalistickému designu operačních systémů. Exokernel se zaměřuje na poskytování minimálních abstrakcí a umožňuje běh více aplikací s izolací procesů, zatímco unikernel je navržen pro běh jediné aplikace a poskytuje tradičnější služby operačního systému, jako je hierarchický souborový systém a síťový zásobník. Rozdíl spočívá v rozsahu poskytovaných služeb a cílovém použití každé architektury.",incorrect:"Exokernely a unikernely jsou v podstatě identické minimalistické operační systémy, které se liší pouze v detailech implementace. Oba typy kernelů jsou navrženy pro běh jediné aplikace a poskytují pouze základní abstrakce, jako je blokové úložiště a redukované síťové služby. Hlavní výhodou obou architektur je jejich schopnost běžet přímo na hypervisoru, čímž se minimalizuje režie spojená s tradičními operačními systémy.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"961924aa-b3b7-4aa1-adf9-6872ed90182a",correct:"Hypervizor na holém kovu se podobá exokernelu nebo mikrokernelovému operačnímu systému v závislosti na konkrétním hypervizoru a úhlu pohledu. Hypervizor typicky poskytuje rozhraní a zdroje, které jsou tradičně implementovány v hardwaru, jako jsou bloková zařízení, síťová rozhraní a virtuální CPU, což umožňuje hostovaným operačním systémům využívat stránkování a další hardwarové funkce. Hypervizor však může používat hrubší abstrakce než operační systém, například celá úložná zařízení namísto souborového systému.",incorrect:"Hypervizor na holém kovu se zásadně liší od exokernelu a mikrokernelového operačního systému, protože hypervizor je navržen výhradně pro správu hardwarových zdrojů a neposkytuje žádné služby aplikacím. Na rozdíl od exokernelů a mikrokernelů, které nabízejí minimální abstrakce a služby pro aplikace, hypervizor se zaměřuje pouze na virtualizaci hardwaru a neumožňuje běh více operačních systémů jako aplikací.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"e4328f80-ca60-43f6-9184-e7b1f09d1fc3",correct:"Unikernel, navržený pro běh jediné aplikace, poskytuje podmnožinu tradičních abstrakcí operačního systému, jako je síťový zásobník a hierarchický souborový systém. Díky tomu se unikernely liší od exokernelů, které poskytují mnohem omezenější služby a vyžadují, aby aplikace implementovaly složitější funkce samy. Unikernel se snaží minimalizovat režii spojenou s obecnými operačními systémy a zároveň poskytnout aplikaci dostatečné standardní služby pro její fungování.",incorrect:"Unikernel, navržený pro běh jediné aplikace, neposkytuje žádné tradiční abstrakce operačního systému, jako je síťový zásobník nebo hierarchický souborový systém. Podobně jako exokernely, unikernely se spoléhají na to, že si aplikace implementuje všechny potřebné služby sama, čímž se dosahuje maximální minimalizace jádra a snížení režie. Hlavním cílem unikernelu je poskytnout absolutně minimální prostředí pro běh jediné aplikace.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"1595f3ff-a7c3-428b-a529-6c1bf811dd86",correct:"Jádro operačního systému běží v privilegovaném režimu procesoru, což mu umožňuje provádět operace, které jsou pro uživatelský kód nedostupné. Paměť jádra je chráněna před přímým přístupem z uživatelského prostoru, čímž se zajišťuje stabilita a bezpečnost systému, protože uživatelské aplikace nemohou poškodit kritické části operačního systému.",incorrect:"Jádro operačního systému běží v uživatelském režimu procesoru, což umožňuje uživatelskému kódu provádět operace s privilegovaným přístupem. Paměť jádra je běžně přístupná z uživatelského prostoru, čímž se zvyšuje flexibilita a efektivita systému, protože uživatelské aplikace mohou přímo manipulovat s kritickými částmi operačního systému.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"2c5355c5-f92c-4e7e-b798-2454f319f990",correct:"Rozhraní systémových volání je klíčové pro bezpečnou komunikaci mezi uživatelskými aplikacemi a jádrem operačního systému. Umožňuje aplikacím žádat o služby jádra, jako je přístup k hardwaru nebo souborovému systému, a to řízeným způsobem, který chrání systém před neoprávněným přístupem a zajišťuje integritu operačního systému.",incorrect:"Rozhraní systémových volání je klíčové pro přímou komunikaci mezi uživatelskými aplikacemi a hardwarem, obcházející jádro operačního systému. Umožňuje aplikacím žádat o zdroje hardwaru bez řízení jádra, což zvyšuje výkon, ale neposkytuje žádnou ochranu systému před neoprávněným přístupem a ohrožuje integritu operačního systému.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"8e4cef03-4194-47c2-87e7-bc64bee018a6",correct:"Pro provedení systémového volání musí uživatelská aplikace iniciovat přepnutí procesoru do privilegovaného režimu. Tento přepínač režimu není libovolný, ale je striktně kontrolován operačním systémem prostřednictvím mechanismu systémových volání, aby se zabránilo zneužití privilegovaného režimu uživatelským kódem a zachovala se bezpečnost systému.",incorrect:"Pro provedení systémového volání musí uživatelská aplikace iniciovat přepnutí procesoru do uživatelského režimu. Tento přepínač režimu je libovolný a není kontrolován operačním systémem, což umožňuje uživatelskému kódu snadno získat privilegovaný přístup a potenciálně narušit bezpečnost systému.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"2b69e9c3-3e3b-4ef8-8e11-43929427b568",correct:"Systémová volání jsou navržena tak, aby se co nejvíce podobala standardním podprogramům, které se běžně používají v systémových knihovnách. To znamená, že by měla umožňovat předávání argumentů do jádra a následné získávání návratových hodnot z jádra, podobně jako je tomu u běžných funkcí. Klíčovým aspektem systémových volání je bezpečnost, zejména zajištění, aby uživatelský prostor nemohl číst ani modifikovat paměť jádra během tohoto procesu.",incorrect:"Systémová volání se záměrně odlišují od standardních podprogramů a jejich cílem není napodobovat chování běžných funkcí. Proto systémová volání obvykle nepodporují předávání argumentů do jádra ani získávání návratových hodnot. Bezpečnostní aspekty, jako je ochrana paměti jádra před neoprávněným přístupem z uživatelského prostoru, nejsou u systémových volání relevantní, protože se předpokládá, že uživatelský prostor má plný přístup k paměti jádra.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"6647073e-8260-4885-9800-f337c4c1435e",correct:"Když program v uživatelském prostoru provede systémové volání, provádění se předá specifické rutině v jádře operačního systému. Součástí tohoto procesu je i předání argumentů, které uživatelský program chce, aby jádro zpracovalo. Po dokončení operace jádro vrátí uživatelskému programu návratovou hodnotu, která indikuje výsledek systémového volání. Celý tento mechanismus je navržen s ohledem na bezpečnost, aby se zabránilo neoprávněnému přístupu k paměti jádra.",incorrect:"Při systémovém volání se řízení programu předává zpět do uživatelského prostoru, nikoli do jádra operačního systému. Argumenty se předávají z jádra do uživatelského prostoru a návratová hodnota se také generuje v uživatelském prostoru. Bezpečnostní aspekty systémových volání se zaměřují na ochranu uživatelského prostoru před potenciálními hrozbami z jádra, a nikoli naopak, protože jádro je považováno za důvěryhodné.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"ece6bd3a-b3d5-4e10-bdfa-d433a57f053a",correct:"Bezpečnost proti spuštění libovolného kódu aplikací se dosahuje spojením eskalace privilegií, tedy vstupu do privilegovaného režimu CPU, se současným přenosem provádění na pevnou adresu, kterou aplikace nemůže změnit, protože tabulka obsluhy přerušení, která tuto adresu obsahuje, je chráněna mechanismy správy paměti a může být modifikována pouze v privilegovaném režimu.",incorrect:"Bezpečnost proti spuštění libovolného kódu aplikací se dosahuje spojením eskalace privilegií, tedy vstupu do privilegovaného režimu CPU, se současným přenosem provádění na pevnou adresu, kterou aplikace může snadno změnit, protože tabulka obsluhy přerušení, která tuto adresu obsahuje, je přístupná i v uživatelském režimu a aplikace ji může modifikovat dle potřeby.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"e5de74d3-1efe-4e44-9637-4c6f568ad82b",correct:"Na tradičních 32bitových procesorech x86 byla preferovanou metodou implementace systémového volání softwarová přerušení, která se vyvolávají instrukcí `int`. Tato instrukce způsobí, že procesor provede proces analogický hardwarovému přerušení, synchronně přepne do privilegovaného režimu a spustí obsluhu přerušení, která je definována v tabulce deskriptorů přerušení (IDT).",incorrect:"Na tradičních 32bitových procesorech x86 byla preferovanou metodou implementace systémového volání softwarová přerušení, která se vyvolávají instrukcí `iret`. Tato instrukce způsobí, že procesor provede proces analogický hardwarovému přerušení, asynchronně přepne do uživatelského režimu a spustí obsluhu přerušení, která je definována v tabulce globálních deskriptorů (GDT).",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"15c96221-961c-4f16-8213-c1d363389f4b",correct:"Mechanismus volání systémových služeb, ačkoliv se v principu drží univerzálního schématu zahrnujícího nastavení pevné vstupní adresy jádrem a použití specifické instrukce pro změnu režimu CPU a skok do jádra, je vysoce závislý na konkrétní architektuře procesoru a operačního systému, což znamená, že implementační detaily se mohou výrazně lišit mezi různými platformami.",incorrect:"Mechanismus volání systémových služeb je plně univerzální a nezávislý na architektuře procesoru a operačního systému, což znamená, že implementační detaily jsou identické na všech platformách. Princip zahrnuje dynamické nastavení vstupní adresy aplikací a použití obecné instrukce pro změnu režimu CPU a skok do jádra, což zajišťuje maximální přenositelnost kódu mezi systémy.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"4efd9cf2-7fa6-4323-b6b3-7c59100ea411",correct:"Mechanismus softwarových přerušení, používaný pro systémová volání, je charakteristický svou nižší efektivitou, která plyne z nutnosti ukládat rozsáhlý stav CPU. Tato vlastnost je dána tím, že mechanismus využívá hardwarových přerušení, což vede k ukládání většího množství stavu, než by bylo pro samotné systémové volání nezbytné, a to i přesto, že modernější architektury procesorů nabízejí specializované a efektivnější instrukce pro systémová volání.",incorrect:"Mechanismus softwarových přerušení, používaný pro systémová volání, je vysoce efektivní, protože minimalizuje ukládání stavu CPU a přímo využívá vyhrazené registry procesoru pro předávání argumentů. To představuje významnou výhodu oproti hardwarovým přerušením při implementaci služeb operačního systému a umožňuje dosáhnout vysoké propustnosti systémových volání s minimálním dopadem na výkon procesoru.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"08f81303-2600-4b2a-b19a-ed4da44eeabf",correct:"Mechanismus softwarových přerušení byl preferovaným způsobem, jakým operační systémy poskytovaly služby aplikacím na architektuře x86 až do konce 32bitové éry, a to i přesto, že procesory x86 již od modelu 80386 nabízely specializované instrukce pro systémová volání. Tyto specializované instrukce však nebyly operačními systémy široce využívány, a softwarová přerušení tak zůstala dominantní metodou pro systémová volání.",incorrect:"Mechanismus softwarových přerušení byl na architektuře x86 opuštěn již v raných dobách 32bitové éry ve prospěch specializovaných a efektivnějších instrukcí pro systémová volání, které procesory x86 nabízely již od modelu 80386. Operační systémy okamžitě začaly široce využívat tyto nové instrukce pro systémová volání, což vedlo k významnému zvýšení výkonu a efektivity zpracování systémových volání a k rychlému nahrazení softwarových přerušení.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"5a811074-6dd4-4cc7-9543-5279ad886b05",correct:"V kontextu softwarových přerušení, která se používají pro systémová volání, je jedním z důvodů snížené efektivity fakt, že adresa obslužné rutiny se získává z paměti, konkrétně z tabulky přerušení uložené v RAM. Tento postup způsobuje dodatečné zpoždění, protože procesor musí přistoupit do paměti pro získání adresy obslužné rutiny, což je méně efektivní ve srovnání s mechanismy, které by mohly mít adresu obslužné rutiny uloženou přímo v registru procesoru.",incorrect:"V kontextu softwarových přerušení, která se používají pro systémová volání, je klíčovým prvkem pro dosažení vysoké efektivity přímé uložení adresy obslužné rutiny v registru procesoru. Tento přístup eliminuje potřebu čtení z paměti a zrychluje tak zpracování systémových volání. Tabulka přerušení se v tomto mechanismu využívá pouze pro inicializaci systému, ale během běžného provozu systémových volání se k ní nepřistupuje, což zajišťuje minimální režii.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"968c2933-ca52-4622-b802-1121bef10578",correct:"Na rozdíl od softwarových přerušení, mechanismus volání systému pomocí instrukcí `sysenter` a `syscall` v architekturách x86-64 využívá pouze jediný vstupní bod, což zjednodušuje a zefektivňuje proces eskalace privilegií a odlišuje se tak od tradičního zpracování přerušení, kde může být vstupních bodů více. Tento jednotný vstupní bod přispívá k rychlejšímu provedení systémových volání.",incorrect:"Na rozdíl od softwarových přerušení, mechanismus volání systému pomocí instrukcí `sysenter` a `syscall` v architekturách x86-64 využívá více vstupních bodů, podobně jako je tomu u softwarových přerušení, což zajišťuje flexibilitu a komplexnější správu systému. Tento přístup s více vstupními body je srovnatelně rychlý s tradičním zpracováním přerušení.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"8cb6f4e4-af3c-44a7-82f1-1fd054d11bd5",correct:"Instrukce `sysenter` a `syscall` byly zavedeny v 64bitové architektuře x86 s cílem urychlit systémová volání oproti softwarovým přerušením. Toho je dosaženo mimo jiné tím, že správa stavu výpočtu je přesunuta do softwaru, což umožňuje kompilátorům optimalizovat ukládání a obnovování registrů, namísto automatického ukládání celého stavu CPU do paměti, jak je tomu u přerušení.",incorrect:"Instrukce `sysenter` a `syscall` byly zavedeny v 64bitové architektuře x86 s cílem zpomalit systémová volání v porovnání se softwarovými přerušeními. Toho je dosaženo mimo jiné tím, že správa stavu výpočtu je ponechána hardwaru, což vyžaduje, aby procesor automaticky ukládal celý stav CPU do paměti, podobně jako u přerušení, a kompilátory nemají možnost optimalizace ukládání registrů.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"8fa82435-ba31-4d17-a46e-0682795a1e7e",correct:"Mechanismus systémových volání pomocí instrukcí `sysenter` a `syscall` umožňuje kompilátorům významně optimalizovat výkon systémových volání tím, že se ukládá a obnovuje pouze malý počet registrů. Tato softwarová správa stavu kontrastuje s tradičními softwarovými přerušeními, kde CPU automaticky ukládá celý svůj stav do paměti, což představuje značnou režii a zpomaluje provádění systémových volání.",incorrect:"Mechanismus systémových volání pomocí instrukcí `sysenter` a `syscall` neumožňuje kompilátorům optimalizovat výkon systémových volání, protože se ukládá a obnovuje celý stav registrů procesoru. Tato hardwarová správa stavu je podobná tradičním softwarovým přerušením, kde CPU automaticky ukládá pouze malou část svého stavu do paměti, což minimalizuje režii a urychluje provádění systémových volání.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"f8566288-80fc-4220-bd23-fec7dce31825",correct:"V moderních operačních systémech, jako je Linux a Windows, existuje podstatně více systémových volání než typů přerušení. Počet systémových volání se pohybuje v stovkách, zatímco počet přerušení je mnohem menší. Všechna systémová volání obvykle sdílejí jediný vstupní bod, jako je například instrukce `sysenter`.",incorrect:"Ačkoli existuje mnoho systémových volání, jejich počet je srovnatelný s počtem typů přerušení v moderních operačních systémech, jako je Linux a Windows. Oba typy událostí mají stovky různých vstupních bodů, přičemž systémová volání i přerušení mají vyhrazené specifické vstupní adresy.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"f83c50ba-a5b9-4516-b0b4-9b855466fa2b",correct:"Pro zpracování systémových volání využívají moderní operační systémy, jako Linux a Windows, jednotný vstupní bod, například instrukci `sysenter`. Rozlišení mezi konkrétními požadavky na systémová volání se provádí na základě čísla systémového volání, které je předáno v registru procesoru.",incorrect:"Moderní operační systémy, jako je Linux a Windows, zpracovávají systémová volání tak, že pro každé systémové volání je přiřazen unikátní vstupní bod. To umožňuje jádru operačního systému přímo skočit na příslušnou obslužnou rutinu bez nutnosti zkoumat číslo systémového volání.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"9d556636-0ca8-4c9c-bfe3-590baaf6162f",correct:"První fází systémového volání, která se typicky odehrává v uživatelském režimu, je příprava argumentů pro systémové volání v knihovně ‹libc›.  Poté se číslo systémového volání uloží do určeného registru a procesor se přepne do privilegovaného režimu, čímž se řízení předá obslužné rutině systémových volání v jádře operačního systému.",incorrect:"První fází systémového volání, která se typicky odehrává v privilegovaném režimu, je příprava argumentů pro systémové volání v jádře operačního systému. Poté se číslo systémového volání uloží do určeného registru a procesor se přepne do uživatelského režimu, čímž se řízení předá obslužné rutině systémových volání v knihovně ‹libc›.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"9f0bea84-56a4-471c-9b10-c53330f57275",correct:"Po přepnutí do privilegovaného režimu jádro operačního systému analyzuje argumenty poskytnuté uživatelským programem a především určí, které systémové volání bylo požadováno. K tomuto účelu se v jádře často používá konstrukce `switch`, která na základě čísla systémového volání (sysnum) volá specifickou obslužnou rutinu, jako například `syscall_write()` pro systémové volání `SYS_write`.",incorrect:"Po přepnutí do privilegovaného režimu uživatelský program analyzuje argumenty poskytnuté jádrem operačního systému a především určí, které systémové volání bylo požadováno. K tomuto účelu se v uživatelském prostoru často používá konstrukce `switch`, která na základě čísla systémového volání (sysnum) volá specifickou obslužnou rutinu, jako například `syscall_write()` pro systémové volání `SYS_write`.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"1325bd4f-9162-4e44-9b5e-a018fb76609d",correct:"V moderních systémech, jako je například amd64 Linux, se argumenty systémových volání typicky předávají pomocí registrů procesoru, přičemž může být použito až šest registrů pro argumenty. Některé z těchto argumentů mohou být adresy paměti, které odkazují na další data, jako je například buffer pro operace čtení nebo zápisu.",incorrect:"V moderních systémech, jako je například amd64 Linux, se argumenty systémových volání typicky předávají pomocí zásobníku uživatelského prostoru, přičemž může být použito až šest položek zásobníku pro argumenty. Všechny argumenty jsou přímo data, a nikdy se nepoužívají adresy paměti pro předávání složitějších datových struktur jako buffery.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"33efcd96-f142-479b-9451-65199deb81d7",correct:"Správa paměti a správa procesů jsou považovány za klíčové odpovědnosti jádra operačního systému a jejich implementace je zřídka delegována na externí služby kvůli jejich zásadní povaze pro chod systému a nutnosti úzké integrace s hardwarem.",incorrect:"Správa paměti a správa procesů, ačkoli jsou důležité pro operační systém, jsou často outsourcovány externím službám v moderních mikrokernelových architekturách, aby se zlepšila modularita a stabilita systému, což je běžný přístup v současných operačních systémech.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"b47f3355-3462-426a-879e-2f7046430091",correct:"Zatímco ovladače zařízení, souborové systémy a sítě jsou základními službami kompletního operačního systému, nejsou vždy považovány za klíčové odpovědnosti jádra a mohou být implementovány mimo jádro v některých návrzích operačních systémů, zejména v mikrokernelech, ačkoli jejich absence v moderním univerzálním OS je nepravděpodobná.",incorrect:"Ovladače zařízení, souborové systémy a sítě jsou vždy implementovány jako nedílná součást jádra operačního systému ve všech moderních architekturách operačních systémů, aby byla zajištěna optimální výkonnost a bezpečnost systému a nelze si představit moderní operační systém bez jejich integrace v jádře.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"77babdd0-d0d8-42c7-b9fb-9156d8dde726",correct:"Moderní univerzální operační systémy typicky zahrnují správu paměti, plánování procesů, ovladače zařízení, souborové systémy a síťové funkce, aby poskytovaly komplexní výpočetní prostředí pro uživatele a aplikace, a ačkoli některé služby nemusí být striktně součástí jádra, jsou nezbytné pro funkčnost OS.",incorrect:"Moderní univerzální operační systémy často vylučují funkce souborového systému a sítí ze svých základních služeb a spoléhají se místo toho na externí knihovny a programy uživatelského prostoru pro zpracování těchto aspektů provozu systému, čímž se jádro stává štíhlejším a efektivnějším.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"57416d8a-def2-493e-b09c-a87721808391",correct:"V tradičních monolitických návrzích operačních systémů jsou všechny základní služby, včetně správy paměti, plánování procesů, ovladačů zařízení, souborových systémů a sítí, integrovány přímo do jádra, aby se dosáhlo těsné integrace a potenciálně vyššího výkonu, ačkoli to může vést ke složitější a méně modulární struktuře.",incorrect:"Monolitické návrhy operačních systémů typicky oddělují základní služby, jako jsou souborové systémy a sítě, od jádra a implementují je jako nezávislé moduly, aby se zvýšila stabilita systému a zjednodušil vývoj jádra, což je klíčový rozdíl oproti mikrokernelovým architekturám.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"a9e49084-c5e8-4af0-8f07-0a76760dc458",correct:"Zatímco monolitická jádra operačních systémů mohou implementovat různé doplňkové služby, interprocesní komunikace (IPC) představuje službu, která je téměř univerzálně přítomna v monolitických jádrech a je považována za natolik zásadní, že se v nějaké formě objevuje i v mikrokernelech, přestože konkrétní implementace a význam IPC mechanismů se mohou lišit mezi monolitickými a mikrokernelovými architekturami, přičemž v mikrokernelech hraje IPC obvykle ještě významnější roli.",incorrect:"Interprocesní komunikace (IPC) je služba, která se sice může vyskytovat v některých monolitických jádrech operačních systémů, avšak není považována za klíčovou součást monolitické architektury a její přítomnost je spíše výjimkou než pravidlem, protože monolitická jádra se primárně zaměřují na integraci jiných doplňkových služeb, zatímco IPC je doménou mikrokernelových systémů, kde je implementována mnohem častěji a s větším důrazem na její efektivitu.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"25af4ad8-bfb9-4a67-bf7c-6123de5c2eed",correct:"Monolitická jádra operačních systémů jsou charakteristická tím, že mohou integrovat široké spektrum doplňkových služeb přímo do jádra, což zahrnuje například správu časovačů, nástroje pro sledování a profilování procesů, bezpečnostní funkce a kryptografické služby, nicméně rozsah a konkrétní implementace těchto služeb se mohou značně lišit mezi různými monolitickými operačními systémy v závislosti na jejich specifických požadavcích a designových cílech.",incorrect:"Monolitická jádra operačních systémů se vyznačují striktním omezením na implementaci pouze základních služeb nezbytných pro fungování systému, a proto typicky neintegrují doplňkové služby jako správu časovačů, sledování procesů nebo kryptografické funkce, protože tyto pokročilé funkce jsou vyhrazeny pro mikrokernelové architektury, které se specializují na modulární a rozšiřitelné operační systémy s bohatou sadou funkcí mimo základní jádro.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"c00f106b-e3f6-4de8-bc23-706c6124c4d0",correct:"Microkernel systémy se vyznačují malým jádrem, které poskytuje pouze služby, jež nelze rozumně implementovat mimo něj. Chybějící funkce operačního systému jsou implementovány mimo mikrokernel, a to buď pomocí superserveru v hybridních systémech, nebo pomocí specializovaných programů v systémech s pravým mikrokernelem.",incorrect:"Microkernel systémy se vyznačují velkým jádrem, které poskytuje všechny služby operačního systému. Chybějící funkce operačního systému jsou implementovány uvnitř mikrokernelu, a to vždy pomocí superserveru, který je charakteristický pro všechny typy mikrokernel systémů, včetně systémů s pravým mikrokernelem.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"fc7d4847-4a38-4b3e-9c5f-e6d1b9959a15",correct:"Hybridní mikrokernel systémy, které využívají superserver, jsou často rychlejší než systémy s pravým mikrokernelem, protože komunikace mezi komponentami v superserveru nevyžaduje přepínání kontextu. Nicméně, systémy s pravým mikrokernelem, kde jsou služby a ovladače striktně odděleny do individuálních procesů, jsou robustnější a teoreticky lépe škálují na rozsáhlé SMP systémy.",incorrect:"Hybridní mikrokernel systémy, které využívají superserver, jsou pomalejší než systémy s pravým mikrokernelem, protože komunikace mezi komponentami v superserveru vyžaduje časté přepínání kontextu. Na druhou stranu, systémy s pravým mikrokernelem, i když jsou méně robustní, se lépe škálují na rozsáhlé SMP systémy díky sdílenému adresnímu prostoru všech služeb.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"4bc9c774-740f-4521-b67d-ce57d9f8e1fa",correct:"Z pohledu uživatelského prostoru by specifika architektury jádra operačního systému neměla být relevantní. Aplikace využívají systémové knihovny pro komunikaci s jádrem, přičemž tyto knihovny implementují protokoly pro lokalizaci relevantních serverů a interakci s nimi, čímž se skrývají mechanismy volání služeb.",incorrect:"Z pohledu uživatelského prostoru je klíčové, aby aplikace detailně znaly specifika architektury jádra operačního systému, včetně toho, který server poskytuje jakou službu. Aplikace přímo komunikují s jádrem a samy musí implementovat protokoly pro vyhledání serverů a interakci s nimi, bez abstrakce mechanismů volání služeb.",sectionNumber:"11.5.4",sectionTitle:"Kernel Services"},{uuid:"b05e38ca-4a6e-4330-b6f9-5919ab065ffc",correct:"Programy se obvykle nestarají o to, který konkrétní server poskytuje požadovanou službu. Pro služby operačního systému je typický monolitický pohled, kde jsou služby využívány prostřednictvím systémových knihoven, a mechanismus volání je plně abstrahován na úrovni uživatelského prostoru.",incorrect:"Programy se musí aktivně starat o to, který konkrétní server poskytuje požadovanou službu. Pro služby operačního systému je typický distribuovaný pohled, kde aplikace přímo komunikují s různými servery jádra, a mechanismus volání je plně odhalen na úrovni uživatelského prostoru bez abstrakce.",sectionNumber:"11.5.4",sectionTitle:"Kernel Services"},{uuid:"d4cbeb90-88ae-4a27-b9fd-1d65b0d2c910",correct:"Zatímco ovladače tiskáren často zahrnují komponenty v uživatelském prostoru operačního systému, jako je zpracování dokumentů a konverze formátů, základní komunikace s tiskárnou na úrovni USB je typicky zprostředkována jádrem operačního systému, a to i v systémech s monolitickým jádrem.",incorrect:"Zatímco ovladače tiskáren často zahrnují komponenty v uživatelském prostoru operačního systému, jako je zpracování dokumentů a konverze formátů, základní komunikace s tiskárnou na úrovni USB je typicky zprostředkována uživatelským prostorem operačního systému, a to i v systémech s monolitickým jádrem.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"d8a7086a-e41f-4229-9e87-501e185ed5d5",correct:"Grafické ovladače v moderních operačních systémech typicky rozdělují svou funkčnost mezi jádro a uživatelský prostor, přičemž jádro se stará o správu paměti a výstupu a poskytuje nízkoúrovňový přístup k hardwaru GPU, zatímco uživatelský prostor hostí komplexnější operace jako kompilaci shaderů a manipulaci s 3D scénami.",incorrect:"Grafické ovladače v moderních operačních systémech typicky soustředí veškerou svou funkčnost výhradně v jádře operačního systému, čímž zajišťují maximální výkon a minimalizují režii spojenou s přepínáním kontextu do uživatelského prostoru, a to i pro operace jako kompilace shaderů a manipulaci s 3D scénami.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"85bfabab-9a59-4a8f-b096-abea3d0ee9bb",correct:"V operačních systémech založených na monolitickém jádře, i když většina ovladačů zařízení běží v prostoru jádra, existují významné výjimky, jako jsou ovladače tiskáren a grafických karet, které mají rozsáhlé komponenty běžící v uživatelském prostoru, což umožňuje větší flexibilitu a modularitu.",incorrect:"V operačních systémech založených na monolitickém jádře běží naprostá většina ovladačů zařízení výhradně v prostoru jádra a neexistují žádné významné výjimky, přičemž veškerá komunikace a zpracování, včetně ovladačů tiskáren a grafických karet, probíhá kompletně v jádře pro maximální výkon.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"}]},{uuid:"6e647c0d-30a2-455a-8e38-c3ed6e8a4140",sectionNumber:"12",sectionTitle:"OS Virtualization",statements:[{uuid:"4c442e79-f152-4a96-89aa-9da68477e434",correct:"Hypervisor, označovaný také jako monitor virtuálních strojů, umožňuje spouštění více operačních systémů současně a funguje jako kernel, který spouští další kernely. Tímto způsobem hypervisor zlepšuje využití hardwarových zdrojů, protože umožňuje efektivnější sdílení fyzického hardwaru mezi různými virtuálními stroji.",incorrect:"Hypervisor, označovaný také jako monitor virtuálních strojů, je zodpovědný za přímou správu fyzického hardwaru a neumožňuje spouštění více operačních systémů. Funguje jako standardní aplikace v rámci operačního systému a jeho hlavním účelem je izolace procesů běžících v jednom operačním systému.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"6a1b41ae-3504-4ea3-9785-0cab0315d915",correct:"Hypervisor se chová podobně jako kernel operačního systému, protože stojí mezi fyzickým hardwarem a virtualizovanými operačními systémy. Virtualizované operační systémy, které běží nad hypervisorem, jsou podobné procesům a jsou izolovány v fyzické paměti pomocí MMU a softwarových technik nebo MMU s podporou překladu druhé úrovně.",incorrect:"Hypervisor se chová spíše jako standardní aplikace operačního systému a nemá žádný vztah k jádru operačního systému. Virtualizované operační systémy, které běží nad hypervisorem, sdílejí stejný paměťový prostor a nejsou izolovány v fyzické paměti, což zjednodušuje komunikaci a sdílení dat mezi nimi.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"05c73b4e-0544-4fc8-99ef-1e1117124a4f",correct:"Virtualizované operační systémy nabízejí vyšší míru autonomie než tradiční systémy sdílené více uživateli, což je primárně způsobeno zjednodušeným rozhraním mezi hypervizorem a operačním systémem. Toto rozhraní záměrně postrádá sofistikované mechanismy pro správu uživatelů a sdílení souborů, které jsou běžné v klasických operačních systémech, a omezuje se na poskytování základních hardwarových zdrojů virtuálním strojům.",incorrect:"Virtualizované operační systémy poskytují srovnatelnou úroveň autonomie s tradičními systémy sdílenými více uživateli, jelikož rozhraní mezi hypervizorem a operačním systémem je navrženo tak, aby emulovalo komplexní funkce tradičních operačních systémů, včetně pokročilé správy uživatelů a detailního řízení sdílení souborů, čímž se stírají rozdíly v autonomii mezi oběma typy prostředí.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"bc03300e-91ae-4c4f-ac16-de908133d616",correct:"Zásadní charakteristikou rozhraní mezi hypervizorem a operačním systémem je jeho relativní jednoduchost v porovnání s rozhraním mezi operačním systémem a aplikacemi. Tato jednoduchost pramení z absence nutnosti implementovat rozsáhlé subsystémy pro správu souborů a komplexní komunikační protokoly mezi operačními systémy, což jsou klíčové komponenty tradičních operačních systémů zajišťující sdílení a izolaci.",incorrect:"Rozhraní mezi hypervizorem a operačním systémem se vyznačuje vysokou mírou komplexity, srovnatelnou s rozhraním mezi operačním systémem a aplikacemi, neboť hypervizor musí implementovat detailní správu souborových systémů a propracované komunikační mechanismy mezi operačními systémy. Tato komplexita je nezbytná pro zajištění robustního sdílení zdrojů a přísné izolace virtuálních strojů, podobně jako v tradičních operačních systémech.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"e40984df-939e-4b56-9831-aed2098d813c",correct:"Operační systémy využívají virtualizaci hardwarových zdrojů, jako je paměť spravovaná MMU a periferie virtualizované samotným operačním systémem, aby zjednodušily správu zdrojů a umožnily izolaci mezi různými komponentami systému. Tato virtualizace je klíčová pro bezpečné a spravedlivé sdílení zdrojů mezi více programy a uživateli.",incorrect:"Operační systémy se spoléhají výhradně na fyzické zdroje bez virtualizace, přičemž MMU a operační systém hrají minimální roli v abstrakci hardwaru. Správa zdrojů a izolace komponent jsou dosahovány jinými mechanismy, a virtualizace hardwaru není považována za klíčovou pro sdílení zdrojů mezi programy a uživateli.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"10b6a803-b9e7-415e-8a88-9a3442e03616",correct:"Virtualizace v operačních systémech se neomezuje pouze na správu paměti pomocí MMU a periferií, ale zahrnuje i další klíčové komponenty, jako jsou souborové systémy, síťový zásobník a ovladače zařízení. Tyto komponenty operačního systému virtualizují hardwarové zdroje, což umožňuje efektivní a bezpečné sdílení těchto zdrojů mezi různými procesy a uživateli.",incorrect:"Virtualizace v operačních systémech se omezuje výhradně na virtualizaci paměti pomocí MMU a virtualizaci periferií. Ostatní komponenty operačního systému, jako jsou souborové systémy, síťový zásobník a ovladače zařízení, nemají s virtualizací nic společného a pracují přímo s fyzickým hardwarem, bez jakékoli abstrakce.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"90076b5d-b09a-42b3-906b-826f0fe0ef08",correct:'Hypervizory typu 1, často označované jako "bare metal" hypervizory, jsou navrženy pro nasazení přímo na fyzickém hardwaru, čímž minimalizují softwarovou vrstvu pod hypervizorem. Tato architektura jim umožňuje fungovat na způsob mikrokernelu, kde hypervizor přebírá primární zodpovědnost za správu klíčových systémových prostředků, především procesoru a operační paměti, a zajišťuje jejich efektivní plánování a alokaci pro virtuální stroje.',incorrect:'Hypervizory typu 1, známé také jako "hosted" hypervizory, vyžadují pro své nasazení existenci hostitelského operačního systému, na kterém běží jako aplikace. Tato závislost na hostitelském systému jim umožňuje delegovat správu hardwarových prostředků, včetně plánování procesoru a správy paměti, na hostitelský operační systém, čímž se zjednodušuje jejich implementace a správa.',sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"a87f6075-07d2-48ae-9575-b79bdb56c309",correct:"Hypervizory typu 2, na rozdíl od hypervizorů typu 1, jsou hostované a vyžadují pro svou funkčnost operační systém, na kterém běží jako běžné aplikace. V důsledku toho hypervizory typu 2 využívají stávající mechanismy hostitelského operačního systému pro plánování výpočetního času procesoru a správu paměti, což se projevuje tím, že virtuální stroje jsou v hostitelském systému reprezentovány jako standardní procesy operačního systému.",incorrect:"Hypervizory typu 2, podobně jako hypervizory typu 1, jsou navrženy tak, aby běžely přímo na fyzickém hardwaru bez nutnosti hostitelského operačního systému. Díky této architektuře si hypervizory typu 2 mohou plně samy řídit plánování procesoru a správu paměti pro virtuální stroje, čímž dosahují vyššího výkonu a izolace virtuálních strojů od hostitelského systému.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"e4f388fa-987d-4da2-8c6b-8cf22af20a5e",correct:"Rozdíl mezi hypervizory typu 1 a typu 2 spočívá v jejich architektonickém umístění v systému. Zatímco hypervizory typu 1 pracují přímo na hardwaru a samy spravují přidělování procesorového času a paměti virtuálním strojům, hypervizory typu 2 jsou závislé na hostitelském operačním systému, kterému delegují správu těchto zdrojů, a virtuální stroje se tak chovají jako procesy v rámci hostitelského operačního systému.",incorrect:"Rozdíl mezi hypervizory typu 1 a typu 2 je minimální, oba typy hypervizorů pracují na stejném principu abstrakce hardwaru a oba vyžadují pro svůj běh hostitelský operační systém. Hypervizory obou typů se liší pouze v detailech implementace, ale z pohledu funkcionality a správy virtuálních strojů jsou v podstatě identické a nabízejí srovnatelné vlastnosti a výkon.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"8f0313f0-f2ac-496c-9e1c-87a01a92e0ff",correct:"Virtualizační technologie, jak naznačuje výčet bare metal hypervizorů zahrnující z/VM, Xen, Hyper-V a ESX, umožňují operačním systémům běžet přímo na hardwaru, efektivně obcházejí tradiční hostitelský operační systém a poskytují tak virtualizační vrstvu, která spravuje hardwarové zdroje a alokuje je virtuálním strojům.",incorrect:"Virtualizační technologie, jak naznačuje výčet bare metal hypervizorů zahrnující VMWare a VirtualBox, vyžadují pro svůj běh hostitelský operační systém, na kterém jsou postaveny, a nemohou tak přímo interagovat s hardwarem, což je zásadní rozdíl oproti hosted hypervizorům, které běží přímo na fyzickém hardwaru.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"d2939542-fd0d-4950-ba64-d0f157251987",correct:"Historie virtualizace sahá až do pozdních 60. let 20. století, kdy společnost IBM představila systémy CP/CMS v roce 1968 a VM/370 v roce 1972, čímž položila základy pro moderní virtualizační technologie a umožnila provoz více operačních systémů na jednom fyzickém počítači, což se stalo standardem zejména u sálových počítačů.",incorrect:"Historie virtualizace se datuje až od počátku 21. století s rozvojem cloudových technologií a komerčním rozšířením hypervizorů jako VMware ESXi a Microsoft Hyper-V, přičemž dřívější systémy jako CP/CMS a VM/370 neměly s virtualizací operačních systémů nic společného a sloužily k úplně jiným účelům v oblasti sálových počítačů.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"eebd1efe-f72c-4792-b4ca-6dfb48bd56c6",correct:"Podle dostupných informací, hardware architektury x86 v raných dobách nepodporoval virtualizační technologie založené na virtualizaci supervizorského režimu, což znamenalo, že pro virtualizaci bylo nutné spoléhat se na softwarové emulační techniky.",incorrect:"Podle dostupných informací, hardware architektury x86 již od raných dob plně podporoval virtualizační technologie založené na virtualizaci supervizorského režimu, což umožňovalo efektivní a výkonnou virtualizaci bez nutnosti softwarové emulace.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"552e5579-d23c-47bd-8978-f1ca05c82b5a",correct:"Dle poskytnutého textu se softwarově orientovaná řešení pro virtualizaci stala životaschopnými až koncem 90. let dvacátého století, protože do té doby nebyl výkon procesorů PC dostatečný pro efektivní emulaci PC na PC.",incorrect:"Dle poskytnutého textu se softwarově orientovaná řešení pro virtualizaci stala životaschopnými již v raných 90. letech dvacátého století, protože výkon procesorů PC byl již tehdy dostatečný pro efektivní emulaci PC na PC.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"045f5685-7d65-4df0-92ea-34a7796f15da",correct:"Zmiňované softwary pro virtualizaci, konkrétně Bochs, VMWare a QEMU, se objevily postupně v letech 1994, 1999 a 2003, což ilustruje postupný vývoj a zlepšování softwarových virtualizačních řešení pro PC platformu.",incorrect:"Zmiňované softwary pro virtualizaci, konkrétně Bochs, VMWare a QEMU, byly všechny uvedeny na trh v roce 1994, což demonstruje rychlý nástup a okamžitou dominanci softwarových virtualizačních řešení pro PC platformu již v raných devadesátých letech.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"7b6688bf-bc22-4374-b288-b88db9b8f92c",correct:"Paravirtualizace, představená společností VMWare v roce 2005 pod názvem VMI, představuje softwarovou virtualizační technologii, která dosahuje výkonu blížícího se nativnímu výkonu, a to i bez hardwarové podpory pro virtualizaci, avšak za cenu nutnosti modifikace hostovaného operačního systému, což bylo v době jejího vzniku usnadněno rostoucí popularitou open-source operačních systémů.",incorrect:"Paravirtualizace, představená společností VMWare v roce 2005 pod názvem VMI, představuje hardwarovou virtualizační technologii, která dosahuje výkonu blížícího se nativnímu výkonu, a to i bez softwarové podpory pro virtualizaci, a nevyžaduje modifikace hostovaného operačního systému, což bylo v době jejího vzniku usnadněno rostoucí popularitou proprietárních operačních systémů.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"7a4797a4-69b2-4862-89b7-f0600580a23a",correct:"Zatímco plná virtualizace se snaží o emulaci celého hardwarového rozhraní pro hostovaný operační systém, paravirtualizace, alternativní přístup zavedený například v systému Xen v roce 2006, spočívá v modifikaci hostovaného operačního systému tak, aby mohl efektivněji komunikovat s hypervizorem, a tím dosáhnout vyššího výkonu bez nutnosti specifické hardwarové podpory.",incorrect:"Zatímco plná virtualizace vyžaduje modifikaci hardwarového rozhraní pro hostovaný operační systém, paravirtualizace, alternativní přístup zavedený například společností VMWare v roce 2005, spočívá v emulaci hostovaného operačního systému tak, aby mohl efektivněji komunikovat s hypervizorem, a tím dosáhnout nižšího výkonu s nutností specifické hardwarové podpory.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"76dd9d09-ee53-4cad-8347-f64623b11e44",correct:"Kolem roku 2005 se začaly objevovat virtualizační rozšíření pro architekturu x86, což znamenalo posun směrem k možnosti provozovat hostované operační systémy bez nutnosti jejich přímé modifikace, alespoň v teoretické rovině, a to díky hardwarové podpoře virtualizace.",incorrect:"Kolem roku 2005 se začaly objevovat virtualizační rozšíření pro architekturu x86, ale toto nemělo vliv na potřebu modifikace hostovaných operačních systémů, a dokonce i v teoretické rovině zůstávala nutnost úprav pro správný běh virtualizace zachována.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"31c603ba-895c-458b-bd8b-91a10e9f5628",correct:"Zavedení MMU virtualizace kolem roku 2008 do běžných desktopových procesorů přineslo významné zjednodušení v návrhu hypervizorů pro architekturu x86. Tato inovace také přispěla ke zvýšení celkové efektivity virtualizace, což umožnilo lepší výkon virtualizovaných systémů.",incorrect:"Zavedení MMU virtualizace kolem roku 2008 do běžných desktopových procesorů paradoxně zkomplikovalo návrh hypervizorů pro architekturu x86. Tato inovace navíc vedla ke snížení celkové efektivity virtualizace a zhoršení výkonu virtualizovaných systémů.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"edef9650-4625-4764-954f-ba599ddf49d3",correct:"S nástupem hardwarové virtualizace a zejména MMU virtualizace se softwarová řešení virtualizace, která vyžadovala modifikaci hostovaného operačního systému, stala do značné míry zastaralá. Důvodem byla nižší efektivita a vyšší složitost těchto softwarových přístupů v porovnání s novými hardwarově akcelerovanými metodami.",incorrect:"S nástupem hardwarové virtualizace a zejména MMU virtualizace se softwarová řešení virtualizace, která vyžadovala modifikaci hostovaného operačního systému, stala ještě více relevantní a rozšířená. Důvodem byla vyšší efektivita a jednoduchost těchto softwarových přístupů v porovnání s novými hardwarově akcelerovanými metodami.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"8bafeaf8-e82f-431c-8da1-6ed3309b4f4b",correct:"Paravirtualizace využívá specifické ovladače pro virtualizovaná zařízení, jako jsou bloková úložiště, sítě a konzole, a je navržena tak, aby byla rychlejší a jednodušší než emulace, přičemž funguje nezávisle na virtualizaci CPU a MMU, což umožňuje efektivnější správu periferních zařízení ve virtualizovaném prostředí.",incorrect:"Paravirtualizace, na rozdíl od plné virtualizace, vyžaduje rozsáhlé modifikace jádra hostovaného operačního systému, aby bylo možné implementovat specializované ovladače pro interakci s virtualizovaným hardwarem, čímž se stává méně transparentní pro hostovaný operační systém a zvyšuje se složitost správy virtualizovaného prostředí.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"08bc237f-cc91-4e9a-9a84-91eb780a0a37",correct:"Zatímco hardwarová virtualizace efektivně řeší virtualizaci CPU a paměti, paravirtualizace se ukázala jako praktické řešení pro virtualizaci periferních zařízení, protože hardwarový přístup k virtualizaci periférií se ukázal jako neekonomický, a paravirtualizace tak nabízí nákladově efektivnější alternativu.",incorrect:"Paravirtualizace byla původně navržena jako univerzální metoda pro všechny formy virtualizace, včetně CPU, paměti a periférií, ale byla postupně nahrazena hardwarovou virtualizací kvůli svým inherentním výkonnostním omezením a komplexnosti při správě rozmanitých hardwarových interakcí.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"895d63d5-f27a-4207-b71c-bfa345968f8f",correct:"Klíčovou výhodou paravirtualizace je její schopnost prezentovat virtuální periferní zařízení hostovanému operačnímu systému tak, jakoby se jednalo o standardní hardwarová zařízení, čehož je dosaženo implementací běžných ovladačů zařízení v hostovaném systému, které komunikují s virtuálními periferiemi hostitelského systému pomocí definovaných protokolů.",incorrect:"Paravirtualizace vyžaduje rozsáhlé úpravy jádra hostovaného operačního systému, včetně integrace specializovaného kódu, který je vědom hypervizoru a přímo interaguje s podkladovým hardwarem, obchází potřebu standardních ovladačů zařízení a vede k výraznému zvýšení složitosti údržby hostovaného operačního systému.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"b8cc7550-20cd-4a8e-af42-f1ee32550b89",correct:"Virtuální stroje, často označované jako virtuální počítače, představují systémy běžící pod virtualizovaným operačním systémem. Tyto stroje se liší od programových virtuálních strojů, jako je Java Virtual Machine, a obvykle poskytují základní výpočetní zdroje, mezi které patří procesor, operační paměť, trvalé blokové úložiště, síťové připojení a konzolové zařízení pro správu. Správa virtuálních strojů je považována za jednodušší ve srovnání se správou fyzického hardwaru, což z nich činí preferovanou volbu v mnoha prostředích.",incorrect:"Virtuální stroje, ačkoli se někdy označují jako virtuální počítače, představují systémy běžící přímo na fyzickém hardwaru bez virtualizace operačního systému. Tyto stroje jsou totožné s programovými virtuálními stroji, jako je Java Virtual Machine, a poskytují širokou škálu periferních zařízení, zatímco základní výpočetní zdroje, jako je procesor, operační paměť, a trvalé blokové úložiště, jsou volitelné. Správa virtuálních strojů je obvykle složitější než správa fyzického hardwaru, což omezuje jejich využití v moderních výpočetních prostředích.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"7c3da5b7-ed84-4331-8812-c88cf6273963",correct:"V kontextu virtualizace, koncept virtuálního stroje zahrnuje virtualizaci všech aspektů počítačového systému, ať už prostřednictvím hardwarových technologií jako VT-x a EPT, nebo softwarových řešení jako QEMU a ‹virtio›. Typický virtuální stroj je navržen tak, aby poskytoval klíčové zdroje nezbytné pro běh operačního systému a aplikací, přičemž mezi tyto zdroje standardně patří procesor, operační paměť RAM, blokové úložiště pro ukládání dat a souborových systémů, síťové rozhraní a konzolové rozhraní pro administraci a monitorování.",incorrect:"V kontextu virtualizace se koncept virtuálního stroje omezuje pouze na virtualizaci procesoru, přičemž ostatní komponenty počítačového systému, jako je operační paměť a úložiště, zůstávají fyzické a nesdílené.  Virtuální stroje se obvykle zaměřují na poskytování širokého spektra periferních zařízení, zatímco klíčové zdroje, jako je procesor a RAM, jsou emulovány pouze okrajově a nejsou považovány za nezbytné pro funkčnost virtuálního stroje. Správa těchto strojů je záměrně komplikovaná pro zvýšení bezpečnosti.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"d190a1b1-9469-466a-9003-e812feba0156",correct:"Hypervisor, který je klíčovou součástí virtualizačního prostředí, implementuje plánovač procesů. Tento plánovač se sice řídí podobnými principy jako běžné plánovače operačních systémů, avšak je navržen s odlišnými kompromisy a je obecně jednodušší, aby minimalizoval režii virtualizace a maximalizoval výkon virtuálních strojů.",incorrect:"Hypervisor, jakožto součást virtualizačního prostředí, neobsahuje vlastní plánovač procesů. Místo toho se spoléhá na plánovač hostitelského operačního systému, který přímo řídí běh virtuálních strojů, čímž se snižuje komplexita hypervisoru a zlepšuje celkový výkon virtualizace.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"2fd6459c-8ec4-434a-96e0-32110495191e",correct:"Většina instrukcí, zejména těch, které jsou běžně dostupné uživatelským programům, je procesorem hostitele vykonávána přímo, bez nutnosti zásahu hypervisoru. Nicméně, hypervisor hraje klíčovou roli při zpracování privilegovaných instrukcí. Když procesor narazí na privilegovanou instrukci, je provedení této instrukce zachyceno a předáno hypervisoru, který provede potřebné akce v softwaru, aby zajistil správnou virtualizaci.",incorrect:"Všechny instrukce, včetně privilegovaných instrukcí, jsou procesorem hostitele vykonávány přímo, bez zásahu hypervisoru. Hypervisor se stará pouze o správu virtualizované paměťové jednotky (MMU), ale do samotného provádění instrukcí nezasahuje, což zajišťuje maximální výkon a minimalizuje režii virtualizace.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"9dfa9d5c-7092-479b-ad9d-201fadf1ac21",correct:"Hypervisor v virtualizačním prostředí aktivně spravuje virtualizovanou paměťovou jednotku (MMU). Tato správa je klíčová pro izolaci a bezpečnost virtuálních strojů, protože hypervisor kontroluje přístup virtuálních strojů k fyzické paměti a zajišťuje, že virtuální stroje nemohou navzájem interferovat nebo narušit hostitelský systém.",incorrect:"Hypervisor v virtualizačním prostředí se nezabývá správou virtualizované paměťové jednotky (MMU). Správa paměti je plně v kompetenci hostitelského operačního systému, který přímo řídí alokaci a ochranu paměti pro všechny virtuální stroje, čímž se zjednodušuje architektura hypervisoru.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"5445d3cd-3aef-46e2-908a-09157223a2be",correct:"Softwarová virtualizace paměti, známá jako stínové tabulky stránek, implementuje virtualizaci paměti tak, že hostovaný operační systém nemůže přímo přistupovat k MMU. Místo toho se používá stínová tabulka stránek, která je pro hosta neviditelná, a tabulky stránek hosta jsou synchronizovány s touto stínovou tabulkou prostřednictvím VMM, což umožňuje efektivní správu paměti a izolaci virtuálních strojů.",incorrect:"Softwarová virtualizace paměti, známá jako stínové tabulky stránek, implementuje virtualizaci paměti tak, že hostovaný operační systém má plný a přímý přístup k MMU. Stínové tabulky stránek se používají pouze pro optimalizaci výkonu a nemají vliv na izolaci hostovaných systémů, protože hostovaný operační systém spravuje paměť nezávisle na hypervizoru.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"bc5dbedf-46db-4cc6-9186-fe3506c2de39",correct:"Hardwarová virtualizace paměti, konkrétně druhá úroveň překladu, představuje hardwarově asistovanou virtualizaci MMU, která přidává vrstvu překladu z guest-fyzické na host-fyzickou adresu. Toto řešení významně zjednodušuje VMM a je výrazně rychlejší než stínové tabulky stránek, protože snižuje režii spojenou s častými zachyceními změn tabulek stránek hostovaného operačního systému.",incorrect:"Hardwarová virtualizace paměti, konkrétně druhá úroveň překladu, je softwarové řešení, které emuluje hardwarovou MMU a nepřidává žádnou další vrstvu překladu adres. Toto řešení je srovnatelné co do výkonu se stínovými tabulkami stránek a složitost VMM zůstává stejná, protože veškerá správa paměti je stále prováděna softwarově hypervizorem.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"a9bb9f06-14aa-417c-a9db-4ed579d23e82",correct:"Virtualizace paměti, podobně jako virtualizace CPU, je založena na základních principech, které standardní operační systémy používají k izolaci procesů. Paměť je rozdělena na stránky a MMU provádí hlavní část práce spojené s překladem adres, což umožňuje efektivní sdílení paměti a izolaci virtuálních strojů od sebe navzájem a od hypervizoru.",incorrect:"Virtualizace paměti se zásadně liší od virtualizace CPU a nepoužívá principy izolace procesů. Paměť není rozdělena na stránky a překlad adres neprobíhá pomocí MMU. Virtualizace paměti se spoléhá na monopolní přístup každého virtuálního stroje k fyzické paměti, což zajišťuje maximální výkon, ale snižuje izolaci a efektivitu sdílení zdrojů.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"5df7b897-cb6e-42fb-a45f-0dd38d42cb72",correct:"Virtualizační řešení v moderních systémech využívají paravirtualizované síťové karty, které slouží k přenosu síťových rámců mezi hostovaným operačním systémem a hostitelským systémem, přičemž tyto karty jsou typicky připojeny k softwarovému mostu v hostitelském systému, ačkoli alternativně může být použito i routování nebo NAT.",incorrect:"Virtualizační řešení v moderních systémech využívají fyzické síťové karty, které jsou přímo sdíleny mezi hostovaným operačním systémem a hostitelským systémem, a nevyužívají žádné virtuální komponenty, přičemž tyto karty jsou typicky připojeny k hardwarovému mostu v hostitelském systému, a alternativně může být použito pouze NAT.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"e232b5cc-3a84-4a8e-ba5b-926299d11930",correct:"V současných virtualizačních řešeních je síťová komunikace realizována pomocí paravirtualizované síťové karty, která je propojena s pseudozařízením typu Ethernet tunel v hostitelském systému, což je v podstatě virtuální síťová karta zpracovávající Ethernetové rámce, kde rámce odeslané na paravirtualizovaném zařízení se objeví na virtuální síťové kartě v hostiteli a naopak.",incorrect:"V současných virtualizačních řešeních je síťová komunikace realizována pomocí emulované síťové karty, která je propojena přímo s fyzickou síťovou kartou v hostitelském systému, což je v podstatě softwarová abstrakce fyzické karty zpracovávající IP pakety, kde rámce odeslané na emulovaném zařízení se transformují na jiné protokoly před odesláním na fyzickou kartu.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"fdd060e8-bc92-46ff-ba6d-b923522f64c9",correct:"Ethernetové rámce, které jsou odeslány na paravirtualizované síťové kartě v hostovaném systému, se objeví na virtuální síťové kartě v hostitelském systému, a toto pseudozařízení je následně softwarově propojeno buď do režimu mostu s hardwarovou síťovou kartou pro komunikaci s vnější sítí Ethernet, nebo je mezi pseudozařízením a hardwarovou síťovou kartou nastaveno routování na třetí vrstvě.",incorrect:"Ethernetové rámce, které jsou odeslány na paravirtualizované síťové kartě v hostovaném systému, jsou enkapsulovány do IP paketů a odeslány přímo na fyzickou síťovou kartu hostitelského systému bez použití virtuální síťové karty, a toto propojení je vždy realizováno pomocí NAT, bez možnosti softwarového mostu nebo routování na třetí vrstvě.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"88a5e044-a531-4c8f-9a33-d7d5c2a9ca3c",correct:"Blokové úložiště ve virtualizovaných prostředích je typicky založeno na paravirtualizaci, což znamená, že hostitelská strana zařízení pro blokové úložiště může být implementována buď jako běžný soubor v souborovém systému hostitele, potenciálně ve speciálním formátu jako copy-on-write, nebo jako skutečné blokové zařízení, které může být virtualizované pomocí technologií jako LVM nebo device-mapper, nebo dokonce přímo hardwarové blokové zařízení.",incorrect:"Blokové úložiště ve virtualizovaných prostředích je vždy založeno na plné virtualizaci, což znamená, že hostitelská strana zařízení pro blokové úložiště je omezena pouze na implementaci jako běžný soubor v souborovém systému hostitele a nemůže být nikdy implementována jako skutečné blokové zařízení, a to ani s využitím technologií jako LVM nebo device-mapper.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"33c323da-4a34-493e-bbbc-9ba8ea37a3ee",correct:"Hostitelská strana zařízení pro blokové úložiště ve virtualizovaném prostředí může být implementována různými způsoby, včetně použití běžných souborů, které mohou být uloženy ve speciálním formátu, například s použitím technologie copy-on-write pro efektivní správu diskového prostoru, a také pomocí skutečných blokových zařízení, která mohou být virtualizována prostřednictvím LVM nebo device-mapper, nebo mohou být přímo svázána s fyzickým hardwarovým blokovým zařízením.",incorrect:"Hostitelská strana zařízení pro blokové úložiště ve virtualizovaném prostředí je výhradně implementována pouze jako běžný soubor v souborovém systému hostitele, bez možnosti použití speciálních formátů nebo technologií copy-on-write, a nemůže být nikdy implementována pomocí skutečných blokových zařízení, a to ani virtualizovaných prostřednictvím LVM nebo device-mapper, ani přímo svázaných s fyzickým hardwarovým blokovým zařízením.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"f01e6c81-51dd-4320-bb54-303b2b1b05b0",correct:"Periferní zařízení, jako jsou grafické karty, zvukové vybavení, tiskárny a skenery, jsou užitečné především v desktopových systémech. S výjimkou výpočetních GPU, jsou periferní zařízení na serverech s virtualizací, která představuje mnohem větší trh než desktopy, méně relevantní, protože jejich primární využití se soustředí na interakci s uživatelem, která je pro servery méně typická.",incorrect:"Periferní zařízení, jako jsou grafické karty, zvukové vybavení, tiskárny a skenery, jsou stejně užitečná jak v desktopových systémech, tak i v serverové virtualizaci. Trh serverové virtualizace není větší než trh desktopových systémů, a proto jsou periferní zařízení stejně relevantní pro obě tyto oblasti, protože jejich využití není omezeno pouze na interakci s koncovým uživatelem.",sectionNumber:"12.1.15",sectionTitle:"Special Resources"},{uuid:"afe790cd-bc58-41ad-8e5a-563cc908da45",correct:"Antivirtualizační technologie umožňují hostovanému operačnímu systému přímou interakci s fyzickým hardwarem prostřednictvím zpřístupnění PCI zařízení a využití mapování IO-MMU pro zajištění ochrany paměti a prevenci konfliktů s hostitelským systémem nebo jinými virtuálními stroji. Tento přístup zaručuje, že pouze jeden operační systém v daný moment může ovládat specifický hardware.",incorrect:"Antivirtualizační technologie umožňují více hostovaným operačním systémům současný a přímý přístup ke stejnému fyzickému hardwaru bez nutnosti IO-MMU, což zjednodušuje správu hardwaru ve virtualizovaných prostředích. Tento přístup umožňuje efektivní sdílení zdrojů mezi virtuálními stroji.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"ba88fb5a-cd26-4e36-9a35-74815b99e062",correct:"Technologie IO-MMU, jako například VT-d a AMD-Vi, hrají klíčovou roli v antivirtualizačních technikách, protože jsou nezbytné pro bezpečné poskytnutí přímého přístupu hostovaného operačního systému k fyzickému hardwaru. Bez IO-MMU by hostovaný systém mohl potenciálně přepsat paměť hostitele nebo jiných virtuálních strojů.",incorrect:"Technologie IO-MMU, jako VT-d a AMD-Vi, jsou sice užitečné, ale nejsou nezbytné pro implementaci antivirtualizačních technik, kde hostovaný operační systém má přímý přístup k fyzickému hardwaru. Moderní hypervisory dokážou zajistit bezpečnost a izolaci i bez IO-MMU.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"dd0ad0fc-28d7-49eb-8c0b-4604328b60d9",correct:"V případě antivirtualizace, kdy je PCI zařízení přímo zpřístupněno hostovanému operačnímu systému, je nezbytné, aby se hostitelský systém zdržel jakékoli komunikace s tímto zařízením prostřednictvím svých vlastních ovladačů. Jakýkoli pokus hostitelského systému o ovládání tohoto zařízení by vedl k nestabilitě a potenciálnímu chaosu v systému.",incorrect:"V konfiguracích antivirtualizace může hostitelský operační systém efektivně sdílet kontrolu nad PCI zařízením s hostovaným operačním systémem. Současné řízení umožňuje hostiteli monitorovat a spravovat hardware, zatímco hostovaný systém využívá zařízení pro specifické úlohy, což zvyšuje flexibilitu systému.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"d4e31c3d-8a01-4291-b4fa-6dc4bd591ec6",correct:"Technologie VT-d umožňuje sdílení GPU ve virtualizovaném prostředí tím, že umožňuje přímé přiřazení fyzické GPU virtuálnímu stroji. Toto řešení, založené na IO-MMU, efektivně obchází hypervisor pro přímý přístup k hardwaru, avšak omezuje GPU na exkluzivní použití jedním operačním systémem, čímž se vylučuje její sdílení mezi více virtuálními stroji současně.",incorrect:"Technologie VT-d je pokročilá metoda sdílení GPU, která umožňuje efektivní časové sdílení GPU mezi více virtuálními stroji. Tato technologie, založená na nativních ovladačích GPU v hypervisoru, zajišťuje, že různé virtuální stroje mohou současně využívat výpočetní výkon GPU, a maximalizuje tak využití hardwarových zdrojů grafického procesoru.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"67bae62e-446b-4568-a690-090c6ccc2537",correct:"Pro efektivní časové sdílení GPU mezi virtuálními stroji pomocí nativních ovladačů (GVT-g) je nezbytné, aby hypervisor nebo hostitelský operační systém poskytoval specifické ovladače pro danou GPU. Tyto ovladače v hypervisoru jsou klíčové pro zprostředkování přístupu jednotlivých virtuálních strojů ke GPU a pro správu kontextů, umožňující pozastavení a obnovení GPU úloh, podobně jako u procesů na CPU.",incorrect:"Časové sdílení GPU mezi virtuálními stroji (GVT-g) nevyžaduje specifické ovladače GPU v hypervisoru, protože virtuální stroje přímo komunikují s fyzickou GPU prostřednictvím standardizovaných rozhraní PCI. Tato metoda se spoléhá na schopnosti samotné GPU spravovat kontexty a přidělovat výpočetní zdroje virtuálním strojům bez nutnosti zásahu hypervisoru do správy GPU.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"bb4526fc-0ab2-41f5-9067-14d6d0fdd546",correct:"Paravirtualizace představuje alternativní přístup ke sdílení GPU, kde hostovaný operační systém používá vendor-neutrální protokol pro odesílání příkazů ovladači GPU běžícímu v hypervisoru.  Tento ovladač v hypervisoru následně provádí multiplexování a správu přístupu ke GPU, zatímco v hostovaném systému je stále vyžadována uživatelská část GPU ovladače pro generování příkazového proudu a kompilaci shaderů.",incorrect:"Paravirtualizace GPU eliminuje potřebu ovladačů GPU v hostovaném operačním systému i v hypervisoru.  Místo toho se spoléhá na standardizované síťové protokoly pro přímou komunikaci mezi virtuálním strojem a fyzickou GPU, což zjednodušuje správu ovladačů a zvyšuje výkon grafických operací ve virtualizovaném prostředí.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"218de291-a4ce-4982-bc31-b26ef2a273ae",correct:"Passthrough periferních zařízení ve virtualizovaném prostředí funguje na principu virtualizace standardních sběrnic, jako jsou PCI, USB nebo SATA, což umožňuje přímé předávání požadavků na reálné fyzické zařízení, například konkrétní USB flash disk nebo SATA disk, připojené k hostitelskému systému. Tímto způsobem se hostovanému operačnímu systému prezentuje přímé rozhraní k hardwaru.",incorrect:"Passthrough periferních zařízení ve virtualizovaném prostředí funguje na principu emulace síťových protokolů, což umožňuje nepřímý přístup k virtuálním zařízením, jako je síťová tiskárna nebo skener, připojeným k hostitelskému systému. Tímto způsobem se hostovanému operačnímu systému prezentuje síťové rozhraní k emulovanému hardwaru, což vede k nulové režii výkonu.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"a062e031-814a-4209-9c1f-abb1171ad649",correct:"Technologie standardního sdílení v virtualizovaných prostředích umožňuje, aby periferní zařízení, jako jsou síťové tiskárny, skenery a někdy i zvukový hardware, byla přístupná hostovaným operačním systémům s využitím standardních síťových protokolů. To vede buď k nulovému snížení výkonu u zařízení, jako jsou tiskárny a skenery, nebo k mírnému zvýšení latence, které je patrné zejména u zvukových zařízení kvůli režii síťové komunikace.",incorrect:"Technologie standardního sdílení v virtualizovaných prostředích umožňuje, aby periferní zařízení, jako jsou USB flash disky a SATA disky, byla přístupná hostovaným operačním systémům s využitím přímého přístupu ke sběrnici. To vede k významnému snížení výkonu u všech zařízení kvůli režii virtualizace sběrnice a složitým interakcím ovladačů v hostovaném operačním systému.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"5c5e7d9f-e65a-4d3f-9f32-4bbc96790694",correct:"Zatímco jak passthrough periferních zařízení, tak standardní sdílení nabízejí způsoby, jak používat hostitelská periferní zařízení v hostovaných operačních systémech, passthrough se vyznačuje přímým přístupem k fyzickým zařízením prostřednictvím virtualizace sběrnice s minimálním dopadem na výkon. Standardní sdílení se naopak spoléhá na síťové protokoly, což může zavést mírnou latenci, zejména u periferních zařízení pracujících v reálném čase, jako jsou zvuková zařízení, ale je vhodné pro zařízení, jako jsou tiskárny a skenery.",incorrect:"Zatímco jak passthrough periferních zařízení, tak standardní sdílení nabízejí způsoby, jak používat hostitelská periferní zařízení v hostovaných operačních systémech, passthrough se vyznačuje nepřímým přístupem prostřednictvím emulace sítě, což vede k vysoké latenci. Standardní sdílení se naopak spoléhá na přímou virtualizaci sběrnice, která nabízí téměř nativní výkon, zejména u periferních zařízení pracujících v reálném čase, jako jsou zvuková zařízení, a je vhodné pro zařízení, jako jsou USB flash disky a SATA disky.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"78728b3e-d4f7-49f6-a121-1897342afa2e",correct:"Virtuální stroj lze snadno zastavit a stav jeho operační paměti RAM, včetně registrů a dalšího stavu, může být uložen do souboru v hostitelském souborovém systému pro pozdější obnovení, což umožňuje pokračovat v práci virtuálního stroje po jeho opětovném spuštění.",incorrect:"Virtuální stroj nelze snadno zastavit a stav jeho operační paměti RAM, včetně registrů a dalšího stavu, nemůže být uložen do souboru v hostitelském souborovém systému pro pozdější obnovení, což znemožňuje pokračovat v práci virtuálního stroje po jeho opětovném spuštění.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"4ffbe59d-53e1-4048-a3b4-bc89268284c1",correct:"Důležitou vlastností virtualizačních řešení je schopnost pozastavit běh virtuálního stroje a uložit jeho aktuální stav, což efektivně vytvoří obraz běžícího virtualizovaného operačního systému, který je možné později znovu načíst a obnovit tak běh stroje.",incorrect:"Důležitou vlastností virtualizačních řešení je neschopnost pozastavit běh virtuálního stroje a uložit jeho aktuální stav, což znemožňuje efektivně vytvořit obraz běžícího virtualizovaného operačního systému, který je možné později znovu načíst a obnovit tak běh stroje.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"ecc84e25-547a-4c9b-b252-48b6d27dd469",correct:"Zásadním rozdílem oproti uspání laptopu je, že operace pozastavení a obnovení virtuálního stroje nevyžaduje žádnou součinnost ani povědomí ze strany hostovaného operačního systému, což znamená, že hostovaný systém nemusí být na tyto operace speciálně navržen.",incorrect:"Zásadní podobností s uspáním laptopu je, že operace pozastavení a obnovení virtuálního stroje vyžaduje aktivní součinnost a povědomí ze strany hostovaného operačního systému, což znamená, že hostovaný systém musí být na tyto operace speciálně navržen.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"819c98f8-90bc-4ce9-b0fc-7f350bf5d6ea",correct:'Při takzvané "paused" migraci dochází k přenosu uloženého stavu virtuálního stroje po síti na jiný hostitel. Obnovení virtuálního stroje na novém hostiteli je možné za předpokladu, že virtuální prostředí zůstává konzistentní mezi oběma hostiteli, což zahrnuje kompatibilitu virtualizovaného blokového úložiště a virtuální síťové infrastruktury.',incorrect:'Při takzvané "paused" migraci dochází k přenosu uloženého stavu virtuálního stroje po síti na jiný hostitel. Obnovení virtuálního stroje na novém hostiteli je možné i v případě, že virtuální prostředí není konzistentní mezi oběma hostiteli, jelikož virtualizace plně izoluje virtuální stroj od rozdílů v hostitelském prostředí a zajišťuje jeho nezávislost.',sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"76e8cc6d-87bd-4bea-a8a3-8833268a28b4",correct:'Během "paused" migrace, kdy se stav virtuálního stroje přenáší po síti pro obnovení na jiném hostiteli, se virtuální stroj dočasně pozastaví. Tato pauza může způsobit znatelné zpoždění pro uživatele a v závislosti na velikosti přenášených dat a rychlosti sítě může dokonce dojít k vypršení časových limitů TCP spojení nebo protokolů na aplikační vrstvě.',incorrect:'Během "paused" migrace, kdy se stav virtuálního stroje přenáší po síti pro obnovení na jiném hostiteli, nedochází k žádnému pozastavení virtuálního stroje. Přenos stavu probíhá zcela transparentně na pozadí, aniž by to mělo jakýkoliv vliv na interaktivní používání systému a bez rizika vypršení časových limitů, a to i při přenosu velkých objemů dat.',sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"8ed8ba6d-358b-4c8f-aa9d-4da2151a9c49",correct:'Pro úspěšnou "paused" migraci virtuálního stroje je zásadní kompatibilita podpůrného prostředí vně virtuálního stroje mezi zdrojovým a cílovým hostitelem. Tato kompatibilita se týká zejména virtualizovaného blokového úložiště a virtuální síťové infrastruktury, které musí být na obou hostitelích srovnatelné, aby bylo zajištěno správné fungování virtuálního stroje po migraci.',incorrect:'Pro "paused" migraci virtuálního stroje není nutná kompatibilita podpůrného prostředí vně virtuálního stroje mezi hostiteli. Virtualizace zajistí, že virtuální stroj je plně izolován od hardwarových a softwarových rozdílů hostitelského prostředí, a proto migrace proběhne úspěšně i bez ohledu na rozdíly v konfiguraci blokového úložiště a síťové infrastruktury.',sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"f3806bde-6faf-4d7a-ba91-2f4b20fab9ec",correct:"Živá migrace virtuálních strojů využívá asynchronní snímky paměti, kde hostitel kopíruje stránky paměti a označí je jako jen pro čtení. Snímek paměti je odesílán postupně během svého vytváření a změněné stránky jsou odeslány až na konci procesu migrace, což minimalizuje přerušení běhu virtuálního stroje.",incorrect:"Živá migrace virtuálních strojů využívá synchronní snímky paměti, kde hostitel kopíruje stránky paměti a označí je jako zapisovatelné. Snímek paměti je odeslán až po jeho úplném vytvoření a změněné stránky jsou odeslány na začátku procesu migrace, což maximalizuje přerušení běhu virtuálního stroje.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"01765079-cf5d-409a-b76c-1325b1cab335",correct:"Hlavní výhodou živé migrace oproti pozastavené migraci je, že virtuální stroj může běžet normálně během kopírování paměti, čímž se předejde znatelnému zpoždění a problémům s TCP spojeními, které by mohly detekovat přerušení. Mechanismus copy-on-write se používá k sledování změn paměti během migrace, aby se zajistila konzistence dat.",incorrect:"Hlavní výhodou pozastavené migrace oproti živé migraci je, že virtuální stroj musí být pozastaven během kopírování paměti, čímž se předejde znatelnému zpoždění a problémům s TCP spojeními, které by mohly detekovat přerušení. Mechanismus copy-on-write se nepoužívá k sledování změn paměti během migrace, protože to není nutné.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"10ad171c-dd30-4383-b5dd-0e1dd6139525",correct:"V živé migraci se nejprve provede počáteční kopírování paměti, následované iterativními průchody zaměřenými pouze na změněné stránky, aby se minimalizoval objem dat k přenosu. Nakonec, když je počet změněných stránek malý, je virtuální stroj krátce pozastaven, zbývající změněné stránky a kontext CPU jsou odeslány, a stroj je obnoven na cílovém hostiteli s minimální latencí.",incorrect:"V živé migraci se nejprve provede počáteční kopírování pouze malého množství paměti, následované iterativními průchody zaměřenými na všechny stránky paměti, aby se maximalizoval objem dat k přenosu. Nakonec, bez ohledu na počet změněných stránek, je virtuální stroj dlouze pozastaven, celá paměť a kontext CPU jsou odeslány, a stroj je obnoven na cílovém hostiteli s velkou latencí.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"3fd05884-4971-4a51-b69b-3b0c0a9318f1",correct:"Hypervisor přiděluje paměť virtuálním strojům dynamicky podle aktuální potřeby, nicméně operační systémy uvnitř virtuálních strojů standardně neobsahují mechanismy pro aktivní vracení fyzické paměti hypervisoru, i když ji momentálně nevyužívají, což může vést k neefektivnímu využití zdrojů.",incorrect:"Hypervisor přiděluje paměť virtuálním strojům staticky při jejich spuštění a operační systémy uvnitř virtuálních strojů běžně obsahují mechanismy pro aktivní vracení fyzické paměti hypervisoru, pokud ji momentálně nevyužívají, což zajišťuje efektivní využití zdrojů a minimalizuje plýtvání pamětí.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"7d1068a5-c09e-4cb5-8048-6fcf210c6f2d",correct:"V situacích, kdy virtuální stroj zaznamená dočasný nárůst požadavků na paměť a následně paměť již nepotřebuje, operační systém uvnitř virtuálního stroje typicky drží alokovanou paměť i nadále, protože standardní operační systémy nemají koncept de-alokace fyzické paměti pro hypervisor.",incorrect:"V situacích, kdy virtuální stroj zaznamená dočasný nárůst požadavků na paměť a následně paměť již nepotřebuje, operační systém uvnitř virtuálního stroje automaticky uvolní přebytečnou paměť zpět hypervisoru, protože moderní operační systémy jsou navrženy s ohledem na efektivní správu paměti ve virtualizovaném prostředí.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"cf544f39-f5a1-48f0-aca9-9306343b5d80",correct:"Pro řešení problému s neefektivním držením paměti virtuálními stroji se používá technika 'memory ballooning', která spočívá v použití speciálního ovladače uvnitř virtuálního stroje, jenž odmapuje paměť z pohledu hosta a vrací ji hypervisoru k potenciálnímu využití jinými virtuálními stroji.",incorrect:"Pro řešení problému s neefektivním držením paměti virtuálními stroji se používá technika 'memory swapping', která spočívá ve swapování paměťových stránek na disk uvnitř virtuálního stroje, čímž se uvolní fyzická paměť pro hypervisor a zlepší se celková výkonnost virtualizovaného prostředí.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"f4e9acde-bf39-4932-9d07-37e940dcd982",correct:"Memory ballooning driver, běžící na straně hosta, funguje na principu odmapování 'fyzické' paměti z pohledu virtuálního stroje, což znamená, že data v této paměti jsou pro hosta ztracena, a tato paměť je následně vrácena hostitelskému operačnímu systému, tedy hypervisoru.",incorrect:"Memory ballooning driver, běžící na straně hosta, funguje na principu komprese paměti uvnitř virtuálního stroje, což znamená, že data v paměti jsou zachována, ale zmenšena, a uvolněná paměť je následně transparentně sdílena s hostitelským operačním systémem bez ztráty dat pro hosta.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"fbf09183-7188-46ba-a5d2-dd2232d36cb8",correct:"Kontejnery využívají virtualizaci na úrovni operačního systému, která je založena především na procesech, a rozšiřují ji o dodatečnou izolaci, umožňující skupinám procesů sdílet například síťový zásobník, který je oddělený od síťového zásobníku jiných skupin procesů, přičemž oba zásobníky běží na stejném hardwaru, ale mají oddělené IP adresy a směrovací tabulky.",incorrect:"Kontejnery využívají virtualizaci na úrovni operačního systému, která je založena především na procesech, ale nerozšiřují ji o dodatečnou izolaci. Skupiny procesů v kontejnerech sdílejí stejný síťový zásobník jako všechny ostatní procesy v hostitelském systému, což znamená, že všechny kontejnery a hostitelský systém sdílejí stejné IP adresy a směrovací tabulky a běží na stejném hardwaru.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"31d53b98-0981-41a8-872b-ede19a0bc3ef",correct:"Virtualizace na úrovni operačního systému, jakou využívají kontejnery, se projevuje například virtualizací síťového zásobníku a omezením přístupu k souborovému systému, přičemž kontejnery nejsou kompletní virtuální počítače, ale spíše vylepšené procesy, které sdílejí jádro operačního systému hostitele, ale mají izolované procesní tabulky a uživatelské mapování.",incorrect:"Virtualizace na úrovni operačního systému, jakou využívají kontejnery, se projevuje pouze virtualizací aplikací a nikoliv virtualizací síťového zásobníku nebo omezením přístupu k souborovému systému. Kontejnery jsou kompletní virtuální počítače s vlastním jádrem operačního systému, které jsou plně izolované od hostitelského systému, včetně sdílení procesních tabulek a uživatelského mapování.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"99d8ca63-ab2b-4ded-91ec-39f0181c5e1c",correct:"Mezi mechanismy virtualizace na úrovni operačního systému, které kontejnery využívají, patří oddělení přístupu k souborovému systému pomocí nástrojů jako chroot, separace uživatelského mapování a izolace procesních tabulek, což umožňuje kontejnerům běžet izolovaně od sebe a od hostitelského systému v rámci jednoho operačního systému.",incorrect:"Mezi mechanismy virtualizace na úrovni operačního systému, které kontejnery využívají, patří pouze změna jmenného prostoru procesů, ale nikoliv oddělení přístupu k souborovému systému, separace uživatelského mapování nebo izolace procesních tabulek. Kontejnery sdílejí stejný souborový systém, uživatelské mapování a procesní tabulky s hostitelským systémem, což omezuje jejich izolaci.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"2293a038-6eb8-4973-a565-4777b9d77d4d",correct:"Jednou z klíčových výhod kontejnerů je jejich efektivní využití zdrojů, dosažené sdílením jediného jádra mezi více kontejnery. Toto sdílení jádra umožňuje kontejnerům sdílet paměť, zejména pro běžné knihovny a spustitelný kód, což vede k nižší režii ve srovnání s virtuálními stroji.",incorrect:"Kontejnery i virtuální stroje spoléhají na samostatná jádra pro každou instanci, což znemožňuje efektivní sdílení paměti mezi nimi. Tato izolace zajišťuje silné bezpečnostní hranice, ale má za následek srovnatelnou režii zdrojů pro kontejnerizovaná i virtualizovaná prostředí.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"1cfee4c4-c5a5-4a8c-a658-1cd90bed75d5",correct:"Zásadní architektonický rozdíl mezi virtuálními stroji a kontejnery spočívá ve správě jádra. Každý virtuální stroj vyžaduje vlastní vyhrazenou instanci jádra, zatímco kontejnery jsou naopak navrženy tak, aby sdílely jediné jádro poskytované hostitelským operačním systémem, což přispívá k jejich efektivitě a rychlosti.",incorrect:"Virtuální stroje i kontejnery fungují na principu sdílení jádra, kdy více instancí sdílí jediné jádro za účelem optimalizace využití zdrojů. Tato architektura sdíleného jádra je definující charakteristikou obou virtualizačních technologií, která zajišťuje efektivní provoz systému.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"cea6ec20-e04c-4dbb-b7c3-e317b0fedbc8",correct:"V hierarchii úrovní izolace představují kontejnery odlišnou úroveň izolace umístěnou mezi izolací na úrovni uživatele a úplnou izolací virtuálního stroje. To znamená, že kontejnery nabízejí vyšší stupeň izolace než jednotlivé uživatelské procesy, ale menší než kompletně oddělené virtuální stroje, čímž poskytují vyvážený přístup k bezpečnosti a správě zdrojů.",incorrect:"Kontejnery nepředstavují odlišnou úroveň izolace, ale spíše fungují na stejné úrovni izolace jako virtuální stroje, poskytujíce kompletní virtualizaci na úrovni hardwaru. Obě technologie nabízejí robustní izolaci, efektivně oddělující instance od sebe i od hostitelského systému na fundamentální úrovni.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"8cf7b4b1-332a-4e11-b541-7446ed761965",correct:"Zatímco spuštění lehkého virtuálního stroje obvykle trvá řádově sekundy, kontejner může být spuštěn za méně než 50 milisekund, což z kontejnerů činí výrazně rychlejší alternativu pro rychlé nasazení aplikací a služeb, zejména v prostředích, kde je klíčová rychlost spouštění.",incorrect:"Zatímco spuštění kontejneru obvykle trvá řádově sekundy, lehké virtuální stroje, díky své optimalizované architektuře a sdílení jádra hostitelského systému, mohou být spuštěny za méně než 50 milisekund, což z virtuálních strojů činí výrazně rychlejší alternativu pro rychlé nasazení aplikací a služeb.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"29cff23f-be77-41b3-a2f6-daba57e15887",correct:"Podle dostupných informací, dokonce i bez zohlednění přípravy diskových obrazů, je kontejner při samotném bootování až dvacetkrát rychlejší než běžný virtuální stroj, s výjimkou exokernelů a podobných minimalistických operačních systémů, které mohou dosahovat srovnatelné rychlosti startu.",incorrect:"Podle dostupných informací, dokonce i bez zohlednění přípravy diskových obrazů, je kontejner při samotném bootování pouze dvakrát rychlejší než běžný virtuální stroj, což naznačuje, že rozdíl v rychlosti startu mezi kontejnery a virtuálními stroji není tak dramatický, jak se často tvrdí.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"6aab692e-8798-4dd3-8506-e7883bbb64fa",correct:"Virtuální stroje, na rozdíl od kontejnerů, nabízejí možnost pozastavení a následného obnovení běžícího stavu, což umožňuje efektivní správu zdrojů a rychlé přepínání mezi různými pracovními prostředími, a je klíčové pro scénáře vyžadující flexibilitu a okamžitou dostupnost dříve spuštěných systémů.",incorrect:"Kontejnery, na rozdíl od virtuálních strojů, nabízejí možnost pozastavení a následného obnovení běžícího stavu, což umožňuje efektivní správu zdrojů a rychlé přepínání mezi různými pracovními prostředími, a je klíčové pro scénáře vyžadující flexibilitu a okamžitou dostupnost dříve spuštěných systémů.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"4f24c086-7897-40d2-a4fc-d4625bb18144",correct:"I když virtuální stroje nabízejí výhody jako izolaci a možnost pozastavení, je důležité si uvědomit, že i neaktivní, takzvaně dormantní virtuální stroje, spotřebovávají značné množství diskového prostoru, což může být limitujícím faktorem v prostředích s omezenými úložnými kapacitami.",incorrect:"I když virtuální stroje nabízejí výhody jako izolaci a možnost pozastavení, je důležité si uvědomit, že neaktivní, takzvaně dormantní virtuální stroje, spotřebovávají jen minimální množství diskového prostoru, srovnatelné s kontejnery, díky efektivní správě paměti a úložných zdrojů.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"9491ee8a-54a9-4c63-b1b8-40c41b35cc43",correct:"Systém chroot umožňuje spouštění více instancí operačního systému pod jedním jádrem, konkrétně uživatelských prostorů, ale sdílení systémových prostředků jako jsou procesní tabulky a síť brání tomu, aby byl chroot považován za plnohodnotný kontejnerový systém.",incorrect:"Systém chroot, i když umožňuje spouštění více instancí operačního systému pod jedním jádrem a izoluje uživatelské prostory, je považován za plnohodnotný kontejnerový systém díky efektivní izolaci procesních tabulek a síťových prostředků.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"7cdee597-8086-41f9-a7da-8c82eb89f662",correct:"V pseudo-kontejnerech vytvořených pomocí chroot, kvůli sdílení síťových prostředků, je nemožné provozovat dva nezávislé webové servery na stejném portu a superuživatel uvnitř chroot prostředí má potenciál získat superuživatelská práva i mimo toto prostředí.",incorrect:"V pseudo-kontejnerech vytvořených pomocí chroot je možné provozovat dva nezávislé webové servery na stejném portu a superuživatel uvnitř chroot prostředí je plně izolován a nemůže získat superuživatelská práva mimo toto prostředí.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"3db93913-21f0-402c-9fe9-22d2b9ade68a",correct:"Ačkoliv systém chroot poskytuje kontejnerům vlastní pohled na systém souborů, včetně systémových knihoven a utilit, klíčové systémové zdroje jako procesní tabulky a síťové rozhraní zůstávají sdílené mezi všemi pseudo-kontejnery.",incorrect:"Systém chroot poskytuje kontejnerům vlastní pohled nejen na systém souborů, ale také na všechny klíčové systémové zdroje, včetně procesních tabulek a síťových rozhraní, čímž zajišťuje plnohodnotnou izolaci mezi kontejnery.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"c2eca5bc-afc0-4d49-8b64-260b7095e044",correct:"Mechanismus FreeBSD jail je evolucí chroot a rozšiřuje jeho funkčnost přidáním izolace uživatelů a procesních tabulek, což chrootu chybělo. Tato vylepšení umožňují vytvářet bezpečnější a izolovanější prostředí pro běh aplikací.",incorrect:"Mechanismus FreeBSD jail je pouhým přejmenováním chroot a nepřináší žádné významné funkční rozšíření kromě změny názvu. Jeho funkcionalita zůstává v podstatě identická s původním chroot, pouze s novým marketingovým označením.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"6df5515e-b0b1-46cb-9b53-6632ccfcc710",correct:"Jednou z klíčových vlastností FreeBSD jail je virtualizovaný síťový zásobník, který umožňuje každému jailu mít vlastní IP adresu. Tato vlastnost zásadně přispívá k izolaci sítových operací jednotlivých jailů a zvyšuje flexibilitu síťové konfigurace.",incorrect:"Přestože FreeBSD jail nabízí virtualizaci sítě, neumožňuje, aby měl každý jail svou vlastní IP adresu. Konfigurace sítě pro jail vyžaduje složitá nastavení a sdílení IP adres mezi jaily, což omezuje izolaci sítových operací.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"e132f5a0-5f66-4170-8aa3-6543edd9aeb3",correct:"FreeBSD jail je navržen tak, aby omezoval pravomoci uživatele 'root' uvnitř jailu a zabraňoval eskalaci privilegií mimo tento jail. To je klíčový bezpečnostní prvek, který brání získání neoprávněného přístupu k hostitelskému systému zevnitř jailu.",incorrect:"FreeBSD jail, i když částečně omezuje některé možnosti uživatele 'root', stále umožňuje uživateli 'root' uvnitř jailu snadno získat plná systémová oprávnění mimo tento jail, což představuje významné bezpečnostní riziko pro hostitelský systém.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"3b70c0ba-b29c-4e6a-8867-141f29fa6455",correct:"FreeBSD jail je považován za jedno z nejstarších open-source kontejnerizačních řešení, a to díky své dlouhé historii a vývoji v rámci operačního systému FreeBSD. Jeho koncepty a principy inspirovaly mnohé moderní kontejnerizační technologie, které se objevily později.",incorrect:"FreeBSD jail je relativně nová kontejnerizační technologie, která byla vyvinuta teprve nedávno s cílem reagovat na moderní potřeby kontejnerizace a cloudových prostředí. Jeho vývoj probíhá paralelně s moderními trendy v oblasti virtualizace a IT.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"2363ecd1-d859-4b7f-a32b-0ceab6a6492f",correct:"Linuxové namespaces, které byly nakonec přidány do oficiálního jádra Linuxu, umožňují jemnozrnnou virtualizaci operačního systému tím, že oddělují různé aspekty, jako je souborový systém, procesní tabulky a síťové rozhraní, pro každý kontejner, čímž poskytují robustnější izolaci než starší řešení jako VServer.",incorrect:"Linuxové namespaces, které byly přidány do oficiálního jádra Linuxu, virtualizují pouze síťové rozhraní a procesní tabulky, ale nesdílejí souborový systém mezi kontejnery, což omezuje flexibilitu a efektivitu kontejnerizace v porovnání s řešeními jako VServer.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"957639e5-8fae-414a-82c0-6e096f8bea17",correct:"Projekt VServer, který se snažil o implementaci kontejnerizace podobné BSD jails v Linuxu, předcházel zavedení namespaces do hlavního jádra Linuxu a byl distribuován jako sada patchů třetí strany, protože nebyl okamžitě přijat do oficiální verze kernelu.",incorrect:"Projekt VServer, který byl okamžitě přijat do hlavního jádra Linuxu a stal se standardním řešením pro kontejnerizaci, byl založen na namespaces a byl distribuován jako oficiální součást kernelu od svého vzniku.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"6998aef8-eb32-475c-b81e-0922ffb6e7c0",correct:"Přestože VServer nabízel formu kontejnerizace v Linuxu dříve než namespaces, poskytoval pouze částečnou izolaci pro uživatele root v jailu, což znamenalo, že potenciální bezpečnostní rizika nebyla zcela eliminována ve srovnání s pozdějšími řešeními založenými na namespaces.",incorrect:"VServer, i když byl dřívějším řešením kontejnerizace v Linuxu než namespaces, poskytoval plnou izolaci pro uživatele root v jailu, čímž efektivně eliminoval veškerá bezpečnostní rizika spojená s sdílením systému mezi různými kontejnery.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"fc017cb9-4e3d-44f4-a241-9153d49633a7",correct:"V operačním systému Linux, kontrolní skupiny (cgroups) slouží jako mechanismus pro řízení a omezování spotřeby systémových prostředků, jako je CPU a paměť, pro skupiny procesů, čímž umožňují efektivní izolaci a spravedlivé sdílení hardwarových zdrojů mezi různými kontejnery a aplikacemi. Tato funkčnost je klíčová pro správu výkonu a stabilitu systému.",incorrect:"V operačním systému Linux, kontrolní skupiny (cgroups) primárně slouží k řízení přístupu k systémovým objektům na úrovni operačního systému a nemají významný vliv na omezování spotřeby hardwarových zdrojů, jako je CPU a paměť, pro skupiny procesů, přičemž izolace zdrojů je řešena výhradně pomocí jmenných prostorů.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"ae67fa98-a2a5-4694-b6bb-8224bb317f15",correct:"Kromě jmenných prostorů, které izolují kontejnery v Linuxu z hlediska přístupu k systémovým objektům, jsou kontrolní skupiny (cgroups) dalším klíčovým komponentem kontejnerizace, který umožňuje omezit spotřebu hardwarových zdrojů pro procesy běžící v kontejnerech, čímž se dosahuje komplexní izolace a prevence negativního ovlivnění výkonu jiných kontejnerů nebo hostitelského systému.",incorrect:"V kontextu Linuxových kontejnerů jsou kontrolní skupiny (cgroups) redundantní a nemají žádný vliv na izolaci spotřeby systémových prostředků, jelikož jmenné prostory plně postačují k zajištění izolace kontejnerů ve všech aspektech, včetně správy a omezení využití CPU, paměti a dalších hardwarových zdrojů.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"9dc57916-b203-47be-8105-e5af9c7aca9c",correct:"LXC kontejnery, implementované s využitím linuxových jmenných prostorů a kontrolních skupin, představují hlavní proud kontejnerizace v Linuxu a nabízejí funkcionalitu srovnatelnou s VServer a OpenVZ, přičemž nástroje pro jejich správu běží v uživatelském prostoru operačního systému.",incorrect:"LXC kontejnery, implementované s využitím linuxových jmenných prostorů a virtualizačních technologií, nepředstavují hlavní proud kontejnerizace v Linuxu a nabízejí funkcionalitu srovnatelnou s virtualizačními technologiemi, přičemž nástroje pro jejich správu běží v jádře operačního systému.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"219aa741-e0c2-46fb-afe4-52115dfbed0c",correct:"LXC, sada nástrojů v uživatelském prostoru pro správu kontejnerů, se objevil relativně nedávno v roce 2008, sedm let po VServeru, a od verze 1.0 z roku 2014 umožňuje oddělení superuživatele uvnitř kontejneru a správu neprivilegovaných kontejnerů běžnými uživateli, s určitými omezeními.",incorrect:"LXC, sada nástrojů v uživatelském prostoru pro správu kontejnerů, se objevil velmi dávno v roce 2001, sedm let před VServerem, a již od počáteční verze z roku 2008 umožňuje oddělení superuživatele uvnitř kontejneru a správu neprivilegovaných kontejnerů běžnými uživateli, bez jakýchkoliv omezení.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"6c18636e-9a10-433d-99ec-7aefccfdbdd9",correct:"Uživatelské režimy jader představují unikátní přístup k virtualizaci operačních systémů, nacházející se koncepčně mezi tradičními kontejnery a plnohodnotnými virtuálními stroji, jelikož jádro běží jako standardní proces v uživatelském prostoru jiného jádra, přičemž využívají paravirtualizační techniky neobvyklým způsobem k dosažení rovnováhy mezi výkonem a izolací.",incorrect:"Uživatelské režimy jader jsou v podstatě totožné s tradičními kontejnery, nabízející srovnatelnou úroveň izolace a bezpečnosti přímým sdílením jádra a zdrojů hostitelského operačního systému, bez nutnosti paravirtualizace nebo běhu jako samostatný proces v uživatelském prostoru, což z nich činí lehkou alternativu k virtuálním strojům.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"beea6765-90bc-4e61-8f93-2c4be90c925d",correct:"Implementace uživatelských režimů jader, jako je User-Mode Linux, sahá do raných let 21. století, kdy byl User-Mode Linux integrován do jádra Linux verze 2.6 v roce 2003 a podobný přístup byl později přijat systémem DragonFlyBSD pod názvem 'virtual kernels', což dokazuje, že koncept uživatelských režimů jader má relativně dlouhou historii ve vývoji operačních systémů.",incorrect:"Implementace uživatelských režimů jader je poměrně nedávný koncept, který se objevil až po roce 2010 s cílem nahradit tradiční virtualizaci a kontejnery, přičemž první implementace jako User-Mode Linux a 'virtual kernels' v DragonFlyBSD byly vyvinuty až v posledních několika letech jako reakce na rostoucí potřebu lehčí a bezpečnější virtualizační technologie.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"dbac0f9f-6337-4a33-975d-9bf71dbdd299",correct:"Z hlediska bezpečnosti na straně hostitelského systému nabízejí uživatelské režimy jader výhodu oproti kontejnerům, protože se hostitelskému systému jeví převážně jako standardní procesy bez zvláštního statusu, což usnadňuje využití stávajících bezpečnostních mechanismů a činí je potenciálně bezpečnějšími pro retrofitování do existujících systémů než kontejnery, jelikož využívají zavedené bezpečnostní postupy hostitelského systému.",incorrect:"Z hlediska bezpečnosti na straně hostitelského systému jsou kontejnery považovány za bezpečnější než uživatelské režimy jader, protože kontejnery využívají pokročilé bezpečnostní mechanismy izolace jader a jmenných prostorů, zatímco uživatelské režimy jader, tím, že běží jako standardní procesy, jsou náchylnější k bezpečnostním zranitelnostem a nabízejí horší ochranu hostitelského systému.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"b1c1e92a-a5a5-463c-8734-b518f4ac46d9",correct:"Jedním z hlavních nedostatků kontejnerů a uživatelských jader je absence podpory suspendování a obnovení, což ztěžuje migraci. Důvodem je složitější stav procesu v porovnání s virtuálním strojem, ačkoli tento problém je závažnější u kontejnerů kvůli komplexnější povaze procesů na hostitelském systému v porovnání s často jediným procesem uživatelského jádra.",incorrect:"Jednou z výhod kontejnerů a uživatelských jader je robustní podpora suspendování a obnovení, která usnadňuje migraci. To je umožněno díky jednoduchému stavu procesu v porovnání s virtuálním strojem, což činí kontejnery méně problematickými než uživatelská jádra z hlediska správy stavu a migrace.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"259f1239-d123-49b5-8df2-da7141309681",correct:"Problém s absencí suspendování a obnovení je u kontejnerů výrazně závažnější než u uživatelských jader. To je způsobeno tím, že kontejnery v sobě zahrnují reálné procesy na hostitelském systému, zatímco uživatelské jádro je často implementováno jako jediný proces, což zjednodušuje správu a serializaci stavu pro účely suspendování a obnovení.",incorrect:"Problém s absencí suspendování a obnovení je u uživatelských jader výrazně závažnější než u kontejnerů. To je způsobeno tím, že uživatelská jádra v sobě zahrnují reálné procesy na hostitelském systému, zatímco kontejnery jsou často implementovány jako jediný proces, což zjednodušuje správu a serializaci stavu pro účely suspendování a obnovení.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"ebf4853d-5ff2-4db8-8dff-fd239b454296",correct:"I když kontejnery a uživatelská jádra postrádají nativní podporu suspendování a obnovení, což omezuje možnosti migrace, tento nedostatek je částečně kompenzován rychlou dobou vypnutí a spuštění. Díky tomu je možné kontejnery a uživatelská jádra rychle restartovat na jiném hostiteli, čímž se minimalizuje dopad výpadků spojených s migrací.",incorrect:"I když kontejnery a uživatelská jádra postrádají nativní podporu suspendování a obnovení, což omezuje možnosti migrace, tento nedostatek je plně kompenzován pomalou dobou vypnutí a spuštění. Díky tomu je možné kontejnery a uživatelská jádra bezpečně migrovat na jiný hostitel, čímž se eliminuje dopad výpadků spojených s migrací.",sectionNumber:"12.2.10",sectionTitle:"Migration"}]}];function o4(){const e=Xr(),[o,n]=l.useState(!1),[t,r]=l.useState(!1),a=s=>{const c=new URLSearchParams;s.forEach(u=>{c.append("sections",u)}),e(`/credit-custom?${c.toString()}`),n(!1)},i=s=>{const c=new URLSearchParams;s.forEach(u=>{c.append("sections",u)}),e(`/exam-custom?${c.toString()}`),r(!1)};return j.jsxs(j.Fragment,{children:[j.jsxs("p",{className:"font-light mb-4 text-sm ",children:["Tato aplikace slouží na procvičení znalostí z předmětu PB152.",j.jsx("br",{})," Akékoliv chyby, připomínky, nápady na vylepšení, nebo návrhy na nové otázky můžete nahlásit na"," ",j.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"underline hover:text-blue-500",target:"_blank",children:["Discord",j.jsx(gt,{className:"w-3 h-3 inline self-center"})]})]}),j.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-[1fr_auto_1fr] gap-4",children:[j.jsxs("div",{className:"flex flex-col gap-1",children:[j.jsx("h2",{className:"text-xl",children:"Zápočet"}),j.jsxs("div",{className:"grid grid-cols-2 gap-1",children:[j.jsx(mt,{to:"/credit",children:j.jsx(zo,{className:"w-full",children:"Všechny části"})}),j.jsx($d,{isOpen:o,onOpenChange:n,onSubmit:a,sections:Bn})]}),Bn.map((s,c)=>j.jsx(mt,{to:`/credit/${s.uuid}`,children:j.jsxs(zo,{variant:"outline",className:"w-full",children:["Část ",s.sectionNumber,": ",s.sectionTitle]},c)},c))]}),j.jsx("div",{className:"h-[0.1rem] md:h-full w-full md:w-[0.1rem] bg-border rounded-full"}),j.jsxs("div",{className:"flex flex-col gap-1",children:[j.jsx("h2",{className:"text-xl",children:"Zkouška"}),j.jsxs("div",{className:"grid grid-cols-2 gap-1",children:[j.jsx(mt,{to:"/exam",children:j.jsx(zo,{className:"w-full",children:"Všechny části"})}),j.jsx($d,{isOpen:t,onOpenChange:r,onSubmit:i,sections:_n})]}),_n.map((s,c)=>j.jsx(mt,{to:`/exam/${s.uuid}`,children:j.jsxs(zo,{variant:"outline",className:"w-full",children:["Část ",s.sectionNumber,": ",s.sectionTitle]},c)},c))]})]})]})}function $d({isOpen:e,onOpenChange:o,onSubmit:n,sections:t}){const[r,a]=l.useState([]),i=c=>{a(u=>u.includes(c)?u.filter(d=>d!==c):[...u,c])},s=()=>{r.length!==0&&(n(r),a([]))};return j.jsxs(Mk,{open:e,onOpenChange:o,children:[j.jsx(Ik,{asChild:!0,children:j.jsx(zo,{className:"w-full",children:"Vlastní výběr"})}),j.jsxs(Cu,{children:[j.jsxs(Mu,{children:[j.jsx(Iu,{children:"Vyberte části pro testování"}),j.jsx(Au,{children:"Vyberte jednu nebo více částí, ze kterých chcete být testováni."})]}),j.jsx("div",{className:"max-h-[60vh] overflow-y-auto py-2",children:t.map(c=>j.jsxs("div",{className:"flex items-center space-x-2 mb-2",children:[j.jsx(Nu,{id:c.uuid,checked:r.includes(c.uuid),onCheckedChange:()=>i(c.uuid)}),j.jsxs("label",{htmlFor:c.uuid,className:"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",children:[c.sectionNumber,": ",c.sectionTitle]})]},c.uuid))}),j.jsx(Vk,{children:j.jsx(zo,{onClick:s,disabled:r.length===0,children:"Začít testování"})})]})]})}function n4({uuid:e}){const o=Bn.find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Section not found")]}function t4(){return[Bn,null]}function r4({uuid:e}){const o=Bn.map(n=>n.statements).flat().find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Statement not found")]}function a4(){return[Bn.map(o=>o.statements).flat(),null]}function i4({count:e=5,sections:o}){const n=Bn.filter(a=>o?o.includes(a.uuid):!0),t=n[Math.floor(Math.random()*n.length)];return t.statements.length<e?[null,new Error("Not enough statements")]:[t.statements.sort(()=>Math.random()-.5).slice(0,e),null]}const Rr={getSingleSection:n4,getAllSections:t4,getSingleStatement:r4,getAllStatements:a4,getRandomStatements:i4};function Rt({title:e,correct:o,incorrect:n,refresh:t}){const[r,a]=l.useState(!1),[i,s]=l.useState(new Array(o.length+n.length).fill(!1)),c=l.useMemo(()=>(s(new Array(o.length+n.length).fill(!1)),az([...o,...n])),[o,n]);return j.jsxs("div",{className:"flex flex-col gap-4",children:[j.jsxs("div",{children:[j.jsx("h2",{className:"text-2xl",children:e}),j.jsxs("p",{className:"font-medium text-sm",children:["Zaškrtněte správné výroky(",o.length,")"]})]}),j.jsx("div",{children:c.map((u,d)=>j.jsx(s4,{statement:u,type:o.find(p=>p.uuid==u.uuid)?"correct":"incorrect",submited:r,checked:i[d],onChange:p=>{const v=[...i];v[d]=p,s(v)}},iz(u.uuid)))}),j.jsx(zo,{className:"w-full",onClick:()=>{r?(a(!1),t()):a(!0)},children:r?"Další otázka":"Odeslat"}),j.jsx("div",{className:"w-full flex justify-end",children:j.jsx(c4,{})})]})}function s4({statement:e,type:o,submited:n,checked:t,onChange:r}){const[a,i]=l.useState(o=="correct");return j.jsxs("div",{className:Ao(["p-2 flex gap-2 items-center",n&&(o=="correct"?"bg-green-200":"bg-red-200"),n?"cursor-default":"cursor-pointer",n?o=="correct"?"hover:bg-green-300":"hover:bg-red-300":"hover:bg-gray-200"]),onClick:()=>{n||r(!t)},children:[j.jsx(Nu,{id:e.uuid,name:o,disabled:n,checked:t}),j.jsxs("div",{className:"flex-1",children:[j.jsx("p",{className:"whitespace-pre-wrap",children:a?e.correct:e.incorrect}),n&&o=="incorrect"&&j.jsxs("div",{className:"flex items-center pt-2 gap-2 select-none",children:[j.jsx("p",{onMouseDown:()=>i(s=>!s),className:"font-bold underline italic cursor-pointer",children:a?"zobrazit nesprávnou":"zobrazit správnou"}),j.jsx("p",{className:"text-gray-600",children:a?"(Zobrazuje se správna odpověď)":"(Zobrazuje se nesprávna odpověď)"})]}),n&&e.sectionNumber&&e.sectionTitle&&j.jsxs("p",{className:"text-gray-600",children:["Fakt z části: ",e.sectionNumber,". ",e.sectionTitle]})]}),n&&t&&(o=="correct"?j.jsx("span",{children:j.jsx(hm,{className:"w-10 h-10"})}):j.jsx("span",{children:j.jsx(bm,{className:"w-10 h-10"})}))]})}function c4(){return j.jsxs(Mk,{children:[j.jsx(Ik,{asChild:!0,children:j.jsx(zo,{variant:"outline",children:"Nahlásit chybu"})}),j.jsx(Cu,{children:j.jsxs(Mu,{children:[j.jsx(Iu,{children:"Vyberte si jak nahlásit chybu"}),j.jsxs(Au,{children:["Nahlášení chyby můžete provést buď přes Discord nebo přes Github.",j.jsx("br",{}),j.jsx("br",{}),"Pokud chcete nahlásit chybu přes Discord, pripojte se na náš server a napište nám (",j.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"underline text-foreground hover:text-blue-500",target:"_blank",children:["link pro připojení",j.jsx(gt,{className:"w-3 h-3 inline self-center"})]}),").",j.jsx("br",{}),j.jsx("br",{}),"Pokud chcete nahlásit chybu přes Github, vytvořte issue(",j.jsxs("a",{href:"https://github.com/tomz197/os-drill/issues/new",className:"underline text-foreground hover:text-blue-500",target:"_blank",children:["link pro vytoření issue",j.jsx(gt,{className:"w-3 h-3 inline self-center"})]}),")."]})]})})]})}function u4(){const{sectionUUID:e}=Im(),[o,n]=l.useState(null),[t,r]=l.useState([]),[a,i]=l.useState([]);l.useEffect(()=>{if(!e){console.error("Section not found"),Co("/");return}const[c,u]=Rr.getSingleSection({uuid:e});if(u){console.error("Section not found"),Co("/");return}n(c)},[e]);const s=l.useCallback(()=>{if(!e){console.error("Section or name not found"),Co("/");return}const[c,u]=Rr.getRandomStatements({count:5,sections:[e]});if(u){console.error("Statements not found"),Co("/");return}r(c.slice(0,2)),i(c.slice(2,5))},[o]);return l.useEffect(()=>{s()},[s]),!t||!a||!o?null:j.jsx(Rt,{title:`Část ${o.sectionNumber}: ${o.sectionTitle}`,correct:t,incorrect:a,refresh:s})}function l4(){const[e,o]=l.useState([]),[n,t]=l.useState([]),r=l.useCallback(()=>{const[a,i]=Rr.getRandomStatements({count:5});if(i){console.error("Statements not found"),Co("/");return}o(a.slice(0,2)),t(a.slice(2,5))},[]);return l.useEffect(()=>{r()},[r]),!e||!n?null:j.jsx(Rt,{title:"Všechny části",correct:e,incorrect:n,refresh:r})}function d4(){return j.jsxs("div",{className:"max-w-prose w-full mx-auto",children:[j.jsx("h1",{className:"text-xl font-semibold text-center",children:"O nás"}),j.jsx("div",{className:"h-[0.1rem] w-full bg-border rounded-full my-4"}),j.jsxs("div",{className:"grid gap-2",children:[j.jsxs("p",{className:"inline",children:["Táto aplikácia bola vytvorená"," ",j.jsxs("a",{href:"https://zifcak.dev",target:"_blank",className:"underline hover:text-blue-500",children:["Tomášom Žifčákom",j.jsx(gt,{className:"w-3 h-3 inline self-center"})]})," ","pretože neexistoval žiadny spôsob ako si preveriť svoje znalosti z predmetu PB152(Operačné systémy) v zkúškovej/zápočtovej forme."]}),j.jsxs("p",{children:["Kód tejto aplikácie je otvorený a dostupný na"," ",j.jsxs("a",{href:"https://github.com/tomz197/os-drill",className:"underline hover:text-blue-500",target:"_blank",children:["Githube",j.jsx(gt,{className:"w-3 h-3 inline self-center"})]}),"."]}),j.jsxs("p",{children:["V prípade akýchkoľvek problémov, nápadov na vylepšenie alebo akýchkoľvek otázok napíš na"," ",j.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"underline hover:text-blue-500",target:"_blank",children:["Discord",j.jsx(gt,{className:"w-3 h-3 inline self-center"})]})," ","alebo vytvor issue, pull request alebo diskusiu na Githube."]}),j.jsx("p",{className:"font-semibold",children:"Každá pomoc je vítaná!"})]})]})}function p4({uuid:e}){const o=_n.find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Section not found")]}function v4(){return[_n,null]}function m4({uuid:e}){const o=_n.map(n=>n.statements).flat().find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Statement not found")]}function k4(){return[_n.map(o=>o.statements).flat(),null]}function h4({count:e=5,sections:o}){const n=_n.filter(a=>o?o.includes(a.uuid):!0),t=n[Math.floor(Math.random()*n.length)];return t.statements.length<e?[null,new Error("Not enough statements")]:[t.statements.sort(()=>Math.random()-.5).slice(0,e),null]}const Dr={getSingleSection:p4,getAllSections:v4,getSingleStatement:m4,getAllStatements:k4,getRandomStatements:h4};function b4(){const{sectionUUID:e}=Im(),[o,n]=l.useState(null),[t,r]=l.useState([]),[a,i]=l.useState([]);l.useEffect(()=>{if(!e){console.error("Section not found"),Co("/");return}const[c,u]=Dr.getSingleSection({uuid:e});if(u){console.error("Section not found"),Co("/");return}n(c)},[e]);const s=l.useCallback(()=>{if(!e){console.error("Section or name not found"),Co("/");return}const[c,u]=Dr.getRandomStatements({count:5,sections:[e]});if(u){console.error("Statements not found"),Co("/");return}r(c.slice(0,2)),i(c.slice(2,5))},[o]);return l.useEffect(()=>{s()},[s]),!t||!a||!o?null:j.jsx(Rt,{title:`Část ${o.sectionNumber}: ${o.sectionTitle}`,correct:t,incorrect:a,refresh:s})}function y4(){const[e,o]=l.useState([]),[n,t]=l.useState([]),r=l.useCallback(()=>{const[a,i]=Dr.getRandomStatements({count:5});if(i){console.error("Statements not found"),Co("/");return}o(a.slice(0,2)),t(a.slice(2,5))},[]);return l.useEffect(()=>{r()},[r]),!e||!n?null:j.jsx(Rt,{title:"Všechny části",correct:e,incorrect:n,refresh:r})}function z4(){const[e]=Em(),o=Xr(),[n,t]=l.useState([]),[r,a]=l.useState([]),[i,s]=l.useState([]),[c,u]=l.useState([]);l.useEffect(()=>{const v=e.getAll("sections");if(!v||v.length===0){console.error("No sections selected"),o("/");return}u(v);const[z,f]=Rr.getAllSections();if(f){console.error("Failed to load sections");return}s(z.filter(h=>v.includes(h.uuid)))},[e,o]);const d=l.useCallback(()=>{if(c.length===0)return;const[v,z]=Rr.getRandomStatements({count:5,sections:c});if(z){console.error("Statements not found",z);return}t(v.slice(0,2)),a(v.slice(2,5))},[c]);if(l.useEffect(()=>{c.length>0&&d()},[c,d]),c.length===0||!n.length||!r.length)return j.jsx("div",{className:"p-8 text-center",children:"Načítání..."});const p=i.map(v=>`${v.sectionNumber}: ${v.sectionTitle}`).join(", ");return j.jsx(Rt,{title:`Vlastní výběr: ${p}`,correct:n,incorrect:r,refresh:d})}function j4(){const[e]=Em(),o=Xr(),[n,t]=l.useState([]),[r,a]=l.useState([]),[i,s]=l.useState([]),[c,u]=l.useState([]);l.useEffect(()=>{const v=e.getAll("sections");if(!v||v.length===0){console.error("No sections selected"),o("/");return}u(v);const[z,f]=Dr.getAllSections();if(f){console.error("Failed to load sections");return}s(z.filter(h=>v.includes(h.uuid)))},[e,o]);const d=l.useCallback(()=>{if(c.length===0)return;const[v,z]=Dr.getRandomStatements({count:5,sections:c});if(z){console.error("Statements not found",z);return}t(v.slice(0,2)),a(v.slice(2,5))},[c]);if(l.useEffect(()=>{c.length>0&&d()},[c,d]),c.length===0||!n.length||!r.length)return j.jsx("div",{className:"p-8 text-center",children:"Načítání..."});const p=i.map(v=>`${v.sectionNumber}: ${v.sectionTitle}`).join(", ");return j.jsx(Rt,{title:`Vlastní výběr: ${p}`,correct:n,incorrect:r,refresh:d})}const f4=Aj([{path:"/",element:j.jsx(Xj,{}),children:[{path:"",element:j.jsx(o4,{})},{path:"about",element:j.jsx(d4,{})},{path:"exam/:sectionUUID",element:j.jsx(b4,{})},{path:"exam",element:j.jsx(y4,{})},{path:"exam-custom",element:j.jsx(j4,{})},{path:"credit/:sectionUUID",element:j.jsx(u4,{})},{path:"credit",element:j.jsx(l4,{})},{path:"credit-custom",element:j.jsx(z4,{})}]}],{basename:"/"});ys.createRoot(document.getElementById("root")).render(j.jsx(tp.StrictMode,{children:j.jsx(Bj,{router:f4})}));
