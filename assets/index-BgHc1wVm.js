function Dd(e,o){for(var n=0;n<o.length;n++){const t=o[n];if(typeof t!="string"&&!Array.isArray(t)){for(const r in t)if(r!=="default"&&!(r in e)){const a=Object.getOwnPropertyDescriptor(t,r);a&&Object.defineProperty(e,r,a.get?a:{enumerable:!0,get:()=>t[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const o=document.createElement("link").relList;if(o&&o.supports&&o.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))t(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&t(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function t(r){if(r.ep)return;r.ep=!0;const a=n(r);fetch(r.href,a)}})();function Ld(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var Ud={exports:{}},ri={},_d={exports:{}},J={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ir=Symbol.for("react.element"),Bk=Symbol.for("react.portal"),Kk=Symbol.for("react.fragment"),$k=Symbol.for("react.strict_mode"),Hk=Symbol.for("react.profiler"),Wk=Symbol.for("react.provider"),Zk=Symbol.for("react.context"),Xk=Symbol.for("react.forward_ref"),Gk=Symbol.for("react.suspense"),Jk=Symbol.for("react.memo"),Qk=Symbol.for("react.lazy"),Du=Symbol.iterator;function Yk(e){return e===null||typeof e!="object"?null:(e=Du&&e[Du]||e["@@iterator"],typeof e=="function"?e:null)}var Fd={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Bd=Object.assign,Kd={};function Ct(e,o,n){this.props=e,this.context=o,this.refs=Kd,this.updater=n||Fd}Ct.prototype.isReactComponent={};Ct.prototype.setState=function(e,o){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,o,"setState")};Ct.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function $d(){}$d.prototype=Ct.prototype;function zs(e,o,n){this.props=e,this.context=o,this.refs=Kd,this.updater=n||Fd}var js=zs.prototype=new $d;js.constructor=zs;Bd(js,Ct.prototype);js.isPureReactComponent=!0;var Lu=Array.isArray,Hd=Object.prototype.hasOwnProperty,gs={current:null},Wd={key:!0,ref:!0,__self:!0,__source:!0};function Zd(e,o,n){var t,r={},a=null,i=null;if(o!=null)for(t in o.ref!==void 0&&(i=o.ref),o.key!==void 0&&(a=""+o.key),o)Hd.call(o,t)&&!Wd.hasOwnProperty(t)&&(r[t]=o[t]);var c=arguments.length-2;if(c===1)r.children=n;else if(1<c){for(var s=Array(c),u=0;u<c;u++)s[u]=arguments[u+2];r.children=s}if(e&&e.defaultProps)for(t in c=e.defaultProps,c)r[t]===void 0&&(r[t]=c[t]);return{$$typeof:Ir,type:e,key:a,ref:i,props:r,_owner:gs.current}}function qk(e,o){return{$$typeof:Ir,type:e.type,key:o,ref:e.ref,props:e.props,_owner:e._owner}}function Ns(e){return typeof e=="object"&&e!==null&&e.$$typeof===Ir}function eb(e){var o={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return o[n]})}var Uu=/\/+/g;function Ei(e,o){return typeof e=="object"&&e!==null&&e.key!=null?eb(""+e.key):o.toString(36)}function fa(e,o,n,t,r){var a=typeof e;(a==="undefined"||a==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(a){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case Ir:case Bk:i=!0}}if(i)return i=e,r=r(i),e=t===""?"."+Ei(i,0):t,Lu(r)?(n="",e!=null&&(n=e.replace(Uu,"$&/")+"/"),fa(r,o,n,"",function(u){return u})):r!=null&&(Ns(r)&&(r=qk(r,n+(!r.key||i&&i.key===r.key?"":(""+r.key).replace(Uu,"$&/")+"/")+e)),o.push(r)),1;if(i=0,t=t===""?".":t+":",Lu(e))for(var c=0;c<e.length;c++){a=e[c];var s=t+Ei(a,c);i+=fa(a,o,n,s,r)}else if(s=Yk(e),typeof s=="function")for(e=s.call(e),c=0;!(a=e.next()).done;)a=a.value,s=t+Ei(a,c++),i+=fa(a,o,n,s,r);else if(a==="object")throw o=String(e),Error("Objects are not valid as a React child (found: "+(o==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":o)+"). If you meant to render a collection of children, use an array instead.");return i}function Xr(e,o,n){if(e==null)return e;var t=[],r=0;return fa(e,t,"","",function(a){return o.call(n,a,r++)}),t}function ob(e){if(e._status===-1){var o=e._result;o=o(),o.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=o)}if(e._status===1)return e._result.default;throw e._result}var De={current:null},ha={transition:null},nb={ReactCurrentDispatcher:De,ReactCurrentBatchConfig:ha,ReactCurrentOwner:gs};function Xd(){throw Error("act(...) is not supported in production builds of React.")}J.Children={map:Xr,forEach:function(e,o,n){Xr(e,function(){o.apply(this,arguments)},n)},count:function(e){var o=0;return Xr(e,function(){o++}),o},toArray:function(e){return Xr(e,function(o){return o})||[]},only:function(e){if(!Ns(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};J.Component=Ct;J.Fragment=Kk;J.Profiler=Hk;J.PureComponent=zs;J.StrictMode=$k;J.Suspense=Gk;J.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=nb;J.act=Xd;J.cloneElement=function(e,o,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var t=Bd({},e.props),r=e.key,a=e.ref,i=e._owner;if(o!=null){if(o.ref!==void 0&&(a=o.ref,i=gs.current),o.key!==void 0&&(r=""+o.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(s in o)Hd.call(o,s)&&!Wd.hasOwnProperty(s)&&(t[s]=o[s]===void 0&&c!==void 0?c[s]:o[s])}var s=arguments.length-2;if(s===1)t.children=n;else if(1<s){c=Array(s);for(var u=0;u<s;u++)c[u]=arguments[u+2];t.children=c}return{$$typeof:Ir,type:e.type,key:r,ref:a,props:t,_owner:i}};J.createContext=function(e){return e={$$typeof:Zk,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:Wk,_context:e},e.Consumer=e};J.createElement=Zd;J.createFactory=function(e){var o=Zd.bind(null,e);return o.type=e,o};J.createRef=function(){return{current:null}};J.forwardRef=function(e){return{$$typeof:Xk,render:e}};J.isValidElement=Ns;J.lazy=function(e){return{$$typeof:Qk,_payload:{_status:-1,_result:e},_init:ob}};J.memo=function(e,o){return{$$typeof:Jk,type:e,compare:o===void 0?null:o}};J.startTransition=function(e){var o=ha.transition;ha.transition={};try{e()}finally{ha.transition=o}};J.unstable_act=Xd;J.useCallback=function(e,o){return De.current.useCallback(e,o)};J.useContext=function(e){return De.current.useContext(e)};J.useDebugValue=function(){};J.useDeferredValue=function(e){return De.current.useDeferredValue(e)};J.useEffect=function(e,o){return De.current.useEffect(e,o)};J.useId=function(){return De.current.useId()};J.useImperativeHandle=function(e,o,n){return De.current.useImperativeHandle(e,o,n)};J.useInsertionEffect=function(e,o){return De.current.useInsertionEffect(e,o)};J.useLayoutEffect=function(e,o){return De.current.useLayoutEffect(e,o)};J.useMemo=function(e,o){return De.current.useMemo(e,o)};J.useReducer=function(e,o,n){return De.current.useReducer(e,o,n)};J.useRef=function(e){return De.current.useRef(e)};J.useState=function(e){return De.current.useState(e)};J.useSyncExternalStore=function(e,o,n){return De.current.useSyncExternalStore(e,o,n)};J.useTransition=function(){return De.current.useTransition()};J.version="18.3.1";_d.exports=J;var l=_d.exports;const Gd=Ld(l),Jd=Dd({__proto__:null,default:Gd},[l]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var tb=l,rb=Symbol.for("react.element"),ab=Symbol.for("react.fragment"),ib=Object.prototype.hasOwnProperty,cb=tb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,sb={key:!0,ref:!0,__self:!0,__source:!0};function Qd(e,o,n){var t,r={},a=null,i=null;n!==void 0&&(a=""+n),o.key!==void 0&&(a=""+o.key),o.ref!==void 0&&(i=o.ref);for(t in o)ib.call(o,t)&&!sb.hasOwnProperty(t)&&(r[t]=o[t]);if(e&&e.defaultProps)for(t in o=e.defaultProps,o)r[t]===void 0&&(r[t]=o[t]);return{$$typeof:rb,type:e,key:a,ref:i,props:r,_owner:cb.current}}ri.Fragment=ab;ri.jsx=Qd;ri.jsxs=Qd;Ud.exports=ri;var g=Ud.exports,kc={},Yd={exports:{}},qe={},qd={exports:{}},ep={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function o(E,L){var _=E.length;E.push(L);e:for(;0<_;){var X=_-1>>>1,ee=E[X];if(0<r(ee,L))E[X]=L,E[_]=ee,_=X;else break e}}function n(E){return E.length===0?null:E[0]}function t(E){if(E.length===0)return null;var L=E[0],_=E.pop();if(_!==L){E[0]=_;e:for(var X=0,ee=E.length,vo=ee>>>1;X<vo;){var We=2*(X+1)-1,Ze=E[We],Re=We+1,oo=E[Re];if(0>r(Ze,_))Re<ee&&0>r(oo,Ze)?(E[X]=oo,E[Re]=_,X=Re):(E[X]=Ze,E[We]=_,X=We);else if(Re<ee&&0>r(oo,_))E[X]=oo,E[Re]=_,X=Re;else break e}}return L}function r(E,L){var _=E.sortIndex-L.sortIndex;return _!==0?_:E.id-L.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;e.unstable_now=function(){return a.now()}}else{var i=Date,c=i.now();e.unstable_now=function(){return i.now()-c}}var s=[],u=[],d=1,p=null,v=3,y=!1,z=!1,b=!1,N=typeof setTimeout=="function"?setTimeout:null,k=typeof clearTimeout=="function"?clearTimeout:null,m=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function f(E){for(var L=n(u);L!==null;){if(L.callback===null)t(u);else if(L.startTime<=E)t(u),L.sortIndex=L.expirationTime,o(s,L);else break;L=n(u)}}function T(E){if(b=!1,f(E),!z)if(n(s)!==null)z=!0,He(x);else{var L=n(u);L!==null&&po(T,L.startTime-E)}}function x(E,L){z=!1,b&&(b=!1,k(C),C=-1),y=!0;var _=v;try{for(f(L),p=n(s);p!==null&&(!(p.expirationTime>L)||E&&!Z());){var X=p.callback;if(typeof X=="function"){p.callback=null,v=p.priorityLevel;var ee=X(p.expirationTime<=L);L=e.unstable_now(),typeof ee=="function"?p.callback=ee:p===n(s)&&t(s),f(L)}else t(s);p=n(s)}if(p!==null)var vo=!0;else{var We=n(u);We!==null&&po(T,We.startTime-L),vo=!1}return vo}finally{p=null,v=_,y=!1}}var O=!1,h=null,C=-1,V=5,R=-1;function Z(){return!(e.unstable_now()-R<V)}function F(){if(h!==null){var E=e.unstable_now();R=E;var L=!0;try{L=h(!0,E)}finally{L?oe():(O=!1,h=null)}}else O=!1}var oe;if(typeof m=="function")oe=function(){m(F)};else if(typeof MessageChannel<"u"){var ve=new MessageChannel,Ue=ve.port2;ve.port1.onmessage=F,oe=function(){Ue.postMessage(null)}}else oe=function(){N(F,0)};function He(E){h=E,O||(O=!0,oe())}function po(E,L){C=N(function(){E(e.unstable_now())},L)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(E){E.callback=null},e.unstable_continueExecution=function(){z||y||(z=!0,He(x))},e.unstable_forceFrameRate=function(E){0>E||125<E?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):V=0<E?Math.floor(1e3/E):5},e.unstable_getCurrentPriorityLevel=function(){return v},e.unstable_getFirstCallbackNode=function(){return n(s)},e.unstable_next=function(E){switch(v){case 1:case 2:case 3:var L=3;break;default:L=v}var _=v;v=L;try{return E()}finally{v=_}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(E,L){switch(E){case 1:case 2:case 3:case 4:case 5:break;default:E=3}var _=v;v=E;try{return L()}finally{v=_}},e.unstable_scheduleCallback=function(E,L,_){var X=e.unstable_now();switch(typeof _=="object"&&_!==null?(_=_.delay,_=typeof _=="number"&&0<_?X+_:X):_=X,E){case 1:var ee=-1;break;case 2:ee=250;break;case 5:ee=1073741823;break;case 4:ee=1e4;break;default:ee=5e3}return ee=_+ee,E={id:d++,callback:L,priorityLevel:E,startTime:_,expirationTime:ee,sortIndex:-1},_>X?(E.sortIndex=_,o(u,E),n(s)===null&&E===n(u)&&(b?(k(C),C=-1):b=!0,po(T,_-X))):(E.sortIndex=ee,o(s,E),z||y||(z=!0,He(x))),E},e.unstable_shouldYield=Z,e.unstable_wrapCallback=function(E){var L=v;return function(){var _=v;v=L;try{return E.apply(this,arguments)}finally{v=_}}}})(ep);qd.exports=ep;var ub=qd.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var lb=l,Ye=ub;function w(e){for(var o="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)o+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+o+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var op=new Set,br={};function Fn(e,o){gt(e,o),gt(e+"Capture",o)}function gt(e,o){for(br[e]=o,e=0;e<o.length;e++)op.add(o[e])}var Uo=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),bc=Object.prototype.hasOwnProperty,db=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,_u={},Fu={};function pb(e){return bc.call(Fu,e)?!0:bc.call(_u,e)?!1:db.test(e)?Fu[e]=!0:(_u[e]=!0,!1)}function vb(e,o,n,t){if(n!==null&&n.type===0)return!1;switch(typeof o){case"function":case"symbol":return!0;case"boolean":return t?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function mb(e,o,n,t){if(o===null||typeof o>"u"||vb(e,o,n,t))return!0;if(t)return!1;if(n!==null)switch(n.type){case 3:return!o;case 4:return o===!1;case 5:return isNaN(o);case 6:return isNaN(o)||1>o}return!1}function Le(e,o,n,t,r,a,i){this.acceptsBooleans=o===2||o===3||o===4,this.attributeName=t,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=o,this.sanitizeURL=a,this.removeEmptyString=i}var we={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){we[e]=new Le(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var o=e[0];we[o]=new Le(o,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){we[e]=new Le(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){we[e]=new Le(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){we[e]=new Le(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){we[e]=new Le(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){we[e]=new Le(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){we[e]=new Le(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){we[e]=new Le(e,5,!1,e.toLowerCase(),null,!1,!1)});var Ts=/[\-:]([a-z])/g;function Ss(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var o=e.replace(Ts,Ss);we[o]=new Le(o,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var o=e.replace(Ts,Ss);we[o]=new Le(o,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var o=e.replace(Ts,Ss);we[o]=new Le(o,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){we[e]=new Le(e,1,!1,e.toLowerCase(),null,!1,!1)});we.xlinkHref=new Le("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){we[e]=new Le(e,1,!1,e.toLowerCase(),null,!0,!0)});function Ps(e,o,n,t){var r=we.hasOwnProperty(o)?we[o]:null;(r!==null?r.type!==0:t||!(2<o.length)||o[0]!=="o"&&o[0]!=="O"||o[1]!=="n"&&o[1]!=="N")&&(mb(o,n,r,t)&&(n=null),t||r===null?pb(o)&&(n===null?e.removeAttribute(o):e.setAttribute(o,""+n)):r.mustUseProperty?e[r.propertyName]=n===null?r.type===3?!1:"":n:(o=r.attributeName,t=r.attributeNamespace,n===null?e.removeAttribute(o):(r=r.type,n=r===3||r===4&&n===!0?"":""+n,t?e.setAttributeNS(t,o,n):e.setAttribute(o,n))))}var $o=lb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,Gr=Symbol.for("react.element"),qn=Symbol.for("react.portal"),et=Symbol.for("react.fragment"),xs=Symbol.for("react.strict_mode"),fc=Symbol.for("react.profiler"),np=Symbol.for("react.provider"),tp=Symbol.for("react.context"),ws=Symbol.for("react.forward_ref"),hc=Symbol.for("react.suspense"),yc=Symbol.for("react.suspense_list"),Cs=Symbol.for("react.memo"),on=Symbol.for("react.lazy"),rp=Symbol.for("react.offscreen"),Bu=Symbol.iterator;function Bt(e){return e===null||typeof e!="object"?null:(e=Bu&&e[Bu]||e["@@iterator"],typeof e=="function"?e:null)}var pe=Object.assign,Mi;function or(e){if(Mi===void 0)try{throw Error()}catch(n){var o=n.stack.trim().match(/\n( *(at )?)/);Mi=o&&o[1]||""}return`
`+Mi+e}var Oi=!1;function Ri(e,o){if(!e||Oi)return"";Oi=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(o)if(o=function(){throw Error()},Object.defineProperty(o.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(o,[])}catch(u){var t=u}Reflect.construct(e,[],o)}else{try{o.call()}catch(u){t=u}e.call(o.prototype)}else{try{throw Error()}catch(u){t=u}e()}}catch(u){if(u&&t&&typeof u.stack=="string"){for(var r=u.stack.split(`
`),a=t.stack.split(`
`),i=r.length-1,c=a.length-1;1<=i&&0<=c&&r[i]!==a[c];)c--;for(;1<=i&&0<=c;i--,c--)if(r[i]!==a[c]){if(i!==1||c!==1)do if(i--,c--,0>c||r[i]!==a[c]){var s=`
`+r[i].replace(" at new "," at ");return e.displayName&&s.includes("<anonymous>")&&(s=s.replace("<anonymous>",e.displayName)),s}while(1<=i&&0<=c);break}}}finally{Oi=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?or(e):""}function kb(e){switch(e.tag){case 5:return or(e.type);case 16:return or("Lazy");case 13:return or("Suspense");case 19:return or("SuspenseList");case 0:case 2:case 15:return e=Ri(e.type,!1),e;case 11:return e=Ri(e.type.render,!1),e;case 1:return e=Ri(e.type,!0),e;default:return""}}function zc(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case et:return"Fragment";case qn:return"Portal";case fc:return"Profiler";case xs:return"StrictMode";case hc:return"Suspense";case yc:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case tp:return(e.displayName||"Context")+".Consumer";case np:return(e._context.displayName||"Context")+".Provider";case ws:var o=e.render;return e=e.displayName,e||(e=o.displayName||o.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Cs:return o=e.displayName||null,o!==null?o:zc(e.type)||"Memo";case on:o=e._payload,e=e._init;try{return zc(e(o))}catch{}}return null}function bb(e){var o=e.type;switch(e.tag){case 24:return"Cache";case 9:return(o.displayName||"Context")+".Consumer";case 10:return(o._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=o.render,e=e.displayName||e.name||"",o.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return o;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return zc(o);case 8:return o===xs?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof o=="function")return o.displayName||o.name||null;if(typeof o=="string")return o}return null}function bn(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function ap(e){var o=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(o==="checkbox"||o==="radio")}function fb(e){var o=ap(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,o),t=""+e[o];if(!e.hasOwnProperty(o)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var r=n.get,a=n.set;return Object.defineProperty(e,o,{configurable:!0,get:function(){return r.call(this)},set:function(i){t=""+i,a.call(this,i)}}),Object.defineProperty(e,o,{enumerable:n.enumerable}),{getValue:function(){return t},setValue:function(i){t=""+i},stopTracking:function(){e._valueTracker=null,delete e[o]}}}}function Jr(e){e._valueTracker||(e._valueTracker=fb(e))}function ip(e){if(!e)return!1;var o=e._valueTracker;if(!o)return!0;var n=o.getValue(),t="";return e&&(t=ap(e)?e.checked?"true":"false":e.value),e=t,e!==n?(o.setValue(e),!0):!1}function Ma(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function jc(e,o){var n=o.checked;return pe({},o,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function Ku(e,o){var n=o.defaultValue==null?"":o.defaultValue,t=o.checked!=null?o.checked:o.defaultChecked;n=bn(o.value!=null?o.value:n),e._wrapperState={initialChecked:t,initialValue:n,controlled:o.type==="checkbox"||o.type==="radio"?o.checked!=null:o.value!=null}}function cp(e,o){o=o.checked,o!=null&&Ps(e,"checked",o,!1)}function gc(e,o){cp(e,o);var n=bn(o.value),t=o.type;if(n!=null)t==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(t==="submit"||t==="reset"){e.removeAttribute("value");return}o.hasOwnProperty("value")?Nc(e,o.type,n):o.hasOwnProperty("defaultValue")&&Nc(e,o.type,bn(o.defaultValue)),o.checked==null&&o.defaultChecked!=null&&(e.defaultChecked=!!o.defaultChecked)}function $u(e,o,n){if(o.hasOwnProperty("value")||o.hasOwnProperty("defaultValue")){var t=o.type;if(!(t!=="submit"&&t!=="reset"||o.value!==void 0&&o.value!==null))return;o=""+e._wrapperState.initialValue,n||o===e.value||(e.value=o),e.defaultValue=o}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function Nc(e,o,n){(o!=="number"||Ma(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var nr=Array.isArray;function vt(e,o,n,t){if(e=e.options,o){o={};for(var r=0;r<n.length;r++)o["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=o.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&t&&(e[n].defaultSelected=!0)}else{for(n=""+bn(n),o=null,r=0;r<e.length;r++){if(e[r].value===n){e[r].selected=!0,t&&(e[r].defaultSelected=!0);return}o!==null||e[r].disabled||(o=e[r])}o!==null&&(o.selected=!0)}}function Tc(e,o){if(o.dangerouslySetInnerHTML!=null)throw Error(w(91));return pe({},o,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function Hu(e,o){var n=o.value;if(n==null){if(n=o.children,o=o.defaultValue,n!=null){if(o!=null)throw Error(w(92));if(nr(n)){if(1<n.length)throw Error(w(93));n=n[0]}o=n}o==null&&(o=""),n=o}e._wrapperState={initialValue:bn(n)}}function sp(e,o){var n=bn(o.value),t=bn(o.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),o.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),t!=null&&(e.defaultValue=""+t)}function Wu(e){var o=e.textContent;o===e._wrapperState.initialValue&&o!==""&&o!==null&&(e.value=o)}function up(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Sc(e,o){return e==null||e==="http://www.w3.org/1999/xhtml"?up(o):e==="http://www.w3.org/2000/svg"&&o==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var Qr,lp=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(o,n,t,r){MSApp.execUnsafeLocalFunction(function(){return e(o,n,t,r)})}:e}(function(e,o){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=o;else{for(Qr=Qr||document.createElement("div"),Qr.innerHTML="<svg>"+o.valueOf().toString()+"</svg>",o=Qr.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;o.firstChild;)e.appendChild(o.firstChild)}});function fr(e,o){if(o){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=o;return}}e.textContent=o}var ar={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},hb=["Webkit","ms","Moz","O"];Object.keys(ar).forEach(function(e){hb.forEach(function(o){o=o+e.charAt(0).toUpperCase()+e.substring(1),ar[o]=ar[e]})});function dp(e,o,n){return o==null||typeof o=="boolean"||o===""?"":n||typeof o!="number"||o===0||ar.hasOwnProperty(e)&&ar[e]?(""+o).trim():o+"px"}function pp(e,o){e=e.style;for(var n in o)if(o.hasOwnProperty(n)){var t=n.indexOf("--")===0,r=dp(n,o[n],t);n==="float"&&(n="cssFloat"),t?e.setProperty(n,r):e[n]=r}}var yb=pe({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Pc(e,o){if(o){if(yb[e]&&(o.children!=null||o.dangerouslySetInnerHTML!=null))throw Error(w(137,e));if(o.dangerouslySetInnerHTML!=null){if(o.children!=null)throw Error(w(60));if(typeof o.dangerouslySetInnerHTML!="object"||!("__html"in o.dangerouslySetInnerHTML))throw Error(w(61))}if(o.style!=null&&typeof o.style!="object")throw Error(w(62))}}function xc(e,o){if(e.indexOf("-")===-1)return typeof o.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var wc=null;function Es(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var Cc=null,mt=null,kt=null;function Zu(e){if(e=Lr(e)){if(typeof Cc!="function")throw Error(w(280));var o=e.stateNode;o&&(o=ui(o),Cc(e.stateNode,e.type,o))}}function vp(e){mt?kt?kt.push(e):kt=[e]:mt=e}function mp(){if(mt){var e=mt,o=kt;if(kt=mt=null,Zu(e),o)for(e=0;e<o.length;e++)Zu(o[e])}}function kp(e,o){return e(o)}function bp(){}var Ai=!1;function fp(e,o,n){if(Ai)return e(o,n);Ai=!0;try{return kp(e,o,n)}finally{Ai=!1,(mt!==null||kt!==null)&&(bp(),mp())}}function hr(e,o){var n=e.stateNode;if(n===null)return null;var t=ui(n);if(t===null)return null;n=t[o];e:switch(o){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(t=!t.disabled)||(e=e.type,t=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!t;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(w(231,o,typeof n));return n}var Ec=!1;if(Uo)try{var Kt={};Object.defineProperty(Kt,"passive",{get:function(){Ec=!0}}),window.addEventListener("test",Kt,Kt),window.removeEventListener("test",Kt,Kt)}catch{Ec=!1}function zb(e,o,n,t,r,a,i,c,s){var u=Array.prototype.slice.call(arguments,3);try{o.apply(n,u)}catch(d){this.onError(d)}}var ir=!1,Oa=null,Ra=!1,Mc=null,jb={onError:function(e){ir=!0,Oa=e}};function gb(e,o,n,t,r,a,i,c,s){ir=!1,Oa=null,zb.apply(jb,arguments)}function Nb(e,o,n,t,r,a,i,c,s){if(gb.apply(this,arguments),ir){if(ir){var u=Oa;ir=!1,Oa=null}else throw Error(w(198));Ra||(Ra=!0,Mc=u)}}function Bn(e){var o=e,n=e;if(e.alternate)for(;o.return;)o=o.return;else{e=o;do o=e,o.flags&4098&&(n=o.return),e=o.return;while(e)}return o.tag===3?n:null}function hp(e){if(e.tag===13){var o=e.memoizedState;if(o===null&&(e=e.alternate,e!==null&&(o=e.memoizedState)),o!==null)return o.dehydrated}return null}function Xu(e){if(Bn(e)!==e)throw Error(w(188))}function Tb(e){var o=e.alternate;if(!o){if(o=Bn(e),o===null)throw Error(w(188));return o!==e?null:e}for(var n=e,t=o;;){var r=n.return;if(r===null)break;var a=r.alternate;if(a===null){if(t=r.return,t!==null){n=t;continue}break}if(r.child===a.child){for(a=r.child;a;){if(a===n)return Xu(r),e;if(a===t)return Xu(r),o;a=a.sibling}throw Error(w(188))}if(n.return!==t.return)n=r,t=a;else{for(var i=!1,c=r.child;c;){if(c===n){i=!0,n=r,t=a;break}if(c===t){i=!0,t=r,n=a;break}c=c.sibling}if(!i){for(c=a.child;c;){if(c===n){i=!0,n=a,t=r;break}if(c===t){i=!0,t=a,n=r;break}c=c.sibling}if(!i)throw Error(w(189))}}if(n.alternate!==t)throw Error(w(190))}if(n.tag!==3)throw Error(w(188));return n.stateNode.current===n?e:o}function yp(e){return e=Tb(e),e!==null?zp(e):null}function zp(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var o=zp(e);if(o!==null)return o;e=e.sibling}return null}var jp=Ye.unstable_scheduleCallback,Gu=Ye.unstable_cancelCallback,Sb=Ye.unstable_shouldYield,Pb=Ye.unstable_requestPaint,ke=Ye.unstable_now,xb=Ye.unstable_getCurrentPriorityLevel,Ms=Ye.unstable_ImmediatePriority,gp=Ye.unstable_UserBlockingPriority,Aa=Ye.unstable_NormalPriority,wb=Ye.unstable_LowPriority,Np=Ye.unstable_IdlePriority,ai=null,Co=null;function Cb(e){if(Co&&typeof Co.onCommitFiberRoot=="function")try{Co.onCommitFiberRoot(ai,e,void 0,(e.current.flags&128)===128)}catch{}}var yo=Math.clz32?Math.clz32:Ob,Eb=Math.log,Mb=Math.LN2;function Ob(e){return e>>>=0,e===0?32:31-(Eb(e)/Mb|0)|0}var Yr=64,qr=4194304;function tr(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Ia(e,o){var n=e.pendingLanes;if(n===0)return 0;var t=0,r=e.suspendedLanes,a=e.pingedLanes,i=n&268435455;if(i!==0){var c=i&~r;c!==0?t=tr(c):(a&=i,a!==0&&(t=tr(a)))}else i=n&~r,i!==0?t=tr(i):a!==0&&(t=tr(a));if(t===0)return 0;if(o!==0&&o!==t&&!(o&r)&&(r=t&-t,a=o&-o,r>=a||r===16&&(a&4194240)!==0))return o;if(t&4&&(t|=n&16),o=e.entangledLanes,o!==0)for(e=e.entanglements,o&=t;0<o;)n=31-yo(o),r=1<<n,t|=e[n],o&=~r;return t}function Rb(e,o){switch(e){case 1:case 2:case 4:return o+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return o+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Ab(e,o){for(var n=e.suspendedLanes,t=e.pingedLanes,r=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-yo(a),c=1<<i,s=r[i];s===-1?(!(c&n)||c&t)&&(r[i]=Rb(c,o)):s<=o&&(e.expiredLanes|=c),a&=~c}}function Oc(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function Tp(){var e=Yr;return Yr<<=1,!(Yr&4194240)&&(Yr=64),e}function Ii(e){for(var o=[],n=0;31>n;n++)o.push(e);return o}function Vr(e,o,n){e.pendingLanes|=o,o!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,o=31-yo(o),e[o]=n}function Ib(e,o){var n=e.pendingLanes&~o;e.pendingLanes=o,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=o,e.mutableReadLanes&=o,e.entangledLanes&=o,o=e.entanglements;var t=e.eventTimes;for(e=e.expirationTimes;0<n;){var r=31-yo(n),a=1<<r;o[r]=0,t[r]=-1,e[r]=-1,n&=~a}}function Os(e,o){var n=e.entangledLanes|=o;for(e=e.entanglements;n;){var t=31-yo(n),r=1<<t;r&o|e[t]&o&&(e[t]|=o),n&=~r}}var q=0;function Sp(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var Pp,Rs,xp,wp,Cp,Rc=!1,ea=[],sn=null,un=null,ln=null,yr=new Map,zr=new Map,tn=[],Vb="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Ju(e,o){switch(e){case"focusin":case"focusout":sn=null;break;case"dragenter":case"dragleave":un=null;break;case"mouseover":case"mouseout":ln=null;break;case"pointerover":case"pointerout":yr.delete(o.pointerId);break;case"gotpointercapture":case"lostpointercapture":zr.delete(o.pointerId)}}function $t(e,o,n,t,r,a){return e===null||e.nativeEvent!==a?(e={blockedOn:o,domEventName:n,eventSystemFlags:t,nativeEvent:a,targetContainers:[r]},o!==null&&(o=Lr(o),o!==null&&Rs(o)),e):(e.eventSystemFlags|=t,o=e.targetContainers,r!==null&&o.indexOf(r)===-1&&o.push(r),e)}function Db(e,o,n,t,r){switch(o){case"focusin":return sn=$t(sn,e,o,n,t,r),!0;case"dragenter":return un=$t(un,e,o,n,t,r),!0;case"mouseover":return ln=$t(ln,e,o,n,t,r),!0;case"pointerover":var a=r.pointerId;return yr.set(a,$t(yr.get(a)||null,e,o,n,t,r)),!0;case"gotpointercapture":return a=r.pointerId,zr.set(a,$t(zr.get(a)||null,e,o,n,t,r)),!0}return!1}function Ep(e){var o=Sn(e.target);if(o!==null){var n=Bn(o);if(n!==null){if(o=n.tag,o===13){if(o=hp(n),o!==null){e.blockedOn=o,Cp(e.priority,function(){xp(n)});return}}else if(o===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function ya(e){if(e.blockedOn!==null)return!1;for(var o=e.targetContainers;0<o.length;){var n=Ac(e.domEventName,e.eventSystemFlags,o[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var t=new n.constructor(n.type,n);wc=t,n.target.dispatchEvent(t),wc=null}else return o=Lr(n),o!==null&&Rs(o),e.blockedOn=n,!1;o.shift()}return!0}function Qu(e,o,n){ya(e)&&n.delete(o)}function Lb(){Rc=!1,sn!==null&&ya(sn)&&(sn=null),un!==null&&ya(un)&&(un=null),ln!==null&&ya(ln)&&(ln=null),yr.forEach(Qu),zr.forEach(Qu)}function Ht(e,o){e.blockedOn===o&&(e.blockedOn=null,Rc||(Rc=!0,Ye.unstable_scheduleCallback(Ye.unstable_NormalPriority,Lb)))}function jr(e){function o(r){return Ht(r,e)}if(0<ea.length){Ht(ea[0],e);for(var n=1;n<ea.length;n++){var t=ea[n];t.blockedOn===e&&(t.blockedOn=null)}}for(sn!==null&&Ht(sn,e),un!==null&&Ht(un,e),ln!==null&&Ht(ln,e),yr.forEach(o),zr.forEach(o),n=0;n<tn.length;n++)t=tn[n],t.blockedOn===e&&(t.blockedOn=null);for(;0<tn.length&&(n=tn[0],n.blockedOn===null);)Ep(n),n.blockedOn===null&&tn.shift()}var bt=$o.ReactCurrentBatchConfig,Va=!0;function Ub(e,o,n,t){var r=q,a=bt.transition;bt.transition=null;try{q=1,As(e,o,n,t)}finally{q=r,bt.transition=a}}function _b(e,o,n,t){var r=q,a=bt.transition;bt.transition=null;try{q=4,As(e,o,n,t)}finally{q=r,bt.transition=a}}function As(e,o,n,t){if(Va){var r=Ac(e,o,n,t);if(r===null)Hi(e,o,t,Da,n),Ju(e,t);else if(Db(r,e,o,n,t))t.stopPropagation();else if(Ju(e,t),o&4&&-1<Vb.indexOf(e)){for(;r!==null;){var a=Lr(r);if(a!==null&&Pp(a),a=Ac(e,o,n,t),a===null&&Hi(e,o,t,Da,n),a===r)break;r=a}r!==null&&t.stopPropagation()}else Hi(e,o,t,null,n)}}var Da=null;function Ac(e,o,n,t){if(Da=null,e=Es(t),e=Sn(e),e!==null)if(o=Bn(e),o===null)e=null;else if(n=o.tag,n===13){if(e=hp(o),e!==null)return e;e=null}else if(n===3){if(o.stateNode.current.memoizedState.isDehydrated)return o.tag===3?o.stateNode.containerInfo:null;e=null}else o!==e&&(e=null);return Da=e,null}function Mp(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(xb()){case Ms:return 1;case gp:return 4;case Aa:case wb:return 16;case Np:return 536870912;default:return 16}default:return 16}}var an=null,Is=null,za=null;function Op(){if(za)return za;var e,o=Is,n=o.length,t,r="value"in an?an.value:an.textContent,a=r.length;for(e=0;e<n&&o[e]===r[e];e++);var i=n-e;for(t=1;t<=i&&o[n-t]===r[a-t];t++);return za=r.slice(e,1<t?1-t:void 0)}function ja(e){var o=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&o===13&&(e=13)):e=o,e===10&&(e=13),32<=e||e===13?e:0}function oa(){return!0}function Yu(){return!1}function eo(e){function o(n,t,r,a,i){this._reactName=n,this._targetInst=r,this.type=t,this.nativeEvent=a,this.target=i,this.currentTarget=null;for(var c in e)e.hasOwnProperty(c)&&(n=e[c],this[c]=n?n(a):a[c]);return this.isDefaultPrevented=(a.defaultPrevented!=null?a.defaultPrevented:a.returnValue===!1)?oa:Yu,this.isPropagationStopped=Yu,this}return pe(o.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=oa)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=oa)},persist:function(){},isPersistent:oa}),o}var Et={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Vs=eo(Et),Dr=pe({},Et,{view:0,detail:0}),Fb=eo(Dr),Vi,Di,Wt,ii=pe({},Dr,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Ds,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Wt&&(Wt&&e.type==="mousemove"?(Vi=e.screenX-Wt.screenX,Di=e.screenY-Wt.screenY):Di=Vi=0,Wt=e),Vi)},movementY:function(e){return"movementY"in e?e.movementY:Di}}),qu=eo(ii),Bb=pe({},ii,{dataTransfer:0}),Kb=eo(Bb),$b=pe({},Dr,{relatedTarget:0}),Li=eo($b),Hb=pe({},Et,{animationName:0,elapsedTime:0,pseudoElement:0}),Wb=eo(Hb),Zb=pe({},Et,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Xb=eo(Zb),Gb=pe({},Et,{data:0}),el=eo(Gb),Jb={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Qb={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Yb={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function qb(e){var o=this.nativeEvent;return o.getModifierState?o.getModifierState(e):(e=Yb[e])?!!o[e]:!1}function Ds(){return qb}var ef=pe({},Dr,{key:function(e){if(e.key){var o=Jb[e.key]||e.key;if(o!=="Unidentified")return o}return e.type==="keypress"?(e=ja(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?Qb[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Ds,charCode:function(e){return e.type==="keypress"?ja(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?ja(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),of=eo(ef),nf=pe({},ii,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),ol=eo(nf),tf=pe({},Dr,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Ds}),rf=eo(tf),af=pe({},Et,{propertyName:0,elapsedTime:0,pseudoElement:0}),cf=eo(af),sf=pe({},ii,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),uf=eo(sf),lf=[9,13,27,32],Ls=Uo&&"CompositionEvent"in window,cr=null;Uo&&"documentMode"in document&&(cr=document.documentMode);var df=Uo&&"TextEvent"in window&&!cr,Rp=Uo&&(!Ls||cr&&8<cr&&11>=cr),nl=" ",tl=!1;function Ap(e,o){switch(e){case"keyup":return lf.indexOf(o.keyCode)!==-1;case"keydown":return o.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Ip(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var ot=!1;function pf(e,o){switch(e){case"compositionend":return Ip(o);case"keypress":return o.which!==32?null:(tl=!0,nl);case"textInput":return e=o.data,e===nl&&tl?null:e;default:return null}}function vf(e,o){if(ot)return e==="compositionend"||!Ls&&Ap(e,o)?(e=Op(),za=Is=an=null,ot=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(o.ctrlKey||o.altKey||o.metaKey)||o.ctrlKey&&o.altKey){if(o.char&&1<o.char.length)return o.char;if(o.which)return String.fromCharCode(o.which)}return null;case"compositionend":return Rp&&o.locale!=="ko"?null:o.data;default:return null}}var mf={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function rl(e){var o=e&&e.nodeName&&e.nodeName.toLowerCase();return o==="input"?!!mf[e.type]:o==="textarea"}function Vp(e,o,n,t){vp(t),o=La(o,"onChange"),0<o.length&&(n=new Vs("onChange","change",null,n,t),e.push({event:n,listeners:o}))}var sr=null,gr=null;function kf(e){Zp(e,0)}function ci(e){var o=rt(e);if(ip(o))return e}function bf(e,o){if(e==="change")return o}var Dp=!1;if(Uo){var Ui;if(Uo){var _i="oninput"in document;if(!_i){var al=document.createElement("div");al.setAttribute("oninput","return;"),_i=typeof al.oninput=="function"}Ui=_i}else Ui=!1;Dp=Ui&&(!document.documentMode||9<document.documentMode)}function il(){sr&&(sr.detachEvent("onpropertychange",Lp),gr=sr=null)}function Lp(e){if(e.propertyName==="value"&&ci(gr)){var o=[];Vp(o,gr,e,Es(e)),fp(kf,o)}}function ff(e,o,n){e==="focusin"?(il(),sr=o,gr=n,sr.attachEvent("onpropertychange",Lp)):e==="focusout"&&il()}function hf(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return ci(gr)}function yf(e,o){if(e==="click")return ci(o)}function zf(e,o){if(e==="input"||e==="change")return ci(o)}function jf(e,o){return e===o&&(e!==0||1/e===1/o)||e!==e&&o!==o}var jo=typeof Object.is=="function"?Object.is:jf;function Nr(e,o){if(jo(e,o))return!0;if(typeof e!="object"||e===null||typeof o!="object"||o===null)return!1;var n=Object.keys(e),t=Object.keys(o);if(n.length!==t.length)return!1;for(t=0;t<n.length;t++){var r=n[t];if(!bc.call(o,r)||!jo(e[r],o[r]))return!1}return!0}function cl(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function sl(e,o){var n=cl(e);e=0;for(var t;n;){if(n.nodeType===3){if(t=e+n.textContent.length,e<=o&&t>=o)return{node:n,offset:o-e};e=t}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=cl(n)}}function Up(e,o){return e&&o?e===o?!0:e&&e.nodeType===3?!1:o&&o.nodeType===3?Up(e,o.parentNode):"contains"in e?e.contains(o):e.compareDocumentPosition?!!(e.compareDocumentPosition(o)&16):!1:!1}function _p(){for(var e=window,o=Ma();o instanceof e.HTMLIFrameElement;){try{var n=typeof o.contentWindow.location.href=="string"}catch{n=!1}if(n)e=o.contentWindow;else break;o=Ma(e.document)}return o}function Us(e){var o=e&&e.nodeName&&e.nodeName.toLowerCase();return o&&(o==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||o==="textarea"||e.contentEditable==="true")}function gf(e){var o=_p(),n=e.focusedElem,t=e.selectionRange;if(o!==n&&n&&n.ownerDocument&&Up(n.ownerDocument.documentElement,n)){if(t!==null&&Us(n)){if(o=t.start,e=t.end,e===void 0&&(e=o),"selectionStart"in n)n.selectionStart=o,n.selectionEnd=Math.min(e,n.value.length);else if(e=(o=n.ownerDocument||document)&&o.defaultView||window,e.getSelection){e=e.getSelection();var r=n.textContent.length,a=Math.min(t.start,r);t=t.end===void 0?a:Math.min(t.end,r),!e.extend&&a>t&&(r=t,t=a,a=r),r=sl(n,a);var i=sl(n,t);r&&i&&(e.rangeCount!==1||e.anchorNode!==r.node||e.anchorOffset!==r.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&(o=o.createRange(),o.setStart(r.node,r.offset),e.removeAllRanges(),a>t?(e.addRange(o),e.extend(i.node,i.offset)):(o.setEnd(i.node,i.offset),e.addRange(o)))}}for(o=[],e=n;e=e.parentNode;)e.nodeType===1&&o.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<o.length;n++)e=o[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var Nf=Uo&&"documentMode"in document&&11>=document.documentMode,nt=null,Ic=null,ur=null,Vc=!1;function ul(e,o,n){var t=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;Vc||nt==null||nt!==Ma(t)||(t=nt,"selectionStart"in t&&Us(t)?t={start:t.selectionStart,end:t.selectionEnd}:(t=(t.ownerDocument&&t.ownerDocument.defaultView||window).getSelection(),t={anchorNode:t.anchorNode,anchorOffset:t.anchorOffset,focusNode:t.focusNode,focusOffset:t.focusOffset}),ur&&Nr(ur,t)||(ur=t,t=La(Ic,"onSelect"),0<t.length&&(o=new Vs("onSelect","select",null,o,n),e.push({event:o,listeners:t}),o.target=nt)))}function na(e,o){var n={};return n[e.toLowerCase()]=o.toLowerCase(),n["Webkit"+e]="webkit"+o,n["Moz"+e]="moz"+o,n}var tt={animationend:na("Animation","AnimationEnd"),animationiteration:na("Animation","AnimationIteration"),animationstart:na("Animation","AnimationStart"),transitionend:na("Transition","TransitionEnd")},Fi={},Fp={};Uo&&(Fp=document.createElement("div").style,"AnimationEvent"in window||(delete tt.animationend.animation,delete tt.animationiteration.animation,delete tt.animationstart.animation),"TransitionEvent"in window||delete tt.transitionend.transition);function si(e){if(Fi[e])return Fi[e];if(!tt[e])return e;var o=tt[e],n;for(n in o)if(o.hasOwnProperty(n)&&n in Fp)return Fi[e]=o[n];return e}var Bp=si("animationend"),Kp=si("animationiteration"),$p=si("animationstart"),Hp=si("transitionend"),Wp=new Map,ll="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function yn(e,o){Wp.set(e,o),Fn(o,[e])}for(var Bi=0;Bi<ll.length;Bi++){var Ki=ll[Bi],Tf=Ki.toLowerCase(),Sf=Ki[0].toUpperCase()+Ki.slice(1);yn(Tf,"on"+Sf)}yn(Bp,"onAnimationEnd");yn(Kp,"onAnimationIteration");yn($p,"onAnimationStart");yn("dblclick","onDoubleClick");yn("focusin","onFocus");yn("focusout","onBlur");yn(Hp,"onTransitionEnd");gt("onMouseEnter",["mouseout","mouseover"]);gt("onMouseLeave",["mouseout","mouseover"]);gt("onPointerEnter",["pointerout","pointerover"]);gt("onPointerLeave",["pointerout","pointerover"]);Fn("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Fn("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Fn("onBeforeInput",["compositionend","keypress","textInput","paste"]);Fn("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Fn("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Fn("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var rr="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new Set("cancel close invalid load scroll toggle".split(" ").concat(rr));function dl(e,o,n){var t=e.type||"unknown-event";e.currentTarget=n,Nb(t,o,void 0,e),e.currentTarget=null}function Zp(e,o){o=(o&4)!==0;for(var n=0;n<e.length;n++){var t=e[n],r=t.event;t=t.listeners;e:{var a=void 0;if(o)for(var i=t.length-1;0<=i;i--){var c=t[i],s=c.instance,u=c.currentTarget;if(c=c.listener,s!==a&&r.isPropagationStopped())break e;dl(r,c,u),a=s}else for(i=0;i<t.length;i++){if(c=t[i],s=c.instance,u=c.currentTarget,c=c.listener,s!==a&&r.isPropagationStopped())break e;dl(r,c,u),a=s}}}if(Ra)throw e=Mc,Ra=!1,Mc=null,e}function re(e,o){var n=o[Fc];n===void 0&&(n=o[Fc]=new Set);var t=e+"__bubble";n.has(t)||(Xp(o,e,2,!1),n.add(t))}function $i(e,o,n){var t=0;o&&(t|=4),Xp(n,e,t,o)}var ta="_reactListening"+Math.random().toString(36).slice(2);function Tr(e){if(!e[ta]){e[ta]=!0,op.forEach(function(n){n!=="selectionchange"&&(Pf.has(n)||$i(n,!1,e),$i(n,!0,e))});var o=e.nodeType===9?e:e.ownerDocument;o===null||o[ta]||(o[ta]=!0,$i("selectionchange",!1,o))}}function Xp(e,o,n,t){switch(Mp(o)){case 1:var r=Ub;break;case 4:r=_b;break;default:r=As}n=r.bind(null,o,n,e),r=void 0,!Ec||o!=="touchstart"&&o!=="touchmove"&&o!=="wheel"||(r=!0),t?r!==void 0?e.addEventListener(o,n,{capture:!0,passive:r}):e.addEventListener(o,n,!0):r!==void 0?e.addEventListener(o,n,{passive:r}):e.addEventListener(o,n,!1)}function Hi(e,o,n,t,r){var a=t;if(!(o&1)&&!(o&2)&&t!==null)e:for(;;){if(t===null)return;var i=t.tag;if(i===3||i===4){var c=t.stateNode.containerInfo;if(c===r||c.nodeType===8&&c.parentNode===r)break;if(i===4)for(i=t.return;i!==null;){var s=i.tag;if((s===3||s===4)&&(s=i.stateNode.containerInfo,s===r||s.nodeType===8&&s.parentNode===r))return;i=i.return}for(;c!==null;){if(i=Sn(c),i===null)return;if(s=i.tag,s===5||s===6){t=a=i;continue e}c=c.parentNode}}t=t.return}fp(function(){var u=a,d=Es(n),p=[];e:{var v=Wp.get(e);if(v!==void 0){var y=Vs,z=e;switch(e){case"keypress":if(ja(n)===0)break e;case"keydown":case"keyup":y=of;break;case"focusin":z="focus",y=Li;break;case"focusout":z="blur",y=Li;break;case"beforeblur":case"afterblur":y=Li;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":y=qu;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":y=Kb;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":y=rf;break;case Bp:case Kp:case $p:y=Wb;break;case Hp:y=cf;break;case"scroll":y=Fb;break;case"wheel":y=uf;break;case"copy":case"cut":case"paste":y=Xb;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":y=ol}var b=(o&4)!==0,N=!b&&e==="scroll",k=b?v!==null?v+"Capture":null:v;b=[];for(var m=u,f;m!==null;){f=m;var T=f.stateNode;if(f.tag===5&&T!==null&&(f=T,k!==null&&(T=hr(m,k),T!=null&&b.push(Sr(m,T,f)))),N)break;m=m.return}0<b.length&&(v=new y(v,z,null,n,d),p.push({event:v,listeners:b}))}}if(!(o&7)){e:{if(v=e==="mouseover"||e==="pointerover",y=e==="mouseout"||e==="pointerout",v&&n!==wc&&(z=n.relatedTarget||n.fromElement)&&(Sn(z)||z[_o]))break e;if((y||v)&&(v=d.window===d?d:(v=d.ownerDocument)?v.defaultView||v.parentWindow:window,y?(z=n.relatedTarget||n.toElement,y=u,z=z?Sn(z):null,z!==null&&(N=Bn(z),z!==N||z.tag!==5&&z.tag!==6)&&(z=null)):(y=null,z=u),y!==z)){if(b=qu,T="onMouseLeave",k="onMouseEnter",m="mouse",(e==="pointerout"||e==="pointerover")&&(b=ol,T="onPointerLeave",k="onPointerEnter",m="pointer"),N=y==null?v:rt(y),f=z==null?v:rt(z),v=new b(T,m+"leave",y,n,d),v.target=N,v.relatedTarget=f,T=null,Sn(d)===u&&(b=new b(k,m+"enter",z,n,d),b.target=f,b.relatedTarget=N,T=b),N=T,y&&z)o:{for(b=y,k=z,m=0,f=b;f;f=Xn(f))m++;for(f=0,T=k;T;T=Xn(T))f++;for(;0<m-f;)b=Xn(b),m--;for(;0<f-m;)k=Xn(k),f--;for(;m--;){if(b===k||k!==null&&b===k.alternate)break o;b=Xn(b),k=Xn(k)}b=null}else b=null;y!==null&&pl(p,v,y,b,!1),z!==null&&N!==null&&pl(p,N,z,b,!0)}}e:{if(v=u?rt(u):window,y=v.nodeName&&v.nodeName.toLowerCase(),y==="select"||y==="input"&&v.type==="file")var x=bf;else if(rl(v))if(Dp)x=zf;else{x=hf;var O=ff}else(y=v.nodeName)&&y.toLowerCase()==="input"&&(v.type==="checkbox"||v.type==="radio")&&(x=yf);if(x&&(x=x(e,u))){Vp(p,x,n,d);break e}O&&O(e,v,u),e==="focusout"&&(O=v._wrapperState)&&O.controlled&&v.type==="number"&&Nc(v,"number",v.value)}switch(O=u?rt(u):window,e){case"focusin":(rl(O)||O.contentEditable==="true")&&(nt=O,Ic=u,ur=null);break;case"focusout":ur=Ic=nt=null;break;case"mousedown":Vc=!0;break;case"contextmenu":case"mouseup":case"dragend":Vc=!1,ul(p,n,d);break;case"selectionchange":if(Nf)break;case"keydown":case"keyup":ul(p,n,d)}var h;if(Ls)e:{switch(e){case"compositionstart":var C="onCompositionStart";break e;case"compositionend":C="onCompositionEnd";break e;case"compositionupdate":C="onCompositionUpdate";break e}C=void 0}else ot?Ap(e,n)&&(C="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(C="onCompositionStart");C&&(Rp&&n.locale!=="ko"&&(ot||C!=="onCompositionStart"?C==="onCompositionEnd"&&ot&&(h=Op()):(an=d,Is="value"in an?an.value:an.textContent,ot=!0)),O=La(u,C),0<O.length&&(C=new el(C,e,null,n,d),p.push({event:C,listeners:O}),h?C.data=h:(h=Ip(n),h!==null&&(C.data=h)))),(h=df?pf(e,n):vf(e,n))&&(u=La(u,"onBeforeInput"),0<u.length&&(d=new el("onBeforeInput","beforeinput",null,n,d),p.push({event:d,listeners:u}),d.data=h))}Zp(p,o)})}function Sr(e,o,n){return{instance:e,listener:o,currentTarget:n}}function La(e,o){for(var n=o+"Capture",t=[];e!==null;){var r=e,a=r.stateNode;r.tag===5&&a!==null&&(r=a,a=hr(e,n),a!=null&&t.unshift(Sr(e,a,r)),a=hr(e,o),a!=null&&t.push(Sr(e,a,r))),e=e.return}return t}function Xn(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function pl(e,o,n,t,r){for(var a=o._reactName,i=[];n!==null&&n!==t;){var c=n,s=c.alternate,u=c.stateNode;if(s!==null&&s===t)break;c.tag===5&&u!==null&&(c=u,r?(s=hr(n,a),s!=null&&i.unshift(Sr(n,s,c))):r||(s=hr(n,a),s!=null&&i.push(Sr(n,s,c)))),n=n.return}i.length!==0&&e.push({event:o,listeners:i})}var xf=/\r\n?/g,wf=/\u0000|\uFFFD/g;function vl(e){return(typeof e=="string"?e:""+e).replace(xf,`
`).replace(wf,"")}function ra(e,o,n){if(o=vl(o),vl(e)!==o&&n)throw Error(w(425))}function Ua(){}var Dc=null,Lc=null;function Uc(e,o){return e==="textarea"||e==="noscript"||typeof o.children=="string"||typeof o.children=="number"||typeof o.dangerouslySetInnerHTML=="object"&&o.dangerouslySetInnerHTML!==null&&o.dangerouslySetInnerHTML.__html!=null}var _c=typeof setTimeout=="function"?setTimeout:void 0,Cf=typeof clearTimeout=="function"?clearTimeout:void 0,ml=typeof Promise=="function"?Promise:void 0,Ef=typeof queueMicrotask=="function"?queueMicrotask:typeof ml<"u"?function(e){return ml.resolve(null).then(e).catch(Mf)}:_c;function Mf(e){setTimeout(function(){throw e})}function Wi(e,o){var n=o,t=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&r.nodeType===8)if(n=r.data,n==="/$"){if(t===0){e.removeChild(r),jr(o);return}t--}else n!=="$"&&n!=="$?"&&n!=="$!"||t++;n=r}while(n);jr(o)}function dn(e){for(;e!=null;e=e.nextSibling){var o=e.nodeType;if(o===1||o===3)break;if(o===8){if(o=e.data,o==="$"||o==="$!"||o==="$?")break;if(o==="/$")return null}}return e}function kl(e){e=e.previousSibling;for(var o=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(o===0)return e;o--}else n==="/$"&&o++}e=e.previousSibling}return null}var Mt=Math.random().toString(36).slice(2),Po="__reactFiber$"+Mt,Pr="__reactProps$"+Mt,_o="__reactContainer$"+Mt,Fc="__reactEvents$"+Mt,Of="__reactListeners$"+Mt,Rf="__reactHandles$"+Mt;function Sn(e){var o=e[Po];if(o)return o;for(var n=e.parentNode;n;){if(o=n[_o]||n[Po]){if(n=o.alternate,o.child!==null||n!==null&&n.child!==null)for(e=kl(e);e!==null;){if(n=e[Po])return n;e=kl(e)}return o}e=n,n=e.parentNode}return null}function Lr(e){return e=e[Po]||e[_o],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function rt(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(w(33))}function ui(e){return e[Pr]||null}var Bc=[],at=-1;function zn(e){return{current:e}}function ae(e){0>at||(e.current=Bc[at],Bc[at]=null,at--)}function ne(e,o){at++,Bc[at]=e.current,e.current=o}var fn={},Oe=zn(fn),Be=zn(!1),Rn=fn;function Nt(e,o){var n=e.type.contextTypes;if(!n)return fn;var t=e.stateNode;if(t&&t.__reactInternalMemoizedUnmaskedChildContext===o)return t.__reactInternalMemoizedMaskedChildContext;var r={},a;for(a in n)r[a]=o[a];return t&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=o,e.__reactInternalMemoizedMaskedChildContext=r),r}function Ke(e){return e=e.childContextTypes,e!=null}function _a(){ae(Be),ae(Oe)}function bl(e,o,n){if(Oe.current!==fn)throw Error(w(168));ne(Oe,o),ne(Be,n)}function Gp(e,o,n){var t=e.stateNode;if(o=o.childContextTypes,typeof t.getChildContext!="function")return n;t=t.getChildContext();for(var r in t)if(!(r in o))throw Error(w(108,bb(e)||"Unknown",r));return pe({},n,t)}function Fa(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||fn,Rn=Oe.current,ne(Oe,e),ne(Be,Be.current),!0}function fl(e,o,n){var t=e.stateNode;if(!t)throw Error(w(169));n?(e=Gp(e,o,Rn),t.__reactInternalMemoizedMergedChildContext=e,ae(Be),ae(Oe),ne(Oe,e)):ae(Be),ne(Be,n)}var Ro=null,li=!1,Zi=!1;function Jp(e){Ro===null?Ro=[e]:Ro.push(e)}function Af(e){li=!0,Jp(e)}function jn(){if(!Zi&&Ro!==null){Zi=!0;var e=0,o=q;try{var n=Ro;for(q=1;e<n.length;e++){var t=n[e];do t=t(!0);while(t!==null)}Ro=null,li=!1}catch(r){throw Ro!==null&&(Ro=Ro.slice(e+1)),jp(Ms,jn),r}finally{q=o,Zi=!1}}return null}var it=[],ct=0,Ba=null,Ka=0,ro=[],ao=0,An=null,Ao=1,Io="";function Nn(e,o){it[ct++]=Ka,it[ct++]=Ba,Ba=e,Ka=o}function Qp(e,o,n){ro[ao++]=Ao,ro[ao++]=Io,ro[ao++]=An,An=e;var t=Ao;e=Io;var r=32-yo(t)-1;t&=~(1<<r),n+=1;var a=32-yo(o)+r;if(30<a){var i=r-r%5;a=(t&(1<<i)-1).toString(32),t>>=i,r-=i,Ao=1<<32-yo(o)+r|n<<r|t,Io=a+e}else Ao=1<<a|n<<r|t,Io=e}function _s(e){e.return!==null&&(Nn(e,1),Qp(e,1,0))}function Fs(e){for(;e===Ba;)Ba=it[--ct],it[ct]=null,Ka=it[--ct],it[ct]=null;for(;e===An;)An=ro[--ao],ro[ao]=null,Io=ro[--ao],ro[ao]=null,Ao=ro[--ao],ro[ao]=null}var Qe=null,Je=null,ue=!1,ho=null;function Yp(e,o){var n=co(5,null,null,0);n.elementType="DELETED",n.stateNode=o,n.return=e,o=e.deletions,o===null?(e.deletions=[n],e.flags|=16):o.push(n)}function hl(e,o){switch(e.tag){case 5:var n=e.type;return o=o.nodeType!==1||n.toLowerCase()!==o.nodeName.toLowerCase()?null:o,o!==null?(e.stateNode=o,Qe=e,Je=dn(o.firstChild),!0):!1;case 6:return o=e.pendingProps===""||o.nodeType!==3?null:o,o!==null?(e.stateNode=o,Qe=e,Je=null,!0):!1;case 13:return o=o.nodeType!==8?null:o,o!==null?(n=An!==null?{id:Ao,overflow:Io}:null,e.memoizedState={dehydrated:o,treeContext:n,retryLane:1073741824},n=co(18,null,null,0),n.stateNode=o,n.return=e,e.child=n,Qe=e,Je=null,!0):!1;default:return!1}}function Kc(e){return(e.mode&1)!==0&&(e.flags&128)===0}function $c(e){if(ue){var o=Je;if(o){var n=o;if(!hl(e,o)){if(Kc(e))throw Error(w(418));o=dn(n.nextSibling);var t=Qe;o&&hl(e,o)?Yp(t,n):(e.flags=e.flags&-4097|2,ue=!1,Qe=e)}}else{if(Kc(e))throw Error(w(418));e.flags=e.flags&-4097|2,ue=!1,Qe=e}}}function yl(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Qe=e}function aa(e){if(e!==Qe)return!1;if(!ue)return yl(e),ue=!0,!1;var o;if((o=e.tag!==3)&&!(o=e.tag!==5)&&(o=e.type,o=o!=="head"&&o!=="body"&&!Uc(e.type,e.memoizedProps)),o&&(o=Je)){if(Kc(e))throw qp(),Error(w(418));for(;o;)Yp(e,o),o=dn(o.nextSibling)}if(yl(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(w(317));e:{for(e=e.nextSibling,o=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(o===0){Je=dn(e.nextSibling);break e}o--}else n!=="$"&&n!=="$!"&&n!=="$?"||o++}e=e.nextSibling}Je=null}}else Je=Qe?dn(e.stateNode.nextSibling):null;return!0}function qp(){for(var e=Je;e;)e=dn(e.nextSibling)}function Tt(){Je=Qe=null,ue=!1}function Bs(e){ho===null?ho=[e]:ho.push(e)}var If=$o.ReactCurrentBatchConfig;function Zt(e,o,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(w(309));var t=n.stateNode}if(!t)throw Error(w(147,e));var r=t,a=""+e;return o!==null&&o.ref!==null&&typeof o.ref=="function"&&o.ref._stringRef===a?o.ref:(o=function(i){var c=r.refs;i===null?delete c[a]:c[a]=i},o._stringRef=a,o)}if(typeof e!="string")throw Error(w(284));if(!n._owner)throw Error(w(290,e))}return e}function ia(e,o){throw e=Object.prototype.toString.call(o),Error(w(31,e==="[object Object]"?"object with keys {"+Object.keys(o).join(", ")+"}":e))}function zl(e){var o=e._init;return o(e._payload)}function ev(e){function o(k,m){if(e){var f=k.deletions;f===null?(k.deletions=[m],k.flags|=16):f.push(m)}}function n(k,m){if(!e)return null;for(;m!==null;)o(k,m),m=m.sibling;return null}function t(k,m){for(k=new Map;m!==null;)m.key!==null?k.set(m.key,m):k.set(m.index,m),m=m.sibling;return k}function r(k,m){return k=kn(k,m),k.index=0,k.sibling=null,k}function a(k,m,f){return k.index=f,e?(f=k.alternate,f!==null?(f=f.index,f<m?(k.flags|=2,m):f):(k.flags|=2,m)):(k.flags|=1048576,m)}function i(k){return e&&k.alternate===null&&(k.flags|=2),k}function c(k,m,f,T){return m===null||m.tag!==6?(m=ec(f,k.mode,T),m.return=k,m):(m=r(m,f),m.return=k,m)}function s(k,m,f,T){var x=f.type;return x===et?d(k,m,f.props.children,T,f.key):m!==null&&(m.elementType===x||typeof x=="object"&&x!==null&&x.$$typeof===on&&zl(x)===m.type)?(T=r(m,f.props),T.ref=Zt(k,m,f),T.return=k,T):(T=wa(f.type,f.key,f.props,null,k.mode,T),T.ref=Zt(k,m,f),T.return=k,T)}function u(k,m,f,T){return m===null||m.tag!==4||m.stateNode.containerInfo!==f.containerInfo||m.stateNode.implementation!==f.implementation?(m=oc(f,k.mode,T),m.return=k,m):(m=r(m,f.children||[]),m.return=k,m)}function d(k,m,f,T,x){return m===null||m.tag!==7?(m=Mn(f,k.mode,T,x),m.return=k,m):(m=r(m,f),m.return=k,m)}function p(k,m,f){if(typeof m=="string"&&m!==""||typeof m=="number")return m=ec(""+m,k.mode,f),m.return=k,m;if(typeof m=="object"&&m!==null){switch(m.$$typeof){case Gr:return f=wa(m.type,m.key,m.props,null,k.mode,f),f.ref=Zt(k,null,m),f.return=k,f;case qn:return m=oc(m,k.mode,f),m.return=k,m;case on:var T=m._init;return p(k,T(m._payload),f)}if(nr(m)||Bt(m))return m=Mn(m,k.mode,f,null),m.return=k,m;ia(k,m)}return null}function v(k,m,f,T){var x=m!==null?m.key:null;if(typeof f=="string"&&f!==""||typeof f=="number")return x!==null?null:c(k,m,""+f,T);if(typeof f=="object"&&f!==null){switch(f.$$typeof){case Gr:return f.key===x?s(k,m,f,T):null;case qn:return f.key===x?u(k,m,f,T):null;case on:return x=f._init,v(k,m,x(f._payload),T)}if(nr(f)||Bt(f))return x!==null?null:d(k,m,f,T,null);ia(k,f)}return null}function y(k,m,f,T,x){if(typeof T=="string"&&T!==""||typeof T=="number")return k=k.get(f)||null,c(m,k,""+T,x);if(typeof T=="object"&&T!==null){switch(T.$$typeof){case Gr:return k=k.get(T.key===null?f:T.key)||null,s(m,k,T,x);case qn:return k=k.get(T.key===null?f:T.key)||null,u(m,k,T,x);case on:var O=T._init;return y(k,m,f,O(T._payload),x)}if(nr(T)||Bt(T))return k=k.get(f)||null,d(m,k,T,x,null);ia(m,T)}return null}function z(k,m,f,T){for(var x=null,O=null,h=m,C=m=0,V=null;h!==null&&C<f.length;C++){h.index>C?(V=h,h=null):V=h.sibling;var R=v(k,h,f[C],T);if(R===null){h===null&&(h=V);break}e&&h&&R.alternate===null&&o(k,h),m=a(R,m,C),O===null?x=R:O.sibling=R,O=R,h=V}if(C===f.length)return n(k,h),ue&&Nn(k,C),x;if(h===null){for(;C<f.length;C++)h=p(k,f[C],T),h!==null&&(m=a(h,m,C),O===null?x=h:O.sibling=h,O=h);return ue&&Nn(k,C),x}for(h=t(k,h);C<f.length;C++)V=y(h,k,C,f[C],T),V!==null&&(e&&V.alternate!==null&&h.delete(V.key===null?C:V.key),m=a(V,m,C),O===null?x=V:O.sibling=V,O=V);return e&&h.forEach(function(Z){return o(k,Z)}),ue&&Nn(k,C),x}function b(k,m,f,T){var x=Bt(f);if(typeof x!="function")throw Error(w(150));if(f=x.call(f),f==null)throw Error(w(151));for(var O=x=null,h=m,C=m=0,V=null,R=f.next();h!==null&&!R.done;C++,R=f.next()){h.index>C?(V=h,h=null):V=h.sibling;var Z=v(k,h,R.value,T);if(Z===null){h===null&&(h=V);break}e&&h&&Z.alternate===null&&o(k,h),m=a(Z,m,C),O===null?x=Z:O.sibling=Z,O=Z,h=V}if(R.done)return n(k,h),ue&&Nn(k,C),x;if(h===null){for(;!R.done;C++,R=f.next())R=p(k,R.value,T),R!==null&&(m=a(R,m,C),O===null?x=R:O.sibling=R,O=R);return ue&&Nn(k,C),x}for(h=t(k,h);!R.done;C++,R=f.next())R=y(h,k,C,R.value,T),R!==null&&(e&&R.alternate!==null&&h.delete(R.key===null?C:R.key),m=a(R,m,C),O===null?x=R:O.sibling=R,O=R);return e&&h.forEach(function(F){return o(k,F)}),ue&&Nn(k,C),x}function N(k,m,f,T){if(typeof f=="object"&&f!==null&&f.type===et&&f.key===null&&(f=f.props.children),typeof f=="object"&&f!==null){switch(f.$$typeof){case Gr:e:{for(var x=f.key,O=m;O!==null;){if(O.key===x){if(x=f.type,x===et){if(O.tag===7){n(k,O.sibling),m=r(O,f.props.children),m.return=k,k=m;break e}}else if(O.elementType===x||typeof x=="object"&&x!==null&&x.$$typeof===on&&zl(x)===O.type){n(k,O.sibling),m=r(O,f.props),m.ref=Zt(k,O,f),m.return=k,k=m;break e}n(k,O);break}else o(k,O);O=O.sibling}f.type===et?(m=Mn(f.props.children,k.mode,T,f.key),m.return=k,k=m):(T=wa(f.type,f.key,f.props,null,k.mode,T),T.ref=Zt(k,m,f),T.return=k,k=T)}return i(k);case qn:e:{for(O=f.key;m!==null;){if(m.key===O)if(m.tag===4&&m.stateNode.containerInfo===f.containerInfo&&m.stateNode.implementation===f.implementation){n(k,m.sibling),m=r(m,f.children||[]),m.return=k,k=m;break e}else{n(k,m);break}else o(k,m);m=m.sibling}m=oc(f,k.mode,T),m.return=k,k=m}return i(k);case on:return O=f._init,N(k,m,O(f._payload),T)}if(nr(f))return z(k,m,f,T);if(Bt(f))return b(k,m,f,T);ia(k,f)}return typeof f=="string"&&f!==""||typeof f=="number"?(f=""+f,m!==null&&m.tag===6?(n(k,m.sibling),m=r(m,f),m.return=k,k=m):(n(k,m),m=ec(f,k.mode,T),m.return=k,k=m),i(k)):n(k,m)}return N}var St=ev(!0),ov=ev(!1),$a=zn(null),Ha=null,st=null,Ks=null;function $s(){Ks=st=Ha=null}function Hs(e){var o=$a.current;ae($a),e._currentValue=o}function Hc(e,o,n){for(;e!==null;){var t=e.alternate;if((e.childLanes&o)!==o?(e.childLanes|=o,t!==null&&(t.childLanes|=o)):t!==null&&(t.childLanes&o)!==o&&(t.childLanes|=o),e===n)break;e=e.return}}function ft(e,o){Ha=e,Ks=st=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&o&&(Fe=!0),e.firstContext=null)}function uo(e){var o=e._currentValue;if(Ks!==e)if(e={context:e,memoizedValue:o,next:null},st===null){if(Ha===null)throw Error(w(308));st=e,Ha.dependencies={lanes:0,firstContext:e}}else st=st.next=e;return o}var Pn=null;function Ws(e){Pn===null?Pn=[e]:Pn.push(e)}function nv(e,o,n,t){var r=o.interleaved;return r===null?(n.next=n,Ws(o)):(n.next=r.next,r.next=n),o.interleaved=n,Fo(e,t)}function Fo(e,o){e.lanes|=o;var n=e.alternate;for(n!==null&&(n.lanes|=o),n=e,e=e.return;e!==null;)e.childLanes|=o,n=e.alternate,n!==null&&(n.childLanes|=o),n=e,e=e.return;return n.tag===3?n.stateNode:null}var nn=!1;function Zs(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function tv(e,o){e=e.updateQueue,o.updateQueue===e&&(o.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Do(e,o){return{eventTime:e,lane:o,tag:0,payload:null,callback:null,next:null}}function pn(e,o,n){var t=e.updateQueue;if(t===null)return null;if(t=t.shared,Y&2){var r=t.pending;return r===null?o.next=o:(o.next=r.next,r.next=o),t.pending=o,Fo(e,n)}return r=t.interleaved,r===null?(o.next=o,Ws(t)):(o.next=r.next,r.next=o),t.interleaved=o,Fo(e,n)}function ga(e,o,n){if(o=o.updateQueue,o!==null&&(o=o.shared,(n&4194240)!==0)){var t=o.lanes;t&=e.pendingLanes,n|=t,o.lanes=n,Os(e,n)}}function jl(e,o){var n=e.updateQueue,t=e.alternate;if(t!==null&&(t=t.updateQueue,n===t)){var r=null,a=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};a===null?r=a=i:a=a.next=i,n=n.next}while(n!==null);a===null?r=a=o:a=a.next=o}else r=a=o;n={baseState:t.baseState,firstBaseUpdate:r,lastBaseUpdate:a,shared:t.shared,effects:t.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=o:e.next=o,n.lastBaseUpdate=o}function Wa(e,o,n,t){var r=e.updateQueue;nn=!1;var a=r.firstBaseUpdate,i=r.lastBaseUpdate,c=r.shared.pending;if(c!==null){r.shared.pending=null;var s=c,u=s.next;s.next=null,i===null?a=u:i.next=u,i=s;var d=e.alternate;d!==null&&(d=d.updateQueue,c=d.lastBaseUpdate,c!==i&&(c===null?d.firstBaseUpdate=u:c.next=u,d.lastBaseUpdate=s))}if(a!==null){var p=r.baseState;i=0,d=u=s=null,c=a;do{var v=c.lane,y=c.eventTime;if((t&v)===v){d!==null&&(d=d.next={eventTime:y,lane:0,tag:c.tag,payload:c.payload,callback:c.callback,next:null});e:{var z=e,b=c;switch(v=o,y=n,b.tag){case 1:if(z=b.payload,typeof z=="function"){p=z.call(y,p,v);break e}p=z;break e;case 3:z.flags=z.flags&-65537|128;case 0:if(z=b.payload,v=typeof z=="function"?z.call(y,p,v):z,v==null)break e;p=pe({},p,v);break e;case 2:nn=!0}}c.callback!==null&&c.lane!==0&&(e.flags|=64,v=r.effects,v===null?r.effects=[c]:v.push(c))}else y={eventTime:y,lane:v,tag:c.tag,payload:c.payload,callback:c.callback,next:null},d===null?(u=d=y,s=p):d=d.next=y,i|=v;if(c=c.next,c===null){if(c=r.shared.pending,c===null)break;v=c,c=v.next,v.next=null,r.lastBaseUpdate=v,r.shared.pending=null}}while(!0);if(d===null&&(s=p),r.baseState=s,r.firstBaseUpdate=u,r.lastBaseUpdate=d,o=r.shared.interleaved,o!==null){r=o;do i|=r.lane,r=r.next;while(r!==o)}else a===null&&(r.shared.lanes=0);Vn|=i,e.lanes=i,e.memoizedState=p}}function gl(e,o,n){if(e=o.effects,o.effects=null,e!==null)for(o=0;o<e.length;o++){var t=e[o],r=t.callback;if(r!==null){if(t.callback=null,t=n,typeof r!="function")throw Error(w(191,r));r.call(t)}}}var Ur={},Eo=zn(Ur),xr=zn(Ur),wr=zn(Ur);function xn(e){if(e===Ur)throw Error(w(174));return e}function Xs(e,o){switch(ne(wr,o),ne(xr,e),ne(Eo,Ur),e=o.nodeType,e){case 9:case 11:o=(o=o.documentElement)?o.namespaceURI:Sc(null,"");break;default:e=e===8?o.parentNode:o,o=e.namespaceURI||null,e=e.tagName,o=Sc(o,e)}ae(Eo),ne(Eo,o)}function Pt(){ae(Eo),ae(xr),ae(wr)}function rv(e){xn(wr.current);var o=xn(Eo.current),n=Sc(o,e.type);o!==n&&(ne(xr,e),ne(Eo,n))}function Gs(e){xr.current===e&&(ae(Eo),ae(xr))}var le=zn(0);function Za(e){for(var o=e;o!==null;){if(o.tag===13){var n=o.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return o}else if(o.tag===19&&o.memoizedProps.revealOrder!==void 0){if(o.flags&128)return o}else if(o.child!==null){o.child.return=o,o=o.child;continue}if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return null;o=o.return}o.sibling.return=o.return,o=o.sibling}return null}var Xi=[];function Js(){for(var e=0;e<Xi.length;e++)Xi[e]._workInProgressVersionPrimary=null;Xi.length=0}var Na=$o.ReactCurrentDispatcher,Gi=$o.ReactCurrentBatchConfig,In=0,de=null,he=null,je=null,Xa=!1,lr=!1,Cr=0,Vf=0;function Ce(){throw Error(w(321))}function Qs(e,o){if(o===null)return!1;for(var n=0;n<o.length&&n<e.length;n++)if(!jo(e[n],o[n]))return!1;return!0}function Ys(e,o,n,t,r,a){if(In=a,de=o,o.memoizedState=null,o.updateQueue=null,o.lanes=0,Na.current=e===null||e.memoizedState===null?_f:Ff,e=n(t,r),lr){a=0;do{if(lr=!1,Cr=0,25<=a)throw Error(w(301));a+=1,je=he=null,o.updateQueue=null,Na.current=Bf,e=n(t,r)}while(lr)}if(Na.current=Ga,o=he!==null&&he.next!==null,In=0,je=he=de=null,Xa=!1,o)throw Error(w(300));return e}function qs(){var e=Cr!==0;return Cr=0,e}function So(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return je===null?de.memoizedState=je=e:je=je.next=e,je}function lo(){if(he===null){var e=de.alternate;e=e!==null?e.memoizedState:null}else e=he.next;var o=je===null?de.memoizedState:je.next;if(o!==null)je=o,he=e;else{if(e===null)throw Error(w(310));he=e,e={memoizedState:he.memoizedState,baseState:he.baseState,baseQueue:he.baseQueue,queue:he.queue,next:null},je===null?de.memoizedState=je=e:je=je.next=e}return je}function Er(e,o){return typeof o=="function"?o(e):o}function Ji(e){var o=lo(),n=o.queue;if(n===null)throw Error(w(311));n.lastRenderedReducer=e;var t=he,r=t.baseQueue,a=n.pending;if(a!==null){if(r!==null){var i=r.next;r.next=a.next,a.next=i}t.baseQueue=r=a,n.pending=null}if(r!==null){a=r.next,t=t.baseState;var c=i=null,s=null,u=a;do{var d=u.lane;if((In&d)===d)s!==null&&(s=s.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),t=u.hasEagerState?u.eagerState:e(t,u.action);else{var p={lane:d,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};s===null?(c=s=p,i=t):s=s.next=p,de.lanes|=d,Vn|=d}u=u.next}while(u!==null&&u!==a);s===null?i=t:s.next=c,jo(t,o.memoizedState)||(Fe=!0),o.memoizedState=t,o.baseState=i,o.baseQueue=s,n.lastRenderedState=t}if(e=n.interleaved,e!==null){r=e;do a=r.lane,de.lanes|=a,Vn|=a,r=r.next;while(r!==e)}else r===null&&(n.lanes=0);return[o.memoizedState,n.dispatch]}function Qi(e){var o=lo(),n=o.queue;if(n===null)throw Error(w(311));n.lastRenderedReducer=e;var t=n.dispatch,r=n.pending,a=o.memoizedState;if(r!==null){n.pending=null;var i=r=r.next;do a=e(a,i.action),i=i.next;while(i!==r);jo(a,o.memoizedState)||(Fe=!0),o.memoizedState=a,o.baseQueue===null&&(o.baseState=a),n.lastRenderedState=a}return[a,t]}function av(){}function iv(e,o){var n=de,t=lo(),r=o(),a=!jo(t.memoizedState,r);if(a&&(t.memoizedState=r,Fe=!0),t=t.queue,eu(uv.bind(null,n,t,e),[e]),t.getSnapshot!==o||a||je!==null&&je.memoizedState.tag&1){if(n.flags|=2048,Mr(9,sv.bind(null,n,t,r,o),void 0,null),ge===null)throw Error(w(349));In&30||cv(n,o,r)}return r}function cv(e,o,n){e.flags|=16384,e={getSnapshot:o,value:n},o=de.updateQueue,o===null?(o={lastEffect:null,stores:null},de.updateQueue=o,o.stores=[e]):(n=o.stores,n===null?o.stores=[e]:n.push(e))}function sv(e,o,n,t){o.value=n,o.getSnapshot=t,lv(o)&&dv(e)}function uv(e,o,n){return n(function(){lv(o)&&dv(e)})}function lv(e){var o=e.getSnapshot;e=e.value;try{var n=o();return!jo(e,n)}catch{return!0}}function dv(e){var o=Fo(e,1);o!==null&&zo(o,e,1,-1)}function Nl(e){var o=So();return typeof e=="function"&&(e=e()),o.memoizedState=o.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Er,lastRenderedState:e},o.queue=e,e=e.dispatch=Uf.bind(null,de,e),[o.memoizedState,e]}function Mr(e,o,n,t){return e={tag:e,create:o,destroy:n,deps:t,next:null},o=de.updateQueue,o===null?(o={lastEffect:null,stores:null},de.updateQueue=o,o.lastEffect=e.next=e):(n=o.lastEffect,n===null?o.lastEffect=e.next=e:(t=n.next,n.next=e,e.next=t,o.lastEffect=e)),e}function pv(){return lo().memoizedState}function Ta(e,o,n,t){var r=So();de.flags|=e,r.memoizedState=Mr(1|o,n,void 0,t===void 0?null:t)}function di(e,o,n,t){var r=lo();t=t===void 0?null:t;var a=void 0;if(he!==null){var i=he.memoizedState;if(a=i.destroy,t!==null&&Qs(t,i.deps)){r.memoizedState=Mr(o,n,a,t);return}}de.flags|=e,r.memoizedState=Mr(1|o,n,a,t)}function Tl(e,o){return Ta(8390656,8,e,o)}function eu(e,o){return di(2048,8,e,o)}function vv(e,o){return di(4,2,e,o)}function mv(e,o){return di(4,4,e,o)}function kv(e,o){if(typeof o=="function")return e=e(),o(e),function(){o(null)};if(o!=null)return e=e(),o.current=e,function(){o.current=null}}function bv(e,o,n){return n=n!=null?n.concat([e]):null,di(4,4,kv.bind(null,o,e),n)}function ou(){}function fv(e,o){var n=lo();o=o===void 0?null:o;var t=n.memoizedState;return t!==null&&o!==null&&Qs(o,t[1])?t[0]:(n.memoizedState=[e,o],e)}function hv(e,o){var n=lo();o=o===void 0?null:o;var t=n.memoizedState;return t!==null&&o!==null&&Qs(o,t[1])?t[0]:(e=e(),n.memoizedState=[e,o],e)}function yv(e,o,n){return In&21?(jo(n,o)||(n=Tp(),de.lanes|=n,Vn|=n,e.baseState=!0),o):(e.baseState&&(e.baseState=!1,Fe=!0),e.memoizedState=n)}function Df(e,o){var n=q;q=n!==0&&4>n?n:4,e(!0);var t=Gi.transition;Gi.transition={};try{e(!1),o()}finally{q=n,Gi.transition=t}}function zv(){return lo().memoizedState}function Lf(e,o,n){var t=mn(e);if(n={lane:t,action:n,hasEagerState:!1,eagerState:null,next:null},jv(e))gv(o,n);else if(n=nv(e,o,n,t),n!==null){var r=Ve();zo(n,e,t,r),Nv(n,o,t)}}function Uf(e,o,n){var t=mn(e),r={lane:t,action:n,hasEagerState:!1,eagerState:null,next:null};if(jv(e))gv(o,r);else{var a=e.alternate;if(e.lanes===0&&(a===null||a.lanes===0)&&(a=o.lastRenderedReducer,a!==null))try{var i=o.lastRenderedState,c=a(i,n);if(r.hasEagerState=!0,r.eagerState=c,jo(c,i)){var s=o.interleaved;s===null?(r.next=r,Ws(o)):(r.next=s.next,s.next=r),o.interleaved=r;return}}catch{}finally{}n=nv(e,o,r,t),n!==null&&(r=Ve(),zo(n,e,t,r),Nv(n,o,t))}}function jv(e){var o=e.alternate;return e===de||o!==null&&o===de}function gv(e,o){lr=Xa=!0;var n=e.pending;n===null?o.next=o:(o.next=n.next,n.next=o),e.pending=o}function Nv(e,o,n){if(n&4194240){var t=o.lanes;t&=e.pendingLanes,n|=t,o.lanes=n,Os(e,n)}}var Ga={readContext:uo,useCallback:Ce,useContext:Ce,useEffect:Ce,useImperativeHandle:Ce,useInsertionEffect:Ce,useLayoutEffect:Ce,useMemo:Ce,useReducer:Ce,useRef:Ce,useState:Ce,useDebugValue:Ce,useDeferredValue:Ce,useTransition:Ce,useMutableSource:Ce,useSyncExternalStore:Ce,useId:Ce,unstable_isNewReconciler:!1},_f={readContext:uo,useCallback:function(e,o){return So().memoizedState=[e,o===void 0?null:o],e},useContext:uo,useEffect:Tl,useImperativeHandle:function(e,o,n){return n=n!=null?n.concat([e]):null,Ta(4194308,4,kv.bind(null,o,e),n)},useLayoutEffect:function(e,o){return Ta(4194308,4,e,o)},useInsertionEffect:function(e,o){return Ta(4,2,e,o)},useMemo:function(e,o){var n=So();return o=o===void 0?null:o,e=e(),n.memoizedState=[e,o],e},useReducer:function(e,o,n){var t=So();return o=n!==void 0?n(o):o,t.memoizedState=t.baseState=o,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:o},t.queue=e,e=e.dispatch=Lf.bind(null,de,e),[t.memoizedState,e]},useRef:function(e){var o=So();return e={current:e},o.memoizedState=e},useState:Nl,useDebugValue:ou,useDeferredValue:function(e){return So().memoizedState=e},useTransition:function(){var e=Nl(!1),o=e[0];return e=Df.bind(null,e[1]),So().memoizedState=e,[o,e]},useMutableSource:function(){},useSyncExternalStore:function(e,o,n){var t=de,r=So();if(ue){if(n===void 0)throw Error(w(407));n=n()}else{if(n=o(),ge===null)throw Error(w(349));In&30||cv(t,o,n)}r.memoizedState=n;var a={value:n,getSnapshot:o};return r.queue=a,Tl(uv.bind(null,t,a,e),[e]),t.flags|=2048,Mr(9,sv.bind(null,t,a,n,o),void 0,null),n},useId:function(){var e=So(),o=ge.identifierPrefix;if(ue){var n=Io,t=Ao;n=(t&~(1<<32-yo(t)-1)).toString(32)+n,o=":"+o+"R"+n,n=Cr++,0<n&&(o+="H"+n.toString(32)),o+=":"}else n=Vf++,o=":"+o+"r"+n.toString(32)+":";return e.memoizedState=o},unstable_isNewReconciler:!1},Ff={readContext:uo,useCallback:fv,useContext:uo,useEffect:eu,useImperativeHandle:bv,useInsertionEffect:vv,useLayoutEffect:mv,useMemo:hv,useReducer:Ji,useRef:pv,useState:function(){return Ji(Er)},useDebugValue:ou,useDeferredValue:function(e){var o=lo();return yv(o,he.memoizedState,e)},useTransition:function(){var e=Ji(Er)[0],o=lo().memoizedState;return[e,o]},useMutableSource:av,useSyncExternalStore:iv,useId:zv,unstable_isNewReconciler:!1},Bf={readContext:uo,useCallback:fv,useContext:uo,useEffect:eu,useImperativeHandle:bv,useInsertionEffect:vv,useLayoutEffect:mv,useMemo:hv,useReducer:Qi,useRef:pv,useState:function(){return Qi(Er)},useDebugValue:ou,useDeferredValue:function(e){var o=lo();return he===null?o.memoizedState=e:yv(o,he.memoizedState,e)},useTransition:function(){var e=Qi(Er)[0],o=lo().memoizedState;return[e,o]},useMutableSource:av,useSyncExternalStore:iv,useId:zv,unstable_isNewReconciler:!1};function ko(e,o){if(e&&e.defaultProps){o=pe({},o),e=e.defaultProps;for(var n in e)o[n]===void 0&&(o[n]=e[n]);return o}return o}function Wc(e,o,n,t){o=e.memoizedState,n=n(t,o),n=n==null?o:pe({},o,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var pi={isMounted:function(e){return(e=e._reactInternals)?Bn(e)===e:!1},enqueueSetState:function(e,o,n){e=e._reactInternals;var t=Ve(),r=mn(e),a=Do(t,r);a.payload=o,n!=null&&(a.callback=n),o=pn(e,a,r),o!==null&&(zo(o,e,r,t),ga(o,e,r))},enqueueReplaceState:function(e,o,n){e=e._reactInternals;var t=Ve(),r=mn(e),a=Do(t,r);a.tag=1,a.payload=o,n!=null&&(a.callback=n),o=pn(e,a,r),o!==null&&(zo(o,e,r,t),ga(o,e,r))},enqueueForceUpdate:function(e,o){e=e._reactInternals;var n=Ve(),t=mn(e),r=Do(n,t);r.tag=2,o!=null&&(r.callback=o),o=pn(e,r,t),o!==null&&(zo(o,e,t,n),ga(o,e,t))}};function Sl(e,o,n,t,r,a,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(t,a,i):o.prototype&&o.prototype.isPureReactComponent?!Nr(n,t)||!Nr(r,a):!0}function Tv(e,o,n){var t=!1,r=fn,a=o.contextType;return typeof a=="object"&&a!==null?a=uo(a):(r=Ke(o)?Rn:Oe.current,t=o.contextTypes,a=(t=t!=null)?Nt(e,r):fn),o=new o(n,a),e.memoizedState=o.state!==null&&o.state!==void 0?o.state:null,o.updater=pi,e.stateNode=o,o._reactInternals=e,t&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=a),o}function Pl(e,o,n,t){e=o.state,typeof o.componentWillReceiveProps=="function"&&o.componentWillReceiveProps(n,t),typeof o.UNSAFE_componentWillReceiveProps=="function"&&o.UNSAFE_componentWillReceiveProps(n,t),o.state!==e&&pi.enqueueReplaceState(o,o.state,null)}function Zc(e,o,n,t){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs={},Zs(e);var a=o.contextType;typeof a=="object"&&a!==null?r.context=uo(a):(a=Ke(o)?Rn:Oe.current,r.context=Nt(e,a)),r.state=e.memoizedState,a=o.getDerivedStateFromProps,typeof a=="function"&&(Wc(e,o,a,n),r.state=e.memoizedState),typeof o.getDerivedStateFromProps=="function"||typeof r.getSnapshotBeforeUpdate=="function"||typeof r.UNSAFE_componentWillMount!="function"&&typeof r.componentWillMount!="function"||(o=r.state,typeof r.componentWillMount=="function"&&r.componentWillMount(),typeof r.UNSAFE_componentWillMount=="function"&&r.UNSAFE_componentWillMount(),o!==r.state&&pi.enqueueReplaceState(r,r.state,null),Wa(e,n,r,t),r.state=e.memoizedState),typeof r.componentDidMount=="function"&&(e.flags|=4194308)}function xt(e,o){try{var n="",t=o;do n+=kb(t),t=t.return;while(t);var r=n}catch(a){r=`
Error generating stack: `+a.message+`
`+a.stack}return{value:e,source:o,stack:r,digest:null}}function Yi(e,o,n){return{value:e,source:null,stack:n??null,digest:o??null}}function Xc(e,o){try{console.error(o.value)}catch(n){setTimeout(function(){throw n})}}var Kf=typeof WeakMap=="function"?WeakMap:Map;function Sv(e,o,n){n=Do(-1,n),n.tag=3,n.payload={element:null};var t=o.value;return n.callback=function(){Qa||(Qa=!0,rs=t),Xc(e,o)},n}function Pv(e,o,n){n=Do(-1,n),n.tag=3;var t=e.type.getDerivedStateFromError;if(typeof t=="function"){var r=o.value;n.payload=function(){return t(r)},n.callback=function(){Xc(e,o)}}var a=e.stateNode;return a!==null&&typeof a.componentDidCatch=="function"&&(n.callback=function(){Xc(e,o),typeof t!="function"&&(vn===null?vn=new Set([this]):vn.add(this));var i=o.stack;this.componentDidCatch(o.value,{componentStack:i!==null?i:""})}),n}function xl(e,o,n){var t=e.pingCache;if(t===null){t=e.pingCache=new Kf;var r=new Set;t.set(o,r)}else r=t.get(o),r===void 0&&(r=new Set,t.set(o,r));r.has(n)||(r.add(n),e=th.bind(null,e,o,n),o.then(e,e))}function wl(e){do{var o;if((o=e.tag===13)&&(o=e.memoizedState,o=o!==null?o.dehydrated!==null:!0),o)return e;e=e.return}while(e!==null);return null}function Cl(e,o,n,t,r){return e.mode&1?(e.flags|=65536,e.lanes=r,e):(e===o?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(o=Do(-1,1),o.tag=2,pn(n,o,1))),n.lanes|=1),e)}var $f=$o.ReactCurrentOwner,Fe=!1;function Ie(e,o,n,t){o.child=e===null?ov(o,null,n,t):St(o,e.child,n,t)}function El(e,o,n,t,r){n=n.render;var a=o.ref;return ft(o,r),t=Ys(e,o,n,t,a,r),n=qs(),e!==null&&!Fe?(o.updateQueue=e.updateQueue,o.flags&=-2053,e.lanes&=~r,Bo(e,o,r)):(ue&&n&&_s(o),o.flags|=1,Ie(e,o,t,r),o.child)}function Ml(e,o,n,t,r){if(e===null){var a=n.type;return typeof a=="function"&&!uu(a)&&a.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(o.tag=15,o.type=a,xv(e,o,a,t,r)):(e=wa(n.type,null,t,o,o.mode,r),e.ref=o.ref,e.return=o,o.child=e)}if(a=e.child,!(e.lanes&r)){var i=a.memoizedProps;if(n=n.compare,n=n!==null?n:Nr,n(i,t)&&e.ref===o.ref)return Bo(e,o,r)}return o.flags|=1,e=kn(a,t),e.ref=o.ref,e.return=o,o.child=e}function xv(e,o,n,t,r){if(e!==null){var a=e.memoizedProps;if(Nr(a,t)&&e.ref===o.ref)if(Fe=!1,o.pendingProps=t=a,(e.lanes&r)!==0)e.flags&131072&&(Fe=!0);else return o.lanes=e.lanes,Bo(e,o,r)}return Gc(e,o,n,t,r)}function wv(e,o,n){var t=o.pendingProps,r=t.children,a=e!==null?e.memoizedState:null;if(t.mode==="hidden")if(!(o.mode&1))o.memoizedState={baseLanes:0,cachePool:null,transitions:null},ne(lt,Ge),Ge|=n;else{if(!(n&1073741824))return e=a!==null?a.baseLanes|n:n,o.lanes=o.childLanes=1073741824,o.memoizedState={baseLanes:e,cachePool:null,transitions:null},o.updateQueue=null,ne(lt,Ge),Ge|=e,null;o.memoizedState={baseLanes:0,cachePool:null,transitions:null},t=a!==null?a.baseLanes:n,ne(lt,Ge),Ge|=t}else a!==null?(t=a.baseLanes|n,o.memoizedState=null):t=n,ne(lt,Ge),Ge|=t;return Ie(e,o,r,n),o.child}function Cv(e,o){var n=o.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(o.flags|=512,o.flags|=2097152)}function Gc(e,o,n,t,r){var a=Ke(n)?Rn:Oe.current;return a=Nt(o,a),ft(o,r),n=Ys(e,o,n,t,a,r),t=qs(),e!==null&&!Fe?(o.updateQueue=e.updateQueue,o.flags&=-2053,e.lanes&=~r,Bo(e,o,r)):(ue&&t&&_s(o),o.flags|=1,Ie(e,o,n,r),o.child)}function Ol(e,o,n,t,r){if(Ke(n)){var a=!0;Fa(o)}else a=!1;if(ft(o,r),o.stateNode===null)Sa(e,o),Tv(o,n,t),Zc(o,n,t,r),t=!0;else if(e===null){var i=o.stateNode,c=o.memoizedProps;i.props=c;var s=i.context,u=n.contextType;typeof u=="object"&&u!==null?u=uo(u):(u=Ke(n)?Rn:Oe.current,u=Nt(o,u));var d=n.getDerivedStateFromProps,p=typeof d=="function"||typeof i.getSnapshotBeforeUpdate=="function";p||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(c!==t||s!==u)&&Pl(o,i,t,u),nn=!1;var v=o.memoizedState;i.state=v,Wa(o,t,i,r),s=o.memoizedState,c!==t||v!==s||Be.current||nn?(typeof d=="function"&&(Wc(o,n,d,t),s=o.memoizedState),(c=nn||Sl(o,n,c,t,v,s,u))?(p||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(o.flags|=4194308)):(typeof i.componentDidMount=="function"&&(o.flags|=4194308),o.memoizedProps=t,o.memoizedState=s),i.props=t,i.state=s,i.context=u,t=c):(typeof i.componentDidMount=="function"&&(o.flags|=4194308),t=!1)}else{i=o.stateNode,tv(e,o),c=o.memoizedProps,u=o.type===o.elementType?c:ko(o.type,c),i.props=u,p=o.pendingProps,v=i.context,s=n.contextType,typeof s=="object"&&s!==null?s=uo(s):(s=Ke(n)?Rn:Oe.current,s=Nt(o,s));var y=n.getDerivedStateFromProps;(d=typeof y=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(c!==p||v!==s)&&Pl(o,i,t,s),nn=!1,v=o.memoizedState,i.state=v,Wa(o,t,i,r);var z=o.memoizedState;c!==p||v!==z||Be.current||nn?(typeof y=="function"&&(Wc(o,n,y,t),z=o.memoizedState),(u=nn||Sl(o,n,u,t,v,z,s)||!1)?(d||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(t,z,s),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(t,z,s)),typeof i.componentDidUpdate=="function"&&(o.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(o.flags|=1024)):(typeof i.componentDidUpdate!="function"||c===e.memoizedProps&&v===e.memoizedState||(o.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||c===e.memoizedProps&&v===e.memoizedState||(o.flags|=1024),o.memoizedProps=t,o.memoizedState=z),i.props=t,i.state=z,i.context=s,t=u):(typeof i.componentDidUpdate!="function"||c===e.memoizedProps&&v===e.memoizedState||(o.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||c===e.memoizedProps&&v===e.memoizedState||(o.flags|=1024),t=!1)}return Jc(e,o,n,t,a,r)}function Jc(e,o,n,t,r,a){Cv(e,o);var i=(o.flags&128)!==0;if(!t&&!i)return r&&fl(o,n,!1),Bo(e,o,a);t=o.stateNode,$f.current=o;var c=i&&typeof n.getDerivedStateFromError!="function"?null:t.render();return o.flags|=1,e!==null&&i?(o.child=St(o,e.child,null,a),o.child=St(o,null,c,a)):Ie(e,o,c,a),o.memoizedState=t.state,r&&fl(o,n,!0),o.child}function Ev(e){var o=e.stateNode;o.pendingContext?bl(e,o.pendingContext,o.pendingContext!==o.context):o.context&&bl(e,o.context,!1),Xs(e,o.containerInfo)}function Rl(e,o,n,t,r){return Tt(),Bs(r),o.flags|=256,Ie(e,o,n,t),o.child}var Qc={dehydrated:null,treeContext:null,retryLane:0};function Yc(e){return{baseLanes:e,cachePool:null,transitions:null}}function Mv(e,o,n){var t=o.pendingProps,r=le.current,a=!1,i=(o.flags&128)!==0,c;if((c=i)||(c=e!==null&&e.memoizedState===null?!1:(r&2)!==0),c?(a=!0,o.flags&=-129):(e===null||e.memoizedState!==null)&&(r|=1),ne(le,r&1),e===null)return $c(o),e=o.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(o.mode&1?e.data==="$!"?o.lanes=8:o.lanes=1073741824:o.lanes=1,null):(i=t.children,e=t.fallback,a?(t=o.mode,a=o.child,i={mode:"hidden",children:i},!(t&1)&&a!==null?(a.childLanes=0,a.pendingProps=i):a=ki(i,t,0,null),e=Mn(e,t,n,null),a.return=o,e.return=o,a.sibling=e,o.child=a,o.child.memoizedState=Yc(n),o.memoizedState=Qc,e):nu(o,i));if(r=e.memoizedState,r!==null&&(c=r.dehydrated,c!==null))return Hf(e,o,i,t,c,r,n);if(a){a=t.fallback,i=o.mode,r=e.child,c=r.sibling;var s={mode:"hidden",children:t.children};return!(i&1)&&o.child!==r?(t=o.child,t.childLanes=0,t.pendingProps=s,o.deletions=null):(t=kn(r,s),t.subtreeFlags=r.subtreeFlags&14680064),c!==null?a=kn(c,a):(a=Mn(a,i,n,null),a.flags|=2),a.return=o,t.return=o,t.sibling=a,o.child=t,t=a,a=o.child,i=e.child.memoizedState,i=i===null?Yc(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},a.memoizedState=i,a.childLanes=e.childLanes&~n,o.memoizedState=Qc,t}return a=e.child,e=a.sibling,t=kn(a,{mode:"visible",children:t.children}),!(o.mode&1)&&(t.lanes=n),t.return=o,t.sibling=null,e!==null&&(n=o.deletions,n===null?(o.deletions=[e],o.flags|=16):n.push(e)),o.child=t,o.memoizedState=null,t}function nu(e,o){return o=ki({mode:"visible",children:o},e.mode,0,null),o.return=e,e.child=o}function ca(e,o,n,t){return t!==null&&Bs(t),St(o,e.child,null,n),e=nu(o,o.pendingProps.children),e.flags|=2,o.memoizedState=null,e}function Hf(e,o,n,t,r,a,i){if(n)return o.flags&256?(o.flags&=-257,t=Yi(Error(w(422))),ca(e,o,i,t)):o.memoizedState!==null?(o.child=e.child,o.flags|=128,null):(a=t.fallback,r=o.mode,t=ki({mode:"visible",children:t.children},r,0,null),a=Mn(a,r,i,null),a.flags|=2,t.return=o,a.return=o,t.sibling=a,o.child=t,o.mode&1&&St(o,e.child,null,i),o.child.memoizedState=Yc(i),o.memoizedState=Qc,a);if(!(o.mode&1))return ca(e,o,i,null);if(r.data==="$!"){if(t=r.nextSibling&&r.nextSibling.dataset,t)var c=t.dgst;return t=c,a=Error(w(419)),t=Yi(a,t,void 0),ca(e,o,i,t)}if(c=(i&e.childLanes)!==0,Fe||c){if(t=ge,t!==null){switch(i&-i){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}r=r&(t.suspendedLanes|i)?0:r,r!==0&&r!==a.retryLane&&(a.retryLane=r,Fo(e,r),zo(t,e,r,-1))}return su(),t=Yi(Error(w(421))),ca(e,o,i,t)}return r.data==="$?"?(o.flags|=128,o.child=e.child,o=rh.bind(null,e),r._reactRetry=o,null):(e=a.treeContext,Je=dn(r.nextSibling),Qe=o,ue=!0,ho=null,e!==null&&(ro[ao++]=Ao,ro[ao++]=Io,ro[ao++]=An,Ao=e.id,Io=e.overflow,An=o),o=nu(o,t.children),o.flags|=4096,o)}function Al(e,o,n){e.lanes|=o;var t=e.alternate;t!==null&&(t.lanes|=o),Hc(e.return,o,n)}function qi(e,o,n,t,r){var a=e.memoizedState;a===null?e.memoizedState={isBackwards:o,rendering:null,renderingStartTime:0,last:t,tail:n,tailMode:r}:(a.isBackwards=o,a.rendering=null,a.renderingStartTime=0,a.last=t,a.tail=n,a.tailMode=r)}function Ov(e,o,n){var t=o.pendingProps,r=t.revealOrder,a=t.tail;if(Ie(e,o,t.children,n),t=le.current,t&2)t=t&1|2,o.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=o.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&Al(e,n,o);else if(e.tag===19)Al(e,n,o);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===o)break e;for(;e.sibling===null;){if(e.return===null||e.return===o)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}t&=1}if(ne(le,t),!(o.mode&1))o.memoizedState=null;else switch(r){case"forwards":for(n=o.child,r=null;n!==null;)e=n.alternate,e!==null&&Za(e)===null&&(r=n),n=n.sibling;n=r,n===null?(r=o.child,o.child=null):(r=n.sibling,n.sibling=null),qi(o,!1,r,n,a);break;case"backwards":for(n=null,r=o.child,o.child=null;r!==null;){if(e=r.alternate,e!==null&&Za(e)===null){o.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}qi(o,!0,n,null,a);break;case"together":qi(o,!1,null,null,void 0);break;default:o.memoizedState=null}return o.child}function Sa(e,o){!(o.mode&1)&&e!==null&&(e.alternate=null,o.alternate=null,o.flags|=2)}function Bo(e,o,n){if(e!==null&&(o.dependencies=e.dependencies),Vn|=o.lanes,!(n&o.childLanes))return null;if(e!==null&&o.child!==e.child)throw Error(w(153));if(o.child!==null){for(e=o.child,n=kn(e,e.pendingProps),o.child=n,n.return=o;e.sibling!==null;)e=e.sibling,n=n.sibling=kn(e,e.pendingProps),n.return=o;n.sibling=null}return o.child}function Wf(e,o,n){switch(o.tag){case 3:Ev(o),Tt();break;case 5:rv(o);break;case 1:Ke(o.type)&&Fa(o);break;case 4:Xs(o,o.stateNode.containerInfo);break;case 10:var t=o.type._context,r=o.memoizedProps.value;ne($a,t._currentValue),t._currentValue=r;break;case 13:if(t=o.memoizedState,t!==null)return t.dehydrated!==null?(ne(le,le.current&1),o.flags|=128,null):n&o.child.childLanes?Mv(e,o,n):(ne(le,le.current&1),e=Bo(e,o,n),e!==null?e.sibling:null);ne(le,le.current&1);break;case 19:if(t=(n&o.childLanes)!==0,e.flags&128){if(t)return Ov(e,o,n);o.flags|=128}if(r=o.memoizedState,r!==null&&(r.rendering=null,r.tail=null,r.lastEffect=null),ne(le,le.current),t)break;return null;case 22:case 23:return o.lanes=0,wv(e,o,n)}return Bo(e,o,n)}var Rv,qc,Av,Iv;Rv=function(e,o){for(var n=o.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===o)break;for(;n.sibling===null;){if(n.return===null||n.return===o)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};qc=function(){};Av=function(e,o,n,t){var r=e.memoizedProps;if(r!==t){e=o.stateNode,xn(Eo.current);var a=null;switch(n){case"input":r=jc(e,r),t=jc(e,t),a=[];break;case"select":r=pe({},r,{value:void 0}),t=pe({},t,{value:void 0}),a=[];break;case"textarea":r=Tc(e,r),t=Tc(e,t),a=[];break;default:typeof r.onClick!="function"&&typeof t.onClick=="function"&&(e.onclick=Ua)}Pc(n,t);var i;n=null;for(u in r)if(!t.hasOwnProperty(u)&&r.hasOwnProperty(u)&&r[u]!=null)if(u==="style"){var c=r[u];for(i in c)c.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(br.hasOwnProperty(u)?a||(a=[]):(a=a||[]).push(u,null));for(u in t){var s=t[u];if(c=r!=null?r[u]:void 0,t.hasOwnProperty(u)&&s!==c&&(s!=null||c!=null))if(u==="style")if(c){for(i in c)!c.hasOwnProperty(i)||s&&s.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in s)s.hasOwnProperty(i)&&c[i]!==s[i]&&(n||(n={}),n[i]=s[i])}else n||(a||(a=[]),a.push(u,n)),n=s;else u==="dangerouslySetInnerHTML"?(s=s?s.__html:void 0,c=c?c.__html:void 0,s!=null&&c!==s&&(a=a||[]).push(u,s)):u==="children"?typeof s!="string"&&typeof s!="number"||(a=a||[]).push(u,""+s):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(br.hasOwnProperty(u)?(s!=null&&u==="onScroll"&&re("scroll",e),a||c===s||(a=[])):(a=a||[]).push(u,s))}n&&(a=a||[]).push("style",n);var u=a;(o.updateQueue=u)&&(o.flags|=4)}};Iv=function(e,o,n,t){n!==t&&(o.flags|=4)};function Xt(e,o){if(!ue)switch(e.tailMode){case"hidden":o=e.tail;for(var n=null;o!==null;)o.alternate!==null&&(n=o),o=o.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var t=null;n!==null;)n.alternate!==null&&(t=n),n=n.sibling;t===null?o||e.tail===null?e.tail=null:e.tail.sibling=null:t.sibling=null}}function Ee(e){var o=e.alternate!==null&&e.alternate.child===e.child,n=0,t=0;if(o)for(var r=e.child;r!==null;)n|=r.lanes|r.childLanes,t|=r.subtreeFlags&14680064,t|=r.flags&14680064,r.return=e,r=r.sibling;else for(r=e.child;r!==null;)n|=r.lanes|r.childLanes,t|=r.subtreeFlags,t|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=t,e.childLanes=n,o}function Zf(e,o,n){var t=o.pendingProps;switch(Fs(o),o.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ee(o),null;case 1:return Ke(o.type)&&_a(),Ee(o),null;case 3:return t=o.stateNode,Pt(),ae(Be),ae(Oe),Js(),t.pendingContext&&(t.context=t.pendingContext,t.pendingContext=null),(e===null||e.child===null)&&(aa(o)?o.flags|=4:e===null||e.memoizedState.isDehydrated&&!(o.flags&256)||(o.flags|=1024,ho!==null&&(cs(ho),ho=null))),qc(e,o),Ee(o),null;case 5:Gs(o);var r=xn(wr.current);if(n=o.type,e!==null&&o.stateNode!=null)Av(e,o,n,t,r),e.ref!==o.ref&&(o.flags|=512,o.flags|=2097152);else{if(!t){if(o.stateNode===null)throw Error(w(166));return Ee(o),null}if(e=xn(Eo.current),aa(o)){t=o.stateNode,n=o.type;var a=o.memoizedProps;switch(t[Po]=o,t[Pr]=a,e=(o.mode&1)!==0,n){case"dialog":re("cancel",t),re("close",t);break;case"iframe":case"object":case"embed":re("load",t);break;case"video":case"audio":for(r=0;r<rr.length;r++)re(rr[r],t);break;case"source":re("error",t);break;case"img":case"image":case"link":re("error",t),re("load",t);break;case"details":re("toggle",t);break;case"input":Ku(t,a),re("invalid",t);break;case"select":t._wrapperState={wasMultiple:!!a.multiple},re("invalid",t);break;case"textarea":Hu(t,a),re("invalid",t)}Pc(n,a),r=null;for(var i in a)if(a.hasOwnProperty(i)){var c=a[i];i==="children"?typeof c=="string"?t.textContent!==c&&(a.suppressHydrationWarning!==!0&&ra(t.textContent,c,e),r=["children",c]):typeof c=="number"&&t.textContent!==""+c&&(a.suppressHydrationWarning!==!0&&ra(t.textContent,c,e),r=["children",""+c]):br.hasOwnProperty(i)&&c!=null&&i==="onScroll"&&re("scroll",t)}switch(n){case"input":Jr(t),$u(t,a,!0);break;case"textarea":Jr(t),Wu(t);break;case"select":case"option":break;default:typeof a.onClick=="function"&&(t.onclick=Ua)}t=r,o.updateQueue=t,t!==null&&(o.flags|=4)}else{i=r.nodeType===9?r:r.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=up(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=i.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof t.is=="string"?e=i.createElement(n,{is:t.is}):(e=i.createElement(n),n==="select"&&(i=e,t.multiple?i.multiple=!0:t.size&&(i.size=t.size))):e=i.createElementNS(e,n),e[Po]=o,e[Pr]=t,Rv(e,o,!1,!1),o.stateNode=e;e:{switch(i=xc(n,t),n){case"dialog":re("cancel",e),re("close",e),r=t;break;case"iframe":case"object":case"embed":re("load",e),r=t;break;case"video":case"audio":for(r=0;r<rr.length;r++)re(rr[r],e);r=t;break;case"source":re("error",e),r=t;break;case"img":case"image":case"link":re("error",e),re("load",e),r=t;break;case"details":re("toggle",e),r=t;break;case"input":Ku(e,t),r=jc(e,t),re("invalid",e);break;case"option":r=t;break;case"select":e._wrapperState={wasMultiple:!!t.multiple},r=pe({},t,{value:void 0}),re("invalid",e);break;case"textarea":Hu(e,t),r=Tc(e,t),re("invalid",e);break;default:r=t}Pc(n,r),c=r;for(a in c)if(c.hasOwnProperty(a)){var s=c[a];a==="style"?pp(e,s):a==="dangerouslySetInnerHTML"?(s=s?s.__html:void 0,s!=null&&lp(e,s)):a==="children"?typeof s=="string"?(n!=="textarea"||s!=="")&&fr(e,s):typeof s=="number"&&fr(e,""+s):a!=="suppressContentEditableWarning"&&a!=="suppressHydrationWarning"&&a!=="autoFocus"&&(br.hasOwnProperty(a)?s!=null&&a==="onScroll"&&re("scroll",e):s!=null&&Ps(e,a,s,i))}switch(n){case"input":Jr(e),$u(e,t,!1);break;case"textarea":Jr(e),Wu(e);break;case"option":t.value!=null&&e.setAttribute("value",""+bn(t.value));break;case"select":e.multiple=!!t.multiple,a=t.value,a!=null?vt(e,!!t.multiple,a,!1):t.defaultValue!=null&&vt(e,!!t.multiple,t.defaultValue,!0);break;default:typeof r.onClick=="function"&&(e.onclick=Ua)}switch(n){case"button":case"input":case"select":case"textarea":t=!!t.autoFocus;break e;case"img":t=!0;break e;default:t=!1}}t&&(o.flags|=4)}o.ref!==null&&(o.flags|=512,o.flags|=2097152)}return Ee(o),null;case 6:if(e&&o.stateNode!=null)Iv(e,o,e.memoizedProps,t);else{if(typeof t!="string"&&o.stateNode===null)throw Error(w(166));if(n=xn(wr.current),xn(Eo.current),aa(o)){if(t=o.stateNode,n=o.memoizedProps,t[Po]=o,(a=t.nodeValue!==n)&&(e=Qe,e!==null))switch(e.tag){case 3:ra(t.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&ra(t.nodeValue,n,(e.mode&1)!==0)}a&&(o.flags|=4)}else t=(n.nodeType===9?n:n.ownerDocument).createTextNode(t),t[Po]=o,o.stateNode=t}return Ee(o),null;case 13:if(ae(le),t=o.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(ue&&Je!==null&&o.mode&1&&!(o.flags&128))qp(),Tt(),o.flags|=98560,a=!1;else if(a=aa(o),t!==null&&t.dehydrated!==null){if(e===null){if(!a)throw Error(w(318));if(a=o.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(w(317));a[Po]=o}else Tt(),!(o.flags&128)&&(o.memoizedState=null),o.flags|=4;Ee(o),a=!1}else ho!==null&&(cs(ho),ho=null),a=!0;if(!a)return o.flags&65536?o:null}return o.flags&128?(o.lanes=n,o):(t=t!==null,t!==(e!==null&&e.memoizedState!==null)&&t&&(o.child.flags|=8192,o.mode&1&&(e===null||le.current&1?ye===0&&(ye=3):su())),o.updateQueue!==null&&(o.flags|=4),Ee(o),null);case 4:return Pt(),qc(e,o),e===null&&Tr(o.stateNode.containerInfo),Ee(o),null;case 10:return Hs(o.type._context),Ee(o),null;case 17:return Ke(o.type)&&_a(),Ee(o),null;case 19:if(ae(le),a=o.memoizedState,a===null)return Ee(o),null;if(t=(o.flags&128)!==0,i=a.rendering,i===null)if(t)Xt(a,!1);else{if(ye!==0||e!==null&&e.flags&128)for(e=o.child;e!==null;){if(i=Za(e),i!==null){for(o.flags|=128,Xt(a,!1),t=i.updateQueue,t!==null&&(o.updateQueue=t,o.flags|=4),o.subtreeFlags=0,t=n,n=o.child;n!==null;)a=n,e=t,a.flags&=14680066,i=a.alternate,i===null?(a.childLanes=0,a.lanes=e,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=i.childLanes,a.lanes=i.lanes,a.child=i.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=i.memoizedProps,a.memoizedState=i.memoizedState,a.updateQueue=i.updateQueue,a.type=i.type,e=i.dependencies,a.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return ne(le,le.current&1|2),o.child}e=e.sibling}a.tail!==null&&ke()>wt&&(o.flags|=128,t=!0,Xt(a,!1),o.lanes=4194304)}else{if(!t)if(e=Za(i),e!==null){if(o.flags|=128,t=!0,n=e.updateQueue,n!==null&&(o.updateQueue=n,o.flags|=4),Xt(a,!0),a.tail===null&&a.tailMode==="hidden"&&!i.alternate&&!ue)return Ee(o),null}else 2*ke()-a.renderingStartTime>wt&&n!==1073741824&&(o.flags|=128,t=!0,Xt(a,!1),o.lanes=4194304);a.isBackwards?(i.sibling=o.child,o.child=i):(n=a.last,n!==null?n.sibling=i:o.child=i,a.last=i)}return a.tail!==null?(o=a.tail,a.rendering=o,a.tail=o.sibling,a.renderingStartTime=ke(),o.sibling=null,n=le.current,ne(le,t?n&1|2:n&1),o):(Ee(o),null);case 22:case 23:return cu(),t=o.memoizedState!==null,e!==null&&e.memoizedState!==null!==t&&(o.flags|=8192),t&&o.mode&1?Ge&1073741824&&(Ee(o),o.subtreeFlags&6&&(o.flags|=8192)):Ee(o),null;case 24:return null;case 25:return null}throw Error(w(156,o.tag))}function Xf(e,o){switch(Fs(o),o.tag){case 1:return Ke(o.type)&&_a(),e=o.flags,e&65536?(o.flags=e&-65537|128,o):null;case 3:return Pt(),ae(Be),ae(Oe),Js(),e=o.flags,e&65536&&!(e&128)?(o.flags=e&-65537|128,o):null;case 5:return Gs(o),null;case 13:if(ae(le),e=o.memoizedState,e!==null&&e.dehydrated!==null){if(o.alternate===null)throw Error(w(340));Tt()}return e=o.flags,e&65536?(o.flags=e&-65537|128,o):null;case 19:return ae(le),null;case 4:return Pt(),null;case 10:return Hs(o.type._context),null;case 22:case 23:return cu(),null;case 24:return null;default:return null}}var sa=!1,Me=!1,Gf=typeof WeakSet=="function"?WeakSet:Set,A=null;function ut(e,o){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(t){me(e,o,t)}else n.current=null}function es(e,o,n){try{n()}catch(t){me(e,o,t)}}var Il=!1;function Jf(e,o){if(Dc=Va,e=_p(),Us(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var t=n.getSelection&&n.getSelection();if(t&&t.rangeCount!==0){n=t.anchorNode;var r=t.anchorOffset,a=t.focusNode;t=t.focusOffset;try{n.nodeType,a.nodeType}catch{n=null;break e}var i=0,c=-1,s=-1,u=0,d=0,p=e,v=null;o:for(;;){for(var y;p!==n||r!==0&&p.nodeType!==3||(c=i+r),p!==a||t!==0&&p.nodeType!==3||(s=i+t),p.nodeType===3&&(i+=p.nodeValue.length),(y=p.firstChild)!==null;)v=p,p=y;for(;;){if(p===e)break o;if(v===n&&++u===r&&(c=i),v===a&&++d===t&&(s=i),(y=p.nextSibling)!==null)break;p=v,v=p.parentNode}p=y}n=c===-1||s===-1?null:{start:c,end:s}}else n=null}n=n||{start:0,end:0}}else n=null;for(Lc={focusedElem:e,selectionRange:n},Va=!1,A=o;A!==null;)if(o=A,e=o.child,(o.subtreeFlags&1028)!==0&&e!==null)e.return=o,A=e;else for(;A!==null;){o=A;try{var z=o.alternate;if(o.flags&1024)switch(o.tag){case 0:case 11:case 15:break;case 1:if(z!==null){var b=z.memoizedProps,N=z.memoizedState,k=o.stateNode,m=k.getSnapshotBeforeUpdate(o.elementType===o.type?b:ko(o.type,b),N);k.__reactInternalSnapshotBeforeUpdate=m}break;case 3:var f=o.stateNode.containerInfo;f.nodeType===1?f.textContent="":f.nodeType===9&&f.documentElement&&f.removeChild(f.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(w(163))}}catch(T){me(o,o.return,T)}if(e=o.sibling,e!==null){e.return=o.return,A=e;break}A=o.return}return z=Il,Il=!1,z}function dr(e,o,n){var t=o.updateQueue;if(t=t!==null?t.lastEffect:null,t!==null){var r=t=t.next;do{if((r.tag&e)===e){var a=r.destroy;r.destroy=void 0,a!==void 0&&es(o,n,a)}r=r.next}while(r!==t)}}function vi(e,o){if(o=o.updateQueue,o=o!==null?o.lastEffect:null,o!==null){var n=o=o.next;do{if((n.tag&e)===e){var t=n.create;n.destroy=t()}n=n.next}while(n!==o)}}function os(e){var o=e.ref;if(o!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof o=="function"?o(e):o.current=e}}function Vv(e){var o=e.alternate;o!==null&&(e.alternate=null,Vv(o)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(o=e.stateNode,o!==null&&(delete o[Po],delete o[Pr],delete o[Fc],delete o[Of],delete o[Rf])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function Dv(e){return e.tag===5||e.tag===3||e.tag===4}function Vl(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Dv(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function ns(e,o,n){var t=e.tag;if(t===5||t===6)e=e.stateNode,o?n.nodeType===8?n.parentNode.insertBefore(e,o):n.insertBefore(e,o):(n.nodeType===8?(o=n.parentNode,o.insertBefore(e,n)):(o=n,o.appendChild(e)),n=n._reactRootContainer,n!=null||o.onclick!==null||(o.onclick=Ua));else if(t!==4&&(e=e.child,e!==null))for(ns(e,o,n),e=e.sibling;e!==null;)ns(e,o,n),e=e.sibling}function ts(e,o,n){var t=e.tag;if(t===5||t===6)e=e.stateNode,o?n.insertBefore(e,o):n.appendChild(e);else if(t!==4&&(e=e.child,e!==null))for(ts(e,o,n),e=e.sibling;e!==null;)ts(e,o,n),e=e.sibling}var Pe=null,bo=!1;function Jo(e,o,n){for(n=n.child;n!==null;)Lv(e,o,n),n=n.sibling}function Lv(e,o,n){if(Co&&typeof Co.onCommitFiberUnmount=="function")try{Co.onCommitFiberUnmount(ai,n)}catch{}switch(n.tag){case 5:Me||ut(n,o);case 6:var t=Pe,r=bo;Pe=null,Jo(e,o,n),Pe=t,bo=r,Pe!==null&&(bo?(e=Pe,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):Pe.removeChild(n.stateNode));break;case 18:Pe!==null&&(bo?(e=Pe,n=n.stateNode,e.nodeType===8?Wi(e.parentNode,n):e.nodeType===1&&Wi(e,n),jr(e)):Wi(Pe,n.stateNode));break;case 4:t=Pe,r=bo,Pe=n.stateNode.containerInfo,bo=!0,Jo(e,o,n),Pe=t,bo=r;break;case 0:case 11:case 14:case 15:if(!Me&&(t=n.updateQueue,t!==null&&(t=t.lastEffect,t!==null))){r=t=t.next;do{var a=r,i=a.destroy;a=a.tag,i!==void 0&&(a&2||a&4)&&es(n,o,i),r=r.next}while(r!==t)}Jo(e,o,n);break;case 1:if(!Me&&(ut(n,o),t=n.stateNode,typeof t.componentWillUnmount=="function"))try{t.props=n.memoizedProps,t.state=n.memoizedState,t.componentWillUnmount()}catch(c){me(n,o,c)}Jo(e,o,n);break;case 21:Jo(e,o,n);break;case 22:n.mode&1?(Me=(t=Me)||n.memoizedState!==null,Jo(e,o,n),Me=t):Jo(e,o,n);break;default:Jo(e,o,n)}}function Dl(e){var o=e.updateQueue;if(o!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new Gf),o.forEach(function(t){var r=ah.bind(null,e,t);n.has(t)||(n.add(t),t.then(r,r))})}}function mo(e,o){var n=o.deletions;if(n!==null)for(var t=0;t<n.length;t++){var r=n[t];try{var a=e,i=o,c=i;e:for(;c!==null;){switch(c.tag){case 5:Pe=c.stateNode,bo=!1;break e;case 3:Pe=c.stateNode.containerInfo,bo=!0;break e;case 4:Pe=c.stateNode.containerInfo,bo=!0;break e}c=c.return}if(Pe===null)throw Error(w(160));Lv(a,i,r),Pe=null,bo=!1;var s=r.alternate;s!==null&&(s.return=null),r.return=null}catch(u){me(r,o,u)}}if(o.subtreeFlags&12854)for(o=o.child;o!==null;)Uv(o,e),o=o.sibling}function Uv(e,o){var n=e.alternate,t=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(mo(o,e),To(e),t&4){try{dr(3,e,e.return),vi(3,e)}catch(b){me(e,e.return,b)}try{dr(5,e,e.return)}catch(b){me(e,e.return,b)}}break;case 1:mo(o,e),To(e),t&512&&n!==null&&ut(n,n.return);break;case 5:if(mo(o,e),To(e),t&512&&n!==null&&ut(n,n.return),e.flags&32){var r=e.stateNode;try{fr(r,"")}catch(b){me(e,e.return,b)}}if(t&4&&(r=e.stateNode,r!=null)){var a=e.memoizedProps,i=n!==null?n.memoizedProps:a,c=e.type,s=e.updateQueue;if(e.updateQueue=null,s!==null)try{c==="input"&&a.type==="radio"&&a.name!=null&&cp(r,a),xc(c,i);var u=xc(c,a);for(i=0;i<s.length;i+=2){var d=s[i],p=s[i+1];d==="style"?pp(r,p):d==="dangerouslySetInnerHTML"?lp(r,p):d==="children"?fr(r,p):Ps(r,d,p,u)}switch(c){case"input":gc(r,a);break;case"textarea":sp(r,a);break;case"select":var v=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!a.multiple;var y=a.value;y!=null?vt(r,!!a.multiple,y,!1):v!==!!a.multiple&&(a.defaultValue!=null?vt(r,!!a.multiple,a.defaultValue,!0):vt(r,!!a.multiple,a.multiple?[]:"",!1))}r[Pr]=a}catch(b){me(e,e.return,b)}}break;case 6:if(mo(o,e),To(e),t&4){if(e.stateNode===null)throw Error(w(162));r=e.stateNode,a=e.memoizedProps;try{r.nodeValue=a}catch(b){me(e,e.return,b)}}break;case 3:if(mo(o,e),To(e),t&4&&n!==null&&n.memoizedState.isDehydrated)try{jr(o.containerInfo)}catch(b){me(e,e.return,b)}break;case 4:mo(o,e),To(e);break;case 13:mo(o,e),To(e),r=e.child,r.flags&8192&&(a=r.memoizedState!==null,r.stateNode.isHidden=a,!a||r.alternate!==null&&r.alternate.memoizedState!==null||(au=ke())),t&4&&Dl(e);break;case 22:if(d=n!==null&&n.memoizedState!==null,e.mode&1?(Me=(u=Me)||d,mo(o,e),Me=u):mo(o,e),To(e),t&8192){if(u=e.memoizedState!==null,(e.stateNode.isHidden=u)&&!d&&e.mode&1)for(A=e,d=e.child;d!==null;){for(p=A=d;A!==null;){switch(v=A,y=v.child,v.tag){case 0:case 11:case 14:case 15:dr(4,v,v.return);break;case 1:ut(v,v.return);var z=v.stateNode;if(typeof z.componentWillUnmount=="function"){t=v,n=v.return;try{o=t,z.props=o.memoizedProps,z.state=o.memoizedState,z.componentWillUnmount()}catch(b){me(t,n,b)}}break;case 5:ut(v,v.return);break;case 22:if(v.memoizedState!==null){Ul(p);continue}}y!==null?(y.return=v,A=y):Ul(p)}d=d.sibling}e:for(d=null,p=e;;){if(p.tag===5){if(d===null){d=p;try{r=p.stateNode,u?(a=r.style,typeof a.setProperty=="function"?a.setProperty("display","none","important"):a.display="none"):(c=p.stateNode,s=p.memoizedProps.style,i=s!=null&&s.hasOwnProperty("display")?s.display:null,c.style.display=dp("display",i))}catch(b){me(e,e.return,b)}}}else if(p.tag===6){if(d===null)try{p.stateNode.nodeValue=u?"":p.memoizedProps}catch(b){me(e,e.return,b)}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===e)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===e)break e;for(;p.sibling===null;){if(p.return===null||p.return===e)break e;d===p&&(d=null),p=p.return}d===p&&(d=null),p.sibling.return=p.return,p=p.sibling}}break;case 19:mo(o,e),To(e),t&4&&Dl(e);break;case 21:break;default:mo(o,e),To(e)}}function To(e){var o=e.flags;if(o&2){try{e:{for(var n=e.return;n!==null;){if(Dv(n)){var t=n;break e}n=n.return}throw Error(w(160))}switch(t.tag){case 5:var r=t.stateNode;t.flags&32&&(fr(r,""),t.flags&=-33);var a=Vl(e);ts(e,a,r);break;case 3:case 4:var i=t.stateNode.containerInfo,c=Vl(e);ns(e,c,i);break;default:throw Error(w(161))}}catch(s){me(e,e.return,s)}e.flags&=-3}o&4096&&(e.flags&=-4097)}function Qf(e,o,n){A=e,_v(e)}function _v(e,o,n){for(var t=(e.mode&1)!==0;A!==null;){var r=A,a=r.child;if(r.tag===22&&t){var i=r.memoizedState!==null||sa;if(!i){var c=r.alternate,s=c!==null&&c.memoizedState!==null||Me;c=sa;var u=Me;if(sa=i,(Me=s)&&!u)for(A=r;A!==null;)i=A,s=i.child,i.tag===22&&i.memoizedState!==null?_l(r):s!==null?(s.return=i,A=s):_l(r);for(;a!==null;)A=a,_v(a),a=a.sibling;A=r,sa=c,Me=u}Ll(e)}else r.subtreeFlags&8772&&a!==null?(a.return=r,A=a):Ll(e)}}function Ll(e){for(;A!==null;){var o=A;if(o.flags&8772){var n=o.alternate;try{if(o.flags&8772)switch(o.tag){case 0:case 11:case 15:Me||vi(5,o);break;case 1:var t=o.stateNode;if(o.flags&4&&!Me)if(n===null)t.componentDidMount();else{var r=o.elementType===o.type?n.memoizedProps:ko(o.type,n.memoizedProps);t.componentDidUpdate(r,n.memoizedState,t.__reactInternalSnapshotBeforeUpdate)}var a=o.updateQueue;a!==null&&gl(o,a,t);break;case 3:var i=o.updateQueue;if(i!==null){if(n=null,o.child!==null)switch(o.child.tag){case 5:n=o.child.stateNode;break;case 1:n=o.child.stateNode}gl(o,i,n)}break;case 5:var c=o.stateNode;if(n===null&&o.flags&4){n=c;var s=o.memoizedProps;switch(o.type){case"button":case"input":case"select":case"textarea":s.autoFocus&&n.focus();break;case"img":s.src&&(n.src=s.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(o.memoizedState===null){var u=o.alternate;if(u!==null){var d=u.memoizedState;if(d!==null){var p=d.dehydrated;p!==null&&jr(p)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(w(163))}Me||o.flags&512&&os(o)}catch(v){me(o,o.return,v)}}if(o===e){A=null;break}if(n=o.sibling,n!==null){n.return=o.return,A=n;break}A=o.return}}function Ul(e){for(;A!==null;){var o=A;if(o===e){A=null;break}var n=o.sibling;if(n!==null){n.return=o.return,A=n;break}A=o.return}}function _l(e){for(;A!==null;){var o=A;try{switch(o.tag){case 0:case 11:case 15:var n=o.return;try{vi(4,o)}catch(s){me(o,n,s)}break;case 1:var t=o.stateNode;if(typeof t.componentDidMount=="function"){var r=o.return;try{t.componentDidMount()}catch(s){me(o,r,s)}}var a=o.return;try{os(o)}catch(s){me(o,a,s)}break;case 5:var i=o.return;try{os(o)}catch(s){me(o,i,s)}}}catch(s){me(o,o.return,s)}if(o===e){A=null;break}var c=o.sibling;if(c!==null){c.return=o.return,A=c;break}A=o.return}}var Yf=Math.ceil,Ja=$o.ReactCurrentDispatcher,tu=$o.ReactCurrentOwner,so=$o.ReactCurrentBatchConfig,Y=0,ge=null,fe=null,xe=0,Ge=0,lt=zn(0),ye=0,Or=null,Vn=0,mi=0,ru=0,pr=null,_e=null,au=0,wt=1/0,Oo=null,Qa=!1,rs=null,vn=null,ua=!1,cn=null,Ya=0,vr=0,as=null,Pa=-1,xa=0;function Ve(){return Y&6?ke():Pa!==-1?Pa:Pa=ke()}function mn(e){return e.mode&1?Y&2&&xe!==0?xe&-xe:If.transition!==null?(xa===0&&(xa=Tp()),xa):(e=q,e!==0||(e=window.event,e=e===void 0?16:Mp(e.type)),e):1}function zo(e,o,n,t){if(50<vr)throw vr=0,as=null,Error(w(185));Vr(e,n,t),(!(Y&2)||e!==ge)&&(e===ge&&(!(Y&2)&&(mi|=n),ye===4&&rn(e,xe)),$e(e,t),n===1&&Y===0&&!(o.mode&1)&&(wt=ke()+500,li&&jn()))}function $e(e,o){var n=e.callbackNode;Ab(e,o);var t=Ia(e,e===ge?xe:0);if(t===0)n!==null&&Gu(n),e.callbackNode=null,e.callbackPriority=0;else if(o=t&-t,e.callbackPriority!==o){if(n!=null&&Gu(n),o===1)e.tag===0?Af(Fl.bind(null,e)):Jp(Fl.bind(null,e)),Ef(function(){!(Y&6)&&jn()}),n=null;else{switch(Sp(t)){case 1:n=Ms;break;case 4:n=gp;break;case 16:n=Aa;break;case 536870912:n=Np;break;default:n=Aa}n=Xv(n,Fv.bind(null,e))}e.callbackPriority=o,e.callbackNode=n}}function Fv(e,o){if(Pa=-1,xa=0,Y&6)throw Error(w(327));var n=e.callbackNode;if(ht()&&e.callbackNode!==n)return null;var t=Ia(e,e===ge?xe:0);if(t===0)return null;if(t&30||t&e.expiredLanes||o)o=qa(e,t);else{o=t;var r=Y;Y|=2;var a=Kv();(ge!==e||xe!==o)&&(Oo=null,wt=ke()+500,En(e,o));do try{oh();break}catch(c){Bv(e,c)}while(!0);$s(),Ja.current=a,Y=r,fe!==null?o=0:(ge=null,xe=0,o=ye)}if(o!==0){if(o===2&&(r=Oc(e),r!==0&&(t=r,o=is(e,r))),o===1)throw n=Or,En(e,0),rn(e,t),$e(e,ke()),n;if(o===6)rn(e,t);else{if(r=e.current.alternate,!(t&30)&&!qf(r)&&(o=qa(e,t),o===2&&(a=Oc(e),a!==0&&(t=a,o=is(e,a))),o===1))throw n=Or,En(e,0),rn(e,t),$e(e,ke()),n;switch(e.finishedWork=r,e.finishedLanes=t,o){case 0:case 1:throw Error(w(345));case 2:Tn(e,_e,Oo);break;case 3:if(rn(e,t),(t&130023424)===t&&(o=au+500-ke(),10<o)){if(Ia(e,0)!==0)break;if(r=e.suspendedLanes,(r&t)!==t){Ve(),e.pingedLanes|=e.suspendedLanes&r;break}e.timeoutHandle=_c(Tn.bind(null,e,_e,Oo),o);break}Tn(e,_e,Oo);break;case 4:if(rn(e,t),(t&4194240)===t)break;for(o=e.eventTimes,r=-1;0<t;){var i=31-yo(t);a=1<<i,i=o[i],i>r&&(r=i),t&=~a}if(t=r,t=ke()-t,t=(120>t?120:480>t?480:1080>t?1080:1920>t?1920:3e3>t?3e3:4320>t?4320:1960*Yf(t/1960))-t,10<t){e.timeoutHandle=_c(Tn.bind(null,e,_e,Oo),t);break}Tn(e,_e,Oo);break;case 5:Tn(e,_e,Oo);break;default:throw Error(w(329))}}}return $e(e,ke()),e.callbackNode===n?Fv.bind(null,e):null}function is(e,o){var n=pr;return e.current.memoizedState.isDehydrated&&(En(e,o).flags|=256),e=qa(e,o),e!==2&&(o=_e,_e=n,o!==null&&cs(o)),e}function cs(e){_e===null?_e=e:_e.push.apply(_e,e)}function qf(e){for(var o=e;;){if(o.flags&16384){var n=o.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var t=0;t<n.length;t++){var r=n[t],a=r.getSnapshot;r=r.value;try{if(!jo(a(),r))return!1}catch{return!1}}}if(n=o.child,o.subtreeFlags&16384&&n!==null)n.return=o,o=n;else{if(o===e)break;for(;o.sibling===null;){if(o.return===null||o.return===e)return!0;o=o.return}o.sibling.return=o.return,o=o.sibling}}return!0}function rn(e,o){for(o&=~ru,o&=~mi,e.suspendedLanes|=o,e.pingedLanes&=~o,e=e.expirationTimes;0<o;){var n=31-yo(o),t=1<<n;e[n]=-1,o&=~t}}function Fl(e){if(Y&6)throw Error(w(327));ht();var o=Ia(e,0);if(!(o&1))return $e(e,ke()),null;var n=qa(e,o);if(e.tag!==0&&n===2){var t=Oc(e);t!==0&&(o=t,n=is(e,t))}if(n===1)throw n=Or,En(e,0),rn(e,o),$e(e,ke()),n;if(n===6)throw Error(w(345));return e.finishedWork=e.current.alternate,e.finishedLanes=o,Tn(e,_e,Oo),$e(e,ke()),null}function iu(e,o){var n=Y;Y|=1;try{return e(o)}finally{Y=n,Y===0&&(wt=ke()+500,li&&jn())}}function Dn(e){cn!==null&&cn.tag===0&&!(Y&6)&&ht();var o=Y;Y|=1;var n=so.transition,t=q;try{if(so.transition=null,q=1,e)return e()}finally{q=t,so.transition=n,Y=o,!(Y&6)&&jn()}}function cu(){Ge=lt.current,ae(lt)}function En(e,o){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,Cf(n)),fe!==null)for(n=fe.return;n!==null;){var t=n;switch(Fs(t),t.tag){case 1:t=t.type.childContextTypes,t!=null&&_a();break;case 3:Pt(),ae(Be),ae(Oe),Js();break;case 5:Gs(t);break;case 4:Pt();break;case 13:ae(le);break;case 19:ae(le);break;case 10:Hs(t.type._context);break;case 22:case 23:cu()}n=n.return}if(ge=e,fe=e=kn(e.current,null),xe=Ge=o,ye=0,Or=null,ru=mi=Vn=0,_e=pr=null,Pn!==null){for(o=0;o<Pn.length;o++)if(n=Pn[o],t=n.interleaved,t!==null){n.interleaved=null;var r=t.next,a=n.pending;if(a!==null){var i=a.next;a.next=r,t.next=i}n.pending=t}Pn=null}return e}function Bv(e,o){do{var n=fe;try{if($s(),Na.current=Ga,Xa){for(var t=de.memoizedState;t!==null;){var r=t.queue;r!==null&&(r.pending=null),t=t.next}Xa=!1}if(In=0,je=he=de=null,lr=!1,Cr=0,tu.current=null,n===null||n.return===null){ye=1,Or=o,fe=null;break}e:{var a=e,i=n.return,c=n,s=o;if(o=xe,c.flags|=32768,s!==null&&typeof s=="object"&&typeof s.then=="function"){var u=s,d=c,p=d.tag;if(!(d.mode&1)&&(p===0||p===11||p===15)){var v=d.alternate;v?(d.updateQueue=v.updateQueue,d.memoizedState=v.memoizedState,d.lanes=v.lanes):(d.updateQueue=null,d.memoizedState=null)}var y=wl(i);if(y!==null){y.flags&=-257,Cl(y,i,c,a,o),y.mode&1&&xl(a,u,o),o=y,s=u;var z=o.updateQueue;if(z===null){var b=new Set;b.add(s),o.updateQueue=b}else z.add(s);break e}else{if(!(o&1)){xl(a,u,o),su();break e}s=Error(w(426))}}else if(ue&&c.mode&1){var N=wl(i);if(N!==null){!(N.flags&65536)&&(N.flags|=256),Cl(N,i,c,a,o),Bs(xt(s,c));break e}}a=s=xt(s,c),ye!==4&&(ye=2),pr===null?pr=[a]:pr.push(a),a=i;do{switch(a.tag){case 3:a.flags|=65536,o&=-o,a.lanes|=o;var k=Sv(a,s,o);jl(a,k);break e;case 1:c=s;var m=a.type,f=a.stateNode;if(!(a.flags&128)&&(typeof m.getDerivedStateFromError=="function"||f!==null&&typeof f.componentDidCatch=="function"&&(vn===null||!vn.has(f)))){a.flags|=65536,o&=-o,a.lanes|=o;var T=Pv(a,c,o);jl(a,T);break e}}a=a.return}while(a!==null)}Hv(n)}catch(x){o=x,fe===n&&n!==null&&(fe=n=n.return);continue}break}while(!0)}function Kv(){var e=Ja.current;return Ja.current=Ga,e===null?Ga:e}function su(){(ye===0||ye===3||ye===2)&&(ye=4),ge===null||!(Vn&268435455)&&!(mi&268435455)||rn(ge,xe)}function qa(e,o){var n=Y;Y|=2;var t=Kv();(ge!==e||xe!==o)&&(Oo=null,En(e,o));do try{eh();break}catch(r){Bv(e,r)}while(!0);if($s(),Y=n,Ja.current=t,fe!==null)throw Error(w(261));return ge=null,xe=0,ye}function eh(){for(;fe!==null;)$v(fe)}function oh(){for(;fe!==null&&!Sb();)$v(fe)}function $v(e){var o=Zv(e.alternate,e,Ge);e.memoizedProps=e.pendingProps,o===null?Hv(e):fe=o,tu.current=null}function Hv(e){var o=e;do{var n=o.alternate;if(e=o.return,o.flags&32768){if(n=Xf(n,o),n!==null){n.flags&=32767,fe=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{ye=6,fe=null;return}}else if(n=Zf(n,o,Ge),n!==null){fe=n;return}if(o=o.sibling,o!==null){fe=o;return}fe=o=e}while(o!==null);ye===0&&(ye=5)}function Tn(e,o,n){var t=q,r=so.transition;try{so.transition=null,q=1,nh(e,o,n,t)}finally{so.transition=r,q=t}return null}function nh(e,o,n,t){do ht();while(cn!==null);if(Y&6)throw Error(w(327));n=e.finishedWork;var r=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(w(177));e.callbackNode=null,e.callbackPriority=0;var a=n.lanes|n.childLanes;if(Ib(e,a),e===ge&&(fe=ge=null,xe=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||ua||(ua=!0,Xv(Aa,function(){return ht(),null})),a=(n.flags&15990)!==0,n.subtreeFlags&15990||a){a=so.transition,so.transition=null;var i=q;q=1;var c=Y;Y|=4,tu.current=null,Jf(e,n),Uv(n,e),gf(Lc),Va=!!Dc,Lc=Dc=null,e.current=n,Qf(n),Pb(),Y=c,q=i,so.transition=a}else e.current=n;if(ua&&(ua=!1,cn=e,Ya=r),a=e.pendingLanes,a===0&&(vn=null),Cb(n.stateNode),$e(e,ke()),o!==null)for(t=e.onRecoverableError,n=0;n<o.length;n++)r=o[n],t(r.value,{componentStack:r.stack,digest:r.digest});if(Qa)throw Qa=!1,e=rs,rs=null,e;return Ya&1&&e.tag!==0&&ht(),a=e.pendingLanes,a&1?e===as?vr++:(vr=0,as=e):vr=0,jn(),null}function ht(){if(cn!==null){var e=Sp(Ya),o=so.transition,n=q;try{if(so.transition=null,q=16>e?16:e,cn===null)var t=!1;else{if(e=cn,cn=null,Ya=0,Y&6)throw Error(w(331));var r=Y;for(Y|=4,A=e.current;A!==null;){var a=A,i=a.child;if(A.flags&16){var c=a.deletions;if(c!==null){for(var s=0;s<c.length;s++){var u=c[s];for(A=u;A!==null;){var d=A;switch(d.tag){case 0:case 11:case 15:dr(8,d,a)}var p=d.child;if(p!==null)p.return=d,A=p;else for(;A!==null;){d=A;var v=d.sibling,y=d.return;if(Vv(d),d===u){A=null;break}if(v!==null){v.return=y,A=v;break}A=y}}}var z=a.alternate;if(z!==null){var b=z.child;if(b!==null){z.child=null;do{var N=b.sibling;b.sibling=null,b=N}while(b!==null)}}A=a}}if(a.subtreeFlags&2064&&i!==null)i.return=a,A=i;else e:for(;A!==null;){if(a=A,a.flags&2048)switch(a.tag){case 0:case 11:case 15:dr(9,a,a.return)}var k=a.sibling;if(k!==null){k.return=a.return,A=k;break e}A=a.return}}var m=e.current;for(A=m;A!==null;){i=A;var f=i.child;if(i.subtreeFlags&2064&&f!==null)f.return=i,A=f;else e:for(i=m;A!==null;){if(c=A,c.flags&2048)try{switch(c.tag){case 0:case 11:case 15:vi(9,c)}}catch(x){me(c,c.return,x)}if(c===i){A=null;break e}var T=c.sibling;if(T!==null){T.return=c.return,A=T;break e}A=c.return}}if(Y=r,jn(),Co&&typeof Co.onPostCommitFiberRoot=="function")try{Co.onPostCommitFiberRoot(ai,e)}catch{}t=!0}return t}finally{q=n,so.transition=o}}return!1}function Bl(e,o,n){o=xt(n,o),o=Sv(e,o,1),e=pn(e,o,1),o=Ve(),e!==null&&(Vr(e,1,o),$e(e,o))}function me(e,o,n){if(e.tag===3)Bl(e,e,n);else for(;o!==null;){if(o.tag===3){Bl(o,e,n);break}else if(o.tag===1){var t=o.stateNode;if(typeof o.type.getDerivedStateFromError=="function"||typeof t.componentDidCatch=="function"&&(vn===null||!vn.has(t))){e=xt(n,e),e=Pv(o,e,1),o=pn(o,e,1),e=Ve(),o!==null&&(Vr(o,1,e),$e(o,e));break}}o=o.return}}function th(e,o,n){var t=e.pingCache;t!==null&&t.delete(o),o=Ve(),e.pingedLanes|=e.suspendedLanes&n,ge===e&&(xe&n)===n&&(ye===4||ye===3&&(xe&130023424)===xe&&500>ke()-au?En(e,0):ru|=n),$e(e,o)}function Wv(e,o){o===0&&(e.mode&1?(o=qr,qr<<=1,!(qr&130023424)&&(qr=4194304)):o=1);var n=Ve();e=Fo(e,o),e!==null&&(Vr(e,o,n),$e(e,n))}function rh(e){var o=e.memoizedState,n=0;o!==null&&(n=o.retryLane),Wv(e,n)}function ah(e,o){var n=0;switch(e.tag){case 13:var t=e.stateNode,r=e.memoizedState;r!==null&&(n=r.retryLane);break;case 19:t=e.stateNode;break;default:throw Error(w(314))}t!==null&&t.delete(o),Wv(e,n)}var Zv;Zv=function(e,o,n){if(e!==null)if(e.memoizedProps!==o.pendingProps||Be.current)Fe=!0;else{if(!(e.lanes&n)&&!(o.flags&128))return Fe=!1,Wf(e,o,n);Fe=!!(e.flags&131072)}else Fe=!1,ue&&o.flags&1048576&&Qp(o,Ka,o.index);switch(o.lanes=0,o.tag){case 2:var t=o.type;Sa(e,o),e=o.pendingProps;var r=Nt(o,Oe.current);ft(o,n),r=Ys(null,o,t,e,r,n);var a=qs();return o.flags|=1,typeof r=="object"&&r!==null&&typeof r.render=="function"&&r.$$typeof===void 0?(o.tag=1,o.memoizedState=null,o.updateQueue=null,Ke(t)?(a=!0,Fa(o)):a=!1,o.memoizedState=r.state!==null&&r.state!==void 0?r.state:null,Zs(o),r.updater=pi,o.stateNode=r,r._reactInternals=o,Zc(o,t,e,n),o=Jc(null,o,t,!0,a,n)):(o.tag=0,ue&&a&&_s(o),Ie(null,o,r,n),o=o.child),o;case 16:t=o.elementType;e:{switch(Sa(e,o),e=o.pendingProps,r=t._init,t=r(t._payload),o.type=t,r=o.tag=ch(t),e=ko(t,e),r){case 0:o=Gc(null,o,t,e,n);break e;case 1:o=Ol(null,o,t,e,n);break e;case 11:o=El(null,o,t,e,n);break e;case 14:o=Ml(null,o,t,ko(t.type,e),n);break e}throw Error(w(306,t,""))}return o;case 0:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),Gc(e,o,t,r,n);case 1:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),Ol(e,o,t,r,n);case 3:e:{if(Ev(o),e===null)throw Error(w(387));t=o.pendingProps,a=o.memoizedState,r=a.element,tv(e,o),Wa(o,t,null,n);var i=o.memoizedState;if(t=i.element,a.isDehydrated)if(a={element:t,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},o.updateQueue.baseState=a,o.memoizedState=a,o.flags&256){r=xt(Error(w(423)),o),o=Rl(e,o,t,n,r);break e}else if(t!==r){r=xt(Error(w(424)),o),o=Rl(e,o,t,n,r);break e}else for(Je=dn(o.stateNode.containerInfo.firstChild),Qe=o,ue=!0,ho=null,n=ov(o,null,t,n),o.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(Tt(),t===r){o=Bo(e,o,n);break e}Ie(e,o,t,n)}o=o.child}return o;case 5:return rv(o),e===null&&$c(o),t=o.type,r=o.pendingProps,a=e!==null?e.memoizedProps:null,i=r.children,Uc(t,r)?i=null:a!==null&&Uc(t,a)&&(o.flags|=32),Cv(e,o),Ie(e,o,i,n),o.child;case 6:return e===null&&$c(o),null;case 13:return Mv(e,o,n);case 4:return Xs(o,o.stateNode.containerInfo),t=o.pendingProps,e===null?o.child=St(o,null,t,n):Ie(e,o,t,n),o.child;case 11:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),El(e,o,t,r,n);case 7:return Ie(e,o,o.pendingProps,n),o.child;case 8:return Ie(e,o,o.pendingProps.children,n),o.child;case 12:return Ie(e,o,o.pendingProps.children,n),o.child;case 10:e:{if(t=o.type._context,r=o.pendingProps,a=o.memoizedProps,i=r.value,ne($a,t._currentValue),t._currentValue=i,a!==null)if(jo(a.value,i)){if(a.children===r.children&&!Be.current){o=Bo(e,o,n);break e}}else for(a=o.child,a!==null&&(a.return=o);a!==null;){var c=a.dependencies;if(c!==null){i=a.child;for(var s=c.firstContext;s!==null;){if(s.context===t){if(a.tag===1){s=Do(-1,n&-n),s.tag=2;var u=a.updateQueue;if(u!==null){u=u.shared;var d=u.pending;d===null?s.next=s:(s.next=d.next,d.next=s),u.pending=s}}a.lanes|=n,s=a.alternate,s!==null&&(s.lanes|=n),Hc(a.return,n,o),c.lanes|=n;break}s=s.next}}else if(a.tag===10)i=a.type===o.type?null:a.child;else if(a.tag===18){if(i=a.return,i===null)throw Error(w(341));i.lanes|=n,c=i.alternate,c!==null&&(c.lanes|=n),Hc(i,n,o),i=a.sibling}else i=a.child;if(i!==null)i.return=a;else for(i=a;i!==null;){if(i===o){i=null;break}if(a=i.sibling,a!==null){a.return=i.return,i=a;break}i=i.return}a=i}Ie(e,o,r.children,n),o=o.child}return o;case 9:return r=o.type,t=o.pendingProps.children,ft(o,n),r=uo(r),t=t(r),o.flags|=1,Ie(e,o,t,n),o.child;case 14:return t=o.type,r=ko(t,o.pendingProps),r=ko(t.type,r),Ml(e,o,t,r,n);case 15:return xv(e,o,o.type,o.pendingProps,n);case 17:return t=o.type,r=o.pendingProps,r=o.elementType===t?r:ko(t,r),Sa(e,o),o.tag=1,Ke(t)?(e=!0,Fa(o)):e=!1,ft(o,n),Tv(o,t,r),Zc(o,t,r,n),Jc(null,o,t,!0,e,n);case 19:return Ov(e,o,n);case 22:return wv(e,o,n)}throw Error(w(156,o.tag))};function Xv(e,o){return jp(e,o)}function ih(e,o,n,t){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=o,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=t,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function co(e,o,n,t){return new ih(e,o,n,t)}function uu(e){return e=e.prototype,!(!e||!e.isReactComponent)}function ch(e){if(typeof e=="function")return uu(e)?1:0;if(e!=null){if(e=e.$$typeof,e===ws)return 11;if(e===Cs)return 14}return 2}function kn(e,o){var n=e.alternate;return n===null?(n=co(e.tag,o,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=o,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,o=e.dependencies,n.dependencies=o===null?null:{lanes:o.lanes,firstContext:o.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function wa(e,o,n,t,r,a){var i=2;if(t=e,typeof e=="function")uu(e)&&(i=1);else if(typeof e=="string")i=5;else e:switch(e){case et:return Mn(n.children,r,a,o);case xs:i=8,r|=8;break;case fc:return e=co(12,n,o,r|2),e.elementType=fc,e.lanes=a,e;case hc:return e=co(13,n,o,r),e.elementType=hc,e.lanes=a,e;case yc:return e=co(19,n,o,r),e.elementType=yc,e.lanes=a,e;case rp:return ki(n,r,a,o);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case np:i=10;break e;case tp:i=9;break e;case ws:i=11;break e;case Cs:i=14;break e;case on:i=16,t=null;break e}throw Error(w(130,e==null?e:typeof e,""))}return o=co(i,n,o,r),o.elementType=e,o.type=t,o.lanes=a,o}function Mn(e,o,n,t){return e=co(7,e,t,o),e.lanes=n,e}function ki(e,o,n,t){return e=co(22,e,t,o),e.elementType=rp,e.lanes=n,e.stateNode={isHidden:!1},e}function ec(e,o,n){return e=co(6,e,null,o),e.lanes=n,e}function oc(e,o,n){return o=co(4,e.children!==null?e.children:[],e.key,o),o.lanes=n,o.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},o}function sh(e,o,n,t,r){this.tag=o,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Ii(0),this.expirationTimes=Ii(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ii(0),this.identifierPrefix=t,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function lu(e,o,n,t,r,a,i,c,s){return e=new sh(e,o,n,c,s),o===1?(o=1,a===!0&&(o|=8)):o=0,a=co(3,null,null,o),e.current=a,a.stateNode=e,a.memoizedState={element:t,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Zs(a),e}function uh(e,o,n){var t=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:qn,key:t==null?null:""+t,children:e,containerInfo:o,implementation:n}}function Gv(e){if(!e)return fn;e=e._reactInternals;e:{if(Bn(e)!==e||e.tag!==1)throw Error(w(170));var o=e;do{switch(o.tag){case 3:o=o.stateNode.context;break e;case 1:if(Ke(o.type)){o=o.stateNode.__reactInternalMemoizedMergedChildContext;break e}}o=o.return}while(o!==null);throw Error(w(171))}if(e.tag===1){var n=e.type;if(Ke(n))return Gp(e,n,o)}return o}function Jv(e,o,n,t,r,a,i,c,s){return e=lu(n,t,!0,e,r,a,i,c,s),e.context=Gv(null),n=e.current,t=Ve(),r=mn(n),a=Do(t,r),a.callback=o??null,pn(n,a,r),e.current.lanes=r,Vr(e,r,t),$e(e,t),e}function bi(e,o,n,t){var r=o.current,a=Ve(),i=mn(r);return n=Gv(n),o.context===null?o.context=n:o.pendingContext=n,o=Do(a,i),o.payload={element:e},t=t===void 0?null:t,t!==null&&(o.callback=t),e=pn(r,o,i),e!==null&&(zo(e,r,i,a),ga(e,r,i)),i}function ei(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Kl(e,o){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<o?n:o}}function du(e,o){Kl(e,o),(e=e.alternate)&&Kl(e,o)}function lh(){return null}var Qv=typeof reportError=="function"?reportError:function(e){console.error(e)};function pu(e){this._internalRoot=e}fi.prototype.render=pu.prototype.render=function(e){var o=this._internalRoot;if(o===null)throw Error(w(409));bi(e,o,null,null)};fi.prototype.unmount=pu.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var o=e.containerInfo;Dn(function(){bi(null,e,null,null)}),o[_o]=null}};function fi(e){this._internalRoot=e}fi.prototype.unstable_scheduleHydration=function(e){if(e){var o=wp();e={blockedOn:null,target:e,priority:o};for(var n=0;n<tn.length&&o!==0&&o<tn[n].priority;n++);tn.splice(n,0,e),n===0&&Ep(e)}};function vu(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function hi(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function $l(){}function dh(e,o,n,t,r){if(r){if(typeof t=="function"){var a=t;t=function(){var u=ei(i);a.call(u)}}var i=Jv(o,t,e,0,null,!1,!1,"",$l);return e._reactRootContainer=i,e[_o]=i.current,Tr(e.nodeType===8?e.parentNode:e),Dn(),i}for(;r=e.lastChild;)e.removeChild(r);if(typeof t=="function"){var c=t;t=function(){var u=ei(s);c.call(u)}}var s=lu(e,0,!1,null,null,!1,!1,"",$l);return e._reactRootContainer=s,e[_o]=s.current,Tr(e.nodeType===8?e.parentNode:e),Dn(function(){bi(o,s,n,t)}),s}function yi(e,o,n,t,r){var a=n._reactRootContainer;if(a){var i=a;if(typeof r=="function"){var c=r;r=function(){var s=ei(i);c.call(s)}}bi(o,i,e,r)}else i=dh(n,o,e,r,t);return ei(i)}Pp=function(e){switch(e.tag){case 3:var o=e.stateNode;if(o.current.memoizedState.isDehydrated){var n=tr(o.pendingLanes);n!==0&&(Os(o,n|1),$e(o,ke()),!(Y&6)&&(wt=ke()+500,jn()))}break;case 13:Dn(function(){var t=Fo(e,1);if(t!==null){var r=Ve();zo(t,e,1,r)}}),du(e,1)}};Rs=function(e){if(e.tag===13){var o=Fo(e,134217728);if(o!==null){var n=Ve();zo(o,e,134217728,n)}du(e,134217728)}};xp=function(e){if(e.tag===13){var o=mn(e),n=Fo(e,o);if(n!==null){var t=Ve();zo(n,e,o,t)}du(e,o)}};wp=function(){return q};Cp=function(e,o){var n=q;try{return q=e,o()}finally{q=n}};Cc=function(e,o,n){switch(o){case"input":if(gc(e,n),o=n.name,n.type==="radio"&&o!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+o)+'][type="radio"]'),o=0;o<n.length;o++){var t=n[o];if(t!==e&&t.form===e.form){var r=ui(t);if(!r)throw Error(w(90));ip(t),gc(t,r)}}}break;case"textarea":sp(e,n);break;case"select":o=n.value,o!=null&&vt(e,!!n.multiple,o,!1)}};kp=iu;bp=Dn;var ph={usingClientEntryPoint:!1,Events:[Lr,rt,ui,vp,mp,iu]},Gt={findFiberByHostInstance:Sn,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},vh={bundleType:Gt.bundleType,version:Gt.version,rendererPackageName:Gt.rendererPackageName,rendererConfig:Gt.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:$o.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=yp(e),e===null?null:e.stateNode},findFiberByHostInstance:Gt.findFiberByHostInstance||lh,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var la=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!la.isDisabled&&la.supportsFiber)try{ai=la.inject(vh),Co=la}catch{}}qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ph;qe.createPortal=function(e,o){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!vu(o))throw Error(w(200));return uh(e,o,null,n)};qe.createRoot=function(e,o){if(!vu(e))throw Error(w(299));var n=!1,t="",r=Qv;return o!=null&&(o.unstable_strictMode===!0&&(n=!0),o.identifierPrefix!==void 0&&(t=o.identifierPrefix),o.onRecoverableError!==void 0&&(r=o.onRecoverableError)),o=lu(e,1,!1,null,null,n,!1,t,r),e[_o]=o.current,Tr(e.nodeType===8?e.parentNode:e),new pu(o)};qe.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var o=e._reactInternals;if(o===void 0)throw typeof e.render=="function"?Error(w(188)):(e=Object.keys(e).join(","),Error(w(268,e)));return e=yp(o),e=e===null?null:e.stateNode,e};qe.flushSync=function(e){return Dn(e)};qe.hydrate=function(e,o,n){if(!hi(o))throw Error(w(200));return yi(null,e,o,!0,n)};qe.hydrateRoot=function(e,o,n){if(!vu(e))throw Error(w(405));var t=n!=null&&n.hydratedSources||null,r=!1,a="",i=Qv;if(n!=null&&(n.unstable_strictMode===!0&&(r=!0),n.identifierPrefix!==void 0&&(a=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),o=Jv(o,null,e,1,n??null,r,!1,a,i),e[_o]=o.current,Tr(e),t)for(e=0;e<t.length;e++)n=t[e],r=n._getVersion,r=r(n._source),o.mutableSourceEagerHydrationData==null?o.mutableSourceEagerHydrationData=[n,r]:o.mutableSourceEagerHydrationData.push(n,r);return new fi(o)};qe.render=function(e,o,n){if(!hi(o))throw Error(w(200));return yi(null,e,o,!1,n)};qe.unmountComponentAtNode=function(e){if(!hi(e))throw Error(w(40));return e._reactRootContainer?(Dn(function(){yi(null,null,e,!1,function(){e._reactRootContainer=null,e[_o]=null})}),!0):!1};qe.unstable_batchedUpdates=iu;qe.unstable_renderSubtreeIntoContainer=function(e,o,n,t){if(!hi(n))throw Error(w(200));if(e==null||e._reactInternals===void 0)throw Error(w(38));return yi(e,o,n,!1,t)};qe.version="18.3.1-next-f1338f8080-20240426";function Yv(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Yv)}catch(e){console.error(e)}}Yv(),Yd.exports=qe;var _r=Yd.exports;const qv=Ld(_r),mh=Dd({__proto__:null,default:qv},[_r]);var Hl=_r;kc.createRoot=Hl.createRoot,kc.hydrateRoot=Hl.hydrateRoot;function Wl(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function kh(...e){return o=>{let n=!1;const t=e.map(r=>{const a=Wl(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():Wl(e[r],null)}}}}var Kn=l.forwardRef((e,o)=>{const{children:n,...t}=e,r=l.Children.toArray(n),a=r.find(fh);if(a){const i=a.props.children,c=r.map(s=>s===a?l.Children.count(i)>1?l.Children.only(null):l.isValidElement(i)?i.props.children:null:s);return g.jsx(ss,{...t,ref:o,children:l.isValidElement(i)?l.cloneElement(i,void 0,c):null})}return g.jsx(ss,{...t,ref:o,children:n})});Kn.displayName="Slot";var ss=l.forwardRef((e,o)=>{const{children:n,...t}=e;if(l.isValidElement(n)){const r=yh(n),a=hh(t,n.props);return n.type!==l.Fragment&&(a.ref=o?kh(o,r):r),l.cloneElement(n,a)}return l.Children.count(n)>1?l.Children.only(null):null});ss.displayName="SlotClone";var bh=({children:e})=>g.jsx(g.Fragment,{children:e});function fh(e){return l.isValidElement(e)&&e.type===bh}function hh(e,o){const n={...o};for(const t in o){const r=e[t],a=o[t];/^on[A-Z]/.test(t)?r&&a?n[t]=(...c)=>{a(...c),r(...c)}:r&&(n[t]=r):t==="style"?n[t]={...r,...a}:t==="className"&&(n[t]=[r,a].filter(Boolean).join(" "))}return{...e,...n}}function yh(e){var t,r;let o=(t=Object.getOwnPropertyDescriptor(e.props,"ref"))==null?void 0:t.get,n=o&&"isReactWarning"in o&&o.isReactWarning;return n?e.ref:(o=(r=Object.getOwnPropertyDescriptor(e,"ref"))==null?void 0:r.get,n=o&&"isReactWarning"in o&&o.isReactWarning,n?e.props.ref:e.props.ref||e.ref)}function em(e){var o,n,t="";if(typeof e=="string"||typeof e=="number")t+=e;else if(typeof e=="object")if(Array.isArray(e)){var r=e.length;for(o=0;o<r;o++)e[o]&&(n=em(e[o]))&&(t&&(t+=" "),t+=n)}else for(n in e)e[n]&&(t&&(t+=" "),t+=n);return t}function om(){for(var e,o,n=0,t="",r=arguments.length;n<r;n++)(e=arguments[n])&&(o=em(e))&&(t&&(t+=" "),t+=o);return t}const Zl=e=>typeof e=="boolean"?`${e}`:e===0?"0":e,Xl=om,zh=(e,o)=>n=>{var t;if((o==null?void 0:o.variants)==null)return Xl(e,n==null?void 0:n.class,n==null?void 0:n.className);const{variants:r,defaultVariants:a}=o,i=Object.keys(r).map(u=>{const d=n==null?void 0:n[u],p=a==null?void 0:a[u];if(d===null)return null;const v=Zl(d)||Zl(p);return r[u][v]}),c=n&&Object.entries(n).reduce((u,d)=>{let[p,v]=d;return v===void 0||(u[p]=v),u},{}),s=o==null||(t=o.compoundVariants)===null||t===void 0?void 0:t.reduce((u,d)=>{let{class:p,className:v,...y}=d;return Object.entries(y).every(z=>{let[b,N]=z;return Array.isArray(N)?N.includes({...a,...c}[b]):{...a,...c}[b]===N})?[...u,p,v]:u},[]);return Xl(e,i,s,n==null?void 0:n.class,n==null?void 0:n.className)},mu="-",jh=e=>{const o=Nh(e),{conflictingClassGroups:n,conflictingClassGroupModifiers:t}=e;return{getClassGroupId:i=>{const c=i.split(mu);return c[0]===""&&c.length!==1&&c.shift(),nm(c,o)||gh(i)},getConflictingClassGroupIds:(i,c)=>{const s=n[i]||[];return c&&t[i]?[...s,...t[i]]:s}}},nm=(e,o)=>{var i;if(e.length===0)return o.classGroupId;const n=e[0],t=o.nextPart.get(n),r=t?nm(e.slice(1),t):void 0;if(r)return r;if(o.validators.length===0)return;const a=e.join(mu);return(i=o.validators.find(({validator:c})=>c(a)))==null?void 0:i.classGroupId},Gl=/^\[(.+)\]$/,gh=e=>{if(Gl.test(e)){const o=Gl.exec(e)[1],n=o==null?void 0:o.substring(0,o.indexOf(":"));if(n)return"arbitrary.."+n}},Nh=e=>{const{theme:o,prefix:n}=e,t={nextPart:new Map,validators:[]};return Sh(Object.entries(e.classGroups),n).forEach(([a,i])=>{us(i,t,a,o)}),t},us=(e,o,n,t)=>{e.forEach(r=>{if(typeof r=="string"){const a=r===""?o:Jl(o,r);a.classGroupId=n;return}if(typeof r=="function"){if(Th(r)){us(r(t),o,n,t);return}o.validators.push({validator:r,classGroupId:n});return}Object.entries(r).forEach(([a,i])=>{us(i,Jl(o,a),n,t)})})},Jl=(e,o)=>{let n=e;return o.split(mu).forEach(t=>{n.nextPart.has(t)||n.nextPart.set(t,{nextPart:new Map,validators:[]}),n=n.nextPart.get(t)}),n},Th=e=>e.isThemeGetter,Sh=(e,o)=>o?e.map(([n,t])=>{const r=t.map(a=>typeof a=="string"?o+a:typeof a=="object"?Object.fromEntries(Object.entries(a).map(([i,c])=>[o+i,c])):a);return[n,r]}):e,Ph=e=>{if(e<1)return{get:()=>{},set:()=>{}};let o=0,n=new Map,t=new Map;const r=(a,i)=>{n.set(a,i),o++,o>e&&(o=0,t=n,n=new Map)};return{get(a){let i=n.get(a);if(i!==void 0)return i;if((i=t.get(a))!==void 0)return r(a,i),i},set(a,i){n.has(a)?n.set(a,i):r(a,i)}}},tm="!",xh=e=>{const{separator:o,experimentalParseClassName:n}=e,t=o.length===1,r=o[0],a=o.length,i=c=>{const s=[];let u=0,d=0,p;for(let N=0;N<c.length;N++){let k=c[N];if(u===0){if(k===r&&(t||c.slice(N,N+a)===o)){s.push(c.slice(d,N)),d=N+a;continue}if(k==="/"){p=N;continue}}k==="["?u++:k==="]"&&u--}const v=s.length===0?c:c.substring(d),y=v.startsWith(tm),z=y?v.substring(1):v,b=p&&p>d?p-d:void 0;return{modifiers:s,hasImportantModifier:y,baseClassName:z,maybePostfixModifierPosition:b}};return n?c=>n({className:c,parseClassName:i}):i},wh=e=>{if(e.length<=1)return e;const o=[];let n=[];return e.forEach(t=>{t[0]==="["?(o.push(...n.sort(),t),n=[]):n.push(t)}),o.push(...n.sort()),o},Ch=e=>({cache:Ph(e.cacheSize),parseClassName:xh(e),...jh(e)}),Eh=/\s+/,Mh=(e,o)=>{const{parseClassName:n,getClassGroupId:t,getConflictingClassGroupIds:r}=o,a=[],i=e.trim().split(Eh);let c="";for(let s=i.length-1;s>=0;s-=1){const u=i[s],{modifiers:d,hasImportantModifier:p,baseClassName:v,maybePostfixModifierPosition:y}=n(u);let z=!!y,b=t(z?v.substring(0,y):v);if(!b){if(!z){c=u+(c.length>0?" "+c:c);continue}if(b=t(v),!b){c=u+(c.length>0?" "+c:c);continue}z=!1}const N=wh(d).join(":"),k=p?N+tm:N,m=k+b;if(a.includes(m))continue;a.push(m);const f=r(b,z);for(let T=0;T<f.length;++T){const x=f[T];a.push(k+x)}c=u+(c.length>0?" "+c:c)}return c};function Oh(){let e=0,o,n,t="";for(;e<arguments.length;)(o=arguments[e++])&&(n=rm(o))&&(t&&(t+=" "),t+=n);return t}const rm=e=>{if(typeof e=="string")return e;let o,n="";for(let t=0;t<e.length;t++)e[t]&&(o=rm(e[t]))&&(n&&(n+=" "),n+=o);return n};function Rh(e,...o){let n,t,r,a=i;function i(s){const u=o.reduce((d,p)=>p(d),e());return n=Ch(u),t=n.cache.get,r=n.cache.set,a=c,c(s)}function c(s){const u=t(s);if(u)return u;const d=Mh(s,n);return r(s,d),d}return function(){return a(Oh.apply(null,arguments))}}const te=e=>{const o=n=>n[e]||[];return o.isThemeGetter=!0,o},am=/^\[(?:([a-z-]+):)?(.+)\]$/i,Ah=/^\d+\/\d+$/,Ih=new Set(["px","full","screen"]),Vh=/^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,Dh=/\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,Lh=/^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,Uh=/^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,_h=/^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,Mo=e=>yt(e)||Ih.has(e)||Ah.test(e),Qo=e=>Ot(e,"length",Xh),yt=e=>!!e&&!Number.isNaN(Number(e)),nc=e=>Ot(e,"number",yt),Jt=e=>!!e&&Number.isInteger(Number(e)),Fh=e=>e.endsWith("%")&&yt(e.slice(0,-1)),W=e=>am.test(e),Yo=e=>Vh.test(e),Bh=new Set(["length","size","percentage"]),Kh=e=>Ot(e,Bh,im),$h=e=>Ot(e,"position",im),Hh=new Set(["image","url"]),Wh=e=>Ot(e,Hh,Jh),Zh=e=>Ot(e,"",Gh),Qt=()=>!0,Ot=(e,o,n)=>{const t=am.exec(e);return t?t[1]?typeof o=="string"?t[1]===o:o.has(t[1]):n(t[2]):!1},Xh=e=>Dh.test(e)&&!Lh.test(e),im=()=>!1,Gh=e=>Uh.test(e),Jh=e=>_h.test(e),Qh=()=>{const e=te("colors"),o=te("spacing"),n=te("blur"),t=te("brightness"),r=te("borderColor"),a=te("borderRadius"),i=te("borderSpacing"),c=te("borderWidth"),s=te("contrast"),u=te("grayscale"),d=te("hueRotate"),p=te("invert"),v=te("gap"),y=te("gradientColorStops"),z=te("gradientColorStopPositions"),b=te("inset"),N=te("margin"),k=te("opacity"),m=te("padding"),f=te("saturate"),T=te("scale"),x=te("sepia"),O=te("skew"),h=te("space"),C=te("translate"),V=()=>["auto","contain","none"],R=()=>["auto","hidden","clip","visible","scroll"],Z=()=>["auto",W,o],F=()=>[W,o],oe=()=>["",Mo,Qo],ve=()=>["auto",yt,W],Ue=()=>["bottom","center","left","left-bottom","left-top","right","right-bottom","right-top","top"],He=()=>["solid","dashed","dotted","double","none"],po=()=>["normal","multiply","screen","overlay","darken","lighten","color-dodge","color-burn","hard-light","soft-light","difference","exclusion","hue","saturation","color","luminosity"],E=()=>["start","end","center","between","around","evenly","stretch"],L=()=>["","0",W],_=()=>["auto","avoid","all","avoid-page","page","left","right","column"],X=()=>[yt,W];return{cacheSize:500,separator:":",theme:{colors:[Qt],spacing:[Mo,Qo],blur:["none","",Yo,W],brightness:X(),borderColor:[e],borderRadius:["none","","full",Yo,W],borderSpacing:F(),borderWidth:oe(),contrast:X(),grayscale:L(),hueRotate:X(),invert:L(),gap:F(),gradientColorStops:[e],gradientColorStopPositions:[Fh,Qo],inset:Z(),margin:Z(),opacity:X(),padding:F(),saturate:X(),scale:X(),sepia:L(),skew:X(),space:F(),translate:F()},classGroups:{aspect:[{aspect:["auto","square","video",W]}],container:["container"],columns:[{columns:[Yo]}],"break-after":[{"break-after":_()}],"break-before":[{"break-before":_()}],"break-inside":[{"break-inside":["auto","avoid","avoid-page","avoid-column"]}],"box-decoration":[{"box-decoration":["slice","clone"]}],box:[{box:["border","content"]}],display:["block","inline-block","inline","flex","inline-flex","table","inline-table","table-caption","table-cell","table-column","table-column-group","table-footer-group","table-header-group","table-row-group","table-row","flow-root","grid","inline-grid","contents","list-item","hidden"],float:[{float:["right","left","none","start","end"]}],clear:[{clear:["left","right","both","none","start","end"]}],isolation:["isolate","isolation-auto"],"object-fit":[{object:["contain","cover","fill","none","scale-down"]}],"object-position":[{object:[...Ue(),W]}],overflow:[{overflow:R()}],"overflow-x":[{"overflow-x":R()}],"overflow-y":[{"overflow-y":R()}],overscroll:[{overscroll:V()}],"overscroll-x":[{"overscroll-x":V()}],"overscroll-y":[{"overscroll-y":V()}],position:["static","fixed","absolute","relative","sticky"],inset:[{inset:[b]}],"inset-x":[{"inset-x":[b]}],"inset-y":[{"inset-y":[b]}],start:[{start:[b]}],end:[{end:[b]}],top:[{top:[b]}],right:[{right:[b]}],bottom:[{bottom:[b]}],left:[{left:[b]}],visibility:["visible","invisible","collapse"],z:[{z:["auto",Jt,W]}],basis:[{basis:Z()}],"flex-direction":[{flex:["row","row-reverse","col","col-reverse"]}],"flex-wrap":[{flex:["wrap","wrap-reverse","nowrap"]}],flex:[{flex:["1","auto","initial","none",W]}],grow:[{grow:L()}],shrink:[{shrink:L()}],order:[{order:["first","last","none",Jt,W]}],"grid-cols":[{"grid-cols":[Qt]}],"col-start-end":[{col:["auto",{span:["full",Jt,W]},W]}],"col-start":[{"col-start":ve()}],"col-end":[{"col-end":ve()}],"grid-rows":[{"grid-rows":[Qt]}],"row-start-end":[{row:["auto",{span:[Jt,W]},W]}],"row-start":[{"row-start":ve()}],"row-end":[{"row-end":ve()}],"grid-flow":[{"grid-flow":["row","col","dense","row-dense","col-dense"]}],"auto-cols":[{"auto-cols":["auto","min","max","fr",W]}],"auto-rows":[{"auto-rows":["auto","min","max","fr",W]}],gap:[{gap:[v]}],"gap-x":[{"gap-x":[v]}],"gap-y":[{"gap-y":[v]}],"justify-content":[{justify:["normal",...E()]}],"justify-items":[{"justify-items":["start","end","center","stretch"]}],"justify-self":[{"justify-self":["auto","start","end","center","stretch"]}],"align-content":[{content:["normal",...E(),"baseline"]}],"align-items":[{items:["start","end","center","baseline","stretch"]}],"align-self":[{self:["auto","start","end","center","stretch","baseline"]}],"place-content":[{"place-content":[...E(),"baseline"]}],"place-items":[{"place-items":["start","end","center","baseline","stretch"]}],"place-self":[{"place-self":["auto","start","end","center","stretch"]}],p:[{p:[m]}],px:[{px:[m]}],py:[{py:[m]}],ps:[{ps:[m]}],pe:[{pe:[m]}],pt:[{pt:[m]}],pr:[{pr:[m]}],pb:[{pb:[m]}],pl:[{pl:[m]}],m:[{m:[N]}],mx:[{mx:[N]}],my:[{my:[N]}],ms:[{ms:[N]}],me:[{me:[N]}],mt:[{mt:[N]}],mr:[{mr:[N]}],mb:[{mb:[N]}],ml:[{ml:[N]}],"space-x":[{"space-x":[h]}],"space-x-reverse":["space-x-reverse"],"space-y":[{"space-y":[h]}],"space-y-reverse":["space-y-reverse"],w:[{w:["auto","min","max","fit","svw","lvw","dvw",W,o]}],"min-w":[{"min-w":[W,o,"min","max","fit"]}],"max-w":[{"max-w":[W,o,"none","full","min","max","fit","prose",{screen:[Yo]},Yo]}],h:[{h:[W,o,"auto","min","max","fit","svh","lvh","dvh"]}],"min-h":[{"min-h":[W,o,"min","max","fit","svh","lvh","dvh"]}],"max-h":[{"max-h":[W,o,"min","max","fit","svh","lvh","dvh"]}],size:[{size:[W,o,"auto","min","max","fit"]}],"font-size":[{text:["base",Yo,Qo]}],"font-smoothing":["antialiased","subpixel-antialiased"],"font-style":["italic","not-italic"],"font-weight":[{font:["thin","extralight","light","normal","medium","semibold","bold","extrabold","black",nc]}],"font-family":[{font:[Qt]}],"fvn-normal":["normal-nums"],"fvn-ordinal":["ordinal"],"fvn-slashed-zero":["slashed-zero"],"fvn-figure":["lining-nums","oldstyle-nums"],"fvn-spacing":["proportional-nums","tabular-nums"],"fvn-fraction":["diagonal-fractions","stacked-fractions"],tracking:[{tracking:["tighter","tight","normal","wide","wider","widest",W]}],"line-clamp":[{"line-clamp":["none",yt,nc]}],leading:[{leading:["none","tight","snug","normal","relaxed","loose",Mo,W]}],"list-image":[{"list-image":["none",W]}],"list-style-type":[{list:["none","disc","decimal",W]}],"list-style-position":[{list:["inside","outside"]}],"placeholder-color":[{placeholder:[e]}],"placeholder-opacity":[{"placeholder-opacity":[k]}],"text-alignment":[{text:["left","center","right","justify","start","end"]}],"text-color":[{text:[e]}],"text-opacity":[{"text-opacity":[k]}],"text-decoration":["underline","overline","line-through","no-underline"],"text-decoration-style":[{decoration:[...He(),"wavy"]}],"text-decoration-thickness":[{decoration:["auto","from-font",Mo,Qo]}],"underline-offset":[{"underline-offset":["auto",Mo,W]}],"text-decoration-color":[{decoration:[e]}],"text-transform":["uppercase","lowercase","capitalize","normal-case"],"text-overflow":["truncate","text-ellipsis","text-clip"],"text-wrap":[{text:["wrap","nowrap","balance","pretty"]}],indent:[{indent:F()}],"vertical-align":[{align:["baseline","top","middle","bottom","text-top","text-bottom","sub","super",W]}],whitespace:[{whitespace:["normal","nowrap","pre","pre-line","pre-wrap","break-spaces"]}],break:[{break:["normal","words","all","keep"]}],hyphens:[{hyphens:["none","manual","auto"]}],content:[{content:["none",W]}],"bg-attachment":[{bg:["fixed","local","scroll"]}],"bg-clip":[{"bg-clip":["border","padding","content","text"]}],"bg-opacity":[{"bg-opacity":[k]}],"bg-origin":[{"bg-origin":["border","padding","content"]}],"bg-position":[{bg:[...Ue(),$h]}],"bg-repeat":[{bg:["no-repeat",{repeat:["","x","y","round","space"]}]}],"bg-size":[{bg:["auto","cover","contain",Kh]}],"bg-image":[{bg:["none",{"gradient-to":["t","tr","r","br","b","bl","l","tl"]},Wh]}],"bg-color":[{bg:[e]}],"gradient-from-pos":[{from:[z]}],"gradient-via-pos":[{via:[z]}],"gradient-to-pos":[{to:[z]}],"gradient-from":[{from:[y]}],"gradient-via":[{via:[y]}],"gradient-to":[{to:[y]}],rounded:[{rounded:[a]}],"rounded-s":[{"rounded-s":[a]}],"rounded-e":[{"rounded-e":[a]}],"rounded-t":[{"rounded-t":[a]}],"rounded-r":[{"rounded-r":[a]}],"rounded-b":[{"rounded-b":[a]}],"rounded-l":[{"rounded-l":[a]}],"rounded-ss":[{"rounded-ss":[a]}],"rounded-se":[{"rounded-se":[a]}],"rounded-ee":[{"rounded-ee":[a]}],"rounded-es":[{"rounded-es":[a]}],"rounded-tl":[{"rounded-tl":[a]}],"rounded-tr":[{"rounded-tr":[a]}],"rounded-br":[{"rounded-br":[a]}],"rounded-bl":[{"rounded-bl":[a]}],"border-w":[{border:[c]}],"border-w-x":[{"border-x":[c]}],"border-w-y":[{"border-y":[c]}],"border-w-s":[{"border-s":[c]}],"border-w-e":[{"border-e":[c]}],"border-w-t":[{"border-t":[c]}],"border-w-r":[{"border-r":[c]}],"border-w-b":[{"border-b":[c]}],"border-w-l":[{"border-l":[c]}],"border-opacity":[{"border-opacity":[k]}],"border-style":[{border:[...He(),"hidden"]}],"divide-x":[{"divide-x":[c]}],"divide-x-reverse":["divide-x-reverse"],"divide-y":[{"divide-y":[c]}],"divide-y-reverse":["divide-y-reverse"],"divide-opacity":[{"divide-opacity":[k]}],"divide-style":[{divide:He()}],"border-color":[{border:[r]}],"border-color-x":[{"border-x":[r]}],"border-color-y":[{"border-y":[r]}],"border-color-s":[{"border-s":[r]}],"border-color-e":[{"border-e":[r]}],"border-color-t":[{"border-t":[r]}],"border-color-r":[{"border-r":[r]}],"border-color-b":[{"border-b":[r]}],"border-color-l":[{"border-l":[r]}],"divide-color":[{divide:[r]}],"outline-style":[{outline:["",...He()]}],"outline-offset":[{"outline-offset":[Mo,W]}],"outline-w":[{outline:[Mo,Qo]}],"outline-color":[{outline:[e]}],"ring-w":[{ring:oe()}],"ring-w-inset":["ring-inset"],"ring-color":[{ring:[e]}],"ring-opacity":[{"ring-opacity":[k]}],"ring-offset-w":[{"ring-offset":[Mo,Qo]}],"ring-offset-color":[{"ring-offset":[e]}],shadow:[{shadow:["","inner","none",Yo,Zh]}],"shadow-color":[{shadow:[Qt]}],opacity:[{opacity:[k]}],"mix-blend":[{"mix-blend":[...po(),"plus-lighter","plus-darker"]}],"bg-blend":[{"bg-blend":po()}],filter:[{filter:["","none"]}],blur:[{blur:[n]}],brightness:[{brightness:[t]}],contrast:[{contrast:[s]}],"drop-shadow":[{"drop-shadow":["","none",Yo,W]}],grayscale:[{grayscale:[u]}],"hue-rotate":[{"hue-rotate":[d]}],invert:[{invert:[p]}],saturate:[{saturate:[f]}],sepia:[{sepia:[x]}],"backdrop-filter":[{"backdrop-filter":["","none"]}],"backdrop-blur":[{"backdrop-blur":[n]}],"backdrop-brightness":[{"backdrop-brightness":[t]}],"backdrop-contrast":[{"backdrop-contrast":[s]}],"backdrop-grayscale":[{"backdrop-grayscale":[u]}],"backdrop-hue-rotate":[{"backdrop-hue-rotate":[d]}],"backdrop-invert":[{"backdrop-invert":[p]}],"backdrop-opacity":[{"backdrop-opacity":[k]}],"backdrop-saturate":[{"backdrop-saturate":[f]}],"backdrop-sepia":[{"backdrop-sepia":[x]}],"border-collapse":[{border:["collapse","separate"]}],"border-spacing":[{"border-spacing":[i]}],"border-spacing-x":[{"border-spacing-x":[i]}],"border-spacing-y":[{"border-spacing-y":[i]}],"table-layout":[{table:["auto","fixed"]}],caption:[{caption:["top","bottom"]}],transition:[{transition:["none","all","","colors","opacity","shadow","transform",W]}],duration:[{duration:X()}],ease:[{ease:["linear","in","out","in-out",W]}],delay:[{delay:X()}],animate:[{animate:["none","spin","ping","pulse","bounce",W]}],transform:[{transform:["","gpu","none"]}],scale:[{scale:[T]}],"scale-x":[{"scale-x":[T]}],"scale-y":[{"scale-y":[T]}],rotate:[{rotate:[Jt,W]}],"translate-x":[{"translate-x":[C]}],"translate-y":[{"translate-y":[C]}],"skew-x":[{"skew-x":[O]}],"skew-y":[{"skew-y":[O]}],"transform-origin":[{origin:["center","top","top-right","right","bottom-right","bottom","bottom-left","left","top-left",W]}],accent:[{accent:["auto",e]}],appearance:[{appearance:["none","auto"]}],cursor:[{cursor:["auto","default","pointer","wait","text","move","help","not-allowed","none","context-menu","progress","cell","crosshair","vertical-text","alias","copy","no-drop","grab","grabbing","all-scroll","col-resize","row-resize","n-resize","e-resize","s-resize","w-resize","ne-resize","nw-resize","se-resize","sw-resize","ew-resize","ns-resize","nesw-resize","nwse-resize","zoom-in","zoom-out",W]}],"caret-color":[{caret:[e]}],"pointer-events":[{"pointer-events":["none","auto"]}],resize:[{resize:["none","y","x",""]}],"scroll-behavior":[{scroll:["auto","smooth"]}],"scroll-m":[{"scroll-m":F()}],"scroll-mx":[{"scroll-mx":F()}],"scroll-my":[{"scroll-my":F()}],"scroll-ms":[{"scroll-ms":F()}],"scroll-me":[{"scroll-me":F()}],"scroll-mt":[{"scroll-mt":F()}],"scroll-mr":[{"scroll-mr":F()}],"scroll-mb":[{"scroll-mb":F()}],"scroll-ml":[{"scroll-ml":F()}],"scroll-p":[{"scroll-p":F()}],"scroll-px":[{"scroll-px":F()}],"scroll-py":[{"scroll-py":F()}],"scroll-ps":[{"scroll-ps":F()}],"scroll-pe":[{"scroll-pe":F()}],"scroll-pt":[{"scroll-pt":F()}],"scroll-pr":[{"scroll-pr":F()}],"scroll-pb":[{"scroll-pb":F()}],"scroll-pl":[{"scroll-pl":F()}],"snap-align":[{snap:["start","end","center","align-none"]}],"snap-stop":[{snap:["normal","always"]}],"snap-type":[{snap:["none","x","y","both"]}],"snap-strictness":[{snap:["mandatory","proximity"]}],touch:[{touch:["auto","none","manipulation"]}],"touch-x":[{"touch-pan":["x","left","right"]}],"touch-y":[{"touch-pan":["y","up","down"]}],"touch-pz":["touch-pinch-zoom"],select:[{select:["none","text","all","auto"]}],"will-change":[{"will-change":["auto","scroll","contents","transform",W]}],fill:[{fill:[e,"none"]}],"stroke-w":[{stroke:[Mo,Qo,nc]}],stroke:[{stroke:[e,"none"]}],sr:["sr-only","not-sr-only"],"forced-color-adjust":[{"forced-color-adjust":["auto","none"]}]},conflictingClassGroups:{overflow:["overflow-x","overflow-y"],overscroll:["overscroll-x","overscroll-y"],inset:["inset-x","inset-y","start","end","top","right","bottom","left"],"inset-x":["right","left"],"inset-y":["top","bottom"],flex:["basis","grow","shrink"],gap:["gap-x","gap-y"],p:["px","py","ps","pe","pt","pr","pb","pl"],px:["pr","pl"],py:["pt","pb"],m:["mx","my","ms","me","mt","mr","mb","ml"],mx:["mr","ml"],my:["mt","mb"],size:["w","h"],"font-size":["leading"],"fvn-normal":["fvn-ordinal","fvn-slashed-zero","fvn-figure","fvn-spacing","fvn-fraction"],"fvn-ordinal":["fvn-normal"],"fvn-slashed-zero":["fvn-normal"],"fvn-figure":["fvn-normal"],"fvn-spacing":["fvn-normal"],"fvn-fraction":["fvn-normal"],"line-clamp":["display","overflow"],rounded:["rounded-s","rounded-e","rounded-t","rounded-r","rounded-b","rounded-l","rounded-ss","rounded-se","rounded-ee","rounded-es","rounded-tl","rounded-tr","rounded-br","rounded-bl"],"rounded-s":["rounded-ss","rounded-es"],"rounded-e":["rounded-se","rounded-ee"],"rounded-t":["rounded-tl","rounded-tr"],"rounded-r":["rounded-tr","rounded-br"],"rounded-b":["rounded-br","rounded-bl"],"rounded-l":["rounded-tl","rounded-bl"],"border-spacing":["border-spacing-x","border-spacing-y"],"border-w":["border-w-s","border-w-e","border-w-t","border-w-r","border-w-b","border-w-l"],"border-w-x":["border-w-r","border-w-l"],"border-w-y":["border-w-t","border-w-b"],"border-color":["border-color-s","border-color-e","border-color-t","border-color-r","border-color-b","border-color-l"],"border-color-x":["border-color-r","border-color-l"],"border-color-y":["border-color-t","border-color-b"],"scroll-m":["scroll-mx","scroll-my","scroll-ms","scroll-me","scroll-mt","scroll-mr","scroll-mb","scroll-ml"],"scroll-mx":["scroll-mr","scroll-ml"],"scroll-my":["scroll-mt","scroll-mb"],"scroll-p":["scroll-px","scroll-py","scroll-ps","scroll-pe","scroll-pt","scroll-pr","scroll-pb","scroll-pl"],"scroll-px":["scroll-pr","scroll-pl"],"scroll-py":["scroll-pt","scroll-pb"],touch:["touch-x","touch-y","touch-pz"],"touch-x":["touch"],"touch-y":["touch"],"touch-pz":["touch"]},conflictingClassGroupModifiers:{"font-size":["leading"]}}},Yh=Rh(Qh);function Ko(...e){return Yh(om(e))}function qh(e){const o=[...e];for(let n=o.length-1;n>0;n--){const t=Math.floor(Math.random()*(n+1)),r=o[n];o[n]=o[t],o[t]=r}return o}function ey(e){return`${e}_${new Date().getTime()}`}const oy=zh("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",{variants:{variant:{default:"bg-primary text-primary-foreground hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground hover:bg-destructive/90",outline:"border border-input bg-background hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground hover:bg-secondary/80",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-10 px-4 py-2",sm:"h-9 rounded-md px-3",lg:"h-11 rounded-md px-8",icon:"h-10 w-10"}},defaultVariants:{variant:"default",size:"default"}}),Vo=l.forwardRef(({className:e,variant:o,size:n,asChild:t=!1,...r},a)=>{const i=t?Kn:"button";return g.jsx(i,{className:Ko(oy({variant:o,size:n,className:e})),ref:a,...r})});Vo.displayName="Button";/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ny=e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase(),cm=(...e)=>e.filter((o,n,t)=>!!o&&t.indexOf(o)===n).join(" ");/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var ty={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const ry=l.forwardRef(({color:e="currentColor",size:o=24,strokeWidth:n=2,absoluteStrokeWidth:t,className:r="",children:a,iconNode:i,...c},s)=>l.createElement("svg",{ref:s,...ty,width:o,height:o,stroke:e,strokeWidth:t?Number(n)*24/Number(o):n,className:cm("lucide",r),...c},[...i.map(([u,d])=>l.createElement(u,d)),...Array.isArray(a)?a:[a]]));/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zi=(e,o)=>{const n=l.forwardRef(({className:t,...r},a)=>l.createElement(ry,{ref:a,iconNode:o,className:cm(`lucide-${ny(e)}`,t),...r}));return n.displayName=`${e}`,n};/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const sm=zi("Check",[["path",{d:"M20 6 9 17l-5-5",key:"1gmf2c"}]]);/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Ql=zi("Github",[["path",{d:"M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4",key:"tonef"}],["path",{d:"M9 18c-4.51 2-5-2-7-2",key:"9comsn"}]]);/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const zt=zi("Link",[["path",{d:"M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",key:"1cjeqo"}],["path",{d:"M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",key:"19qd67"}]]);/**
 * @license lucide-react v0.379.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const um=zi("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),ay=(e,o)=>g.jsx("svg",{xmlns:"http://www.w3.org/2000/svg",width:800,height:800,fill:"none",viewBox:"0 0 24 24",ref:o,...e,children:g.jsx("path",{stroke:"currentColor",strokeLinejoin:"round",d:"M18.894 4.344A17.409 17.409 0 0 0 14.532 3c-.192.33-.406.779-.555 1.13a16.677 16.677 0 0 0-4.833 0c-.15-.351-.373-.8-.555-1.13a17.162 17.162 0 0 0-4.363 1.344C1.463 8.419.716 12.397 1.09 16.323A17.782 17.782 0 0 0 6.435 19a13 13 0 0 0 1.14-1.845 11.182 11.182 0 0 1-1.802-.864c.15-.107.299-.224.438-.342 3.477 1.59 7.243 1.59 10.678 0 .15.118.288.235.437.342a11.18 11.18 0 0 1-1.802.864A13 13 0 0 0 16.665 19a17.684 17.684 0 0 0 5.345-2.677c.459-4.544-.726-8.491-3.116-11.979ZM8.056 13.901c-1.045 0-1.899-.949-1.899-2.112 0-1.162.832-2.112 1.899-2.112 1.056 0 1.92.95 1.899 2.112 0 1.163-.843 2.112-1.9 2.112Zm7.009 0c-1.045 0-1.9-.949-1.9-2.112 0-1.162.833-2.112 1.9-2.112 1.056 0 1.92.95 1.899 2.112 0 1.163-.832 2.112-1.899 2.112Z"})}),lm=l.forwardRef(ay);lm.displayName="Discord";/**
 * @remix-run/router v1.16.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function ce(){return ce=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},ce.apply(this,arguments)}var be;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(be||(be={}));const Yl="popstate";function iy(e){e===void 0&&(e={});function o(r,a){let{pathname:i="/",search:c="",hash:s=""}=Ho(r.location.hash.substr(1));return!i.startsWith("/")&&!i.startsWith(".")&&(i="/"+i),Rr("",{pathname:i,search:c,hash:s},a.state&&a.state.usr||null,a.state&&a.state.key||"default")}function n(r,a){let i=r.document.querySelector("base"),c="";if(i&&i.getAttribute("href")){let s=r.location.href,u=s.indexOf("#");c=u===-1?s:s.slice(0,u)}return c+"#"+(typeof a=="string"?a:Un(a))}function t(r,a){Ln(r.pathname.charAt(0)==="/","relative pathnames are not supported in hash history.push("+JSON.stringify(a)+")")}return sy(o,n,t,e)}function G(e,o){if(e===!1||e===null||typeof e>"u")throw new Error(o)}function Ln(e,o){if(!e){typeof console<"u"&&console.warn(o);try{throw new Error(o)}catch{}}}function cy(){return Math.random().toString(36).substr(2,8)}function ql(e,o){return{usr:e.state,key:e.key,idx:o}}function Rr(e,o,n,t){return n===void 0&&(n=null),ce({pathname:typeof e=="string"?e:e.pathname,search:"",hash:""},typeof o=="string"?Ho(o):o,{state:n,key:o&&o.key||t||cy()})}function Un(e){let{pathname:o="/",search:n="",hash:t=""}=e;return n&&n!=="?"&&(o+=n.charAt(0)==="?"?n:"?"+n),t&&t!=="#"&&(o+=t.charAt(0)==="#"?t:"#"+t),o}function Ho(e){let o={};if(e){let n=e.indexOf("#");n>=0&&(o.hash=e.substr(n),e=e.substr(0,n));let t=e.indexOf("?");t>=0&&(o.search=e.substr(t),e=e.substr(0,t)),e&&(o.pathname=e)}return o}function sy(e,o,n,t){t===void 0&&(t={});let{window:r=document.defaultView,v5Compat:a=!1}=t,i=r.history,c=be.Pop,s=null,u=d();u==null&&(u=0,i.replaceState(ce({},i.state,{idx:u}),""));function d(){return(i.state||{idx:null}).idx}function p(){c=be.Pop;let N=d(),k=N==null?null:N-u;u=N,s&&s({action:c,location:b.location,delta:k})}function v(N,k){c=be.Push;let m=Rr(b.location,N,k);n&&n(m,N),u=d()+1;let f=ql(m,u),T=b.createHref(m);try{i.pushState(f,"",T)}catch(x){if(x instanceof DOMException&&x.name==="DataCloneError")throw x;r.location.assign(T)}a&&s&&s({action:c,location:b.location,delta:1})}function y(N,k){c=be.Replace;let m=Rr(b.location,N,k);n&&n(m,N),u=d();let f=ql(m,u),T=b.createHref(m);i.replaceState(f,"",T),a&&s&&s({action:c,location:b.location,delta:0})}function z(N){let k=r.location.origin!=="null"?r.location.origin:r.location.href,m=typeof N=="string"?N:Un(N);return m=m.replace(/ $/,"%20"),G(k,"No window.location.(origin|href) available to create URL for href: "+m),new URL(m,k)}let b={get action(){return c},get location(){return e(r,i)},listen(N){if(s)throw new Error("A history only accepts one active listener");return r.addEventListener(Yl,p),s=N,()=>{r.removeEventListener(Yl,p),s=null}},createHref(N){return o(r,N)},createURL:z,encodeLocation(N){let k=z(N);return{pathname:k.pathname,search:k.search,hash:k.hash}},push:v,replace:y,go(N){return i.go(N)}};return b}var se;(function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"})(se||(se={}));const uy=new Set(["lazy","caseSensitive","path","id","index","children"]);function ly(e){return e.index===!0}function ls(e,o,n,t){return n===void 0&&(n=[]),t===void 0&&(t={}),e.map((r,a)=>{let i=[...n,a],c=typeof r.id=="string"?r.id:i.join("-");if(G(r.index!==!0||!r.children,"Cannot specify children on an index route"),G(!t[c],'Found a route id collision on id "'+c+`".  Route id's must be globally unique within Data Router usages`),ly(r)){let s=ce({},r,o(r),{id:c});return t[c]=s,s}else{let s=ce({},r,o(r),{id:c,children:void 0});return t[c]=s,r.children&&(s.children=ls(r.children,o,i,t)),s}})}function dt(e,o,n){n===void 0&&(n="/");let t=typeof o=="string"?Ho(o):o,r=Rt(t.pathname||"/",n);if(r==null)return null;let a=dm(e);py(a);let i=null;for(let c=0;i==null&&c<a.length;++c){let s=Ty(r);i=jy(a[c],s)}return i}function dy(e,o){let{route:n,pathname:t,params:r}=e;return{id:n.id,pathname:t,params:r,data:o[n.id],handle:n.handle}}function dm(e,o,n,t){o===void 0&&(o=[]),n===void 0&&(n=[]),t===void 0&&(t="");let r=(a,i,c)=>{let s={relativePath:c===void 0?a.path||"":c,caseSensitive:a.caseSensitive===!0,childrenIndex:i,route:a};s.relativePath.startsWith("/")&&(G(s.relativePath.startsWith(t),'Absolute route path "'+s.relativePath+'" nested under path '+('"'+t+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),s.relativePath=s.relativePath.slice(t.length));let u=Lo([t,s.relativePath]),d=n.concat(s);a.children&&a.children.length>0&&(G(a.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+u+'".')),dm(a.children,o,d,u)),!(a.path==null&&!a.index)&&o.push({path:u,score:yy(u,a.index),routesMeta:d})};return e.forEach((a,i)=>{var c;if(a.path===""||!((c=a.path)!=null&&c.includes("?")))r(a,i);else for(let s of pm(a.path))r(a,i,s)}),o}function pm(e){let o=e.split("/");if(o.length===0)return[];let[n,...t]=o,r=n.endsWith("?"),a=n.replace(/\?$/,"");if(t.length===0)return r?[a,""]:[a];let i=pm(t.join("/")),c=[];return c.push(...i.map(s=>s===""?a:[a,s].join("/"))),r&&c.push(...i),c.map(s=>e.startsWith("/")&&s===""?"/":s)}function py(e){e.sort((o,n)=>o.score!==n.score?n.score-o.score:zy(o.routesMeta.map(t=>t.childrenIndex),n.routesMeta.map(t=>t.childrenIndex)))}const vy=/^:[\w-]+$/,my=3,ky=2,by=1,fy=10,hy=-2,ed=e=>e==="*";function yy(e,o){let n=e.split("/"),t=n.length;return n.some(ed)&&(t+=hy),o&&(t+=ky),n.filter(r=>!ed(r)).reduce((r,a)=>r+(vy.test(a)?my:a===""?by:fy),t)}function zy(e,o){return e.length===o.length&&e.slice(0,-1).every((t,r)=>t===o[r])?e[e.length-1]-o[o.length-1]:0}function jy(e,o){let{routesMeta:n}=e,t={},r="/",a=[];for(let i=0;i<n.length;++i){let c=n[i],s=i===n.length-1,u=r==="/"?o:o.slice(r.length)||"/",d=gy({path:c.relativePath,caseSensitive:c.caseSensitive,end:s},u);if(!d)return null;Object.assign(t,d.params);let p=c.route;a.push({params:t,pathname:Lo([r,d.pathname]),pathnameBase:xy(Lo([r,d.pathnameBase])),route:p}),d.pathnameBase!=="/"&&(r=Lo([r,d.pathnameBase]))}return a}function gy(e,o){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,t]=Ny(e.path,e.caseSensitive,e.end),r=o.match(n);if(!r)return null;let a=r[0],i=a.replace(/(.)\/+$/,"$1"),c=r.slice(1);return{params:t.reduce((u,d,p)=>{let{paramName:v,isOptional:y}=d;if(v==="*"){let b=c[p]||"";i=a.slice(0,a.length-b.length).replace(/(.)\/+$/,"$1")}const z=c[p];return y&&!z?u[v]=void 0:u[v]=(z||"").replace(/%2F/g,"/"),u},{}),pathname:a,pathnameBase:i,pattern:e}}function Ny(e,o,n){o===void 0&&(o=!1),n===void 0&&(n=!0),Ln(e==="*"||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were '+('"'+e.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+e.replace(/\*$/,"/*")+'".'));let t=[],r="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,c,s)=>(t.push({paramName:c,isOptional:s!=null}),s?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(t.push({paramName:"*"}),r+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?r+="\\/*$":e!==""&&e!=="/"&&(r+="(?:(?=\\/|$))"),[new RegExp(r,o?void 0:"i"),t]}function Ty(e){try{return e.split("/").map(o=>decodeURIComponent(o).replace(/\//g,"%2F")).join("/")}catch(o){return Ln(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+o+").")),e}}function Rt(e,o){if(o==="/")return e;if(!e.toLowerCase().startsWith(o.toLowerCase()))return null;let n=o.endsWith("/")?o.length-1:o.length,t=e.charAt(n);return t&&t!=="/"?null:e.slice(n)||"/"}function Sy(e,o){o===void 0&&(o="/");let{pathname:n,search:t="",hash:r=""}=typeof e=="string"?Ho(e):e;return{pathname:n?n.startsWith("/")?n:Py(n,o):o,search:wy(t),hash:Cy(r)}}function Py(e,o){let n=o.replace(/\/+$/,"").split("/");return e.split("/").forEach(r=>{r===".."?n.length>1&&n.pop():r!=="."&&n.push(r)}),n.length>1?n.join("/"):"/"}function tc(e,o,n,t){return"Cannot include a '"+e+"' character in a manually specified "+("`to."+o+"` field ["+JSON.stringify(t)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function vm(e){return e.filter((o,n)=>n===0||o.route.path&&o.route.path.length>0)}function ku(e,o){let n=vm(e);return o?n.map((t,r)=>r===e.length-1?t.pathname:t.pathnameBase):n.map(t=>t.pathnameBase)}function bu(e,o,n,t){t===void 0&&(t=!1);let r;typeof e=="string"?r=Ho(e):(r=ce({},e),G(!r.pathname||!r.pathname.includes("?"),tc("?","pathname","search",r)),G(!r.pathname||!r.pathname.includes("#"),tc("#","pathname","hash",r)),G(!r.search||!r.search.includes("#"),tc("#","search","hash",r)));let a=e===""||r.pathname==="",i=a?"/":r.pathname,c;if(i==null)c=n;else{let p=o.length-1;if(!t&&i.startsWith("..")){let v=i.split("/");for(;v[0]==="..";)v.shift(),p-=1;r.pathname=v.join("/")}c=p>=0?o[p]:"/"}let s=Sy(r,c),u=i&&i!=="/"&&i.endsWith("/"),d=(a||i===".")&&n.endsWith("/");return!s.pathname.endsWith("/")&&(u||d)&&(s.pathname+="/"),s}const Lo=e=>e.join("/").replace(/\/\/+/g,"/"),xy=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),wy=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,Cy=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e,wo=function(o,n){n===void 0&&(n=302);let t=n;typeof t=="number"?t={status:t}:typeof t.status>"u"&&(t.status=302);let r=new Headers(t.headers);return r.set("Location",o),new Response(null,ce({},t,{headers:r}))};class fu{constructor(o,n,t,r){r===void 0&&(r=!1),this.status=o,this.statusText=n||"",this.internal=r,t instanceof Error?(this.data=t.toString(),this.error=t):this.data=t}}function hu(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}const mm=["post","put","patch","delete"],Ey=new Set(mm),My=["get",...mm],Oy=new Set(My),Ry=new Set([301,302,303,307,308]),Ay=new Set([307,308]),rc={state:"idle",location:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},Iy={state:"idle",data:void 0,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0},Yt={state:"unblocked",proceed:void 0,reset:void 0,location:void 0},yu=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Vy=e=>({hasErrorBoundary:!!e.hasErrorBoundary}),km="remix-router-transitions";function Dy(e){const o=e.window?e.window:typeof window<"u"?window:void 0,n=typeof o<"u"&&typeof o.document<"u"&&typeof o.document.createElement<"u",t=!n;G(e.routes.length>0,"You must provide a non-empty routes array to createRouter");let r;if(e.mapRouteProperties)r=e.mapRouteProperties;else if(e.detectErrorBoundary){let j=e.detectErrorBoundary;r=S=>({hasErrorBoundary:j(S)})}else r=Vy;let a={},i=ls(e.routes,r,void 0,a),c,s=e.basename||"/",u=e.unstable_dataStrategy||Fy,d=ce({v7_fetcherPersist:!1,v7_normalizeFormMethod:!1,v7_partialHydration:!1,v7_prependBasename:!1,v7_relativeSplatPath:!1,unstable_skipActionErrorRevalidation:!1},e.future),p=null,v=new Set,y=null,z=null,b=null,N=e.hydrationData!=null,k=dt(i,e.history.location,s),m=null;if(k==null){let j=to(404,{pathname:e.history.location.pathname}),{matches:S,route:P}=ld(i);k=S,m={[P.id]:j}}let f,T=k.some(j=>j.route.lazy),x=k.some(j=>j.route.loader);if(T)f=!1;else if(!x)f=!0;else if(d.v7_partialHydration){let j=e.hydrationData?e.hydrationData.loaderData:null,S=e.hydrationData?e.hydrationData.errors:null,P=M=>M.route.loader?typeof M.route.loader=="function"&&M.route.loader.hydrate===!0?!1:j&&j[M.route.id]!==void 0||S&&S[M.route.id]!==void 0:!0;if(S){let M=k.findIndex(I=>S[I.route.id]!==void 0);f=k.slice(0,M+1).every(P)}else f=k.every(P)}else f=e.hydrationData!=null;let O,h={historyAction:e.history.action,location:e.history.location,matches:k,initialized:f,navigation:rc,restoreScrollPosition:e.hydrationData!=null?!1:null,preventScrollReset:!1,revalidation:"idle",loaderData:e.hydrationData&&e.hydrationData.loaderData||{},actionData:e.hydrationData&&e.hydrationData.actionData||null,errors:e.hydrationData&&e.hydrationData.errors||m,fetchers:new Map,blockers:new Map},C=be.Pop,V=!1,R,Z=!1,F=new Map,oe=null,ve=!1,Ue=!1,He=[],po=[],E=new Map,L=0,_=-1,X=new Map,ee=new Set,vo=new Map,We=new Map,Ze=new Set,Re=new Map,oo=new Map,xi=!1;function xk(){if(p=e.history.listen(j=>{let{action:S,location:P,delta:M}=j;if(xi){xi=!1;return}Ln(oo.size===0||M!=null,"You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");let I=Ru({currentLocation:h.location,nextLocation:P,historyAction:S});if(I&&M!=null){xi=!0,e.history.go(M*-1),$r(I,{state:"blocked",location:P,proceed(){$r(I,{state:"proceeding",proceed:void 0,reset:void 0,location:P}),e.history.go(M)},reset(){let $=new Map(h.blockers);$.set(I,Yt),Xe({blockers:$})}});return}return gn(S,P)}),n){qy(o,F);let j=()=>ez(o,F);o.addEventListener("pagehide",j),oe=()=>o.removeEventListener("pagehide",j)}return h.initialized||gn(be.Pop,h.location,{initialHydration:!0}),O}function wk(){p&&p(),oe&&oe(),v.clear(),R&&R.abort(),h.fetchers.forEach((j,S)=>Kr(S)),h.blockers.forEach((j,S)=>Ou(S))}function Ck(j){return v.add(j),()=>v.delete(j)}function Xe(j,S){S===void 0&&(S={}),h=ce({},h,j);let P=[],M=[];d.v7_fetcherPersist&&h.fetchers.forEach((I,$)=>{I.state==="idle"&&(Ze.has($)?M.push($):P.push($))}),[...v].forEach(I=>I(h,{deletedFetchers:M,unstable_viewTransitionOpts:S.viewTransitionOpts,unstable_flushSync:S.flushSync===!0})),d.v7_fetcherPersist&&(P.forEach(I=>h.fetchers.delete(I)),M.forEach(I=>Kr(I)))}function Vt(j,S,P){var M,I;let{flushSync:$}=P===void 0?{}:P,U=h.actionData!=null&&h.navigation.formMethod!=null&&fo(h.navigation.formMethod)&&h.navigation.state==="loading"&&((M=j.state)==null?void 0:M._isRedirect)!==!0,D;S.actionData?Object.keys(S.actionData).length>0?D=S.actionData:D=null:U?D=h.actionData:D=null;let H=S.loaderData?sd(h.loaderData,S.loaderData,S.matches||[],S.errors):h.loaderData,K=h.blockers;K.size>0&&(K=new Map(K),K.forEach((B,ie)=>K.set(ie,Yt)));let Ne=V===!0||h.navigation.formMethod!=null&&fo(h.navigation.formMethod)&&((I=j.state)==null?void 0:I._isRedirect)!==!0;c&&(i=c,c=void 0),ve||C===be.Pop||(C===be.Push?e.history.push(j,j.state):C===be.Replace&&e.history.replace(j,j.state));let Te;if(C===be.Pop){let B=F.get(h.location.pathname);B&&B.has(j.pathname)?Te={currentLocation:h.location,nextLocation:j}:F.has(j.pathname)&&(Te={currentLocation:j,nextLocation:h.location})}else if(Z){let B=F.get(h.location.pathname);B?B.add(j.pathname):(B=new Set([j.pathname]),F.set(h.location.pathname,B)),Te={currentLocation:h.location,nextLocation:j}}Xe(ce({},S,{actionData:D,loaderData:H,historyAction:C,location:j,initialized:!0,navigation:rc,revalidation:"idle",restoreScrollPosition:Iu(j,S.matches||h.matches),preventScrollReset:Ne,blockers:K}),{viewTransitionOpts:Te,flushSync:$===!0}),C=be.Pop,V=!1,Z=!1,ve=!1,Ue=!1,He=[],po=[]}async function Pu(j,S){if(typeof j=="number"){e.history.go(j);return}let P=ds(h.location,h.matches,s,d.v7_prependBasename,j,d.v7_relativeSplatPath,S==null?void 0:S.fromRouteId,S==null?void 0:S.relative),{path:M,submission:I,error:$}=od(d.v7_normalizeFormMethod,!1,P,S),U=h.location,D=Rr(h.location,M,S&&S.state);D=ce({},D,e.history.encodeLocation(D));let H=S&&S.replace!=null?S.replace:void 0,K=be.Push;H===!0?K=be.Replace:H===!1||I!=null&&fo(I.formMethod)&&I.formAction===h.location.pathname+h.location.search&&(K=be.Replace);let Ne=S&&"preventScrollReset"in S?S.preventScrollReset===!0:void 0,Te=(S&&S.unstable_flushSync)===!0,B=Ru({currentLocation:U,nextLocation:D,historyAction:K});if(B){$r(B,{state:"blocked",location:D,proceed(){$r(B,{state:"proceeding",proceed:void 0,reset:void 0,location:D}),Pu(j,S)},reset(){let ie=new Map(h.blockers);ie.set(B,Yt),Xe({blockers:ie})}});return}return await gn(K,D,{submission:I,pendingError:$,preventScrollReset:Ne,replace:S&&S.replace,enableViewTransition:S&&S.unstable_viewTransition,flushSync:Te})}function Ek(){if(wi(),Xe({revalidation:"loading"}),h.navigation.state!=="submitting"){if(h.navigation.state==="idle"){gn(h.historyAction,h.location,{startUninterruptedRevalidation:!0});return}gn(C||h.historyAction,h.navigation.location,{overrideNavigation:h.navigation})}}async function gn(j,S,P){R&&R.abort(),R=null,C=j,ve=(P&&P.startUninterruptedRevalidation)===!0,Uk(h.location,h.matches),V=(P&&P.preventScrollReset)===!0,Z=(P&&P.enableViewTransition)===!0;let M=c||i,I=P&&P.overrideNavigation,$=dt(M,S,s),U=(P&&P.flushSync)===!0;if(!$){let B=to(404,{pathname:S.pathname}),{matches:ie,route:ze}=ld(M);Ci(),Vt(S,{matches:ie,loaderData:{},errors:{[ze.id]:B}},{flushSync:U});return}if(h.initialized&&!Ue&&Zy(h.location,S)&&!(P&&P.submission&&fo(P.submission.formMethod))){Vt(S,{matches:$},{flushSync:U});return}R=new AbortController;let D=Gn(e.history,S,R.signal,P&&P.submission),H;if(P&&P.pendingError)H=[mr($).route.id,{type:se.error,error:P.pendingError}];else if(P&&P.submission&&fo(P.submission.formMethod)){let B=await Mk(D,S,P.submission,$,{replace:P.replace,flushSync:U});if(B.shortCircuited)return;H=B.pendingActionResult,I=ac(S,P.submission),U=!1,D=Gn(e.history,D.url,D.signal)}let{shortCircuited:K,loaderData:Ne,errors:Te}=await Ok(D,S,$,I,P&&P.submission,P&&P.fetcherSubmission,P&&P.replace,P&&P.initialHydration===!0,U,H);K||(R=null,Vt(S,ce({matches:$},ud(H),{loaderData:Ne,errors:Te})))}async function Mk(j,S,P,M,I){I===void 0&&(I={}),wi();let $=Qy(S,P);Xe({navigation:$},{flushSync:I.flushSync===!0});let U,D=vs(M,S);if(!D.route.action&&!D.route.lazy)U={type:se.error,error:to(405,{method:j.method,pathname:S.pathname,routeId:D.route.id})};else if(U=(await Lt("action",j,[D],M))[0],j.signal.aborted)return{shortCircuited:!0};if(Cn(U)){let H;return I&&I.replace!=null?H=I.replace:H=ad(U.response.headers.get("Location"),new URL(j.url),s)===h.location.pathname+h.location.search,await Dt(j,U,{submission:P,replace:H}),{shortCircuited:!0}}if(wn(U))throw to(400,{type:"defer-action"});if(io(U)){let H=mr(M,D.route.id);return(I&&I.replace)!==!0&&(C=be.Push),{pendingActionResult:[H.route.id,U]}}return{pendingActionResult:[D.route.id,U]}}async function Ok(j,S,P,M,I,$,U,D,H,K){let Ne=M||ac(S,I),Te=I||$||vd(Ne),B=c||i,[ie,ze]=nd(e.history,h,P,Te,S,d.v7_partialHydration&&D===!0,d.unstable_skipActionErrorRevalidation,Ue,He,po,Ze,vo,ee,B,s,K);if(Ci(Q=>!(P&&P.some(Ae=>Ae.route.id===Q))||ie&&ie.some(Ae=>Ae.route.id===Q)),_=++L,ie.length===0&&ze.length===0){let Q=Eu();return Vt(S,ce({matches:P,loaderData:{},errors:K&&io(K[1])?{[K[0]]:K[1].error}:null},ud(K),Q?{fetchers:new Map(h.fetchers)}:{}),{flushSync:H}),{shortCircuited:!0}}if(!ve&&(!d.v7_partialHydration||!D)){ze.forEach(Ae=>{let no=h.fetchers.get(Ae.key),Se=qt(void 0,no?no.data:void 0);h.fetchers.set(Ae.key,Se)});let Q;K&&!io(K[1])?Q={[K[0]]:K[1].data}:h.actionData&&(Object.keys(h.actionData).length===0?Q=null:Q=h.actionData),Xe(ce({navigation:Ne},Q!==void 0?{actionData:Q}:{},ze.length>0?{fetchers:new Map(h.fetchers)}:{}),{flushSync:H})}ze.forEach(Q=>{E.has(Q.key)&&Xo(Q.key),Q.controller&&E.set(Q.key,Q.controller)});let _t=()=>ze.forEach(Q=>Xo(Q.key));R&&R.signal.addEventListener("abort",_t);let{loaderResults:Go,fetcherResults:Hn}=await xu(h.matches,P,ie,ze,j);if(j.signal.aborted)return{shortCircuited:!0};R&&R.signal.removeEventListener("abort",_t),ze.forEach(Q=>E.delete(Q.key));let Wn=dd([...Go,...Hn]);if(Wn){if(Wn.idx>=ie.length){let Q=ze[Wn.idx-ie.length].key;ee.add(Q)}return await Dt(j,Wn.result,{replace:U}),{shortCircuited:!0}}let{loaderData:Zn,errors:No}=cd(h,P,ie,Go,K,ze,Hn,Re);Re.forEach((Q,Ae)=>{Q.subscribe(no=>{(no||Q.done)&&Re.delete(Ae)})}),d.v7_partialHydration&&D&&h.errors&&Object.entries(h.errors).filter(Q=>{let[Ae]=Q;return!ie.some(no=>no.route.id===Ae)}).forEach(Q=>{let[Ae,no]=Q;No=Object.assign(No||{},{[Ae]:no})});let Hr=Eu(),Wr=Mu(_),Zr=Hr||Wr||ze.length>0;return ce({loaderData:Zn,errors:No},Zr?{fetchers:new Map(h.fetchers)}:{})}function Rk(j,S,P,M){if(t)throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");E.has(j)&&Xo(j);let I=(M&&M.unstable_flushSync)===!0,$=c||i,U=ds(h.location,h.matches,s,d.v7_prependBasename,P,d.v7_relativeSplatPath,S,M==null?void 0:M.relative),D=dt($,U,s);if(!D){Ut(j,S,to(404,{pathname:U}),{flushSync:I});return}let{path:H,submission:K,error:Ne}=od(d.v7_normalizeFormMethod,!0,U,M);if(Ne){Ut(j,S,Ne,{flushSync:I});return}let Te=vs(D,H);if(V=(M&&M.preventScrollReset)===!0,K&&fo(K.formMethod)){Ak(j,S,H,Te,D,I,K);return}vo.set(j,{routeId:S,path:H}),Ik(j,S,H,Te,D,I,K)}async function Ak(j,S,P,M,I,$,U){if(wi(),vo.delete(j),!M.route.action&&!M.route.lazy){let Se=to(405,{method:U.formMethod,pathname:P,routeId:S});Ut(j,S,Se,{flushSync:$});return}let D=h.fetchers.get(j);Zo(j,Yy(U,D),{flushSync:$});let H=new AbortController,K=Gn(e.history,P,H.signal,U);E.set(j,H);let Ne=L,B=(await Lt("action",K,[M],I))[0];if(K.signal.aborted){E.get(j)===H&&E.delete(j);return}if(d.v7_fetcherPersist&&Ze.has(j)){if(Cn(B)||io(B)){Zo(j,qo(void 0));return}}else{if(Cn(B))if(E.delete(j),_>Ne){Zo(j,qo(void 0));return}else return ee.add(j),Zo(j,qt(U)),Dt(K,B,{fetcherSubmission:U});if(io(B)){Ut(j,S,B.error);return}}if(wn(B))throw to(400,{type:"defer-action"});let ie=h.navigation.location||h.location,ze=Gn(e.history,ie,H.signal),_t=c||i,Go=h.navigation.state!=="idle"?dt(_t,h.navigation.location,s):h.matches;G(Go,"Didn't find any matches after fetcher action");let Hn=++L;X.set(j,Hn);let Wn=qt(U,B.data);h.fetchers.set(j,Wn);let[Zn,No]=nd(e.history,h,Go,U,ie,!1,d.unstable_skipActionErrorRevalidation,Ue,He,po,Ze,vo,ee,_t,s,[M.route.id,B]);No.filter(Se=>Se.key!==j).forEach(Se=>{let Ft=Se.key,Vu=h.fetchers.get(Ft),Fk=qt(void 0,Vu?Vu.data:void 0);h.fetchers.set(Ft,Fk),E.has(Ft)&&Xo(Ft),Se.controller&&E.set(Ft,Se.controller)}),Xe({fetchers:new Map(h.fetchers)});let Hr=()=>No.forEach(Se=>Xo(Se.key));H.signal.addEventListener("abort",Hr);let{loaderResults:Wr,fetcherResults:Zr}=await xu(h.matches,Go,Zn,No,ze);if(H.signal.aborted)return;H.signal.removeEventListener("abort",Hr),X.delete(j),E.delete(j),No.forEach(Se=>E.delete(Se.key));let Q=dd([...Wr,...Zr]);if(Q){if(Q.idx>=Zn.length){let Se=No[Q.idx-Zn.length].key;ee.add(Se)}return Dt(ze,Q.result)}let{loaderData:Ae,errors:no}=cd(h,h.matches,Zn,Wr,void 0,No,Zr,Re);if(h.fetchers.has(j)){let Se=qo(B.data);h.fetchers.set(j,Se)}Mu(Hn),h.navigation.state==="loading"&&Hn>_?(G(C,"Expected pending action"),R&&R.abort(),Vt(h.navigation.location,{matches:Go,loaderData:Ae,errors:no,fetchers:new Map(h.fetchers)})):(Xe({errors:no,loaderData:sd(h.loaderData,Ae,Go,no),fetchers:new Map(h.fetchers)}),Ue=!1)}async function Ik(j,S,P,M,I,$,U){let D=h.fetchers.get(j);Zo(j,qt(U,D?D.data:void 0),{flushSync:$});let H=new AbortController,K=Gn(e.history,P,H.signal);E.set(j,H);let Ne=L,B=(await Lt("loader",K,[M],I))[0];if(wn(B)&&(B=await ym(B,K.signal,!0)||B),E.get(j)===H&&E.delete(j),!K.signal.aborted){if(Ze.has(j)){Zo(j,qo(void 0));return}if(Cn(B))if(_>Ne){Zo(j,qo(void 0));return}else{ee.add(j),await Dt(K,B);return}if(io(B)){Ut(j,S,B.error);return}G(!wn(B),"Unhandled fetcher deferred data"),Zo(j,qo(B.data))}}async function Dt(j,S,P){let{submission:M,fetcherSubmission:I,replace:$}=P===void 0?{}:P;S.response.headers.has("X-Remix-Revalidate")&&(Ue=!0);let U=S.response.headers.get("Location");G(U,"Expected a Location header on the redirect Response"),U=ad(U,new URL(j.url),s);let D=Rr(h.location,U,{_isRedirect:!0});if(n){let ie=!1;if(S.response.headers.has("X-Remix-Reload-Document"))ie=!0;else if(yu.test(U)){const ze=e.history.createURL(U);ie=ze.origin!==o.location.origin||Rt(ze.pathname,s)==null}if(ie){$?o.location.replace(U):o.location.assign(U);return}}R=null;let H=$===!0?be.Replace:be.Push,{formMethod:K,formAction:Ne,formEncType:Te}=h.navigation;!M&&!I&&K&&Ne&&Te&&(M=vd(h.navigation));let B=M||I;if(Ay.has(S.response.status)&&B&&fo(B.formMethod))await gn(H,D,{submission:ce({},B,{formAction:U}),preventScrollReset:V});else{let ie=ac(D,M);await gn(H,D,{overrideNavigation:ie,fetcherSubmission:I,preventScrollReset:V})}}async function Lt(j,S,P,M){try{let I=await By(u,j,S,P,M,a,r);return await Promise.all(I.map(($,U)=>{if(Xy($)){let D=$.result;return{type:se.redirect,response:Hy(D,S,P[U].route.id,M,s,d.v7_relativeSplatPath)}}return $y($)}))}catch(I){return P.map(()=>({type:se.error,error:I}))}}async function xu(j,S,P,M,I){let[$,...U]=await Promise.all([P.length?Lt("loader",I,P,S):[],...M.map(D=>{if(D.matches&&D.match&&D.controller){let H=Gn(e.history,D.path,D.controller.signal);return Lt("loader",H,[D.match],D.matches).then(K=>K[0])}else return Promise.resolve({type:se.error,error:to(404,{pathname:D.path})})})]);return await Promise.all([pd(j,P,$,$.map(()=>I.signal),!1,h.loaderData),pd(j,M.map(D=>D.match),U,M.map(D=>D.controller?D.controller.signal:null),!0)]),{loaderResults:$,fetcherResults:U}}function wi(){Ue=!0,He.push(...Ci()),vo.forEach((j,S)=>{E.has(S)&&(po.push(S),Xo(S))})}function Zo(j,S,P){P===void 0&&(P={}),h.fetchers.set(j,S),Xe({fetchers:new Map(h.fetchers)},{flushSync:(P&&P.flushSync)===!0})}function Ut(j,S,P,M){M===void 0&&(M={});let I=mr(h.matches,S);Kr(j),Xe({errors:{[I.route.id]:P},fetchers:new Map(h.fetchers)},{flushSync:(M&&M.flushSync)===!0})}function wu(j){return d.v7_fetcherPersist&&(We.set(j,(We.get(j)||0)+1),Ze.has(j)&&Ze.delete(j)),h.fetchers.get(j)||Iy}function Kr(j){let S=h.fetchers.get(j);E.has(j)&&!(S&&S.state==="loading"&&X.has(j))&&Xo(j),vo.delete(j),X.delete(j),ee.delete(j),Ze.delete(j),h.fetchers.delete(j)}function Vk(j){if(d.v7_fetcherPersist){let S=(We.get(j)||0)-1;S<=0?(We.delete(j),Ze.add(j)):We.set(j,S)}else Kr(j);Xe({fetchers:new Map(h.fetchers)})}function Xo(j){let S=E.get(j);G(S,"Expected fetch controller: "+j),S.abort(),E.delete(j)}function Cu(j){for(let S of j){let P=wu(S),M=qo(P.data);h.fetchers.set(S,M)}}function Eu(){let j=[],S=!1;for(let P of ee){let M=h.fetchers.get(P);G(M,"Expected fetcher: "+P),M.state==="loading"&&(ee.delete(P),j.push(P),S=!0)}return Cu(j),S}function Mu(j){let S=[];for(let[P,M]of X)if(M<j){let I=h.fetchers.get(P);G(I,"Expected fetcher: "+P),I.state==="loading"&&(Xo(P),X.delete(P),S.push(P))}return Cu(S),S.length>0}function Dk(j,S){let P=h.blockers.get(j)||Yt;return oo.get(j)!==S&&oo.set(j,S),P}function Ou(j){h.blockers.delete(j),oo.delete(j)}function $r(j,S){let P=h.blockers.get(j)||Yt;G(P.state==="unblocked"&&S.state==="blocked"||P.state==="blocked"&&S.state==="blocked"||P.state==="blocked"&&S.state==="proceeding"||P.state==="blocked"&&S.state==="unblocked"||P.state==="proceeding"&&S.state==="unblocked","Invalid blocker state transition: "+P.state+" -> "+S.state);let M=new Map(h.blockers);M.set(j,S),Xe({blockers:M})}function Ru(j){let{currentLocation:S,nextLocation:P,historyAction:M}=j;if(oo.size===0)return;oo.size>1&&Ln(!1,"A router only supports one blocker at a time");let I=Array.from(oo.entries()),[$,U]=I[I.length-1],D=h.blockers.get($);if(!(D&&D.state==="proceeding")&&U({currentLocation:S,nextLocation:P,historyAction:M}))return $}function Ci(j){let S=[];return Re.forEach((P,M)=>{(!j||j(M))&&(P.cancel(),S.push(M),Re.delete(M))}),S}function Lk(j,S,P){if(y=j,b=S,z=P||null,!N&&h.navigation===rc){N=!0;let M=Iu(h.location,h.matches);M!=null&&Xe({restoreScrollPosition:M})}return()=>{y=null,b=null,z=null}}function Au(j,S){return z&&z(j,S.map(M=>dy(M,h.loaderData)))||j.key}function Uk(j,S){if(y&&b){let P=Au(j,S);y[P]=b()}}function Iu(j,S){if(y){let P=Au(j,S),M=y[P];if(typeof M=="number")return M}return null}function _k(j){a={},c=ls(j,r,void 0,a)}return O={get basename(){return s},get future(){return d},get state(){return h},get routes(){return i},get window(){return o},initialize:xk,subscribe:Ck,enableScrollRestoration:Lk,navigate:Pu,fetch:Rk,revalidate:Ek,createHref:j=>e.history.createHref(j),encodeLocation:j=>e.history.encodeLocation(j),getFetcher:wu,deleteFetcher:Vk,dispose:wk,getBlocker:Dk,deleteBlocker:Ou,_internalFetchControllers:E,_internalActiveDeferreds:Re,_internalSetRoutes:_k},O}function Ly(e){return e!=null&&("formData"in e&&e.formData!=null||"body"in e&&e.body!==void 0)}function ds(e,o,n,t,r,a,i,c){let s,u;if(i){s=[];for(let p of o)if(s.push(p),p.route.id===i){u=p;break}}else s=o,u=o[o.length-1];let d=bu(r||".",ku(s,a),Rt(e.pathname,n)||e.pathname,c==="path");return r==null&&(d.search=e.search,d.hash=e.hash),(r==null||r===""||r===".")&&u&&u.route.index&&!zu(d.search)&&(d.search=d.search?d.search.replace(/^\?/,"?index&"):"?index"),t&&n!=="/"&&(d.pathname=d.pathname==="/"?n:Lo([n,d.pathname])),Un(d)}function od(e,o,n,t){if(!t||!Ly(t))return{path:n};if(t.formMethod&&!Jy(t.formMethod))return{path:n,error:to(405,{method:t.formMethod})};let r=()=>({path:n,error:to(400,{type:"invalid-body"})}),a=t.formMethod||"get",i=e?a.toUpperCase():a.toLowerCase(),c=fm(n);if(t.body!==void 0){if(t.formEncType==="text/plain"){if(!fo(i))return r();let v=typeof t.body=="string"?t.body:t.body instanceof FormData||t.body instanceof URLSearchParams?Array.from(t.body.entries()).reduce((y,z)=>{let[b,N]=z;return""+y+b+"="+N+`
`},""):String(t.body);return{path:n,submission:{formMethod:i,formAction:c,formEncType:t.formEncType,formData:void 0,json:void 0,text:v}}}else if(t.formEncType==="application/json"){if(!fo(i))return r();try{let v=typeof t.body=="string"?JSON.parse(t.body):t.body;return{path:n,submission:{formMethod:i,formAction:c,formEncType:t.formEncType,formData:void 0,json:v,text:void 0}}}catch{return r()}}}G(typeof FormData=="function","FormData is not available in this environment");let s,u;if(t.formData)s=ps(t.formData),u=t.formData;else if(t.body instanceof FormData)s=ps(t.body),u=t.body;else if(t.body instanceof URLSearchParams)s=t.body,u=id(s);else if(t.body==null)s=new URLSearchParams,u=new FormData;else try{s=new URLSearchParams(t.body),u=id(s)}catch{return r()}let d={formMethod:i,formAction:c,formEncType:t&&t.formEncType||"application/x-www-form-urlencoded",formData:u,json:void 0,text:void 0};if(fo(d.formMethod))return{path:n,submission:d};let p=Ho(n);return o&&p.search&&zu(p.search)&&s.append("index",""),p.search="?"+s,{path:Un(p),submission:d}}function Uy(e,o){let n=e;if(o){let t=e.findIndex(r=>r.route.id===o);t>=0&&(n=e.slice(0,t))}return n}function nd(e,o,n,t,r,a,i,c,s,u,d,p,v,y,z,b){let N=b?io(b[1])?b[1].error:b[1].data:void 0,k=e.createURL(o.location),m=e.createURL(r),f=b&&io(b[1])?b[0]:void 0,T=f?Uy(n,f):n,x=b?b[1].statusCode:void 0,O=i&&x&&x>=400,h=T.filter((V,R)=>{let{route:Z}=V;if(Z.lazy)return!0;if(Z.loader==null)return!1;if(a)return typeof Z.loader!="function"||Z.loader.hydrate?!0:o.loaderData[Z.id]===void 0&&(!o.errors||o.errors[Z.id]===void 0);if(_y(o.loaderData,o.matches[R],V)||s.some(ve=>ve===V.route.id))return!0;let F=o.matches[R],oe=V;return td(V,ce({currentUrl:k,currentParams:F.params,nextUrl:m,nextParams:oe.params},t,{actionResult:N,unstable_actionStatus:x,defaultShouldRevalidate:O?!1:c||k.pathname+k.search===m.pathname+m.search||k.search!==m.search||bm(F,oe)}))}),C=[];return p.forEach((V,R)=>{if(a||!n.some(Ue=>Ue.route.id===V.routeId)||d.has(R))return;let Z=dt(y,V.path,z);if(!Z){C.push({key:R,routeId:V.routeId,path:V.path,matches:null,match:null,controller:null});return}let F=o.fetchers.get(R),oe=vs(Z,V.path),ve=!1;v.has(R)?ve=!1:u.includes(R)?ve=!0:F&&F.state!=="idle"&&F.data===void 0?ve=c:ve=td(oe,ce({currentUrl:k,currentParams:o.matches[o.matches.length-1].params,nextUrl:m,nextParams:n[n.length-1].params},t,{actionResult:N,unstable_actionStatus:x,defaultShouldRevalidate:O?!1:c})),ve&&C.push({key:R,routeId:V.routeId,path:V.path,matches:Z,match:oe,controller:new AbortController})}),[h,C]}function _y(e,o,n){let t=!o||n.route.id!==o.route.id,r=e[n.route.id]===void 0;return t||r}function bm(e,o){let n=e.route.path;return e.pathname!==o.pathname||n!=null&&n.endsWith("*")&&e.params["*"]!==o.params["*"]}function td(e,o){if(e.route.shouldRevalidate){let n=e.route.shouldRevalidate(o);if(typeof n=="boolean")return n}return o.defaultShouldRevalidate}async function rd(e,o,n){if(!e.lazy)return;let t=await e.lazy();if(!e.lazy)return;let r=n[e.id];G(r,"No route found in manifest");let a={};for(let i in t){let s=r[i]!==void 0&&i!=="hasErrorBoundary";Ln(!s,'Route "'+r.id+'" has a static property "'+i+'" defined but its lazy function is also returning a value for this property. '+('The lazy route property "'+i+'" will be ignored.')),!s&&!uy.has(i)&&(a[i]=t[i])}Object.assign(r,a),Object.assign(r,ce({},o(r),{lazy:void 0}))}function Fy(e){return Promise.all(e.matches.map(o=>o.resolve()))}async function By(e,o,n,t,r,a,i,c){let s=t.reduce((p,v)=>p.add(v.route.id),new Set),u=new Set,d=await e({matches:r.map(p=>{let v=s.has(p.route.id);return ce({},p,{shouldLoad:v,resolve:z=>(u.add(p.route.id),v?Ky(o,n,p,a,i,z,c):Promise.resolve({type:se.data,result:void 0}))})}),request:n,params:r[0].params,context:c});return r.forEach(p=>G(u.has(p.route.id),'`match.resolve()` was not called for route id "'+p.route.id+'". You must call `match.resolve()` on every match passed to `dataStrategy` to ensure all routes are properly loaded.')),d.filter((p,v)=>s.has(r[v].route.id))}async function Ky(e,o,n,t,r,a,i){let c,s,u=d=>{let p,v=new Promise((b,N)=>p=N);s=()=>p(),o.signal.addEventListener("abort",s);let y=b=>typeof d!="function"?Promise.reject(new Error("You cannot call the handler for a route which defines a boolean "+('"'+e+'" [routeId: '+n.route.id+"]"))):d({request:o,params:n.params,context:i},...b!==void 0?[b]:[]),z;return a?z=a(b=>y(b)):z=(async()=>{try{return{type:"data",result:await y()}}catch(b){return{type:"error",result:b}}})(),Promise.race([z,v])};try{let d=n.route[e];if(n.route.lazy)if(d){let p,[v]=await Promise.all([u(d).catch(y=>{p=y}),rd(n.route,r,t)]);if(p!==void 0)throw p;c=v}else if(await rd(n.route,r,t),d=n.route[e],d)c=await u(d);else if(e==="action"){let p=new URL(o.url),v=p.pathname+p.search;throw to(405,{method:o.method,pathname:v,routeId:n.route.id})}else return{type:se.data,result:void 0};else if(d)c=await u(d);else{let p=new URL(o.url),v=p.pathname+p.search;throw to(404,{pathname:v})}G(c.result!==void 0,"You defined "+(e==="action"?"an action":"a loader")+" for route "+('"'+n.route.id+"\" but didn't return anything from your `"+e+"` ")+"function. Please return a value or `null`.")}catch(d){return{type:se.error,result:d}}finally{s&&o.signal.removeEventListener("abort",s)}return c}async function $y(e){let{result:o,type:n,status:t}=e;if(hm(o)){let i;try{let c=o.headers.get("Content-Type");c&&/\bapplication\/json\b/.test(c)?o.body==null?i=null:i=await o.json():i=await o.text()}catch(c){return{type:se.error,error:c}}return n===se.error?{type:se.error,error:new fu(o.status,o.statusText,i),statusCode:o.status,headers:o.headers}:{type:se.data,data:i,statusCode:o.status,headers:o.headers}}if(n===se.error)return{type:se.error,error:o,statusCode:hu(o)?o.status:t};if(Gy(o)){var r,a;return{type:se.deferred,deferredData:o,statusCode:(r=o.init)==null?void 0:r.status,headers:((a=o.init)==null?void 0:a.headers)&&new Headers(o.init.headers)}}return{type:se.data,data:o,statusCode:t}}function Hy(e,o,n,t,r,a){let i=e.headers.get("Location");if(G(i,"Redirects returned/thrown from loaders/actions must have a Location header"),!yu.test(i)){let c=t.slice(0,t.findIndex(s=>s.route.id===n)+1);i=ds(new URL(o.url),c,r,!0,i,a),e.headers.set("Location",i)}return e}function ad(e,o,n){if(yu.test(e)){let t=e,r=t.startsWith("//")?new URL(o.protocol+t):new URL(t),a=Rt(r.pathname,n)!=null;if(r.origin===o.origin&&a)return r.pathname+r.search+r.hash}return e}function Gn(e,o,n,t){let r=e.createURL(fm(o)).toString(),a={signal:n};if(t&&fo(t.formMethod)){let{formMethod:i,formEncType:c}=t;a.method=i.toUpperCase(),c==="application/json"?(a.headers=new Headers({"Content-Type":c}),a.body=JSON.stringify(t.json)):c==="text/plain"?a.body=t.text:c==="application/x-www-form-urlencoded"&&t.formData?a.body=ps(t.formData):a.body=t.formData}return new Request(r,a)}function ps(e){let o=new URLSearchParams;for(let[n,t]of e.entries())o.append(n,typeof t=="string"?t:t.name);return o}function id(e){let o=new FormData;for(let[n,t]of e.entries())o.append(n,t);return o}function Wy(e,o,n,t,r,a){let i={},c=null,s,u=!1,d={},p=t&&io(t[1])?t[1].error:void 0;return n.forEach((v,y)=>{let z=o[y].route.id;if(G(!Cn(v),"Cannot handle redirect results in processLoaderData"),io(v)){let b=v.error;p!==void 0&&(b=p,p=void 0),c=c||{};{let N=mr(e,z);c[N.route.id]==null&&(c[N.route.id]=b)}i[z]=void 0,u||(u=!0,s=hu(v.error)?v.error.status:500),v.headers&&(d[z]=v.headers)}else wn(v)?(r.set(z,v.deferredData),i[z]=v.deferredData.data,v.statusCode!=null&&v.statusCode!==200&&!u&&(s=v.statusCode),v.headers&&(d[z]=v.headers)):(i[z]=v.data,v.statusCode&&v.statusCode!==200&&!u&&(s=v.statusCode),v.headers&&(d[z]=v.headers))}),p!==void 0&&t&&(c={[t[0]]:p},i[t[0]]=void 0),{loaderData:i,errors:c,statusCode:s||200,loaderHeaders:d}}function cd(e,o,n,t,r,a,i,c){let{loaderData:s,errors:u}=Wy(o,n,t,r,c);for(let d=0;d<a.length;d++){let{key:p,match:v,controller:y}=a[d];G(i!==void 0&&i[d]!==void 0,"Did not find corresponding fetcher result");let z=i[d];if(!(y&&y.signal.aborted))if(io(z)){let b=mr(e.matches,v==null?void 0:v.route.id);u&&u[b.route.id]||(u=ce({},u,{[b.route.id]:z.error})),e.fetchers.delete(p)}else if(Cn(z))G(!1,"Unhandled fetcher revalidation redirect");else if(wn(z))G(!1,"Unhandled fetcher deferred data");else{let b=qo(z.data);e.fetchers.set(p,b)}}return{loaderData:s,errors:u}}function sd(e,o,n,t){let r=ce({},o);for(let a of n){let i=a.route.id;if(o.hasOwnProperty(i)?o[i]!==void 0&&(r[i]=o[i]):e[i]!==void 0&&a.route.loader&&(r[i]=e[i]),t&&t.hasOwnProperty(i))break}return r}function ud(e){return e?io(e[1])?{actionData:{}}:{actionData:{[e[0]]:e[1].data}}:{}}function mr(e,o){return(o?e.slice(0,e.findIndex(t=>t.route.id===o)+1):[...e]).reverse().find(t=>t.route.hasErrorBoundary===!0)||e[0]}function ld(e){let o=e.length===1?e[0]:e.find(n=>n.index||!n.path||n.path==="/")||{id:"__shim-error-route__"};return{matches:[{params:{},pathname:"",pathnameBase:"",route:o}],route:o}}function to(e,o){let{pathname:n,routeId:t,method:r,type:a}=o===void 0?{}:o,i="Unknown Server Error",c="Unknown @remix-run/router error";return e===400?(i="Bad Request",r&&n&&t?c="You made a "+r+' request to "'+n+'" but '+('did not provide a `loader` for route "'+t+'", ')+"so there is no way to handle the request.":a==="defer-action"?c="defer() is not supported in actions":a==="invalid-body"&&(c="Unable to encode submission body")):e===403?(i="Forbidden",c='Route "'+t+'" does not match URL "'+n+'"'):e===404?(i="Not Found",c='No route matches URL "'+n+'"'):e===405&&(i="Method Not Allowed",r&&n&&t?c="You made a "+r.toUpperCase()+' request to "'+n+'" but '+('did not provide an `action` for route "'+t+'", ')+"so there is no way to handle the request.":r&&(c='Invalid request method "'+r.toUpperCase()+'"')),new fu(e||500,i,new Error(c),!0)}function dd(e){for(let o=e.length-1;o>=0;o--){let n=e[o];if(Cn(n))return{result:n,idx:o}}}function fm(e){let o=typeof e=="string"?Ho(e):e;return Un(ce({},o,{hash:""}))}function Zy(e,o){return e.pathname!==o.pathname||e.search!==o.search?!1:e.hash===""?o.hash!=="":e.hash===o.hash?!0:o.hash!==""}function Xy(e){return hm(e.result)&&Ry.has(e.result.status)}function wn(e){return e.type===se.deferred}function io(e){return e.type===se.error}function Cn(e){return(e&&e.type)===se.redirect}function Gy(e){let o=e;return o&&typeof o=="object"&&typeof o.data=="object"&&typeof o.subscribe=="function"&&typeof o.cancel=="function"&&typeof o.resolveData=="function"}function hm(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.headers=="object"&&typeof e.body<"u"}function Jy(e){return Oy.has(e.toLowerCase())}function fo(e){return Ey.has(e.toLowerCase())}async function pd(e,o,n,t,r,a){for(let i=0;i<n.length;i++){let c=n[i],s=o[i];if(!s)continue;let u=e.find(p=>p.route.id===s.route.id),d=u!=null&&!bm(u,s)&&(a&&a[s.route.id])!==void 0;if(wn(c)&&(r||d)){let p=t[i];G(p,"Expected an AbortSignal for revalidating fetcher deferred result"),await ym(c,p,r).then(v=>{v&&(n[i]=v||n[i])})}}}async function ym(e,o,n){if(n===void 0&&(n=!1),!await e.deferredData.resolveData(o)){if(n)try{return{type:se.data,data:e.deferredData.unwrappedData}}catch(r){return{type:se.error,error:r}}return{type:se.data,data:e.deferredData.data}}}function zu(e){return new URLSearchParams(e).getAll("index").some(o=>o==="")}function vs(e,o){let n=typeof o=="string"?Ho(o).search:o.search;if(e[e.length-1].route.index&&zu(n||""))return e[e.length-1];let t=vm(e);return t[t.length-1]}function vd(e){let{formMethod:o,formAction:n,formEncType:t,text:r,formData:a,json:i}=e;if(!(!o||!n||!t)){if(r!=null)return{formMethod:o,formAction:n,formEncType:t,formData:void 0,json:void 0,text:r};if(a!=null)return{formMethod:o,formAction:n,formEncType:t,formData:a,json:void 0,text:void 0};if(i!==void 0)return{formMethod:o,formAction:n,formEncType:t,formData:void 0,json:i,text:void 0}}}function ac(e,o){return o?{state:"loading",location:e,formMethod:o.formMethod,formAction:o.formAction,formEncType:o.formEncType,formData:o.formData,json:o.json,text:o.text}:{state:"loading",location:e,formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0}}function Qy(e,o){return{state:"submitting",location:e,formMethod:o.formMethod,formAction:o.formAction,formEncType:o.formEncType,formData:o.formData,json:o.json,text:o.text}}function qt(e,o){return e?{state:"loading",formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text,data:o}:{state:"loading",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:o}}function Yy(e,o){return{state:"submitting",formMethod:e.formMethod,formAction:e.formAction,formEncType:e.formEncType,formData:e.formData,json:e.json,text:e.text,data:o?o.data:void 0}}function qo(e){return{state:"idle",formMethod:void 0,formAction:void 0,formEncType:void 0,formData:void 0,json:void 0,text:void 0,data:e}}function qy(e,o){try{let n=e.sessionStorage.getItem(km);if(n){let t=JSON.parse(n);for(let[r,a]of Object.entries(t||{}))a&&Array.isArray(a)&&o.set(r,new Set(a||[]))}}catch{}}function ez(e,o){if(o.size>0){let n={};for(let[t,r]of o)n[t]=[...r];try{e.sessionStorage.setItem(km,JSON.stringify(n))}catch(t){Ln(!1,"Failed to save applied view transitions in sessionStorage ("+t+").")}}}/**
 * React Router v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function oi(){return oi=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},oi.apply(this,arguments)}const ji=l.createContext(null),zm=l.createContext(null),$n=l.createContext(null),ju=l.createContext(null),Wo=l.createContext({outlet:null,matches:[],isDataRoute:!1}),jm=l.createContext(null);function oz(e,o){let{relative:n}=o===void 0?{}:o;Fr()||G(!1);let{basename:t,navigator:r}=l.useContext($n),{hash:a,pathname:i,search:c}=Tm(e,{relative:n}),s=i;return t!=="/"&&(s=i==="/"?t:Lo([t,i])),r.createHref({pathname:s,search:c,hash:a})}function Fr(){return l.useContext(ju)!=null}function gi(){return Fr()||G(!1),l.useContext(ju).location}function gm(e){l.useContext($n).static||l.useLayoutEffect(e)}function nz(){let{isDataRoute:e}=l.useContext(Wo);return e?bz():tz()}function tz(){Fr()||G(!1);let e=l.useContext(ji),{basename:o,future:n,navigator:t}=l.useContext($n),{matches:r}=l.useContext(Wo),{pathname:a}=gi(),i=JSON.stringify(ku(r,n.v7_relativeSplatPath)),c=l.useRef(!1);return gm(()=>{c.current=!0}),l.useCallback(function(u,d){if(d===void 0&&(d={}),!c.current)return;if(typeof u=="number"){t.go(u);return}let p=bu(u,JSON.parse(i),a,d.relative==="path");e==null&&o!=="/"&&(p.pathname=p.pathname==="/"?o:Lo([o,p.pathname])),(d.replace?t.replace:t.push)(p,d.state,d)},[o,t,i,a,e])}const rz=l.createContext(null);function az(e){let o=l.useContext(Wo).outlet;return o&&l.createElement(rz.Provider,{value:e},o)}function Nm(){let{matches:e}=l.useContext(Wo),o=e[e.length-1];return o?o.params:{}}function Tm(e,o){let{relative:n}=o===void 0?{}:o,{future:t}=l.useContext($n),{matches:r}=l.useContext(Wo),{pathname:a}=gi(),i=JSON.stringify(ku(r,t.v7_relativeSplatPath));return l.useMemo(()=>bu(e,JSON.parse(i),a,n==="path"),[e,i,a,n])}function iz(e,o,n,t){Fr()||G(!1);let{navigator:r}=l.useContext($n),{matches:a}=l.useContext(Wo),i=a[a.length-1],c=i?i.params:{};i&&i.pathname;let s=i?i.pathnameBase:"/";i&&i.route;let u=gi(),d;d=u;let p=d.pathname||"/",v=p;if(s!=="/"){let b=s.replace(/^\//,"").split("/");v="/"+p.replace(/^\//,"").split("/").slice(b.length).join("/")}let y=dt(e,{pathname:v});return dz(y&&y.map(b=>Object.assign({},b,{params:Object.assign({},c,b.params),pathname:Lo([s,r.encodeLocation?r.encodeLocation(b.pathname).pathname:b.pathname]),pathnameBase:b.pathnameBase==="/"?s:Lo([s,r.encodeLocation?r.encodeLocation(b.pathnameBase).pathname:b.pathnameBase])})),a,n,t)}function cz(){let e=kz(),o=hu(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,r={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return l.createElement(l.Fragment,null,l.createElement("h2",null,"Unexpected Application Error!"),l.createElement("h3",{style:{fontStyle:"italic"}},o),n?l.createElement("pre",{style:r},n):null,null)}const sz=l.createElement(cz,null);class uz extends l.Component{constructor(o){super(o),this.state={location:o.location,revalidation:o.revalidation,error:o.error}}static getDerivedStateFromError(o){return{error:o}}static getDerivedStateFromProps(o,n){return n.location!==o.location||n.revalidation!=="idle"&&o.revalidation==="idle"?{error:o.error,location:o.location,revalidation:o.revalidation}:{error:o.error!==void 0?o.error:n.error,location:n.location,revalidation:o.revalidation||n.revalidation}}componentDidCatch(o,n){console.error("React Router caught the following error during render",o,n)}render(){return this.state.error!==void 0?l.createElement(Wo.Provider,{value:this.props.routeContext},l.createElement(jm.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function lz(e){let{routeContext:o,match:n,children:t}=e,r=l.useContext(ji);return r&&r.static&&r.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(r.staticContext._deepestRenderedBoundaryId=n.route.id),l.createElement(Wo.Provider,{value:o},t)}function dz(e,o,n,t){var r;if(o===void 0&&(o=[]),n===void 0&&(n=null),t===void 0&&(t=null),e==null){var a;if((a=n)!=null&&a.errors)e=n.matches;else return null}let i=e,c=(r=n)==null?void 0:r.errors;if(c!=null){let d=i.findIndex(p=>p.route.id&&(c==null?void 0:c[p.route.id])!==void 0);d>=0||G(!1),i=i.slice(0,Math.min(i.length,d+1))}let s=!1,u=-1;if(n&&t&&t.v7_partialHydration)for(let d=0;d<i.length;d++){let p=i[d];if((p.route.HydrateFallback||p.route.hydrateFallbackElement)&&(u=d),p.route.id){let{loaderData:v,errors:y}=n,z=p.route.loader&&v[p.route.id]===void 0&&(!y||y[p.route.id]===void 0);if(p.route.lazy||z){s=!0,u>=0?i=i.slice(0,u+1):i=[i[0]];break}}}return i.reduceRight((d,p,v)=>{let y,z=!1,b=null,N=null;n&&(y=c&&p.route.id?c[p.route.id]:void 0,b=p.route.errorElement||sz,s&&(u<0&&v===0?(fz("route-fallback"),z=!0,N=null):u===v&&(z=!0,N=p.route.hydrateFallbackElement||null)));let k=o.concat(i.slice(0,v+1)),m=()=>{let f;return y?f=b:z?f=N:p.route.Component?f=l.createElement(p.route.Component,null):p.route.element?f=p.route.element:f=d,l.createElement(lz,{match:p,routeContext:{outlet:d,matches:k,isDataRoute:n!=null},children:f})};return n&&(p.route.ErrorBoundary||p.route.errorElement||v===0)?l.createElement(uz,{location:n.location,revalidation:n.revalidation,component:b,error:y,children:m(),routeContext:{outlet:null,matches:k,isDataRoute:!0}}):m()},null)}var Sm=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(Sm||{}),ni=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(ni||{});function pz(e){let o=l.useContext(ji);return o||G(!1),o}function vz(e){let o=l.useContext(zm);return o||G(!1),o}function mz(e){let o=l.useContext(Wo);return o||G(!1),o}function Pm(e){let o=mz(),n=o.matches[o.matches.length-1];return n.route.id||G(!1),n.route.id}function kz(){var e;let o=l.useContext(jm),n=vz(ni.UseRouteError),t=Pm(ni.UseRouteError);return o!==void 0?o:(e=n.errors)==null?void 0:e[t]}function bz(){let{router:e}=pz(Sm.UseNavigateStable),o=Pm(ni.UseNavigateStable),n=l.useRef(!1);return gm(()=>{n.current=!0}),l.useCallback(function(r,a){a===void 0&&(a={}),n.current&&(typeof r=="number"?e.navigate(r):e.navigate(r,oi({fromRouteId:o},a)))},[e,o])}const md={};function fz(e,o,n){md[e]||(md[e]=!0)}function hz(e){return az(e.context)}function yz(e){let{basename:o="/",children:n=null,location:t,navigationType:r=be.Pop,navigator:a,static:i=!1,future:c}=e;Fr()&&G(!1);let s=o.replace(/^\/*/,"/"),u=l.useMemo(()=>({basename:s,navigator:a,static:i,future:oi({v7_relativeSplatPath:!1},c)}),[s,c,a,i]);typeof t=="string"&&(t=Ho(t));let{pathname:d="/",search:p="",hash:v="",state:y=null,key:z="default"}=t,b=l.useMemo(()=>{let N=Rt(d,s);return N==null?null:{location:{pathname:N,search:p,hash:v,state:y,key:z},navigationType:r}},[s,d,p,v,y,z,r]);return b==null?null:l.createElement($n.Provider,{value:u},l.createElement(ju.Provider,{children:n,value:b}))}new Promise(()=>{});function zz(e){let o={hasErrorBoundary:e.ErrorBoundary!=null||e.errorElement!=null};return e.Component&&Object.assign(o,{element:l.createElement(e.Component),Component:void 0}),e.HydrateFallback&&Object.assign(o,{hydrateFallbackElement:l.createElement(e.HydrateFallback),HydrateFallback:void 0}),e.ErrorBoundary&&Object.assign(o,{errorElement:l.createElement(e.ErrorBoundary),ErrorBoundary:void 0}),o}/**
 * React Router DOM v6.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Ar(){return Ar=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},Ar.apply(this,arguments)}function jz(e,o){if(e==null)return{};var n={},t=Object.keys(e),r,a;for(a=0;a<t.length;a++)r=t[a],!(o.indexOf(r)>=0)&&(n[r]=e[r]);return n}function gz(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function Nz(e,o){return e.button===0&&(!o||o==="_self")&&!gz(e)}const Tz=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"],Sz="6";try{window.__reactRouterVersion=Sz}catch{}function Pz(e,o){return Dy({basename:o==null?void 0:o.basename,future:Ar({},o==null?void 0:o.future,{v7_prependBasename:!0}),history:iy({window:o==null?void 0:o.window}),hydrationData:(o==null?void 0:o.hydrationData)||xz(),routes:e,mapRouteProperties:zz,unstable_dataStrategy:o==null?void 0:o.unstable_dataStrategy,window:o==null?void 0:o.window}).initialize()}function xz(){var e;let o=(e=window)==null?void 0:e.__staticRouterHydrationData;return o&&o.errors&&(o=Ar({},o,{errors:wz(o.errors)})),o}function wz(e){if(!e)return null;let o=Object.entries(e),n={};for(let[t,r]of o)if(r&&r.__type==="RouteErrorResponse")n[t]=new fu(r.status,r.statusText,r.data,r.internal===!0);else if(r&&r.__type==="Error"){if(r.__subType){let a=window[r.__subType];if(typeof a=="function")try{let i=new a(r.message);i.stack="",n[t]=i}catch{}}if(n[t]==null){let a=new Error(r.message);a.stack="",n[t]=a}}else n[t]=r;return n}const Cz=l.createContext({isTransitioning:!1}),Ez=l.createContext(new Map),Mz="startTransition",kd=Jd[Mz],Oz="flushSync",bd=mh[Oz];function Rz(e){kd?kd(e):e()}function er(e){bd?bd(e):e()}class Az{constructor(){this.status="pending",this.promise=new Promise((o,n)=>{this.resolve=t=>{this.status==="pending"&&(this.status="resolved",o(t))},this.reject=t=>{this.status==="pending"&&(this.status="rejected",n(t))}})}}function Iz(e){let{fallbackElement:o,router:n,future:t}=e,[r,a]=l.useState(n.state),[i,c]=l.useState(),[s,u]=l.useState({isTransitioning:!1}),[d,p]=l.useState(),[v,y]=l.useState(),[z,b]=l.useState(),N=l.useRef(new Map),{v7_startTransition:k}=t||{},m=l.useCallback(h=>{k?Rz(h):h()},[k]),f=l.useCallback((h,C)=>{let{deletedFetchers:V,unstable_flushSync:R,unstable_viewTransitionOpts:Z}=C;V.forEach(oe=>N.current.delete(oe)),h.fetchers.forEach((oe,ve)=>{oe.data!==void 0&&N.current.set(ve,oe.data)});let F=n.window==null||n.window.document==null||typeof n.window.document.startViewTransition!="function";if(!Z||F){R?er(()=>a(h)):m(()=>a(h));return}if(R){er(()=>{v&&(d&&d.resolve(),v.skipTransition()),u({isTransitioning:!0,flushSync:!0,currentLocation:Z.currentLocation,nextLocation:Z.nextLocation})});let oe=n.window.document.startViewTransition(()=>{er(()=>a(h))});oe.finished.finally(()=>{er(()=>{p(void 0),y(void 0),c(void 0),u({isTransitioning:!1})})}),er(()=>y(oe));return}v?(d&&d.resolve(),v.skipTransition(),b({state:h,currentLocation:Z.currentLocation,nextLocation:Z.nextLocation})):(c(h),u({isTransitioning:!0,flushSync:!1,currentLocation:Z.currentLocation,nextLocation:Z.nextLocation}))},[n.window,v,d,N,m]);l.useLayoutEffect(()=>n.subscribe(f),[n,f]),l.useEffect(()=>{s.isTransitioning&&!s.flushSync&&p(new Az)},[s]),l.useEffect(()=>{if(d&&i&&n.window){let h=i,C=d.promise,V=n.window.document.startViewTransition(async()=>{m(()=>a(h)),await C});V.finished.finally(()=>{p(void 0),y(void 0),c(void 0),u({isTransitioning:!1})}),y(V)}},[m,i,d,n.window]),l.useEffect(()=>{d&&i&&r.location.key===i.location.key&&d.resolve()},[d,v,r.location,i]),l.useEffect(()=>{!s.isTransitioning&&z&&(c(z.state),u({isTransitioning:!0,flushSync:!1,currentLocation:z.currentLocation,nextLocation:z.nextLocation}),b(void 0))},[s.isTransitioning,z]),l.useEffect(()=>{},[]);let T=l.useMemo(()=>({createHref:n.createHref,encodeLocation:n.encodeLocation,go:h=>n.navigate(h),push:(h,C,V)=>n.navigate(h,{state:C,preventScrollReset:V==null?void 0:V.preventScrollReset}),replace:(h,C,V)=>n.navigate(h,{replace:!0,state:C,preventScrollReset:V==null?void 0:V.preventScrollReset})}),[n]),x=n.basename||"/",O=l.useMemo(()=>({router:n,navigator:T,static:!1,basename:x}),[n,T,x]);return l.createElement(l.Fragment,null,l.createElement(ji.Provider,{value:O},l.createElement(zm.Provider,{value:r},l.createElement(Ez.Provider,{value:N.current},l.createElement(Cz.Provider,{value:s},l.createElement(yz,{basename:x,location:r.location,navigationType:r.historyAction,navigator:T,future:{v7_relativeSplatPath:n.future.v7_relativeSplatPath}},r.initialized||n.future.v7_partialHydration?l.createElement(Vz,{routes:n.routes,future:n.future,state:r}):o))))),null)}function Vz(e){let{routes:o,future:n,state:t}=e;return iz(o,void 0,t,n)}const Dz=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",Lz=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,pt=l.forwardRef(function(o,n){let{onClick:t,relative:r,reloadDocument:a,replace:i,state:c,target:s,to:u,preventScrollReset:d,unstable_viewTransition:p}=o,v=jz(o,Tz),{basename:y}=l.useContext($n),z,b=!1;if(typeof u=="string"&&Lz.test(u)&&(z=u,Dz))try{let f=new URL(window.location.href),T=u.startsWith("//")?new URL(f.protocol+u):new URL(u),x=Rt(T.pathname,y);T.origin===f.origin&&x!=null?u=x+T.search+T.hash:b=!0}catch{}let N=oz(u,{relative:r}),k=Uz(u,{replace:i,state:c,target:s,preventScrollReset:d,relative:r,unstable_viewTransition:p});function m(f){t&&t(f),f.defaultPrevented||k(f)}return l.createElement("a",Ar({},v,{href:z||N,onClick:b||a?t:m,ref:n,target:s}))});var fd;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(fd||(fd={}));var hd;(function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"})(hd||(hd={}));function Uz(e,o){let{target:n,replace:t,state:r,preventScrollReset:a,relative:i,unstable_viewTransition:c}=o===void 0?{}:o,s=nz(),u=gi(),d=Tm(e,{relative:i});return l.useCallback(p=>{if(Nz(p,n)){p.preventDefault();let v=t!==void 0?t:Un(u)===Un(d);s(e,{replace:v,state:r,preventScrollReset:a,relative:i,unstable_viewTransition:c})}},[u,s,d,t,r,n,e,a,i,c])}function _z(){return g.jsxs(g.Fragment,{children:[g.jsxs("header",{className:"px-4 py-1 flex justify-between items-center",children:[g.jsx(pt,{to:"/",children:g.jsxs("h1",{className:"text-3xl font-bold",children:["PB152",g.jsx("span",{className:"text-xl font-light",children:"drill"})]})}),g.jsxs("div",{className:"flex gap-1 items-center",children:[g.jsx(pt,{to:"/about",children:g.jsx(Vo,{variant:"ghost",children:"O nás"})}),g.jsx("div",{className:"h-6 w-[0.1rem] bg-border rounded-full"}),g.jsx("a",{href:"https://github.com/tomz197/os-drill",target:"_blank",children:g.jsx(Vo,{variant:"ghost",size:"icon",children:g.jsx(Ql,{})})})]})]}),g.jsx("div",{className:"h-[0.1rem] w-full bg-border rounded-full"}),g.jsx("main",{className:"p-4 f slex flex-1 flex-col gap-2",children:g.jsx(hz,{})}),g.jsx("div",{className:"h-[0.1rem] w-full bg-border rounded-full"}),g.jsxs("footer",{className:"p-4 flex justify-center gap-2",children:[g.jsxs("a",{href:"https://github.com/tomz197/os-drill",target:"_blank",className:"text-grey-400 hover:text-blue-500 flex items-center gap-1",children:["Github",g.jsx(Ql,{className:"w-5 h-5 inline"})]}),g.jsx("div",{className:"h-6 w-[0.1rem] bg-border rounded-full"}),g.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"text-grey-400 hover:text-blue-500 flex items-center gap-1",target:"_blank",children:["Discord",g.jsx(lm,{className:"w-6 h-6 stroke-[1.5] inline"})]})]})]})}const At=[{uuid:"95bb68e1-4510-4a5e-9c7f-ae982661c1f8",sectionNumber:"0",sectionTitle:"B. Základní pojmy a definice",statements:[{uuid:"956b03dc-986f-4604-87e2-0e987af3b4ca",correct:"Abstrakce v operačních systémech umožňuje stavět rozsáhlé systémy skrytím implementačních detailů.",incorrect:"Abstrakce v operačních systémech vyžaduje znalost všech implementačních detailů pro stavbu rozsáhlých systémů.",sectionNumber:"0.1.1",sectionTitle:"Co je abstrakce?"},{uuid:"37a4399d-c091-49ac-b34d-e77743e8063f",correct:"Pro abstrakci je klíčové znát vnější chování systému, zatímco vnitřní struktura může zůstat skryta.",incorrect:"Pro abstrakci je klíčové znát vnější i vnitřní chování a strukturu systému detailně.",sectionNumber:"0.1.1",sectionTitle:"Co je abstrakce?"},{uuid:"77fe023f-570c-42ff-ba5b-767ff80f6d9e",correct:"Modul je základní jednotkou abstrakce v software, oddělující rozhraní od implementace.",incorrect:"Modul je základní jednotkou implementace v software, oddělující rozhraní od abstrakce.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"cfbba433-a623-453a-ae1b-c741b89c8624",correct:"Modularita systému umožňuje výměnu modulu za jiný se stejným vnějším chováním.",incorrect:"Modularita systému vyžaduje výměnu modulu za jiný s odlišným vnějším chováním.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"0830ecab-2480-48a9-a67d-671b90118e43",correct:'Abstrakce modulu "propouští", když se vnitřní detaily projevují navenek.',incorrect:'Abstrakce modulu nikdy "nepropouští" a vnitřní detaily se nikdy neprojevují navenek.',sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"3159fe5a-c613-4266-882a-2da2e556e1b1",correct:"Při porušení modularity, výměna modulu vyžaduje úpravu dalších modulů.",incorrect:"Při porušení modularity, výměna modulu nevyžaduje úpravu žádných dalších modulů.",sectionNumber:"0.1.2",sectionTitle:"Modul"},{uuid:"8654feed-9fd7-4dda-a2e6-b8ba91383288",correct:"Von Neumannova architektura popisuje počítač s jednotným vnějším chováním, nezávisle na výrobci komponent.",incorrect:"Von Neumannova architektura popisuje počítač s proměnlivým vnějším chováním, v závislosti na výrobci komponent.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"c3f5999d-680c-40af-90f2-3797059264ca",correct:"Výpočetní jednotka, procesor, vykonává instrukce, které jsou uloženy v operační paměti.",incorrect:"Výpočetní jednotka, procesor, vykonává instrukce, které jsou uloženy ve vyrovnávací paměti.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"3d9c7d51-626a-4d7a-b59b-c65e7f3c612b",correct:"Operační paměť ve von Neumannově architektuře je adresovatelná a skládá se z očíslovaných buněk.",incorrect:"Operační paměť ve von Neumannově architektuře není adresovatelná a skládá se z neuspořádaných buněk.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"60b2b654-199f-4312-9fac-66650001c2bf",correct:"Každá buňka v operační paměti von Neumannovy architektury typicky uchovává jeden byte dat.",incorrect:"Každá buňka v operační paměti von Neumannovy architektury typicky uchovává jeden bit dat.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"f13f9d46-c538-4be8-a1e9-96ea6fd70101",correct:"Instrukce mohou vyžádat načtení dat z libovolně vypočtené adresy, což odlišuje paměť od registrů.",incorrect:"Instrukce mohou vyžádat načtení dat pouze z pevných adres, což odlišuje paměť od registrů.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"f28299a6-fe2b-4ac8-91e3-7908ce8401ab",correct:"Registry se odlišují od operační paměti tím, že mají pevná jména, nikoliv adresy.",incorrect:"Registry se odlišují od operační paměti tím, že mají proměnlivá jména, podobně jako proměnné.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"6fa471c7-9988-4462-ac21-b4b859df57e4",correct:"Pro zjednodušení se v kontextu von Neumannova modelu program považuje za neměnný.",incorrect:"Pro zjednodušení se v kontextu von Neumannova modelu program považuje za dynamicky modifikovatelný.",sectionNumber:"0.2.1",sectionTitle:"Počítač"},{uuid:"60f28404-7d12-44e4-92d8-74b541e9bb54",correct:"Periferie slouží k příjmu a odesílání dat, která jsou reprezentována jako sekvence čísel.",incorrect:"Periferie slouží pouze k odesílání dat, která jsou reprezentována jako slova.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"c4769bbe-9361-4208-b250-01db23e1dcc8",correct:"Data pro periferie jsou výsledkem výpočtu, zatímco data z periferií jsou vstupem pro výpočet.",incorrect:"Data pro periferie i data z periferií jsou vždy výsledkem výpočtu.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"9ac086be-94e3-4388-a8ad-577f28b221df",correct:"Veškerá činnost programu sestává z manipulace s čísly, což je v podstatě výpočet.",incorrect:"Některé činnosti programu, jako kreslení obrázků, nejsou považovány za výpočet.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"1fff4f0d-0d58-4229-adc8-eed82f9084d8",correct:"Program je abstrakce, která popisuje sekvenci instrukcí pro výpočet a zahrnuje synchronizaci s periferiemi.",incorrect:"Program je abstrakce, která popisuje pouze sekvenci instrukcí pro výpočet a nezahrnuje synchronizaci s periferiemi.",sectionNumber:"0.2.2",sectionTitle:"Periferie"},{uuid:"1d2f23cb-6eb0-44bb-8c13-815408e9c4a1",correct:"Operační systém a hardware společně realizují virtualizaci výpočetních zdrojů.",incorrect:"Pouze operační systém realizuje virtualizaci výpočetních zdrojů, hardware se na ní nepodílí.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"05ade31c-019c-4b8a-af17-a43c66daef0e",correct:"Virtualizace umožňuje, aby programy pracovaly, jako kdyby měly svůj vlastní počítač.",incorrect:"Virtualizace nutí programy pracovat sdíleně na jednom virtuálním počítači.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"e7c03c66-95f3-4390-99fd-b96910cdbdc5",correct:"Úkolem virtualizace je vytvořit několik nezávislých virtuálních kopií jednoho fyzického zařízení.",incorrect:"Úkolem virtualizace je sdílet jeden fyzický počítač mezi více programy.",sectionNumber:"0.2.3",sectionTitle:"Virtualizace"},{uuid:"b9352630-77b0-426e-96b2-5a202eb711fd",correct:"Události, které nejsou uspořádané relací předcházení, jsou považovány za souběžné.",incorrect:"Události, které jsou uspořádané relací předcházení, jsou považovány za souběžné.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"7e0c57b2-30df-44b8-a71d-4e1448122dcc",correct:"Relace předcházení definuje chronologické uspořádání událostí, popisující, která událost nastala dříve.",incorrect:"Relace předcházení definuje časové trvání událostí, popisující, jak dlouho událost trvala.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"c27c6d93-86fd-4596-b298-16876e925ccd",correct:"Pokud událost A nepředchází událost B a událost B nepředchází událost A, pak jsou události A a B souběžné.",incorrect:"Pokud událost A předchází událost B a událost B předchází událost A, pak jsou události A a B souběžné.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"db1f5212-6c38-4248-8138-bb34ba7f012e",correct:"V množině událostí U = {A, B, X, Y} s relací předcházení P = {(A, X), (X, B), (A, Y), (Y, B)} jsou události X a Y souběžné.",incorrect:"V množině událostí U = {A, B, X, Y} s relací předcházení P = {(A, X), (X, B), (A, Y), (Y, B)} jsou události X a B souběžné.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"6d75d5f7-9b29-48ba-9275-88c7bf095176",correct:"Vnější chování modulu v operačním systému závisí na relaci předcházení událostí, nikoliv na přesném časování.",incorrect:"Vnější chování modulu v operačním systému závisí na přesném časovém rozložení jednotlivých událostí.",sectionNumber:"0.3.1",sectionTitle:"Událost a předcházení"},{uuid:"4ae0eb2a-aaab-43ff-92b3-c6f42eaf93e9",correct:"Časový sled událostí představuje lineární uspořádání událostí, kde pro každou dvojici událostí platí, že jedna předchází druhou.",incorrect:"Časový sled událostí představuje nelineární uspořádání událostí, kde pro každou dvojici událostí platí, že jedna předchází druhou.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"d3d5ef7b-6259-4c59-898f-8fdb8d696774",correct:"Časový sled událostí lze chápat jako přidělení časových razítek událostem tak, že žádné dvě události nenastanou ve stejný okamžik.",incorrect:"Časový sled událostí nelze chápat jako přidělení časových razítek událostem tak, že žádné dvě události nenastanou ve stejný okamžik.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"c066cb52-2599-48b5-af79-85a29d67635b",correct:"Hazard souběhu nastává, pokud se vnější chování systému liší v různých časových sledech, které jsou konzistentní s relací předcházení.",incorrect:"Hazard souběhu nastává, pokud se vnější chování systému neliší v různých časových sledech, které jsou konzistentní s relací předcházení.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"e6008e07-13e8-4c7f-bb0b-967007da14c0",correct:"Pojem hazard souběhu označuje situaci, kdy různé platné časové sledy, kompatibilní s relací předcházení, vedou k rozdílným výsledkům.",incorrect:"Pojem hazard souběhu označuje situaci, kdy různé platné časové sledy, nekompatibilní s relací předcházení, vedou k rozdílným výsledkům.",sectionNumber:"0.3.2",sectionTitle:"Časový sled, hazard souběhu"},{uuid:"c8a07608-6c2a-4f8b-aaab-32ef78e69205",correct:"Operační systém zprostředkovává aplikacím přístup k hardwarovým i softwarovým zdrojům počítače.",incorrect:"Operační systém zprostředkovává aplikacím přístup pouze k hardwarovým zdrojům a nikoliv softwarovým.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"33d55748-603d-4e55-b7a6-7ba2cf21ad3d",correct:"Víceúlohový operační systém umožňuje současný běh několika uživatelských programů na jednom počítači.",incorrect:"Víceúlohový operační systém neumožňuje běh více uživatelských programů současně.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"851fabb5-edcf-4c44-8aa8-faf9370ae7be",correct:"Operační systém poskytuje izolaci běžících programů, aby se vzájemně nemohly narušovat.",incorrect:"Operační systém nezajišťuje izolaci běžících programů, které se tak mohou vzájemně ovlivňovat.",sectionNumber:"0.4.1",sectionTitle:"Vnější rozhraní"},{uuid:"c4e249b9-36e7-4088-b46c-a9f6bee2d297",correct:"POSIX je standardizované rozhraní pro víceúlohové a víceuživatelské operační systémy.",incorrect:"POSIX je standardizované rozhraní pouze pro jednoúlohové operační systémy.",sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"3ccd5b03-2624-4791-a9f3-f73821e02849",correct:"Standard POSIX popisuje aplikační programovací rozhraní (API) v jazyce C.",incorrect:"Standard POSIX popisuje aplikační programovací rozhraní (API) v jazyce Java.",sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"66b2e7db-1746-4cfe-93d6-612712a4c451",correct:"Standardizaci POSIX provedla organizace The Open Group.",incorrect:"Standardizaci POSIX provedla organizace IEEE.",sectionNumber:"0.4.2",sectionTitle:"POSIX"},{uuid:"6552e5a9-3169-41e2-a911-1deb06fe4dc7",correct:"Běžný návrh operačního systému se skládá z jádra a uživatelského prostoru.",incorrect:"Běžný návrh operačního systému se skládá pouze z uživatelského prostoru.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"39953053-12c9-4aad-af09-fab92fb94039",correct:"Jádro operačního systému má privilegovaný přístup k hardwarovým zdrojům, zejména k procesoru.",incorrect:"Uživatelský prostor operačního systému má privilegovaný přístup k hardwarovým zdrojům.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"7e6cd78d-60ab-450f-8727-e750df78cdd0",correct:"Jádro operačního systému řídí virtualizaci zdrojů, jako je přidělování paměti a procesoru.",incorrect:"Uživatelské programy řídí virtualizaci hardwarových zdrojů operačního systému.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"bf056675-3f43-4e39-a5e5-349738830de6",correct:"Jádro operačního systému funguje jako strážce integrity systému tím, že kontroluje přístup uživatelských procesů.",incorrect:"Uživatelské procesy fungují jako strážce integrity systému, nezávisle na jádru operačního systému.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"5526b55a-8efa-425a-84fa-2d0e171fa3c3",correct:"Operační systémy bez jádra jsou v současnosti považovány za vzácné a okrajové v kontextu výuky.",incorrect:"Operační systémy bez jádra jsou v současnosti běžnější než systémy s jádrem v praxi.",sectionNumber:"0.4.3",sectionTitle:"Jádro"},{uuid:"494270d5-bc91-4dcc-8804-e4d22353ddf7",correct:"Virtualizace operačního systému umožňuje provozovat více instancí operačního systému na jednom fyzickém počítači.",incorrect:"Virtualizace operačního systému omezuje provozování více instancí operačního systému na jednom fyzickém počítači.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"139c34b4-1d34-4516-a0b3-0e356ffd0c2b",correct:"Virtualizace operačního systému poskytuje silnější izolaci mezi úlohami než standardní procesy sdílející stejný operační systém.",incorrect:"Virtualizace operačního systému poskytuje slabší izolaci mezi úlohami než standardní procesy sdílející stejný operační systém.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"6be3ed3b-23d2-4ac4-ade3-52306ed0da4e",correct:"Jedním z hlavních důvodů virtualizace operačních systémů je zjednodušení správy a organizace počítačových systémů.",incorrect:"Zjednodušení správy a organizace počítačových systémů není považováno za důvod pro virtualizaci operačních systémů.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"b08b50d2-3cc4-43de-a856-b9692c6510f8",correct:"Díky virtualizaci operačních systémů je možná migrace, včetně živé migrace běžícího operačního systému na jiný hardware.",incorrect:"Virtualizace operačních systémů neumožňuje migraci, ani živou migraci běžícího operačního systému na jiný hardware.",sectionNumber:"0.4.4",sectionTitle:"Virtualizace OS"},{uuid:"1d79d84b-bde6-46d2-8e73-2f77dcf2f95f",correct:"Abstrakce hardwaru a modularita systému usnadňují přenos operačního systému na jiný hardware.",incorrect:"Abstrakce hardwaru nemá vliv na přenositelnost operačního systému mezi různými hardwarovými platformami.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"},{uuid:"46693132-5d2c-4f32-b427-80711045abe5",correct:"Pro aplikační software operační systém vytváří abstrakční rozhraní, které podporuje jeho přenositelnost mezi systémy.",incorrect:"Aplikační software je přenositelný mezi operačními systémy i bez abstrakčního rozhraní poskytovaného operačním systémem.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"},{uuid:"05f269b4-2e2a-4685-9129-d6f4db80bbb7",correct:"Přenositelnost aplikačního software je omezena využitím vlastností specifických pro daný operační systém.",incorrect:"Přenositelnost aplikačního software mezi operačními systémy není ovlivněna využitím specifických vlastností operačního systému.",sectionNumber:"0.4.5",sectionTitle:"Přenositelnost"}]},{uuid:"73c45141-9794-451f-b11d-8b36598420f5",sectionNumber:"1",sectionTitle:"Virtualizace paměti",statements:[{uuid:"41a737a1-037a-4d2d-af1e-1942f509bacc",correct:"Program interaguje s pamětí použitím instrukcí ld a st.",incorrect:"Program interaguje s pamětí výhradně instrukcí ld.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"4a56642c-8857-4e72-9bb9-259a1a1d0026",correct:"Instrukce ld načítá data z paměti určené adresou v registru do cílového registru.",incorrect:"Instrukce ld načítá data přímo z registru do paměti.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"a07ff963-d10b-4c83-b6e4-8d958df65ebc",correct:"Adresa paměti pro instrukce ld a st je číselná hodnota uložená v registru.",incorrect:"Adresa paměti pro ld a st je symbolický název.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"c4486a58-4f7f-406b-99fe-7db5a0c18d24",correct:"Složitější instrukce procesoru lze vždy rozdělit na sekvenci instrukcí ld, výpočetních a st.",incorrect:"Některé instrukce procesoru nelze rozdělit na ld, výpočetní a st instrukce.",sectionNumber:"1.1.1",sectionTitle:"Přístup k paměti"},{uuid:"66a204ef-d78a-4fa2-a49c-c690678723f3",correct:"Adresní prostor se obvykle skládá ze souvislých bloků adres.",incorrect:"Adresní prostor se nikdy neskládá ze souvislých bloků adres.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"4fa8af70-62f9-4b50-a42e-30dfb0c39f3c",correct:"Každá adresa v typickém adresním prostoru odpovídá právě jednomu bajtu dat.",incorrect:"Každá adresa v typickém adresním prostoru odpovídá právě dvěma bajtům dat.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"49abd2d1-f845-4bf4-8b07-54e802d02562",correct:"Ne každé číslo reprezentuje platnou adresu v adresním prostoru.",incorrect:"Každé číslo reprezentuje platnou adresu v adresním prostoru.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"4206b23d-4857-48cf-813f-c2f1873f1b0d",correct:"Pro uložení většího objektu je potřeba několik sousedních adres.",incorrect:"Pro uložení většího objektu stačí pouze jedna adresa.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"54ff93f4-777b-42f6-afb5-a1afb45c568f",correct:"Adresa 0x010030 je platná adresa v uvedeném příkladu adresního prostoru.",incorrect:"Adresa 0x000050 je platná adresa v uvedeném příkladu adresního prostoru.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"a6ac0fed-cbe3-4d7b-a86e-e8d0985a120c",correct:"Čtyřbajtové slovo lze uložit na adresu 0x010030 v uvedeném adresním prostoru.",incorrect:"Čtyřbajtové slovo nelze uložit na adresu 0x01fffd v uvedeném adresním prostoru.",sectionNumber:"1.1.2",sectionTitle:"Adresní prostor"},{uuid:"20aeff10-b2a4-4814-af7f-f25d2e3b712b",correct:"Adresní prostor programu obvykle zahrnuje sekce pro kód, data a zásobník.",incorrect:"Adresní prostor programu obvykle zahrnuje pouze sekce pro kód a dočasná data.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"5aea504c-dc94-4797-9abe-f6a213b4c369",correct:"Zásobník v adresním prostoru slouží k ukládání informací o aktivních podprogramech.",incorrect:"Zásobník v adresním prostoru slouží výhradně k ukládání statických dat programu.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"19778e88-1ecc-4bc1-8830-39495fc00a05",correct:"Adresní prostor procesu může být dynamický a umožňovat změny velikosti za běhu programu.",incorrect:"Adresní prostor procesu je statický a jeho velikost je pevně daná při spuštění programu.",sectionNumber:"1.1.3",sectionTitle:"Paměť programu"},{uuid:"6bd80b68-f1d5-4533-b619-8649c0474161",correct:"Fyzické adresy přímo pojmenovávají fyzické paměťové buňky hardwarových zařízení, zejména RAM.",incorrect:"Fyzické adresy nepřímo pojmenovávají logické paměťové buňky softwarových zařízení, zejména ROM.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"4da1da6b-98a2-4ad0-8ba3-2d5bc8b4d9c7",correct:"Většina fyzických adres v typickém počítači odpovídá buňkám operační paměti RAM.",incorrect:"Většina fyzických adres v typickém počítači odpovídá buňkám permanentní paměti ROM.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"4be1a9b2-7b44-4e84-9d11-22d703e2a0c8",correct:"Některé fyzické adresy mohou patřit periferiím, jako jsou grafické nebo síťové karty.",incorrect:"Fyzické adresy mohou patřit pouze operační paměti RAM, nikdy ne periferiím.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"88b8cbaa-19a8-418c-8f4e-4e054a0d4b00",correct:"Bloky fyzických adres, které nepatří RAM, obvykle nelze používat pro pracovní data výpočtů.",incorrect:"Bloky fyzických adres, které nepatří RAM, se běžně používají pro ukládání pracovních dat programů.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"9fec3f7f-b9dc-4a10-9629-cb9913f6053c",correct:"Operační paměť RAM slouží především k ukládání pracovních dat programů v klasickém smyslu.",incorrect:"Operační paměť RAM slouží především k ukládání instrukcí operačního systému a metadat.",sectionNumber:"1.1.4",sectionTitle:"Fyzická paměť"},{uuid:"773d5293-ba31-44ae-a86f-c34b6bf61b5d",correct:"V principu je možné, aby programy pracovaly s pamětí přímo s fyzickými adresami.",incorrect:"V principu není možné, aby programy pracovaly s pamětí přímo s fyzickými adresami.",sectionNumber:"1.2.1",sectionTitle:"Motivace"},{uuid:"e63741d3-9e6a-4a25-9f11-d277cca08119",correct:"Spuštění více programů současně vyžaduje koordinaci fyzických adres kvůli potenciálním konfliktům.",incorrect:"Spuštění více programů současně nevyžaduje koordinaci fyzických adres a nezpůsobuje konflikty.",sectionNumber:"1.2.1",sectionTitle:"Motivace"},{uuid:"42efd9d1-f816-441c-b905-2c80979f21a9",correct:"Virtuální adresní prostory jsou pro programy odděleny od fyzických adresních prostorů.",incorrect:"Virtuální adresní prostory jsou pro programy totožné s fyzickými adresními prostory.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"078a1566-857b-46b3-9667-ed7551481807",correct:"Fyzický adresní prostor je pro běžné uživatelské programy zcela nepřístupný.",incorrect:"Fyzický adresní prostor je pro běžné uživatelské programy plně přístupný.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"e2ea115c-9cab-4775-a0f3-14fc07a326b1",correct:"Virtuálních adresních prostorů může existovat v počítači rovnou několik.",incorrect:"V počítači existuje vždy pouze jeden virtuální adresní prostor.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"f527fbaf-81b6-4603-b88e-0017de944e30",correct:"Adresa 0x0100 ve dvou různých virtuálních prostorech jsou považovány za různé virtuální adresy.",incorrect:"Adresa 0x0100 ve dvou různých virtuálních prostorech jsou považovány za stejné virtuální adresy.",sectionNumber:"1.2.2",sectionTitle:"Virtuální a fyzické adresy"},{uuid:"a6dcc6b9-8eb8-480e-8301-82b0743c789b",correct:"Fyzická buňka má právě jednu fyzickou adresu, ale může mít více virtuálních adres.",incorrect:"Fyzická buňka má vždy právě jednu fyzickou adresu a může mít pouze jednu virtuální adresu.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"2bfe562b-10db-460a-9e00-1f0df26920e6",correct:"Virtuální adresní prostory umožňují oddělit programy tak, aby nesdílely stejné fyzické buňky.",incorrect:"Virtuální adresní prostory jsou primárně určeny pro zvýšení rychlosti přístupu k fyzické paměti.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"dfe6d25a-e941-41e7-a5bd-7d0685ab539d",correct:"Jedna fyzická paměťová buňka může být mapována do více virtuálních adres v různých adresních prostorech.",incorrect:"Jedna fyzická paměťová buňka může být mapována pouze do jedné virtuální adresy, a to bez ohledu na adresní prostor.",sectionNumber:"1.2.3",sectionTitle:"Překlad adres"},{uuid:"3a59bc28-b760-4cab-a6cc-e5a567546e0c",correct:"Překlad adres musí být rychlý a je realizován specializovaným hardwarem v CPU.",incorrect:"Překlad adres může být pomalý a je realizován softwarem v operačním systému.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"6605fcc6-4ac1-43fa-9a41-a3ebd375f993",correct:"Jednotka správy paměti je programovatelná překladovými tabulkami a řízena jádrem OS.",incorrect:"Jednotka správy paměti není programovatelná a není řízena jádrem OS.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"b26d5a92-5fd1-4f8a-aeb0-1340cf25bb58",correct:"Virtuální adresa musí být přeložena na fyzickou adresu před přístupem do paměti.",incorrect:"Fyzická adresa musí být přeložena na virtuální adresu před přístupem do paměti.",sectionNumber:"1.2.4",sectionTitle:"Jednotka správy paměti"},{uuid:"cb01b040-f7f8-48b0-8727-12149c5024db",correct:"Stránky virtuální paměti představují bloky virtuálních adres o pevné velikosti.",incorrect:"Stránky virtuální paměti představují bloky virtuálních adres s proměnlivou velikostí.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"0fe00cda-ec91-48a0-a88d-4b40fb9a1b3e",correct:"Velikost stránky virtuální paměti je typicky mocninou dvou.",incorrect:"Velikost stránky virtuální paměti nemusí být mocninou dvou.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"474c0854-471e-4d4c-811d-e1ac3ee7b74b",correct:"V rámci stránkování se spodních n bitů virtuální adresy mapuje přímo na fyzickou adresu.",incorrect:"V rámci stránkování se spodních n bitů virtuální adresy nikdy nemapuje přímo na fyzickou adresu.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"ff0d6143-b8e6-4f81-90f5-04a3fda55fb9",correct:"Použitím stránek se dosahuje zmenšení velikosti překladových tabulek oproti mapování každé adresy.",incorrect:"Použitím stránek se velikost překladových tabulek nemění oproti mapování každé adresy.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"9e80d110-408a-4a6a-a27e-0e13da4c8752",correct:"Počáteční adresa každé stránky virtuální paměti je vždy dělitelná velikostí stránky.",incorrect:"Počáteční adresa každé stránky virtuální paměti nemusí být dělitelná velikostí stránky.",sectionNumber:"1.2.5",sectionTitle:"Stránky"},{uuid:"e41373bf-f5f2-41a2-ad81-d9414ab744ea",correct:"Stránkové tabulky jsou uloženy v operační paměti RAM a slouží k překladu virtuálních adres na fyzické.",incorrect:"Stránkové tabulky jsou uloženy v cache procesoru a slouží k urychlení výpočtů.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"47b93a5d-7177-47bb-9243-78a47fc31a17",correct:"Pro velké adresní prostory se používají víceúrovňové překladové tabulky z důvodu efektivity paměti.",incorrect:"Pro velké adresní prostory se používají jednoúrovňové překladové tabulky z důvodu rychlosti.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"576b8be0-dd3c-485d-924e-062d444cc4f1",correct:"Řídká stránková tabulka efektivně šetří paměť, protože nemusí mapovat všechny virtuální adresy.",incorrect:"Řídká stránková tabulka plýtvá pamětí, protože musí mapovat všechny virtuální adresy.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"1c347f2b-6bbd-4712-8f3f-db018aafdca7",correct:"Segment virtuální adresy se používá jako index pro výběr řádku v příslušné úrovni překladové tabulky.",incorrect:"Segment virtuální adresy se přímo používá jako offset v operační paměti pro přístup k datům.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"e7d2fc3e-eb15-4e95-b716-970aa2b74f8d",correct:"TLB (Translation Lookaside Buffer) je rychlá asociativní paměť pro ukládání nedávno přeložených adres.",incorrect:"TLB (Translation Lookaside Buffer) je pomalá sekvenční paměť pro ukládání všech přeložených adres.",sectionNumber:"1.2.6",sectionTitle:"Stránkové tabulky"},{uuid:"adadedc0-57ca-445a-8094-a3fb5958488a",correct:"Formálněji proces označuje virtuální adresní prostor, který obsahuje kód programu a pracovní data.",incorrect:"Formálněji proces označuje pouze kód programu, ale neobsahuje pracovní data.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"013040dd-ccaf-42f7-abd5-caf342b279b4",correct:"Operační systém vede záznam o každém procesu a proces může vlastnit různé systémové zdroje.",incorrect:"Operační systém nevede záznam o procesech a proces nemůže vlastnit žádné systémové zdroje.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"09a970d1-60e4-4f60-acaa-6bc76adfba31",correct:"K jednomu procesu se může vázat libovolný počet vláken, což umožňuje paralelní provádění úloh.",incorrect:"K jednomu procesu se může vázat maximálně jedno vlákno, čímž se omezuje paralelismus.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"2f281585-014a-48ae-995b-f19e81f359c9",correct:"V abstrakci počítače proces odpovídá virtuální operační paměti, zatímco vlákno výpočetní jednotce.",incorrect:"V abstrakci počítače proces odpovídá virtuální výpočetní jednotce, a vlákno operační paměti.",sectionNumber:"1.3.1",sectionTitle:"Proces"},{uuid:"007e8a81-eb5c-45e9-baf5-8f67f1634a09",correct:"Adresní prostory procesů jsou v operačním systému převážně oddělené.",incorrect:"Adresní prostory procesů jsou v operačním systému vždy plně sdílené.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"7548e6e6-549a-421b-9777-bf5ab92fcc50",correct:"Standardně procesy nemají přímý přístup k paměti jiných procesů.",incorrect:"Standardně procesy mají plný přístup k paměti všech procesů v systému.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"9e8f7ef3-7ff3-4aaf-ad46-fc353e9004f6",correct:"Operační systémy umožňují sdílení kódu mezi procesy pouze pro čtení.",incorrect:"Operační systémy běžně sdílejí kód mezi procesy s plným přístupem pro zápis.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"475238a6-5280-4003-beb2-af2a0d08d18b",correct:"Sdílená paměť s možností zápisu slouží jako komunikační mechanismus procesů.",incorrect:"Sdílená paměť s zápisem slouží k izolaci procesů a omezení komunikace.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"d5190114-b6fc-464c-83b9-e87a0348c7f2",correct:"Virtuální adresy sdílené paměti nemusí být v různých procesech nutně stejné.",incorrect:"Virtuální adresy sdílené paměti musí být vždy identické ve všech procesech.",sectionNumber:"1.3.2",sectionTitle:"Ochrana paměti"},{uuid:"f96e23dd-2c3b-46d1-9347-17acdc23c32c",correct:"Fyzická adresa stránkovací tabulky první úrovně je uložena v registru procesoru.",incorrect:"Virtuální adresa stránkovací tabulky první úrovně je uložena v registru procesoru.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"e4a1debc-8f3a-46a5-8021-2dfdbe1d39b2",correct:"Nastavení adresy stránkovací tabulky první úrovně je privilegovaná instrukce.",incorrect:"Nastavení adresy stránkovací tabulky první úrovně může provést i běžný program.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"48a6f3d5-7a48-438e-a6bb-e1f9883f5888",correct:"Přepnutí procesu zahrnuje změnu aktivní stránkovací tabulky.",incorrect:"Přepnutí procesu nezahrnuje změnu aktivní stránkovací tabulky.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"78ffd594-2980-457b-8727-384c1f02a3aa",correct:"Přepnutí vlákna souvisí s výměnou hodnot výpočetních registrů.",incorrect:"Přepnutí procesu souvisí s výměnou hodnot výpočetních registrů.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"7c5e270d-7d56-4fda-89b5-1489c25624ce",correct:"Virtuální výpočetní jednotku představuje vlákno, nikoliv proces.",incorrect:"Virtuální výpočetní jednotku představuje proces, nikoliv vlákno.",sectionNumber:"1.3.3",sectionTitle:"Přepnutí procesu"},{uuid:"6883baf5-1be4-48c3-b097-4ce501a5daab",correct:"Proces se vytváří duplikací, v POSIX systémech operací fork.",incorrect:"Proces se vytváří klonováním, v POSIX systémech operací clone.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"17fdd2da-3715-4421-bcfe-1f3dbc49f033",correct:"Copy-on-write duplikuje adresní prostor, ale fyzická data sdílí do prvního zápisu.",incorrect:"Copy-on-write duplikuje adresní prostor i fyzická data okamžitě při fork.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"2853ca5d-7eab-4fe3-81b9-46a6b2862856",correct:"Stránky v copy-on-write jsou zpočátku jen pro čtení a kopírují se až při pokusu o zápis.",incorrect:"Stránky v copy-on-write jsou zpočátku pro čtení i zápis a kopírují se ihned.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"51e3e18a-dfd3-4681-92ab-e489e38904c7",correct:"Mechanismus copy-on-write vytváří iluzi oddělených adresních prostorů procesů.",incorrect:"Mechanismus copy-on-write vytváří skutečně oddělené adresní prostory procesů od začátku.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"8aafc3d6-e42b-452f-a810-86a276669a25",correct:"Operace fork s copy-on-write je obvykle rychlejší než plná kopie paměti procesu.",incorrect:"Operace fork s copy-on-write je vždy pomalejší než plná kopie paměti procesu.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"bbd990d9-a4bc-43a7-a13b-94f544cee0fe",correct:"Při zápisu do copy-on-write stránky vyvolá proces výjimku ochrany paměti.",incorrect:"Při zápisu do copy-on-write stránky se data rovnou zapíší bez výjimky.",sectionNumber:"1.3.4",sectionTitle:"Vytvoření procesu"},{uuid:"9aceae88-dfa7-4ffa-8c33-a43c0e8b3e87",correct:"Neplatná virtuální adresa způsobí výjimku, kterou následně řeší jádro operačního systému.",incorrect:"Neplatná virtuální adresa nezpůsobí výjimku a jádro operačního systému ji neřeší.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"c996603f-0eba-42e6-8995-12d646a96a83",correct:"Při pokusu o zápis na virtuální adresu s příznakem „jen pro čtení“ dojde k výjimce ochrany paměti.",incorrect:"Při pokusu o zápis na virtuální adresu s příznakem „jen pro čtení“ nedojde k výjimce ochrany paměti.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"83deb08b-9934-48a0-8f1a-8f3da8223a79",correct:"Operační systém může využít prázdný řádek stránkovací tabulky pro vlastní potřeby.",incorrect:"Operační systém nemůže využít prázdný řádek stránkovací tabulky pro vlastní potřeby.",sectionNumber:"1.4.1",sectionTitle:"Neplatné adresy"},{uuid:"321b1e7e-af6f-49f9-9225-21b25ea3e90d",correct:"Operační systém může přesunout stránky z operační paměti na externí úložiště.",incorrect:"Operační systém nemůže přesunout stránky z operační paměti na externí úložiště.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"edb9545f-e78e-415e-b10f-09f4ca9f43cf",correct:"V stránkové tabulce operační systém označí adresu za neplatnou, když je stránka přesunuta z RAM.",incorrect:"V stránkové tabulce operační systém vymaže adresu, když je stránka přesunuta z RAM.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"803f0b7b-edf9-4b1e-9f49-b1e994dc9aca",correct:"Virtuální paměť umožňuje přidělit programům více paměti, než je fyzicky dostupné v operační paměti.",incorrect:"Virtuální paměť omezuje přidělení paměti programům na množství fyzické operační paměti.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"2cc9393f-bf10-47ba-b12a-90c13b096295",correct:"Přístup ke stránkám na externím úložišti je pomalejší než přístup ke stránkám v operační paměti.",incorrect:"Přístup ke stránkám na externím úložišti je rychlejší než přístup ke stránkám v operační paměti.",sectionNumber:"1.4.2",sectionTitle:"Externí stránkování"},{uuid:"03c10304-71f9-463c-a81a-2ccc45a47268",correct:"Stránka označuje rozsah virtuálních adres.",incorrect:"Stránka označuje rozsah fyzických adres.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"afbbc4b3-b0e2-47ff-acfd-276096de01f7",correct:"Rámec označuje rozsah fyzických adres.",incorrect:"Rámec označuje rozsah virtuálních adres.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"10e87cbd-1603-40cd-aec1-24019ed5c44c",correct:"Stránka je uložena v rámci.",incorrect:"Rámec je uložen ve stránce.",sectionNumber:"1.4.3",sectionTitle:"Rámce a stránky"},{uuid:"50568d08-cfce-4808-b697-2fbda578a144",correct:"Líné načítání spustitelného souboru využívá stránkovací tabulky k načítání stránek z disku dle potřeby.",incorrect:"Líné načítání spustitelného souboru nevyužívá stránkovací tabulky a načítá celý soubor najednou.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"7d2688f5-fff5-4723-81ef-46de239a0aa7",correct:"Při líném načítání spustitelného souboru není nutné nahrávat ihned celý obsah souboru do operační paměti.",incorrect:"Při líném načítání spustitelného souboru je nezbytné nahrát kompletní obsah souboru do operační paměti před spuštěním.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"05831b3b-77ec-4ecf-9aea-8da1f2e168b1",correct:"Mechanismus líného načítání je podobný externímu stránkování, avšak odpadá nutnost hledat oběť pro výměnu stránek.",incorrect:"Mechanismus líného načítání se zásadně liší od externího stránkování a vyžaduje složitější algoritmy pro výběr oběti.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"983fc2b0-28a7-416a-9f38-2c54bc0672c6",correct:"Líné načítání lze efektivně kombinovat s klasickým externím stránkováním pro optimalizaci správy operační paměti.",incorrect:"Líné načítání a klasické externí stránkování jsou neslučitelné metody a nemohou být kombinovány.",sectionNumber:"1.4.4",sectionTitle:"Líné načítání"},{uuid:"7d49eaed-f598-4e50-88a1-8587bf0a408b",correct:"Mapování datových souborů do paměti je nejdůležitější využití externího stránkování v praxi.",incorrect:"Mapování datových souborů do paměti se používá pro správu paměti procesu, nikoliv pro přístup k souborům.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"},{uuid:"2529caf0-e62b-4628-8e21-758811d9bdfb",correct:"Při mapování souboru do paměti program přistupuje k souboru jako k místu v operační paměti.",incorrect:"Při mapování souboru do paměti program musí používat standardní systémová volání pro čtení a zápis.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"},{uuid:"4d478b54-2317-454f-9098-b3e5e0ab10ea",correct:"Externí stránkování umožňuje uložit stránky mapovaného souboru do běžného datového souboru.",incorrect:"Externí stránkování pro mapování souborů vyžaduje speciální diskový oddíl, nikoliv běžný soubor.",sectionNumber:"1.4.5",sectionTitle:"Mapování souborů"}]},{uuid:"dc119fde-5b9a-4b1d-ab0a-b4e5d1b2fb77",sectionNumber:"2",sectionTitle:"Virtualizace procesoru",statements:[{uuid:"bf8b2927-4e17-418d-a080-43532e0ed1f2",correct:"Aritmetické a logické instrukce procesoru zahrnují sčítání, bitové posuvy a relační operátory.",incorrect:"Aritmetické a logické instrukce procesoru zahrnují pouze sčítání a odčítání celých čísel.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"9e54cd6a-118f-46c0-9d59-5f038db7094b",correct:"Instrukce pro přístup do paměti, označené jako ld a st, umožňují procesoru pracovat s daty uloženými v paměti.",incorrect:"Instrukce ld a st slouží výhradně k provádění aritmetických operací s daty v registrech procesoru.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"ccf49522-96e3-4898-903a-e8511e267b0b",correct:"Mezi instrukce řízení toku patří podmíněné skoky a nepřímé skoky, které ovlivňují pořadí provádění instrukcí.",incorrect:"Instrukce řízení toku se používají pouze pro manipulaci s daty v paměti a nemají vliv na pořadí provádění instrukcí.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"761f2e50-8748-44fe-b47b-a7e6c95a4db6",correct:"Realizace podprogramů pomocí specializovaných instrukcí zjednodušuje abstrakci, ale není pro funkčnost procesoru nezbytná.",incorrect:"Pro implementaci podprogramů jsou specializované instrukce procesoru naprosto nezbytné a nelze je nahradit jednoduššími instrukcemi.",sectionNumber:"2.1.1",sectionTitle:"Výpočet"},{uuid:"473c1123-bea5-4855-8cfc-fb013fa66ec6",correct:"Registry procesoru ukládají čísla reprezentovaná jako celá slova, nikoliv jednotlivé bajty.",incorrect:"Registry procesoru ukládají čísla reprezentovaná jako jednotlivé bajty, nikoliv celá slova.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"6b5e059f-98fa-4549-ab9a-85f839b8904f",correct:"Programový čítač obsahuje virtuální adresu instrukce, která se má aktuálně provést.",incorrect:"Programový čítač obsahuje fyzickou adresu instrukce, která se má aktuálně provést.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"a8e9f62e-a60d-43f2-bcf1-795b0b2908a9",correct:"Paměťové adresy lze indexovat a vypočítat, registry se v instrukcích používají přímo.",incorrect:"Registry lze indexovat a vypočítat, paměťové adresy se v instrukcích používají přímo.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"cb32d73c-4f9a-4bdc-926f-6f5e884b5854",correct:"Hodnotu programového čítače lze měnit instrukcemi řízení toku programu, nikoliv aritmetickými instrukcemi.",incorrect:"Hodnotu programového čítače lze měnit aritmetickými instrukcemi, nikoliv instrukcemi řízení toku programu.",sectionNumber:"2.1.2",sectionTitle:"Registry"},{uuid:"7e16c838-308d-4a14-aa32-c9f373b736a8",correct:"Instrukce je elementární příkaz strojového kódu, což představuje nejmenší jednotku činnosti procesoru.",incorrect:"Instrukce je složitý příkaz vyššího programovacího jazyka, který procesor vykonává přímo.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"7b716660-c27d-49e7-85f2-0e8aba7e8160",correct:"Procesor zná pouze konečný počet instrukcí strojového kódu, což umožňuje jejich jednoznačné očíslování.",incorrect:"Procesor je schopen vykonat nekonečný počet různých instrukcí strojového kódu bez omezení.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"213afe79-ba33-442f-9d33-8901c827c1cc",correct:"Instrukce strojového kódu lze logicky sdružovat do rodin podle prováděných operací, například sčítání.",incorrect:"Instrukce strojového kódu jsou zcela nesourodé a nelze je smysluplně kategorizovat podle operací.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"2064730c-1120-49a8-8c08-9d47c944073d",correct:"Mnemonický zápis instrukcí je určen pro čitelnost programátory a není totožný s jazykem symbolických adres.",incorrect:"Mnemonický zápis instrukcí je formální jazyk symbolických adres přímo interpretovaný procesorem.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"48ff1706-8caa-4b41-9a4b-d7ded63bb745",correct:"Operace, kterou má instrukce provést, je obvykle určena operačním kódem v rámci číselného kódování instrukce.",incorrect:"Operace instrukce není nikdy explicitně kódována, ale je odvozena pouze z kontextu a operandů.",sectionNumber:"2.1.3",sectionTitle:"Instrukce"},{uuid:"e4c8bf3e-ac6a-4565-a2ee-e2f09643426f",correct:"Každá instrukce operačního systému má za následek změnu stavu procesoru.",incorrect:"Některé instrukce operačního systému nemají žádný vliv na stav procesoru.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"9eba04a3-f219-4ad1-b93c-2725a9829f07",correct:"Výpočet programu je definován jako posloupnost elementárních změn stavu systému.",incorrect:"Výpočet programu je jednorázová operace bez posloupnosti změn stavu.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"e31a9b05-7b98-4ebc-b097-dfd48ce27976",correct:"Efekt instrukce je elementární změna stavu, což je základní stavební kámen výpočtu.",incorrect:"Efekt instrukce je komplexní transformace stavu, nikoliv elementární změna.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"eb05d003-832f-4279-8c81-2727e78f7468",correct:"Programy manipulují se stavem procesoru, paměti a periferií pro dosažení výstupů ze vstupů.",incorrect:"Programy ignorují stav systému a přímo generují výstupy nezávisle na vstupech.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"fb4e17ef-7b95-49ca-93a1-ad6f2b7f66f4",correct:"Vstupy a výstupy programu jsou integrální součástí celkového stavu výpočetního systému.",incorrect:"Vstupy a výstupy programu existují mimo kontext stavu výpočetního systému.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"7ff47499-d48b-4633-ae62-477f4deb1010",correct:"Instrukce typu `add op1 op2 -> result` typicky sečte hodnoty registrů op1 a op2.",incorrect:"Instrukce typu `add op1 op2 -> result` obvykle provádí bitový posun hodnot registrů.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"6fcc9b66-d7cc-4ebf-95bd-936b868407a3",correct:"Po provedení instrukce `add op1 op2 -> result` se programový čítač posune na další instrukci.",incorrect:"Po provedení instrukce `add op1 op2 -> result` programový čítač zůstává nezměněn.",sectionNumber:"2.1.4",sectionTitle:"Efekt instrukce"},{uuid:"a30f59f2-69c1-4c23-ad67-beb097341e2a",correct:"Program je tvořen instrukcemi uloženými v paměti.",incorrect:"Program je tvořen daty uloženými v registech procesoru.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"9bb77e9b-d246-4ac4-bd9e-e73ee5c00629",correct:"Většina programu je prováděna v pořadí od nižších k vyšším virtuálním adresám.",incorrect:"Většina programu je prováděna v náhodném pořadí adres v paměti.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"2dff8de0-804b-403e-b6ac-74d5651911b2",correct:"Instrukce skoku mohou způsobit návrat k dříve vykonané instrukci, například u cyklů.",incorrect:"Instrukce skoku nikdy nemohou způsobit návrat k dříve vykonané instrukci.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"eacead6c-ddc5-4536-acfb-c790ea8d7597",correct:"Podmíněné příkazy obvykle posouvají programový čítač dopředu v adresovém prostoru.",incorrect:"Podmíněné příkazy obvykle posouvají programový čítač dozadu v adresovém prostoru.",sectionNumber:"2.1.5",sectionTitle:"Program"},{uuid:"fcbadfd9-3a83-4cf6-aa3f-03ec557a9282",correct:"Podprogram je pomocný blok instrukcí, který se může opakovaně volat z různých částí programu.",incorrect:"Podprogram je hlavní program, který se volá pouze jednou na začátku výpočtu.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"c8d0cf24-5630-42d9-8804-ea0f33b47211",correct:"Aktivace podprogramu zahrnuje uložení části stavu procesoru a vyhrazení místa pro lokální proměnné.",incorrect:"Aktivace podprogramu nevyžaduje uložení stavu procesoru, pouze skok na začátek podprogramu.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"9bd17c43-bc04-46f9-9f5b-0d5142a23087",correct:"Zásobník je spojitá oblast virtuálního adresního prostoru, která se používá pro realizaci podprogramů.",incorrect:"Zásobník je diskrétní oblast fyzické paměti, která se používá pro ukládání globálních proměnných.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"854edbe6-7a40-4c55-bdb3-6f1f5f3ffa4d",correct:"Návrat z podprogramu je realizován skokem zpět na instrukci následující po aktivaci podprogramu.",incorrect:"Návrat z podprogramu je realizován ukončením procesu a uvolněním všech zdrojů.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"d596bc0b-40dd-47a2-bb4d-f1b20d379d2e",correct:"Pro realizaci podprogramů se běžně používá hardwarový zásobník.",incorrect:"Pro realizaci podprogramů se běžně používá fronta.",sectionNumber:"2.1.6",sectionTitle:"Zásobník"},{uuid:"5ab28e8c-74ab-499d-b677-beea5cc5d139",correct:"Zásobník typického programu je tvořen sekvencí aktivačních záznamů, známých jako rámce.",incorrect:"Zásobník typického programu je tvořen sekvencí instrukcí procesoru, známých jako rámce.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"4e54333c-a4d5-4fdd-bbf6-8352a4270c0a",correct:"Každý aktivační záznam v zásobníku odpovídá jedné dosud neskončené aktivaci podprogramu.",incorrect:"Každý aktivační záznam v zásobníku odpovídá každému volání podprogramu, i skončenému.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"5fc76e23-a971-4d4b-8984-9494df6d4f53",correct:"Zásobník funguje na principu LIFO, což znamená, že poslední zavolaný podprogram končí první.",incorrect:"Zásobník funguje na principu FIFO, kde první zavolaný podprogram končí první.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"d6ee4141-b009-4769-996f-64abef06e800",correct:"Pro správnou funkci zásobníku musí podprogram skončit až po skončení všech jím aktivovaných podprogramů.",incorrect:"Pro správnou funkci zásobníku může podprogram skončit i před skončením jím aktivovaných podprogramů.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"3f30fc17-41ad-45ca-9805-e3c3c6c3ca32",correct:"Některé procesory používají zásobníky, které rostou směrem k nižším paměťovým adresám.",incorrect:"Všechny procesory používají zásobníky, které rostou směrem k vyšším paměťovým adresám.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"00c17def-2079-42b8-8ef3-2e69a56dcb32",correct:"Aktivační záznam obvykle obsahuje lokální proměnné a uložené registry pro obnovení stavu po návratu.",incorrect:"Aktivační záznam obvykle obsahuje pouze globální proměnné a žádné registry procesoru.",sectionNumber:"2.1.7",sectionTitle:"Aktivační záznam"},{uuid:"4b39e58f-a48b-4701-a116-f162a9a1fbf9",correct:"Stav procesoru pro účely výpočtu zahrnuje registry, programový čítač a ukazatel zásobníku.",incorrect:"Stav procesoru pro účely výpočtu zahrnuje pouze aritmetické registry a stav paměti.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"098b44bb-71fe-45d0-b847-f99b2334eee8",correct:"Izolovaný výpočet je deterministický, což znamená, že je jednoznačně určen počátečním stavem a programem.",incorrect:"Izolovaný výpočet je deterministický bez ohledu na počáteční stav procesoru a prováděný program.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"b262b4cc-54a9-4815-8aa5-f3c955638f89",correct:"Determinismus výpočtu může být narušen, pokud program interaguje s periferiemi mapovanými do paměti.",incorrect:"Interakce programu s periferiemi mapovanými do paměti nemá vliv na determinismus výpočtu.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"3534b101-99bc-42db-8a1a-f7b3ae74a645",correct:"Pro deterministický výpočet je klíčové, aby program neměl přístup do paměti mimo vyhrazený adresní prostor.",incorrect:"Deterministický výpočet je možný i v případě, že program má neomezený přístup do paměti.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"2bd449f4-f01e-4f62-8ceb-595bcfbba5b7",correct:"Výpočet procesoru lze chápat jako sekvenci postupných změn stavu procesoru.",incorrect:"Výpočet procesoru je statický a neměnný, bez postupných změn stavu.",sectionNumber:"2.2.1",sectionTitle:"Stav procesoru"},{uuid:"fb272868-65c4-450b-a5c7-d221be708944",correct:"V neizolovaném výpočtu může externí entita změnit hodnotu v paměti programu a ovlivnit tak jeho běh.",incorrect:"V izolovaném výpočtu může externí entita změnit hodnotu v paměti programu a ovlivnit tak jeho běh.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"21460bcf-79c4-43b7-8531-250240ea9058",correct:"Synchronizace v operačních systémech popisuje interakci výpočtů, kdy externí událost ovlivní průběh programu.",incorrect:"Synchronizace v operačních systémech popisuje izolovaný výpočet, kdy externí událost neovlivní průběh programu.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"070237a2-72b5-437e-9c70-641ada9f91cc",correct:"Virtuální adresa 0x1000 v programu nemusí odpovídat fyzické adrese 0x1000 v paměti systému.",incorrect:"Virtuální adresa 0x1000 v programu vždy odpovídá fyzické adrese 0x1000 v paměti systému.",sectionNumber:"2.2.2",sectionTitle:"Synchronizace"},{uuid:"61d8738d-bf2a-4d1c-9aab-4bf54a29c848",correct:"Stav procesoru je určen výlučně programem, jak je definováno v tomto kontextu.",incorrect:"Stav procesoru není určen výlučně programem, ale i vnějšími vlivy.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"def175b9-652f-4756-a931-96a82b07f595",correct:"Zásobník v kontextu vláken operačního systému patří výhradně vláknu.",incorrect:"Zásobník v kontextu vláken operačního systému patří procesu, nikoliv vláknu.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"d3f7fcca-97bb-4aff-9ccb-43aa303d476c",correct:"Výpočet vlákna není jednoznačně určen, protože výpočet není izolován od vnějších událostí.",incorrect:"Výpočet vlákna je jednoznačně určen, protože výpočet je plně izolován od vnějších událostí.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"3ca6388a-5805-4fbc-895f-9fd9c9d9f66f",correct:"Vlákno může iniciovat synchronizaci s jinými vlákny zápisem do sdílené paměti.",incorrect:"Vlákno nemůže iniciovat synchronizaci s jinými vlákny zápisem do sdílené paměti.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"354d7aa0-a132-4d48-8ae7-964a95ce2bb2",correct:"Vlákno pozoruje vnější události operačního systému prostřednictvím čtení paměti.",incorrect:"Vlákno pozoruje vnější události operačního systému prostřednictvím zápisu do paměti.",sectionNumber:"2.2.3",sectionTitle:"Vlákno"},{uuid:"7ad7c784-5d4c-431d-963e-530db91f5e21",correct:"Stav logického procesoru je definován výhradně hodnotami registrů procesoru.",incorrect:"Stav logického procesoru je definován obsahem operační paměti.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"2c413012-620a-4e32-8e16-938e44bf3213",correct:"Změna stavu logického procesoru nastává pouze vykonáváním instrukcí.",incorrect:"Změna stavu logického procesoru může nastat i bez vykonávání instrukcí.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"ad82e302-dccb-4bc5-99f7-5abef9575c8e",correct:"Virtualizace procesoru umožňuje provozovat více logických procesorů na jednom fyzickém procesoru.",incorrect:"Virtualizace procesoru omezuje počet logických procesorů na maximálně jeden na fyzický procesor.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"66767e71-25be-45ac-bfad-e88e3432f0a6",correct:"Operační systém dokáže uložit a obnovit stav logického procesoru pro účely virtualizace.",incorrect:"Operační systém nemůže uložit ani obnovit stav logického procesoru.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"e6860944-4369-448a-8404-6d6e982b084e",correct:"Přerušení je vnější událost, která umožňuje operačnímu systému převzít kontrolu nad fyzickým procesorem.",incorrect:"Přerušení je událost vyvolaná vláknem, která umožňuje operačnímu systému převzít kontrolu.",sectionNumber:"2.2.4",sectionTitle:"Logický procesor"},{uuid:"54cb05c9-fc03-49fe-bc5b-eb719ec6e854",correct:"Díky uložení a obnově registrů se vlákno může jevit jako samostatný logický procesor.",incorrect:"Vlákno funguje zcela nezávisle na uložení a obnově registrů fyzického procesoru.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"3772cd6d-c3b6-4f33-b317-16f412c263f4",correct:"Pro správnou funkčnost vláken je nezbytná hardwarová podpora procesoru pro uložení a obnovu jeho stavu.",incorrect:"Softwarová emulace plně postačuje pro uložení a obnovu stavu procesoru pro běh vláken bez hardwarové podpory.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"c1640fda-c909-40dd-83e5-39c4bb58f55c",correct:"Obsluha přerušení, která vyžaduje uložení části stavu, poskytuje základ pro mechanismy vláken.",incorrect:"Obsluha přerušení nemá žádný vliv na mechanismy uložení stavu, které se používají pro vlákna.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"afc7438e-f2d3-4a07-95a0-2c12aafd3c3e",correct:"Programový čítač představuje největší komplikaci při implementaci uložení a obnovení kontextu vláken.",incorrect:"Uložení a obnovení programového čítače je triviální operací v kontextu správy vláken.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"25533738-63e2-4301-8303-47ec867898e9",correct:"Střídavé provádění více vláken na jednom procesoru je umožněno mechanismy uložení a obnovy registrů.",incorrect:"Paralelní provádění více vláken na jednom procesoru je přímo umožněno mechanismy uložení a obnovy registrů.",sectionNumber:"2.2.5",sectionTitle:"Přepnutí vlákna"},{uuid:"fbc59b48-693d-40e2-9adc-8751e58807bd",correct:"Plánovač vláken se spouští pravidelně přerušením časovače na každém fyzickém procesorovém jádře.",incorrect:"Plánovač vláken se spouští asynchronně, pouze pokud běžící vlákno explicitně uvolní procesor.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"bf04861e-e0fb-47a8-90c9-c7fc6f1c5c65",correct:"Hlavním úkolem plánovače vláken je rozhodnout, zda má být aktivní vlákno přerušeno a které má běžet dále.",incorrect:"Hlavním úkolem plánovače vláken je pouze optimalizovat využití procesoru bez ohledu na spuštěná vlákna.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"6987faf8-18c3-49a9-994f-fbb5173561b6",correct:"Díky preemptivnímu plánování může operační systém odebrat vláknu procesor i bez jeho aktivního souhlasu.",incorrect:"Preemptivní plánování vyžaduje, aby vlákno aktivně signalizovalo operačnímu systému, že může být přerušeno.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"fd0c49ef-778b-4197-ae58-41ba9d407a3a",correct:"Termín plánovač procesů se historicky používá jako synonymum pro modernější plánovač vláken.",incorrect:"Termíny plánovač procesů a plánovač vláken označují různé komponenty operačního systému s odlišnými funkcemi.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"b4aa0d80-845b-4545-9b24-3c894c136a9f",correct:"Pro aktivaci plánovače vláken se používá programovatelný časovač, který může pracovat v periodickém režimu.",incorrect:"Pro aktivaci plánovače vláken se používá výhradně jednorázový časovač, který je nutné po každém spuštění znovu aktivovat.",sectionNumber:"2.3.1",sectionTitle:"Plánovač"},{uuid:"a0662570-cd8a-4509-ab96-5d29c5076b64",correct:"Maximalizace propustnosti plánovače operačního systému se zaměřuje na maximalizaci práce vykonané za jednotku času.",incorrect:"Maximalizace propustnosti plánovače operačního systému se zaměřuje na minimalizaci reakční doby systému.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"59abb30b-7332-47e6-a323-491837d571f6",correct:"Minimalizace latence v plánování operačního systému je klíčová pro interaktivní programy a síťové služby.",incorrect:"Minimalizace latence v plánování operačního systému je klíčová pro výpočetně náročné programy.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"17eec286-bac2-43bf-9a2c-4718f0e1650c",correct:"Spravedlivost v plánování operačního systému zajišťuje, že všechna vlákna obdrží přibližně stejný díl procesorového času.",incorrect:"Spravedlivost v plánování operačního systému upřednostňuje vlákna s nejvyšší prioritou bez ohledu na ostatní vlákna.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"91d73888-f1b3-45c4-bf86-7a987b57c505",correct:"Požadavky na minimální latenci a maximální propustnost jsou v plánování operačního systému často protichůdné.",incorrect:"Požadavky na minimální latenci a maximální propustnost se v plánování operačního systému vzájemně doplňují a posilují.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"4541c5c5-1f68-4cc2-8857-facb4255e58b",correct:"Příliš časté střídání vláken může snížit propustnost systému kvůli režii spojené s přepínáním kontextu.",incorrect:"Příliš časté střídání vláken obvykle zvyšuje propustnost systému díky lepšímu využití procesoru.",sectionNumber:"2.3.2",sectionTitle:"Cíle"},{uuid:"934e4899-d170-4f9c-84bd-22b1be4fb8a0",correct:"Vlákno se může nacházet ve stavech běžící, připravené nebo čekající na událost.",incorrect:"Vlákno se může nacházet ve stavech běžící, blokované, uspáno a čekající na událost.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"6b3707a0-0370-4076-a0d2-695755d01f12",correct:"Plánovač operačního systému rozhoduje o přechodu vlákna z běžícího stavu do stavu připraveno.",incorrect:"Samotné vlákno rozhoduje o svém přechodu z běžícího stavu do stavu připraveno.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"78e64b0c-f8de-4f9d-8d0c-36f0fd2bcc15",correct:"Přímý přechod vlákna ze stavu čekání na procesor do stavu čekání na událost není možný.",incorrect:"Přímý přechod vlákna ze stavu čekání na procesor do stavu čekání na událost je běžně prováděn.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"3d3a17c5-ab60-43b2-bd50-f5a711c13db2",correct:"Po nastání události a dostupnosti procesoru přechází vlákno z čekání na událost do stavu běžící.",incorrect:"Po nastání události vlákno z čekání na událost vždy okamžitě přechází do stavu běžící.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"5e6bc6a4-bcea-4360-b088-7e69be689a5e",correct:"Pokud po události není procesor dostupný, vlákno čekající na událost přejde do stavu připraveno.",incorrect:"Pokud po události není procesor dostupný, vlákno čekající na událost zůstane ve stavu čekání na událost.",sectionNumber:"2.3.3",sectionTitle:"Stav vlákna"},{uuid:"83ce430b-c57b-4fa0-9e15-7a294bd7c446",correct:"Běhové fronty úloh jsou klíčovým nástrojem plánovače operačního systému pro správu vláken čekajících na procesor.",incorrect:"Běhové fronty úloh se používají pro ukládání hotových procesů, nikoliv pro vlákna čekající na procesor.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"121e3adb-3e95-4ba5-b399-639eea2419fd",correct:"Plánovací algoritmy se liší zejména v chování běhových front úloh, které ovlivňují pořadí a prioritu vláken.",incorrect:"Plánovací algoritmy se liší pouze v rychlosti přepínání kontextu, nikoliv v chování běhových front úloh.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"ee0b661c-4aae-4152-8152-c129bdfebfaf",correct:"Globální fronta úloh je sdílená mezi všemi procesory, zatímco lokální fronta je specifická pro jeden procesor.",incorrect:"Globální fronta úloh je specifická pro jeden procesor, zatímco lokální fronta je sdílená mezi všemi procesory.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"0b8c5a84-f8f2-4fde-9db0-1d42e6fa9199",correct:"FIFO fronta zpracovává vlákna v pořadí, v jakém byla do fronty zařazena, bez ohledu na prioritu.",incorrect:"FIFO fronta zpracovává vlákna s nejvyšší prioritou jako první, bez ohledu na pořadí zařazení.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"3a42e3a9-c623-4e1e-bae0-aa47a401a4a4",correct:"Implementace fronty úloh, například monolitická nebo složená, má zásadní vliv na chování plánovače.",incorrect:"Implementace fronty úloh nemá žádný vliv na chování plánovače, protože plánovač je řízen pouze prioritami.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"6ea4c80e-dade-4968-b61b-6ce7f389f9d3",correct:"Prioritní fronty umožňují vláknům s vyšší prioritou předbíhat vlákna s nižší prioritou ve frontě úloh.",incorrect:"Prioritní fronty zajišťují, že všechna vlákna mají stejnou šanci na přidělení procesoru bez ohledu na prioritu.",sectionNumber:"2.3.4",sectionTitle:"Fronta úloh"},{uuid:"c8774ace-b221-4bfa-9a3d-328dd6349181",correct:"Plánovač s afinitou se snaží opakovaně plánovat vlákno na stejném fyzickém procesoru.",incorrect:"Plánovač s afinitou automaticky migruje vlákna mezi procesory pro lepší vyvážení zátěže.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"e1671a9e-8adb-4407-8f10-3dd447315a06",correct:"Migrace vlákna mezi procesory je drahá operace kvůli sdílení obsahu mezipaměti mezi nimi.",incorrect:"Migrace vlákna mezi procesory je levná operace, která zlepšuje výkon systému.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"2caef622-1484-4a89-b3a4-de36f53a8ef1",correct:'Kradení práce je mechanismus, kde procesor bez práce "ukradne" vlákno z jiné fronty.',incorrect:'Kradení práce je mechanismus, kde procesor s přebytkem práce "ukradne" vlákno z jiné fronty.',sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"8fb0531a-2c21-44dc-b14a-b7df7e1bab0d",correct:"Plánovač s globální frontou obvykle postrádá afinitu vláken k procesorům.",incorrect:"Plánovač s globální frontou aktivně podporuje afinitu vláken k procesorům.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"b3b3cd69-beda-4499-8b80-f85cb9dc39db",correct:"Plánovač s lokálními frontami a bez migrace zamezuje přesunu vláken mezi procesory.",incorrect:"Plánovač s lokálními frontami a bez migrace aktivně přesouvá vlákna mezi procesory.",sectionNumber:"2.3.5",sectionTitle:"Afinita"},{uuid:"fb8e43ec-df95-4d8d-9fef-abdb2b25a07b",correct:"Interaktivní plánovače používají prioritní plánování, kde priorita ovlivňuje latenci vláken a celkový přidělený čas.",incorrect:"Interaktivní plánovače používají prioritní plánování, kde priorita neovlivňuje latenci vláken a celkový přidělený čas.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"2f6c30e4-ee97-43eb-870f-4eb29afea807",correct:"Statické priority vláken jsou určeny rozhodnutím uživatele a nemění se v závislosti na chování systému.",incorrect:"Statické priority vláken jsou určeny dynamicky systémem a mění se v závislosti na chování uživatele.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"46fb7afd-c9c3-4884-9a17-16bb3467c340",correct:"Klasické prioritní plánování s FIFO frontami vybírá vlákna z nejvyšší neprázdné fronty prioritních tříd.",incorrect:"Klasické prioritní plánování s FIFO frontami vybírá vlákna z nejnižší neprázdné fronty prioritních tříd.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"aa50a663-7660-437a-a071-877752e0b3eb",correct:"Dynamická úprava priority vláken snižováním priority za běh řeší problém blokování procesoru dlouhými vlákny.",incorrect:"Dynamická úprava priority vláken zvyšováním priority za běh řeší problém blokování procesoru dlouhými vlákny.",sectionNumber:"2.3.6",sectionTitle:"Prioritní fronty"},{uuid:"24114977-fd24-4bd2-bc92-b968e952dd18",correct:"Férové plánování se podobá dynamickému prioritnímu plánování s prioritami v libovolném rozsahu.",incorrect:"Férové plánování je zcela odlišné od dynamického prioritního plánování a nepoužívá priority.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"6736f8fd-248a-4fb3-ad70-101ef709cb8e",correct:"Při plném vytížení systému mohou být dlouhodobě běžící interaktivní procesy férovým plánováním znevýhodněny.",incorrect:"Při plném vytížení systému jsou dlouhodobě běžící interaktivní procesy férovým plánováním vždy zvýhodněny.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"7be22771-4e8e-4660-8432-20710d222bb8",correct:"Priorita ve férovém plánování klesá s rostoucím využitým výpočetním časem vlákna.",incorrect:"Priorita ve férovém plánování roste s rostoucím využitým výpočetním časem vlákna.",sectionNumber:"2.3.7",sectionTitle:"Férové plánování"},{uuid:"f9ef5773-313b-48da-9afd-46ded57a8be6",correct:"Rozhodnutí o odebrání procesoru zohledňuje dobu běhu aktuálního vlákna a srovnání s dalším vláknem ve frontě.",incorrect:"Rozhodnutí o odebrání procesoru je založeno výhradně na prioritě aktuálního vlákna bez ohledu na dobu jeho běhu.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"c66bc833-2dd1-4a6e-9689-de39c14a8842",correct:"Plánovací kvantum definuje minimální dobu, po kterou vlákno běží na procesoru, i když existuje vlákno s vyšší prioritou.",incorrect:"Plánovací kvantum zaručuje, že vlákno s vyšší prioritou vždy okamžitě získá procesor, i během kvanta běžícího vlákna.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"fe39c1ae-1860-447b-8b15-e30a00d1dbd5",correct:"Dlouhé plánovací kvantum obvykle zvyšuje propustnost systému, ale může negativně ovlivnit latenci a reakční dobu.",incorrect:"Dlouhé plánovací kvantum zlepšuje latenci systému a reakční dobu, ale snižuje celkovou propustnost systému.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"4e4d002d-eadf-4e1c-9838-82795bea8e02",correct:"V algoritmech FIFO a RR jsou vlákna s rovnocennou prioritou spravedlivě rotována po časových kvantech.",incorrect:"V algoritmech FIFO a RR jsou vlákna s rovnocennou prioritou rotována po časových úsecích, jejichž délka se dynamicky mění v závislosti na prioritě.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"629c9b58-3ea4-40a0-a826-d93b27955364",correct:"Dobrovolné propuštění procesoru je v moderních preemptivních systémech spíše výjimkou a nahrazuje se signalizací událostí.",incorrect:"Dobrovolné propuštění procesoru je klíčovým mechanismem moderních preemptivních systémů pro efektivní správu zdrojů.",sectionNumber:"2.3.8",sectionTitle:"Odebrání procesoru"},{uuid:"2aa3eed8-259f-41df-af8b-9054d1aa3fad",correct:"Při čekání na vyřízení požadavku je vlákno probuzeno komponentou, která daný požadavek vyřídila.",incorrect:"Při čekání na vyřízení požadavku je vlákno probuzeno plánovačem operačního systému ještě před vyřízením požadavku.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"},{uuid:"1ba29f46-60ab-4078-ac8c-0329ec012a5e",correct:"V situaci soutěže o zdroj se vlákna řadí do čekací fronty a po uvolnění zdroje se probudí jen první vlákno z fronty.",incorrect:"V situaci soutěže o zdroj se všechna čekající vlákna probudí současně po uvolnění daného zdroje.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"},{uuid:"07d72691-0064-405b-ba90-cb704f8a242d",correct:"Vlákno může být uspáno, pokud se pokusí vstoupit do kritické sekce, která je aktuálně zamčená jiným vláknem.",incorrect:"Vlákno se uspí, pokud úspěšně vstoupí do kritické sekce a začne v ní provádět operace.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"},{uuid:"664ea3ab-fac6-46a7-ae55-8f2d13b4b642",correct:"Čekání na vstup z klávesnice a čekání na data ze sítě jsou příklady událostí, které mohou vlákno uspat.",incorrect:"Čekání na tisk dokumentu a výpočet matematické operace jsou typické události, které uspí vlákno.",sectionNumber:"2.3.9",sectionTitle:"Čekající vlákna"}]},{uuid:"033995ad-e925-4494-ac23-ea2ca52f69c5",sectionNumber:"3",sectionTitle:"Souborové systémy",statements:[{uuid:"8d2f5a12-8090-439f-b7cc-6dc50b82c2d1",correct:"Perzistentní úložiště slouží k dlouhodobému uchování dat i po odpojení napájení.",incorrect:"Perzistentní úložiště slouží pouze k dočasnému uchování dat během běhu programu.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"97decc12-1ebd-42ec-8a9e-a3c9b493715b",correct:"Operace čtení a zápisu v perzistentním úložišti pracují s bloky dat o velikosti 512 bajtů a více.",incorrect:"Operace čtení a zápisu v perzistentním úložišti pracují s jednotlivými bajty, podobně jako operační paměť.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"50360a1b-e2e9-47f0-aa2d-7bb1abd3cc08",correct:"SSD, HDD a NVMe jsou příklady perzistentních úložišť, která se používají pro dlouhodobé ukládání dat.",incorrect:"Operační paměť RAM a cache procesoru jsou příklady perzistentních úložišť pro dlouhodobé uložení dat.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"c399abcc-9b1d-4b41-969b-045e6036dcfe",correct:"Magnetické pásky nejsou vhodné jako perzistentní blokové úložiště kvůli jejich sekvenčnímu přístupu k datům.",incorrect:"Magnetické pásky jsou ideální jako perzistentní blokové úložiště díky jejich rychlému náhodnému přístupu k datům.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"ec25b9dc-3efa-4811-89e8-2b02582dae86",correct:"Perzistentní úložiště je primárně určeno pro ukládání uživatelsky relevantních dat, jako jsou dokumenty a multimédia.",incorrect:"Perzistentní úložiště se primárně využívá pro ukládání dočasných mezivýsledků výpočtů a systémové cache.",sectionNumber:"3.1.1",sectionTitle:"Trvalé úložiště"},{uuid:"1ba26c2c-fd45-46ec-adfd-e65d20a26419",correct:"Adresa v blokově orientovaném zařízení odkazuje na celý blok dat, nikoliv na jednotlivé bajty.",incorrect:"Adresa v blokově orientovaném zařízení odkazuje na jednotlivé bajty dat, nikoliv na bloky.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"fdcd37a0-7276-4944-9ce7-d5913739f9b9",correct:"Komunikace s blokově orientovaným zařízením je asynchronní kvůli latenci spojené s přístupem k blokům.",incorrect:"Komunikace s blokově orientovaným zařízením je synchronní, a to i přes latenci přístupu k blokům.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"3a8d221f-41a1-42f7-9182-97145281fc18",correct:"Blokově orientovaná zařízení, na rozdíl od operační paměti, přenášejí data po větších blocích.",incorrect:"Blokově orientovaná zařízení přenášejí data po jednotlivých bajtech, stejně jako operační paměť.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"c55c1c54-3b5a-42b2-bfec-a4a2a97b8492",correct:"Struktura blokově orientovaných zařízení odpovídá jejich fyzickému uspořádání do bloků.",incorrect:"Struktura blokově orientovaných zařízení je abstraktní a neodpovídá fyzickému uspořádání.",sectionNumber:"3.1.2",sectionTitle:"Blokové operace"},{uuid:"f17ec05d-c66c-43b4-a13c-054354e73943",correct:"Problém prodlevy mezi požadavkem a vyřízením nelze skrýt hardwarově a musí být řešen operačním systémem.",incorrect:"Problém prodlevy mezi požadavkem a vyřízením lze efektivně skrýt hardwarově bez zásahu operačního systému.",sectionNumber:"3.1.3",sectionTitle:"Latence"},{uuid:"592f27b0-c4e3-4249-b456-93a25ca4f619",correct:'Pro zajištění spolehlivého uložení dat, takzvané "durability" v ACID, je nutné v operačních systémech čekat na potvrzení zápisu kvůli prodlevě.',incorrect:'Pro zajištění spolehlivého uložení dat, takzvané "durability" v ACID, není nutné v operačních systémech čekat na potvrzení zápisu i přes prodlevu.',sectionNumber:"3.1.3",sectionTitle:"Latence"},{uuid:"b1159f0b-4418-426d-97b7-beaab0cf288c",correct:"Prodleva v kontextu operačních systémů označuje dobu, která uplyne mezi odesláním požadavku a obdržením odpovědi, a je příliš významná, než aby mohla být ignorována.",incorrect:"Prodleva v kontextu operačních systémů označuje dobu, která uplyne pouze při zpracování požadavku uvnitř hardwaru a operační systém ji může plně eliminovat.",sectionNumber:"3.1.3",sectionTitle:"Latence"},{uuid:"760e2546-84fa-43c2-bc49-3c52724fe92a",correct:"Mezipaměť v operačních systémech je navržena tak, aby skrývala latenci přístupu k datům.",incorrect:"Mezipaměť v operačních systémech primárně zvyšuje spolehlivost datových úložišť.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"1d36d03e-33ac-446a-8b14-b9c117512925",correct:"Politika mezipaměti operačního systému určuje, které nedávno čtené bloky dat zůstanou uloženy v RAM.",incorrect:"Politika mezipaměti operačního systému určuje, které nejméně často čtené bloky dat zůstanou uloženy v RAM.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"ef12571b-72e1-414e-b9fc-d1772271603b",correct:"Správu mezipaměti trvalých úložišť implementuje operační systém softwarově.",incorrect:"Správu mezipaměti trvalých úložišť implementuje výhradně hardware řadiče disku.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"c58514f6-0aca-4b5f-bfa1-9c83c655c7a6",correct:"Mezipaměť operačního systému nemá vliv na spolehlivost dat uložených v trvalém úložišti, pouze na rychlost přístupu.",incorrect:"Mezipaměť operačního systému je klíčová pro zajištění spolehlivosti dat uložených v trvalém úložišti.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"87c9af88-6fde-4176-ac07-56538350c89c",correct:"Hlavním účelem mezipaměti je zrychlení opakovaného přístupu ke stejným adresám v datovém úložišti.",incorrect:"Hlavním účelem mezipaměti je optimalizace sekvenčního přístupu k různým adresám v datovém úložišti.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"8257d804-2533-4036-8672-726bb0029b79",correct:"Operační systémy mohou využívat techniku prefetchingu pro načítání dat do mezipaměti s předstihem.",incorrect:"Operační systémy nikdy nevyužívají techniku prefetchingu kvůli neefektivnímu využití přenosové kapacity.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"2c0f64ef-4192-4427-92ee-e6ef0de37ab1",correct:"Při sekvenčním čtení souboru je efektivní načítat následující bloky do mezipaměti předem.",incorrect:"Při sekvenčním čtení souboru je neefektivní načítat následující bloky do mezipaměti předem.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"82a4a2a8-a164-412d-8c4b-59e00e348d9f",correct:"V kontextu trvalých úložišť je správa mezipaměti typicky realizována operačním systémem softwarově.",incorrect:"V kontextu trvalých úložišť je správa mezipaměti typicky realizována hardwarově řadičem paměti.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"14177550-b00e-42db-aa46-eeeab8ed4cc2",correct:"V mezipaměti trvalých úložišť operační paměť slouží jako rychlá mezipaměť a trvalé úložiště jako pomalá.",incorrect:"V mezipaměti trvalých úložišť trvalé úložiště slouží jako rychlá mezipaměť a operační paměť jako pomalá.",sectionNumber:"3.1.4",sectionTitle:"Mezipaměť"},{uuid:"3c2adf59-9c9a-4b80-b457-624b26bb100c",correct:"Vyrovnávací paměť slouží k vyrovnání rozdílu rychlostí mezi aplikací a trvalým úložištěm při zápisu dat.",incorrect:"Vyrovnávací paměť slouží k urychlení čtení dat z trvalého úložiště do aplikace.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"ecc030c3-bfd4-40fe-a78e-3434d2c1e59b",correct:"Data uložená ve vyrovnávací paměti se při výpadku napájení ztratí.",incorrect:"Data uložená ve vyrovnávací paměti jsou trvale uložena i po výpadku napájení.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"660efa26-e892-4c6a-b1b9-2235c919eae1",correct:"Oddělená vyrovnávací paměť uchovává požadavky na zápis i samotná data určená k zápisu.",incorrect:"Oddělená vyrovnávací paměť uchovává pouze požadavky na zápis, data jsou uložena v mezipaměti.",sectionNumber:"3.1.5",sectionTitle:"Vyrovnávací paměť"},{uuid:"835a4aa8-cc51-459f-9b40-78d47aa674d8",correct:"Sekvenční přístup k úložišti dat je obecně mnohem rychlejší než nahodilý přístup.",incorrect:"Nahodilý přístup k úložišti dat je obecně mnohem rychlejší než sekvenční přístup.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"b670418e-5631-4eb4-86c9-516e787c589f",correct:"Operace s trvalým úložištěm dat vykazují vysokou míru souběžnosti díky mnoha nezávislým požadavkům.",incorrect:"Operace s trvalým úložištěm dat obvykle nevykazují vysokou míru souběžnosti.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"8fc1bbcd-9156-43c0-bf1a-1a7674c96fbf",correct:"Přeuspořádání diskových operací, zejména zápisů, může vést k vyšší propustnosti systému.",incorrect:"Přeuspořádání diskových operací obvykle nevede k vyšší propustnosti systému.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"2c8488ee-a6fd-4bf5-994a-b0227d049ae5",correct:"Vyšší míra přeuspořádání zápisů může potenciálně zvýšit riziko nekonzistence dat při výpadku.",incorrect:"Vyšší míra přeuspořádání zápisů obvykle snižuje riziko nekonzistence dat při výpadku.",sectionNumber:"3.1.6",sectionTitle:"Plánování operací"},{uuid:"3483bdf2-5ead-489d-be9e-2d69c2d6235d",correct:"Virtualizace trvalých úložišť se liší od virtualizace paměti a procesoru kvůli potřebě interakce uživatele s daty.",incorrect:"Virtualizace trvalých úložišť je stejná jako virtualizace paměti a procesoru, protože cílem je izolace.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"f4253f3f-c188-4807-af29-0bf76aac8739",correct:"Jedno z řešení virtualizace trvalých úložišť spočívá ve vyčlenění aplikace odpovědné za správu dat.",incorrect:"Všechny aplikace mají přímý a neomezený přístup k trvalému úložišti i při virtualizaci.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"c1dc43ac-716f-4ff0-855c-540f9cda8bfb",correct:"Operační systém může poskytnout abstrakci trvalého úložiště, čímž skryje fyzické zařízení před aplikacemi.",incorrect:"Operační systém vždy poskytuje přímý přístup k fyzickému trvalému úložišti bez abstrakce.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"4cb9d37f-82a9-415d-9318-a5621266eae6",correct:"V obou navržených řešeních virtualizace trvalých úložišť je přímý přístup omezen na jeden program.",incorrect:"V obou navržených řešeních virtualizace trvalých úložišť mají všechny programy přímý přístup.",sectionNumber:"3.1.7",sectionTitle:"Problémy virtualizace"},{uuid:"a95344cd-c5d0-4b3f-aee3-47d3d13b8e8e",correct:"Souborový systém je abstrakce poskytovaná operačním systémem pro řízený přístup k datům.",incorrect:"Souborový systém je abstrakce poskytovaná aplikacemi pro přímý přístup k datům.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"67d72dbd-2a4c-41e2-9d15-f7dea60f918c",correct:"Virtualizace na aplikační úrovni se typicky používá v databázových systémech pro správu dat.",incorrect:"Virtualizace na aplikační úrovni se typicky používá pro virtualizaci operační paměti.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"28581bad-3951-4fba-8f8f-5b8aeb6e6b9e",correct:"Izolovaná virtuální instance úložiště je užitečná zejména při virtualizaci operačních systémů.",incorrect:"Izolovaná virtuální instance úložiště je nejběžnější metodou virtualizace trvalých úložišť.",sectionNumber:"3.1.8",sectionTitle:"Metody virtualizace"},{uuid:"15db155a-1e40-47f6-bf17-6fd3b4df76d5",correct:"Standardním řešením problémů se spolehlivostí paměti je v operačních systémech redundance.",incorrect:"Standardním řešením problémů se spolehlivostí paměti je v operačních systémech mezipaměť.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"35d8dd24-a89b-4b09-b7b8-f0dfa8ca8161",correct:"Technologie RAID spojuje několik fyzických úložišť do jednoho virtuálního diskového pole.",incorrect:"Technologie RAID rozděluje jedno fyzické úložiště na několik virtuálních diskových polí.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"c5d23acd-c284-47c3-90ca-5b4ef0ac7843",correct:"Softwarový RAID je implementován v blokové vrstvě operačního systému.",incorrect:"Softwarový RAID je implementován mimo blokovou vrstvu operačního systému.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"0043c964-9653-487f-b23b-ce960619e549",correct:"RAID 0 je jediná úroveň RAID, která neposkytuje žádnou redundanci dat.",incorrect:"RAID 0 je úroveň RAID, která poskytuje nejvyšší úroveň redundance dat.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"3cc32042-a59c-40d9-8e48-c2e8ee80c51b",correct:"Čtení z RAID pole je obvykle rychlejší díky paralelnímu přístupu k datům.",incorrect:"Čtení z RAID pole je obvykle pomalejší kvůli nutnosti skládat data z více disků.",sectionNumber:"3.1.9",sectionTitle:"RAID"},{uuid:"2bcbaa4c-26ad-40f7-a92c-7690b7ceecc6",correct:"Šifrování blokových zařízení typicky využívá symetrické šifrování pro zachování délky dat.",incorrect:"Šifrování blokových zařízení typicky využívá asymetrické šifrování pro zachování délky dat.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"7393195a-5401-4fd0-bb98-b47b8aecb023",correct:"Šifrování blokových zařízení je transparentní pro souborový systém a ten o něm nemusí vědět.",incorrect:"Souborový systém musí být speciálně navržen, aby mohl pracovat se šifrovanými blokovými zařízeními.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"0ecd422c-cb6b-40dc-b16c-0b17bd851bee",correct:"Šifrování blokových zařízení zachovává délku bloků, pokud se nepoužívá kontrola integrity dat.",incorrect:"Šifrování blokových zařízení vždy zachovává délku bloků dat, i když se používá kontrola integrity.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"dd60ac7f-2523-4ef7-96cb-53529b1f7725",correct:"Pro šifrování blokových zařízení se běžně používá hardwarově akcelerovaná šifra AES v módu CBC nebo XTS.",incorrect:"Pro šifrování blokových zařízení se běžně používá softwarově implementovaná šifra DES v módu ECB.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"4036c1df-2639-4f69-9ee8-459680655feb",correct:"Šifrování blokových zařízení chrání data v případě fyzického přístupu útočníka k pevnému disku.",incorrect:"Šifrování blokových zařízení chrání data pouze proti útokům vedeným přes počítačovou síť.",sectionNumber:"3.1.10",sectionTitle:"Šifrování, integrita"},{uuid:"7ef67309-da6a-4b27-bee9-26e84a1679eb",correct:"Soubor v operačním systému je abstrakce, která skrývá blokový charakter fyzického úložiště.",incorrect:"Soubor v operačním systému je fyzické blokové úložiště dat bez abstrakční vrstvy.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"6b475aa1-f92e-4c74-8926-276b263c8d6e",correct:"V POSIX systémech volání `read` a `write` umožňují čtení a zápis souborů po bajtech nebo blocích libovolné velikosti.",incorrect:"V POSIX systémech volání `read` a `write` umožňují čtení a zápis souborů pouze po blocích pevně dané velikosti.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"a4151833-4ab8-446f-be68-0f18119ee64d",correct:"Operační systém automaticky prodlouží soubor, pokud se zapisuje za aktuální konec souboru.",incorrect:"Operační systém nikdy automaticky neprodlužuje soubor, i když se zapisuje za jeho konec.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"808321ac-47ab-4a27-b077-108d5d6c3ac6",correct:"Soubory v operačním systému jsou obvykle perzistentní a existují nezávisle na běžících procesech.",incorrect:"Soubory v operačním systému jsou dočasné a existují pouze po dobu běhu procesu, který je vytvořil.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"569ca1ab-4cd2-4dae-8730-7d28ff64e9f7",correct:"Pro práci se souborem je ve většině systémů nutné jej nejprve otevřít, například pomocí volání `open` v POSIX.",incorrect:"Pro práci se souborem ve většině systémů není nutné jej otevírat, stačí znát jeho umístění v systému souborů.",sectionNumber:"3.2.1",sectionTitle:"Operace"},{uuid:"2fd4b7fb-019a-45aa-ae0e-225489992cac",correct:"Obyčejný soubor reprezentuje paměť a souborový systém neinterpretuje obsah obyčejných souborů.",incorrect:"Obyčejný soubor reprezentuje paměť a souborový systém interpretuje obsah obyčejných souborů.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"1595165b-66b0-469c-a5e9-ecda773a9a0f",correct:"Soubory nemají omezení na zarovnání, zatímco operace nad pevným úložištěm pracují po blocích s pevnou velikostí.",incorrect:"Soubory mají omezení na zarovnání, a operace nad pevným úložištěm nepracují po blocích s pevnou velikostí.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"d67fa53a-729c-41fe-9f45-533f05996fe6",correct:"Fyzické umístění dat souborů řeší operační systém a aplikace je od fyzického umístění odstíněna.",incorrect:"Fyzické umístění dat souborů řeší aplikace a operační systém se o fyzické umístění nestará.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"d36348e5-c140-42b4-9773-5709ee22b22b",correct:"Při prodlužování souboru souborový systém alokuje volné bloky a aktualizuje metadata souboru o nové bloky.",incorrect:"Při prodlužování souboru souborový systém nealokuje volné bloky, pouze aktualizuje metadata souboru.",sectionNumber:"3.2.2",sectionTitle:"Obyčejný soubor"},{uuid:"3ae61659-e12c-43ec-80b7-8625f2f3d5ad",correct:"Mapování souborů do paměti s líným načítáním zlepšuje efektivitu aplikací čtoucích data.",incorrect:"Mapování souborů do paměti s agresivním načítáním zlepšuje efektivitu aplikací čtoucích data.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"7e881440-4710-4579-bb86-70acd39cc971",correct:"Při mapování souborů do paměti mohou být externí stránky uloženy v běžném souboru na disku.",incorrect:"Při mapování souborů do paměti musí být externí stránky uloženy ve vyhrazené swapovací oblasti.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"1b828d87-bf6a-4dd9-a002-1a9f8d59a682",correct:"Mapování souborů do paměti umožňuje pracovat se soubory s menší režií než explicitní čtení a zápis.",incorrect:"Mapování souborů do paměti vyžaduje větší režii než explicitní čtení a zápis kvůli správě stránek.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"699f551a-a1d5-4271-a60e-e17f0c59a4c0",correct:"Operační systémy mohou optimalizovat čtení mapovaných souborů přemapováním stránek namísto kopírování dat, pokud jsou zarovnané.",incorrect:"Operační systémy vždy kopírují data při čtení mapovaných souborů, i když jsou operace zarovnané na stránky.",sectionNumber:"3.2.3",sectionTitle:"Mapováni do paměti"},{uuid:"79c73042-3244-4223-8429-8763861a9fc5",correct:"K souboru lze přistupovat z více vláken současně, pokud se jedná pouze o čtení.",incorrect:"K souboru lze přistupovat pouze z jednoho vlákna, i když se jedná pouze o čtení.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"76c9bd1e-a99d-4a4f-8367-6ecd9de6aa31",correct:"Při souběžném zápisu do souboru může dojít k hazardu souběhu, vyžadujícímu zamykání.",incorrect:"Při souběžném zápisu do souboru nikdy nedojde k hazardu souběhu, zamykání není nutné.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"603af444-98f3-46de-b1a9-722c904f80ff",correct:"Jmenný prostor souborového systému je sdílený mezi všemi procesy v operačním systému.",incorrect:"Jmenný prostor souborového systému je izolovaný pro každý proces v operačním systému.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"b1d43f04-ae07-4006-9931-82a0ab75cc2c",correct:"Operační systémy poskytují mechanismy zamykání souborů pro prevenci poškození dat při souběžném přístupu.",incorrect:"Operační systémy neposkytují mechanismy zamykání souborů, spoléhají se na programátory pro řešení souběžnosti.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"c2cbf28f-f1ae-43a6-9ff8-6f757c9c1640",correct:"Systémové volání `flock` v POSIX uzamkne pro proces celý soubor najednou.",incorrect:"Systémové volání `flock` v POSIX umožňuje zamknout pouze specifickou část souboru.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"8a2cb775-1ddd-416e-85b5-d3d574a4d60a",correct:"Systémové volání `fcntl` v POSIX umožňuje zamknout specifický rozsah bajtů v souboru.",incorrect:"Systémové volání `fcntl` v POSIX uzamkne vždy celý soubor, nikoliv jeho část.",sectionNumber:"3.2.4",sectionTitle:"Souběžný přístup"},{uuid:"91636412-6a1e-4ca4-9d50-290ce73ae5fe",correct:"Spustitelné soubory obsahují počáteční obraz paměti, který se používá k inicializaci virtuálního adresního prostoru procesu.",incorrect:"Spustitelné soubory obsahují pouze instrukce programu a neobsahují data pro inicializaci paměti.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"c0141274-9f52-4242-be65-88bea26fcf26",correct:"Volání funkce exec v POSIX systémech inicializuje virtuální adresní prostor procesu z dat ve spustitelném souboru.",incorrect:"Volání funkce exec v POSIX systémech kopíruje data ze spustitelného souboru přímo do fyzické paměti.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"8f79db0d-e761-4978-b599-b0bc930ec277",correct:"Z hlediska souborového systému nejsou spustitelné soubory speciálním typem souborů.",incorrect:"Spustitelné soubory jsou v souborovém systému označeny jako speciální typ souborů.",sectionNumber:"3.2.5",sectionTitle:"Spustitelný soubor"},{uuid:"0403dccb-2263-4062-885b-d4fe2316a762",correct:"Data v rourách nejsou trvale uložena a po přečtení dat z roury zmizí.",incorrect:"Data v rourách se trvale ukládají na disk a zůstávají dostupná i po přečtení.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"14f3f70a-5c8c-49f7-880e-b51dfcbe5ca2",correct:"Roury využívají buffer v operační paměti pro dočasné uložení dat.",incorrect:"Roury pro ukládání dat využívají trvalé úložiště na pevném disku.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"3c416fe5-cf30-46da-b044-8dd1c64c1450",correct:"Pojmenované roury v POSIX mají jméno v souborovém systému, ale data nejsou trvale uložena.",incorrect:"Pojmenované roury v POSIX trvale ukládají data v souborovém systému pod svým jménem.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"b38d506e-1a5d-4bc5-aead-3391b7ab05c0",correct:"Anonymní roury jsou přístupné pouze skrze popisovače souborů a po uzavření zanikají.",incorrect:"Anonymní roury jsou trvale uloženy v souborovém systému a mají přidělené jméno.",sectionNumber:"3.2.6",sectionTitle:"Roura"},{uuid:"c04f4de2-f9e6-45d7-b205-3c15f9ad74ab",correct:"Znaková zařízení v operačních systémech se chovají podobně jako roury.",incorrect:"Znaková zařízení v operačních systémech se chovají podobně jako fronty.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"d3fc9ec8-ea05-4122-a646-7bc8a0a6b26b",correct:"Znaková zařízení reprezentují periferie jako soubory v operačním systému.",incorrect:"Znaková zařízení reprezentují periferie jako procesy v operačním systému.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"f3d4ec9a-e7bc-4f65-8369-3435c6e2ad67",correct:"Data zapsaná do znakového zařízení jsou odeslána do hardwarové periferie.",incorrect:"Data zapsaná do znakového zařízení jsou uložena do souboru na disku.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"00e972e0-1034-418f-ba1e-bffe79655c6b",correct:"Znaková zařízení umožňují čtení dat přicházejících z hardwarové periferie.",incorrect:"Znaková zařízení umožňují modifikaci dat přicházejících z hardwarové periferie.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"02894245-a3c5-40d2-9428-2ff1ee58178d",correct:"Tiskárna a skener jsou příklady znakových zařízení v operačním systému.",incorrect:"Tiskárna a monitor jsou příklady znakových zařízení v operačním systému.",sectionNumber:"3.2.7",sectionTitle:"Zařízení"},{uuid:"c09d0203-5957-4b5b-bb30-21c972567304",correct:"V cestách souborů se pro oddělení adresářů používá znak lomítko, avšak systémy Windows používají zpětné lomítko.",incorrect:"V cestách souborů se pro oddělení adresářů vždy používá znak zpětné lomítko, a to i v systémech typu POSIX.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"2ddc2654-8621-4316-98ae-6f7ab911877a",correct:"Cesty mohou být absolutní, začínající od kořenového adresáře, nebo relativní, vztažené k aktuálnímu pracovnímu adresáři.",incorrect:"Cesty jsou vždy absolutní a začínají od kořenového adresáře, relativní cesty v moderních operačních systémech neexistují.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"26ea8717-a7f3-42c8-bb66-f67a3fe6d9df",correct:"Kořenový adresář v souborovém systému POSIX je označen cestou s jedním dopředným lomítkem, tedy znakem '/'.",incorrect:"Kořenový adresář v souborovém systému je označen prázdnou cestou, která neobsahuje žádné znaky.",sectionNumber:"3.3.1",sectionTitle:"Cesta"},{uuid:"5cebdc32-d69f-4c95-8e1f-a13ba395c6bd",correct:"Složka funguje jako slovník, kde klíčem je název souboru a hodnotou odkaz na i-uzel.",incorrect:"Složka funguje jako pole, kde indexem je pořadové číslo souboru a hodnotou obsah souboru.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"9be52149-6d36-4637-a205-6eeb68b33f7e",correct:"Složka obsahuje strukturovaná metadata, která mapují názvy souborů na odkazy, nikoliv obsah souborů.",incorrect:"Složka primárně obsahuje data souborů, a metadata slouží pouze pro organizaci zobrazení.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"362c5793-1d90-42fe-8120-fed62ad76427",correct:"Interakce uživatelských programů se složkami obvykle probíhá skrze cesty nebo iterací pro získání seznamu položek.",incorrect:"Uživatelské programy běžně interagují se složkami přímým čtením a zápisem datových struktur složky.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"302ba6d7-a3ef-42fd-8806-a7c4b9a608f3",correct:"V systémech POSIX se pro iteraci složek používají volání jako opendir, readdir a closedir.",incorrect:"V systémech POSIX se pro iteraci složek používají standardní volání read a write na souborovém deskriptoru.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"30d6e759-f291-4af2-804f-df02b39c3f17",correct:"Přidávání a odebírání položek ve složce se typicky provádí implicitně skrze operace s cestami, například vytvářením souborů.",incorrect:"Přidávání a odebírání položek ve složce vyžaduje přímou manipulaci s datovou strukturou složky pomocí speciálních systémových volání.",sectionNumber:"3.3.2",sectionTitle:"Adresář (složka)"},{uuid:"4866e4ad-2edd-4c02-8db1-ca911cb98253",correct:"Stejný soubor může být odkazován z více adresářů pomocí tvrdých odkazů.",incorrect:"Stejný soubor může být odkazován pouze z jednoho adresáře pomocí tvrdých odkazů.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"61ce0d88-f59c-40e2-bab4-a6feb78f6506",correct:"Tvrdé odkazy umožňují, aby více adresářových položek odkazovalo na stejný i-uzel.",incorrect:"Tvrdé odkazy umožňují, aby pouze jedna adresářová položka odkazovala na stejný i-uzel.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"7f1f00cf-66b0-4e81-9d5d-a2682bf7936e",correct:"I-uzel souboru je zničen, až když počítadlo odkazů klesne na nulu.",incorrect:"I-uzel souboru je zničen ihned po odstranění posledního adresářového odkazu.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"2c7322ae-320f-41e8-88c4-3c0363f10c76",correct:"Odstranění adresářové položky nemusí vést ke smazání souboru kvůli tvrdým odkazům.",incorrect:"Odstranění adresářové položky vždy vede ke smazání souboru i při existenci tvrdých odkazů.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"58462193-9a73-469e-93c6-c9b5c84707ba",correct:"Se souborem lze pracovat i po odstranění všech adresářových odkazů, pokud existuje otevřený popisovač.",incorrect:"Se souborem nelze pracovat po odstranění všech adresářových odkazů, i když existuje otevřený popisovač.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"4ee31d72-a72f-4106-9851-7be68e51ad8b",correct:"Tvrdé odkazy nelze vytvářet mezi různými souborovými systémy.",incorrect:"Tvrdé odkazy lze vytvářet i mezi různými souborovými systémy.",sectionNumber:"3.3.3",sectionTitle:"Tvrdé odkazy"},{uuid:"064fd70a-a4ec-4ecc-bddc-efb1f973d32f",correct:"Měkký odkaz je reprezentován samostatným i-uzlem v souborovém systému.",incorrect:"Měkký odkaz není reprezentován i-uzlem, ale přímo odkazuje na data souboru.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"94326c14-c987-4c25-a021-4674080395c0",correct:"Měkké odkazy mohou obsahovat cesty, které nemusí vést do stejného souborového systému.",incorrect:"Měkké odkazy musí vždy obsahovat cesty vedoucí do stejného souborového systému.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"27eb0462-298a-4a17-8d0b-652e974676ae",correct:"Operační systém při procházení měkkého odkazu čte cestu v něm obsaženou a pokračuje vyhledáváním.",incorrect:"Operační systém při procházení měkkého odkazu ignoruje cestu a pokračuje původní cestou.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"4ba544ff-4d83-4bdd-aa38-b7a810a43298",correct:"Cesta uložená v měkkém odkazu nemusí být platná a nemusí vést k existujícímu i-uzlu.",incorrect:"Cesta uložená v měkkém odkazu musí být vždy platná a vést k existujícímu i-uzlu.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"be139222-303b-4bd1-adf4-d5c2bc361990",correct:"Měkké odkazy umožňují vytvářet cykly v adresářové struktuře souborového systému.",incorrect:"Měkké odkazy jsou navrženy tak, aby nikdy nemohly vytvářet cykly v adresářové struktuře.",sectionNumber:"3.3.4",sectionTitle:"Měkké odkazy"},{uuid:"4c8c038d-57e6-47ab-8a6a-8b89e68fb950",correct:"Adresářová struktura je sdílená mezi všemi procesy v systému.",incorrect:"Adresářová struktura je privátní a každý proces má svou vlastní.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"04a8b3a4-970f-4b4b-8b55-d42d98415295",correct:"Sdílená adresářová struktura může vést k problémům souběhu při manipulaci se soubory.",incorrect:"Sdílená adresářová struktura eliminuje problémy souběhu při práci se soubory.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"ffbbf3a7-a09b-4343-9914-fc40c00163bc",correct:"Globální adresářová struktura usnadňuje předávání souborů mezi různými programy.",incorrect:"Globální adresářová struktura komplikuje sdílení souborů mezi programy.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"5a33a3a5-c380-4dc0-8511-c4a79f6939f5",correct:"Uživatelé ocení globální adresářovou strukturu pro snazší orientaci a organizaci dat.",incorrect:"Globální adresářová struktura zhoršuje uživatelskou orientaci v systému.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"566950c1-4fc6-4bfd-bf53-54476f30f0a3",correct:"Sdílení adresářové struktury může představovat bezpečnostní riziko neautorizovaného přístupu.",incorrect:"Sdílení adresářové struktury zvyšuje bezpečnost a chrání před neautorizovaným přístupem.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"b7a17aa2-e84c-4268-9506-8069816d3858",correct:"Některé operační systémy částečně omezují sdílení adresářové struktury z důvodu bezpečnosti.",incorrect:"Operační systémy nikdy neomezují sdílení adresářové struktury, je vždy plně globální.",sectionNumber:"3.3.5",sectionTitle:"Sdílení"},{uuid:"c0d3dcf0-f255-42d2-a0db-06de0c382493",correct:"Datové struktury souborového systému musí minimalizovat počet bloků potřebných pro danou operaci.",incorrect:"Datové struktury souborového systému se primárně zaměřují na maximalizaci počtu bloků pro operaci.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"843aa1af-e6d7-41ea-8ccf-3b212f17e513",correct:"Robustnost vůči přerušení operací je klíčová vlastnost datových struktur souborového systému.",incorrect:"Pro datové struktury souborového systému není robustnost vůči přerušení operací důležitá.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"f68d87c3-1ff3-49ff-adf9-2c113561be2b",correct:"Klasické zřetězené seznamy nejsou vhodné pro souborové systémy kvůli mnoha navazujícím operacím s malým objemem dat.",incorrect:"Klasické zřetězené seznamy jsou ideální pro souborové systémy díky efektivnímu využití paměti.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"6faf312c-9805-453b-a03d-ab8c8a5c53c6",correct:"Vyvažování stromů rotacemi může být nevhodné pro souborové systémy kvůli riziku ztráty dat při přerušení.",incorrect:"Rotace pro vyvažování stromů jsou preferovanou metodou v souborových systémech pro zvýšení výkonu.",sectionNumber:"3.4.1",sectionTitle:"Datové struktury"},{uuid:"53afcbfa-d539-4fd1-809c-cb27c35447bb",correct:"Bitmapa se v souborových systémech používá pro mapování volných a využitých datových bloků.",incorrect:"Bitmapa se v souborových systémech používá pro správu metadat souborů, nikoliv datových bloků.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"c6b827b4-d22d-4e56-890e-95db1c59e015",correct:"Každý bit v bitmapě reprezentuje stav jednoho datového bloku, typicky zda je blok volný nebo využitý.",incorrect:"Každý bit v bitmapě reprezentuje stav souboru a obsahuje informace o jeho oprávněních.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"a00ed7f7-5fed-47ef-963d-a3ae40ef93f1",correct:"Díky kompaktní reprezentaci bitmapy je možné rychle prohledávat velké diskové oblasti pro nalezení volného místa.",incorrect:"Kvůli nekompaktní reprezentaci bitmapy je prohledávání velkých diskových oblastí pomalé a neefektivní.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"d8b7ec4c-0eca-4fd5-8bef-677d91b84888",correct:"Zápis do bitmapy je považován za robustní, protože operace jsou jednoduché a bez složitých odkazů.",incorrect:"Zápis do bitmapy je náchylný k chybám kvůli složité struktuře odkazů mezi bity a datovými bloky.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"6c476412-5cc6-41be-b200-c770c55f8e09",correct:"Bitmapa umožňuje rychlé vyhledávání volných bloků i přesto, že asymptotická složitost vyhledávání je lineární.",incorrect:"Bitmapa je pomalá při vyhledávání volných bloků kvůli její logaritmické asymptotické složitosti.",sectionNumber:"3.4.2",sectionTitle:"Bitmapa"},{uuid:"66e1682e-a826-4195-8c5c-a7c0aaddbc36",correct:"Tabulky v souborovém systému jsou souvislé oblasti paměti obsahující řádky fixní velikosti, obvykle navržené tak, aby se jich vešel celočíselný počet do bloku.",incorrect:"Tabulky v souborovém systému jsou souvislé oblasti paměti obsahující řádky fixní velikosti, jejichž velikost není závislá na velikosti bloku.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"425744f9-d4ac-402f-87c7-ea3cfec904fb",correct:"Pro alokaci řádků v tabulce se běžně používá bitmapa a pro odkazování na řádky stačí znát jejich index.",incorrect:"Pro alokaci řádků v tabulce se běžně používá spojový seznam a pro odkazování na řádky stačí znát jejich index.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"4db4754b-80c9-4c28-ae2a-49e4ca58e52f",correct:"Tabulky v souborovém systému jsou obvykle alokovány pevně při jeho vzniku, což může vést k neefektivnímu využití místa.",incorrect:"Tabulky v souborovém systému jsou obvykle alokovány dynamicky během běhu systému pro efektivnější využití místa.",sectionNumber:"3.4.3",sectionTitle:"Tabulka"},{uuid:"39d2f8b3-b080-44be-9f77-5c5990f7488f",correct:"B-stromy jsou samovyvažovací vyhledávací stromy s logaritmickou hloubkou a složitostí operací.",incorrect:"B-stromy nejsou samovyvažovací vyhledávací stromy s logaritmickou hloubkou a složitostí operací.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"03f26396-bbb9-4a3f-ac53-042aefe8c835",correct:"B-strom je n-ární strom, kde každý uzel může mít desítky až stovky potomků, což zmenšuje hloubku stromu.",incorrect:"B-strom je binární strom, kde každý uzel může mít desítky až stovky potomků, což zmenšuje hloubku stromu.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"775eeb55-07a3-4d05-9110-e966ddff4795",correct:"Optimalizace B-stromů pro blokové operace spočívá v nastavení velikosti uzlu na velikost diskového bloku.",incorrect:"Optimalizace B-stromů pro blokové operace nespočívá v nastavení velikosti uzlu na velikost diskového bloku.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"bbd9ee9c-56ca-483b-85e1-b5473a4a7eb5",correct:"B-stromy jsou univerzální datové struktury, které mohou reprezentovat adresáře a být základem souborových systémů.",incorrect:"B-stromy nejsou univerzální datové struktury, a nemohou reprezentovat adresáře ani být základem souborových systémů.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"6de774b6-3052-404f-b49e-fae8772b87d7",correct:"Kvůli složitosti implementace B-stromů může být obtížné zajistit konzistenci dat při operacích zápisu.",incorrect:"Kvůli jednoduchosti implementace B-stromů je snadné zajistit konzistenci dat při operacích zápisu.",sectionNumber:"3.4.4",sectionTitle:"B-strom"},{uuid:"78ebd36e-decb-4efe-9eb5-917bacee5e4d",correct:"Konzistence metadat souborového systému může být narušena mezi daty a metadaty.",incorrect:"Konzistence metadat souborového systému může být narušena pouze v metadatech.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"951df37a-1ea9-4498-bf01-70f290cfbd42",correct:"Přerušení kritické operace, jako výpadek napájení, může způsobit nekonzistenci souborového systému.",incorrect:"Přerušení nekritické operace, jako restart aplikace, může způsobit nekonzistenci souborového systému.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"ed7076cc-5f4f-4727-baf9-9a5cd480f565",correct:"Narušení B-stromu, kdy uzel není platný, představuje porušení konzistence jednotlivé datové struktury.",incorrect:"Narušení B-stromu, kdy uzel není platný, představuje porušení konzistence mezi daty a metadaty.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"1c52c541-47f7-4320-90f1-2a758567057b",correct:"Konfliktní informace v bitmapě a metadatech tabulky je příkladem nekonzistence mezi strukturami.",incorrect:"Konfliktní informace uvnitř jedné bitmapy je příkladem nekonzistence mezi strukturami.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"441578eb-bc79-496d-8b32-b8bdd4e12618",correct:"Nesoulad mezi metadaty vlastníka souboru a daty uživatele v blocích je nekonzistence metadat a dat.",incorrect:"Nesoulad mezi metadaty vlastníka souboru a názvem souboru je nekonzistence metadat a dat.",sectionNumber:"3.4.5",sectionTitle:"Konzistence"},{uuid:"e283e896-453d-4d68-97d5-cfe06a9424a2",correct:"Žurnál souborového systému obsahuje sekvenci záznamů o akcích, které se mají provést, pro zajištění konzistence metadat.",incorrect:"Žurnál souborového systému obsahuje sekvenci záznamů o akcích, které se již provedly, pro urychlení zápisu metadat.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"5d100d7b-1bce-412c-9c8f-de8edab79991",correct:"Záznamy v žurnálu souborového systému jsou seskupeny do transakcí, které zaručují atomicitu operací s metadaty.",incorrect:"Záznamy v žurnálu souborového systému jsou seskupeny do transakcí, které primárně slouží k optimalizaci diskového prostoru.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"8e1c58c2-3b8b-4be1-9f52-de2dfbc8de64",correct:"Použití žurnálu v souborovém systému snižuje riziko poškození metadat a umožňuje rychlejší zotavení po havárii.",incorrect:"Použití žurnálu v souborovém systému zvyšuje riziko poškození metadat a zpomaluje zotavení po havárii.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"257dd988-b0bc-4213-8069-7d88e77920b9",correct:"Záznamy v žurnálu souborového systému musí být idempotentní, aby opakovaná aplikace záznamu nezpůsobila nekonzistenci.",incorrect:"Záznamy v žurnálu souborového systému nemusí být idempotentní, protože se nikdy neaplikují více než jednou.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"cc2d59e8-4b9c-453d-a054-b379b6b551f5",correct:"Souborový systém ext4 používá dvouúrovňový žurnál, kde JBD2 tvoří fyzickou vrstvu a fast commit logickou vrstvu.",incorrect:"Souborový systém ext4 používá pouze jedinou úroveň žurnálu, která kombinuje fyzické i logické aspekty operací.",sectionNumber:"3.4.6",sectionTitle:"Žurnál"},{uuid:"c983d92e-36af-494f-a9a0-58f356fab5e8",correct:"Při úpravě metadat se vytváří nová verze datové struktury namísto úpravy stávající.",incorrect:"Při úpravě metadat se datová struktura upravuje přímo na místě bez vytváření kopie.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"15e2271e-0243-4774-87aa-9260d9c0459f",correct:"Tento přístup je vhodný pro stromové datové struktury, jako jsou B-stromy v souborových systémech.",incorrect:"Tento přístup je nejvhodnější pro lineární datové struktury, jako jsou spojové seznamy.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"85a288ad-168a-47dc-bb66-4fe20c8799c7",correct:"Synchronizace zápisu nového kořene stromu zajišťuje konzistenci metadat.",incorrect:"Konzistence metadat je zajištěna i bez synchronizace zápisu nového kořene stromu.",sectionNumber:"3.4.7",sectionTitle:"Funkcionální metadata"},{uuid:"acdcc724-da35-42c4-970a-59bae12d7ec7",correct:"Cílem správy volných bloků je rychlé nalezení volného místa a minimalizace externí fragmentace.",incorrect:"Cílem správy volných bloků je pomalé nalezení volného místa a maximalizace externí fragmentace.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"67cccae3-203f-4d20-badd-9eef5589e410",correct:"Pro organizaci volných bloků se často používají bitmapy nebo B-stromy.",incorrect:"Pro organizaci volných bloků se často používají spojové seznamy nebo kruhové fronty.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"cc5195e6-b5e6-431d-aff0-2c471c27c93c",correct:"V B-stromě pro správu volných bloků může být klíčem adresa prvního bloku volné skupiny.",incorrect:"V B-stromě pro správu volných bloků musí být klíčem velikost volné skupiny.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"30b399d4-74fc-4ea6-add1-6ae75b64c938",correct:"Některé B-stromy pro volné bloky používají velikost volné oblasti jako hlavní klíč a adresu jako vedlejší.",incorrect:"Všechny B-stromy pro volné bloky používají velikost volné oblasti jako hlavní klíč.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"e55c8567-589b-41d7-adda-b70b1e427503",correct:"Některé souborové systémy rozdělují disk na alokační skupiny s vlastními bitmapami a i-uzly.",incorrect:"Všechny souborové systémy rozdělují disk na alokační skupiny s vlastními bitmapami a i-uzly.",sectionNumber:"3.4.8",sectionTitle:"Prázdné místo"},{uuid:"6b59a164-1c28-4b98-9cae-ae1bb317a709",correct:"Externí fragmentace nastává, když volné místo na disku není souvislé, například po smazání starých souborů.",incorrect:"Externí fragmentace popisuje situaci, kdy jsou data jednoho souboru uložena v nesouvislých blocích.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"740299c0-7f69-4cdd-958a-7f39d5b58ab6",correct:"Datová fragmentace souborů zhoršuje efektivitu čtení dat z disku kvůli nutnosti přeskakování mezi fragmenty.",incorrect:"Datová fragmentace zlepšuje efektivitu čtení souborů, protože data jsou lépe uspořádána.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"ccba3b3e-8896-4743-8d98-d196b77d5816",correct:"Fragmentace souborového systému vede ke zvětšení metadat potřebných pro správu souborů a jejich umístění.",incorrect:"Fragmentace souborového systému snižuje objem metadat nutných pro správu souborů na disku.",sectionNumber:"3.4.9",sectionTitle:"Externí a datová fragmentace"},{uuid:"f15b2938-46fc-4792-8ac7-b298115436e7",correct:"Extenty pro reprezentaci datových bloků souboru mohou být úspornější a efektivnější než tradiční tabulky přímých a nepřímých odkazů.",incorrect:"Extenty pro reprezentaci datových bloků souboru jsou vždy méně úsporné a méně efektivní než tradiční tabulky přímých a nepřímých odkazů.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"eefcae1f-b72d-49c0-8e23-7b7c72b2f391",correct:"Vyhledávání datového bloku podle offsetu v metadatech s extenty může být lineární v závislosti na délce tabulky extentů.",incorrect:"Vyhledávání datového bloku podle offsetu v metadatech s extenty je vždy konstantní bez ohledu na délku tabulky extentů.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"40622c0c-709b-4339-8fae-5e6cbbf7d842",correct:"Rozsahy (extenty) datových bloků lze kombinovat s tabulkami i B-stromy pro správu metadat souborů.",incorrect:"Rozsahy (extenty) datových bloků lze kombinovat pouze s B-stromy, nikoliv s tabulkami pro správu metadat souborů.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"70b8da5d-b87f-48f1-986e-be2508688710",correct:"Při čtení celého souboru je celková složitost přístupu k datům s extenty asymptoticky stejná, ale prakticky lepší než u tabulek jednotlivých bloků.",incorrect:"Při čtení celého souboru je celková složitost přístupu k datům s extenty asymptoticky horší a prakticky horší než u tabulek jednotlivých bloků.",sectionNumber:"3.4.10",sectionTitle:"Obyčejné soubory"},{uuid:"d757b1fc-6c3a-4145-9f2f-22cb7a63dab0",correct:"Vnitřní fragmentace vzniká, protože soubory se ukládají v blocích pevné velikosti.",incorrect:"Vnitřní fragmentace nevzniká, protože soubory se ukládají v blocích pevné velikosti.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"a020500e-11ea-4f67-b09f-a70175b78f19",correct:"Zarovnání souborů na hranice bloků může vést k vnitřní fragmentaci paměti.",incorrect:"Zarovnání souborů na hranice bloků vždy zabraňuje vnitřní fragmentaci paměti.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"dfbd0f22-436b-47f8-b008-25987272d2d8",correct:"Vnitřní fragmentace představuje nevyužité místo uvnitř alokovaných bloků souboru.",incorrect:"Vnitřní fragmentace představuje nevyužité místo mezi alokovanými bloky souboru.",sectionNumber:"3.4.11",sectionTitle:"Vnitřní fragmentace"},{uuid:"9e9f636e-a105-46ae-8618-7e3de0b23772",correct:"Klasické reprezentace složek mají lineární složitost vyhledávání, což je neefektivní pro velké adresáře.",incorrect:"Klasické reprezentace složek mají konstantní složitost vyhledávání, což je efektivní i pro velké adresáře.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"510f5a04-1d5f-40e6-8da5-923b8f250ef0",correct:"Hašované složky ukládají položky do hašovací tabulky, iterace vrací položky v náhodném pořadí.",incorrect:"Hašované složky ukládají položky seřazené podle jména, iterace vrací položky v uspořádaném pořadí.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"3164a9bb-9316-498a-a649-bd7bb7c59437",correct:"Stromové složky využívají B-stromy v metadatech, operace mají logaritmickou časovou složitost.",incorrect:"Stromové složky využívají hašovací tabulky v datových blocích, operace mají konstantní časovou složitost.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"f64407c0-5b10-4dc2-9b2a-9a1492088c1c",correct:"Pro malé složky může být klasická reprezentace dostačující, ale pro velké se stává nepraktickou.",incorrect:"Pro malé složky je stromová reprezentace nejefektivnější, zatímco klasická je vždy nepraktická.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"},{uuid:"6e6431c7-7ea0-4a4d-96a2-dfc621e14210",correct:"Stromové složky zaručují logaritmickou složitost všech operací a vrací položky seřazené podle jména.",incorrect:"Stromové složky zaručují konstantní složitost všech operací a vrací položky v náhodném pořadí.",sectionNumber:"3.4.12",sectionTitle:"Adresáře"}]},{uuid:"1ad5b698-0291-4fa7-8feb-bbbc27c26bfd",sectionNumber:"4",sectionTitle:"Virtualizace periferií",statements:[{uuid:"c442e1b1-24b2-4fd4-8752-107218aefeb8",correct:"Řadiče sběrnic jsou považovány za pomocná vnitřní zařízení počítače.",incorrect:"Řadiče sběrnic jsou považovány za perzistentní úložiště dat.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"54e5ec88-217d-44bc-8038-39ca23e0692a",correct:"Perzistentní úložiště slouží k dlouhodobému uchování dat i po vypnutí napájení.",incorrect:"Perzistentní úložiště slouží pouze k dočasnému uchování dat během běhu programu.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"20fea280-a7a7-4b12-968a-a3b4518bdf8f",correct:"Síťová rozhraní umožňují počítačům komunikovat a vyměňovat si data v síti.",incorrect:"Síťová rozhraní slouží výhradně pro komunikaci s vnitřními komponentami počítače.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"ef17f393-6b0b-46a3-a842-1f51c66c27ab",correct:"Terminál zahrnuje obrazovku, klávesnici a další periferie pro interakci uživatele s počítačem.",incorrect:"Terminál se skládá pouze z centrální procesorové jednotky a operační paměti.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"2a05b7e4-f2bd-4bc4-92c0-43503205885c",correct:"Mezi součásti terminálu patří vstupní zařízení jako klávesnice a myš.",incorrect:"Mezi součásti terminálu patří výhradně výstupní zařízení jako tiskárny a skenery.",sectionNumber:"4.1.1",sectionTitle:"Typy periferií"},{uuid:"516b3315-6735-4f3f-9206-ae40781f98ef",correct:"Mapování registrů zařízení na fyzické adresy se typicky používá pro komunikaci s malým objemem dat.",incorrect:"Mapování registrů zařízení na fyzické adresy se typicky používá pro komunikaci s velkým objemem dat.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"e916a8c7-65da-4149-98f6-3d99d0e2f3b4",correct:"Registry zařízení se liší od registrů procesoru a představují paměťové buňky s pevnou funkcí.",incorrect:"Registry zařízení jsou identické s registry procesoru a nemají pevnou funkci.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"d81f6da8-c88c-4a1f-9d63-7c6fbbf3c4b9",correct:"Hodnoty v registrech zařízení se mohou měnit samovolně bez přímého zásahu hlavního procesoru.",incorrect:"Hodnoty v registrech zařízení se mohou měnit pouze přímým zásahem hlavního procesoru.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"87014756-1f09-43dd-b78a-61642118b612",correct:"Princip FIFO u paměti zařízení znamená, že nejstarší data jsou přepsána novými po zaplnění.",incorrect:"Princip FIFO u paměti zařízení znamená, že nejnovější data jsou přepsána starými po zaplnění.",sectionNumber:"4.1.2",sectionTitle:"Co je periferie?"},{uuid:"4144d03c-9c1b-4a29-90b4-c37809aeac16",correct:"Programované I/O vyžaduje aktivní účast procesoru v pravidelných časových intervalech.",incorrect:"Programované I/O nevyžaduje aktivní účast procesoru v pravidelných časových intervalech.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"b5969363-4b22-4309-9d3d-8973a18c2ae6",correct:"Programované I/O je vhodné pro občasné přenosy nebo přenosy s malou šířkou pásma.",incorrect:"Programované I/O je vhodné pro velké objemy dat a kontinuální přenosy s vysokou šířkou pásma.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"b3c51b53-856f-47c8-920c-3e25bfdb6a79",correct:"Při velkých objemech dat vede programované I/O k vysoké režii.",incorrect:"Při velkých objemech dat vede programované I/O k nízké režii.",sectionNumber:"4.1.3",sectionTitle:"Programovaný vstup/výstup (PIO)"},{uuid:"9226b603-b4a2-432b-b2cb-3c1fcfa29a51",correct:"DMA přenosy umožňují periferiím asynchronně zapisovat data přímo do operační paměti bez přímé účasti CPU při samotném přenosu.",incorrect:"DMA přenosy vyžadují aktivní účast hlavního procesoru při každém přenosu dat mezi periferií a operační pamětí.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"d7494bef-eb96-4f2a-a749-3a7267ae4174",correct:"V moderních počítačových systémech je běžnější, že DMA přenosy jsou řízeny přímo periferií, což zvyšuje efektivitu.",incorrect:"Dedikovaný pomocný procesor je v moderních systémech běžnější metodou pro řízení DMA přenosů než přímé řízení periferií.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"1bb1bca3-0650-46b5-a490-b1d85c57b8b3",correct:"DMA se často využívá pro periferie jako SSD disky a grafické karty, kde jsou vyžadovány časté a velké přenosy dat.",incorrect:"DMA se obvykle nepoužívá pro SSD disky a grafické karty, protože tyto periferie obvykle nevyžadují rychlé přenosy dat.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"c2a7599f-4ec1-48f3-99d7-cbd5ac522725",correct:"Při DMA přenosu na sdílené sběrnici se periferie dočasně stává řídícím zařízením sběrnice pro provedení přenosu.",incorrect:"Při DMA přenosu na sdílené sběrnici zůstává procesor vždy řídícím zařízením sběrnice a periferie nemůže převzít kontrolu.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"d1b5dede-9f4e-4224-bf15-74b9a4eb3aab",correct:"Rozdíl mezi DMA a mapováním paměti zařízení spočívá v tom, že DMA obchází procesor při komunikaci s pamětí.",incorrect:"DMA a mapování paměti zařízení jsou v podstatě totožné mechanismy pro přímý přístup procesoru k periferiím.",sectionNumber:"4.1.4",sectionTitle:"Přímý přístup do paměti (DMA)"},{uuid:"d24d99a4-927a-4036-8b26-7ff1fea11037",correct:"Klasická implementace DMA představuje bezpečnostní riziko kvůli neomezenému přístupu periferií do fyzické paměti.",incorrect:"Klasická implementace DMA je zcela bezpečná, protože operační systém plně kontroluje přístup periferií do paměti.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"aa1f9096-ed6b-4af8-8022-e33aedaf54cc",correct:"IO-MMU řeší bezpečnostní rizika DMA tím, že zavádí překlad adres pro periferie, podobně jako MMU pro software.",incorrect:"IO-MMU primárně zvyšuje výkon DMA operací, nikoliv řeší bezpečnostní rizika spojená s přímým přístupem do paměti.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"a8f885ff-21f6-4955-abf0-50def37cf24e",correct:"IO-MMU je programovatelná výhradně operačním systémem, což zajišťuje kontrolu nad přístupem periferií do paměti.",incorrect:"IO-MMU mohou programovat i ovladače periferií, což umožňuje flexibilnější správu paměťových přístupů.",sectionNumber:"4.1.5",sectionTitle:"IO-MMU"},{uuid:"f6716fa2-41d8-4f50-8af9-0035d02a885d",correct:"Sběrnice se skládá z fyzické a logické vrstvy, kde logická vrstva řeší adresaci a konfiguraci zařízení.",incorrect:"Sběrnice se skládá pouze z fyzické vrstvy, která se stará o veškerou komunikaci a konfiguraci zařízení.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"3cb3b012-1fcd-47b7-8a7b-cbd5267a5697",correct:"Řadič sběrnice je typ periferie, s nímž procesor komunikuje a který rozděluje adresní prostor.",incorrect:"Řadič sběrnice není periferie, ale pouze pasivní prvek propojující různé typy sběrnic.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"e0c2664f-310e-4efb-91c3-1cdb0b34ec97",correct:"Hlavním úkolem sběrnice je přenos dat a signalizace událostí, přičemž události se mohou projevit jako přerušení.",incorrect:"Hlavním úkolem sběrnice je pouze konfigurace připojených periferií a nikoliv přenos dat mezi nimi.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"7092f638-5262-4323-bf3e-017b7aef0bab",correct:"Procesory Intel Skylake propojují jádra, GPU a cache pomocí sběrnice Ring Bus.",incorrect:"Procesory Intel Skylake propojují jádra a paměť pomocí sběrnice PCIe.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"daa2b10a-fa06-447f-b4d3-7ceab3173eee",correct:"Na sběrnici PCIe mohou být připojeny NVMe úložiště, síťová rozhraní a řadiče USB.",incorrect:"Na sběrnici PCIe jsou připojeny výhradně paměťové moduly RAM a žádná jiná zařízení.",sectionNumber:"4.1.6",sectionTitle:"Sběrnice"},{uuid:"9df852a8-d2f9-4f6f-a73a-d5d770422409",correct:"Enumerace sběrnice umožňuje operačnímu systému zjistit připojené periferie automaticky.",incorrect:"Enumerace sběrnice vyžaduje manuální konfiguraci uživatelem pro zjištění připojených periferií.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"a0e81b81-1b8e-4c8f-8689-8892540e2a1e",correct:"Moderní sběrnice poskytují unikátní identifikátory zařízení pro automatickou konfiguraci ovladačů.",incorrect:"Unikátní identifikátory zařízení nejsou poskytovány moderními sběrnicemi pro konfiguraci ovladačů.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"3829e707-1950-47e4-bfaa-d64d3b66bf97",correct:"Historická sběrnice ISA nepodporovala enumeraci, vyžadovala konfiguraci adres uživatelem.",incorrect:"Historická sběrnice ISA podporovala enumeraci periferií automaticky bez zásahu uživatele.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"c0894816-a2ff-4286-b44b-a248bf6c8814",correct:"Enumerace sběrnice zahrnuje vyjmenování periferií a jejich základních parametrů pro OS.",incorrect:"Enumerace sběrnice se omezuje pouze na zjištění přítomnosti periferií bez parametrů.",sectionNumber:"4.1.7",sectionTitle:"Enumerace"},{uuid:"b35c90ec-d7fe-441e-ac5f-bf30e0fc8215",correct:"Ovladač zařízení je program, který poskytuje softwarovou abstrakci dané třídy zařízení operačnímu systému.",incorrect:"Ovladač zařízení je hardware, který obsluhuje periferie a je zcela nezávislý na operačním systému.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"33c3185f-9c59-4025-9d5d-cb80bbe56379",correct:"Hlavním úkolem ovladače je převod dat mezi formou, kterou poskytuje zařízení, a formou, kterou vyžaduje operační systém.",incorrect:"Hlavním úkolem ovladače je pouze zajistit fyzický přenos dat mezi zařízením a operační pamětí bez nutnosti konverze dat.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"2ab06248-83d9-4011-9e84-1c9e68c8a275",correct:"Ovladače sběrnic jsou využívány ovladači periferií pro komunikaci se zařízeními, která jsou připojena přes danou sběrnici.",incorrect:"Ovladače periferií obcházejí ovladače sběrnic a komunikují přímo s hardwarem sběrnice pro zvýšení výkonu.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"31cfcd1a-d19d-4226-8434-6f2782a757bf",correct:"Komunikace s periferiemi skrze ovladače zahrnuje čtení a zápis dat, což představuje výpočetní operace pro zpracování datových formátů.",incorrect:"Komunikace s periferiemi je čistě hardwarová záležitost, která se obejde bez jakýchkoliv výpočetních operací na straně ovladače.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"cde8819f-a382-4af1-9bfc-f1cd8dae03d9",correct:"Ovladače zpracovávají nejen užitná data, ale i řídící data, která konfigurují chování zařízení a aktivují specifické funkce.",incorrect:"Ovladače se starají výhradně o přenos užitných dat, řízení a konfigurace zařízení je plně v kompetenci operačního systému.",sectionNumber:"4.1.8",sectionTitle:"Ovladač"},{uuid:"6d66ee01-6710-43a7-9ec1-0a603666ca96",correct:"Fyzický terminál se skládá z výstupní i vstupní části, jako je obrazovka a klávesnice.",incorrect:"Fyzický terminál se skládá pouze z výstupní části, jako je například obrazovka.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"d8a85e66-fe73-45b4-bf71-8d45dd9ceeda",correct:"Virtualizace terminálů umožňuje vytvořit více virtuálních terminálů, než je fyzických zařízení.",incorrect:"Virtualizace terminálů omezuje počet virtuálních terminálů na počet fyzických zařízení.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"d12bdde1-fe4a-4f3a-b578-f88e8d350886",correct:"Pro virtualizaci textového terminálu je nezbytné zapamatovat si obsah obrazovky v operační paměti.",incorrect:"Pro virtualizaci textového terminálu není nutné ukládat obsah obrazovky do operační paměti.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"4117834d-e0d1-457a-adae-e4c0bf89e145",correct:"Aktivace virtuálního terminálu způsobí, že se obsah fyzické obrazovky přepíše uloženým obsahem.",incorrect:"Aktivace virtuálního terminálu nemá vliv na obsah fyzické obrazovky a její zobrazení.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"ecfb6fe2-1437-428e-b40d-52ec356a68d0",correct:"Připojení a odpojení fyzické klávesnice od virtuálního terminálu neovlivní běžící program.",incorrect:"Odpojení fyzické klávesnice od virtuálního terminálu vždy způsobí pád běžícího programu.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"cb41fa33-7682-4bd0-9b03-e1d98aa16747",correct:"Synchronizace přepojování klávesnice a obrazovky zajišťuje, že obrazovka zobrazuje terminál s připojenou klávesnicí.",incorrect:"Přepojování klávesnice a obrazovky u virtuálních terminálů probíhá zcela nezávisle na sobě.",sectionNumber:"4.2.1",sectionTitle:"Textový terminál"},{uuid:"15a1e831-80a2-43ef-89fa-968d6d465610",correct:"Na virtuálním terminálu je vždy aktivní právě jeden program, který ovládá terminál a zobrazuje výstup.",incorrect:"Na virtuálním terminálu může být aktivních více programů současně, které sdílí ovládání terminálu.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"4880efd2-11df-4737-a8f6-8e68525c3941",correct:"V řádkovém režimu terminálu se text vypisuje pouze do jednoho řádku, přičemž scrollování posouvá starší řádky pryč.",incorrect:"V řádkovém režimu terminálu se text vypisuje do více řádků současně bez scrollování.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"abcf776b-81d6-4247-8897-5a9ca5946d92",correct:"Obrazovkový režim terminálu umožňuje programům cíleně měnit obsah libovolného políčka na obrazovce.",incorrect:"Obrazovkový režim terminálu omezuje programy pouze na změnu aktuálního řádku.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"a89b33da-82f5-4e2c-be91-b86031bad4a0",correct:"Virtuální terminál může být emulován grafickou aplikací, čímž není nutná fyzická přítomnost terminálu.",incorrect:"Virtuální terminál vyžaduje fyzické zařízení a nemůže být emulován softwarovou aplikací.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"632acf0e-a403-433e-99de-6f611dcc3abf",correct:"Přes síťové spojení, například pomocí ssh, může být virtuální terminál zobrazen na vzdáleném počítači.",incorrect:"Virtuální terminál je vždy zobrazen pouze na lokálním počítači a nemůže být sdílen přes síť.",sectionNumber:"4.2.2",sectionTitle:"Výstup na obrazovku"},{uuid:"8a8efd6e-9157-44c1-96c8-7e443b24b1f5",correct:"Virtuální klávesnice buď přeposílá data z fyzické klávesnice, nebo je nulová.",incorrect:"Virtuální klávesnice vždy aktivně zpracovává data a nikdy není nulová.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"5b5f2597-a5e9-4f51-a2bc-4c589f87c767",correct:"K fyzické klávesnici je obvykle připojena jedna virtuální klávesnice.",incorrect:"K fyzické klávesnici může být připojeno více virtuálních klávesnic současně.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"4b51febc-a2f9-44bf-beab-bf3842c88bd6",correct:"Programy v neaktivních virtuálních terminálech jsou typicky připojeny k nulové klávesnici.",incorrect:"Programy v neaktivních virtuálních terminálech jsou aktivně obsluhovány fyzickou klávesnicí.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"41d1da81-2b23-4a33-924c-639ddb30ae25",correct:"Virtuální klávesnice může být řízena programem, například u vzdáleného terminálu.",incorrect:"Virtuální klávesnice je vždy řízena fyzickým uživatelem, nikoliv programem.",sectionNumber:"4.2.3",sectionTitle:"Vstup z klávesnice"},{uuid:"2afcdef8-64e1-4356-bc22-76f66b154eae",correct:"V grafickém režimu jsou buňky s písmeny nahrazeny pixely, což umožňuje flexibilnější zobrazení.",incorrect:"V grafickém režimu jsou pixely nahrazeny buňkami s písmeny, což zachovává omezení textového terminálu.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"9f7a8349-0c21-424e-99c6-6329176349fc",correct:"Virtualizace vstupu v grafickém režimu má podobná omezení jako virtualizace vstupu v textovém režimu.",incorrect:"Virtualizace vstupu v grafickém režimu je výrazně flexibilnější než virtualizace vstupu v textovém režimu.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"27972471-d3ab-4c64-9e1d-876b487ed8f9",correct:"Grafická obrazovka nabízí flexibilnější metody virtualizace výstupu oproti textové obrazovce.",incorrect:"Textová obrazovka nabízí flexibilnější metody virtualizace výstupu oproti grafické obrazovce.",sectionNumber:"4.2.4",sectionTitle:"Grafický režim"},{uuid:"97f42306-3d95-4ffb-bbda-556c3e683ee5",correct:"Každá aplikace v okenním systému obdrží svou vlastní virtuální obrazovku.",incorrect:"Pouze některé aplikace v okenním systému obdrží svou vlastní virtuální obrazovku.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"e6322595-e3ac-4d22-96a4-18482518c9db",correct:"Virtuální obrazovky aplikací jsou zobrazeny jako okna, s nimiž může uživatel manipulovat.",incorrect:"Virtuální obrazovky aplikací jsou zobrazeny jako okna, s nimiž uživatel nemůže manipulovat.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"fea0681f-a210-4c76-a285-d19300046b80",correct:"Chování oken, včetně jejich zobrazení a ovládání, se může lišit v závislosti na konkrétním okenním systému.",incorrect:"Chování oken, včetně jejich zobrazení a ovládání, je jednotné napříč všemi okenními systémy.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"22d3bf83-7569-4382-a9b6-419d5369325a",correct:"Okenní systém virtualizuje klávesnici a události ukazovacích zařízení pro aktivní okno.",incorrect:"Okenní systém virtualizuje pouze klávesnici, ale ne události ukazovacích zařízení.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"953070d9-6925-4105-b71f-4aff7b2dce40",correct:"Rozhraní mobilních telefonů, umožňující přepínání mezi aplikacemi, lze považovat za formu okenního systému.",incorrect:"Rozhraní mobilních telefonů, umožňující přepínání mezi aplikacemi, nelze považovat za formu okenního systému.",sectionNumber:"4.2.5",sectionTitle:"Okenní systémy"},{uuid:"dcf24305-d985-484f-96ca-6f0cd01e2c55",correct:"Rasterizace, neboli výpočet barev pixelů, je výpočetně náročný proces, jehož náročnost roste s počtem pixelů a složitostí scény.",incorrect:"Rasterizace, neboli výpočet barev pixelů, je výpočetně nenáročný proces, jehož náročnost klesá s počtem pixelů a složitostí scény.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"e2326424-9d4a-412b-902d-235ba0cf2330",correct:"Moderní GPU využívají virtualizaci s hardwarovými kontexty pro efektivní sdílení mezi více aplikacemi.",incorrect:"Moderní GPU nepodporují virtualizaci a nemohou být efektivně sdíleny mezi více aplikacemi.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"94ce95d9-11c9-480c-9761-0c37ab8de0b1",correct:"Výpočet pixelů pomocí GPU typicky zahrnuje uložení vypočtených pixelů do paměti.",incorrect:"Výpočet pixelů pomocí GPU se obejde bez nutnosti ukládat vypočtené pixely do paměti.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"cad0b46f-df05-43f4-9629-f2bfb10f079c",correct:"Specializovaný hardware GPU urychluje rasterizaci mimo jiné díky efektivní virtualizaci přepínáním kontextů.",incorrect:"Specializovaný hardware GPU urychluje rasterizaci, ale virtualizace přepínáním kontextů s tím nesouvisí.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"5aa360ec-34d3-4f43-bd56-31f6d531b5ec",correct:"Přístup CPU do paměti je nákladný, obzvláště pokud vyžaduje načítání dat pro výpočet barvy pixelu.",incorrect:"Přístup CPU do paměti je rychlý a nenákladný, a to i při načítání dat pro výpočet barvy pixelu.",sectionNumber:"4.2.6",sectionTitle:"GPU"},{uuid:"e0e58789-62c8-4abe-bc91-1d3a45416c45",correct:"Výstupní část okenního systému, kompozitor, skládá obrázky aplikací do jednoho snímku.",incorrect:"Vstupní část okenního systému, kompozitor, skládá obrázky aplikací do jednoho snímku.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"0125d2a4-3559-47c6-bc1c-bacbb9fcec58",correct:"Pro výpočet snímku kompozitor obvykle využívá GPU, čímž šetří operační paměť.",incorrect:"Pro výpočet snímku kompozitor obvykle využívá CPU, čímž šetří operační paměť.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"98e4d2ac-42f3-4ac8-a963-1cbe65af21c4",correct:"Kompozitor musí spolupracovat se vstupní částí systému kvůli správnému zpracování souřadnic událostí.",incorrect:"Kompozitor nemusí spolupracovat se vstupní částí systému, protože souřadnice událostí jsou irelevantní.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"300bfcd3-4f37-4f98-8e74-fa136b707300",correct:"V okenním systému s kompozitorem je každá aplikace odpovědná za vykreslování vlastních pixelů.",incorrect:"V okenním systému s kompozitorem je kompozitor odpovědný za vykreslování pixelů všech aplikací.",sectionNumber:"4.2.7",sectionTitle:"Kompozitor"},{uuid:"90c82156-bebd-4611-a073-6fe2c25a0be4",correct:"Grafický server je alternativní metoda virtualizace grafického podsystému.",incorrect:"Grafický server je primární metoda virtualizace grafického podsystému.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"f03b45ca-e63d-4533-a44a-ae3504dea905",correct:"Grafický server přijímá příkazy vyšší úrovně pro vykreslování 2D a 3D objektů.",incorrect:"Grafický server přijímá příkazy na úrovni jednotlivých pixelů pro vykreslování.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"5c84ea94-0299-434a-aa36-d40e9f9839cc",correct:"Grafický server má plnou kontrolu nad obsahem obrazovky.",incorrect:"Grafický server nemá žádnou kontrolu nad obsahem obrazovky.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"892dcef4-075e-47e7-8ee0-a63bd8517a38",correct:"Použitím grafického serveru se může objem přenášených dat zmenšit oproti rastrové reprezentaci.",incorrect:"Použitím grafického serveru se objem přenášených dat zvětší oproti rastrové reprezentaci.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"96f0d698-4f24-4d15-ac68-cfd965db5095",correct:"Grafický server usnadňuje vzdálené vykreslování díky menšímu objemu přenášených dat.",incorrect:"Grafický server znesnadňuje vzdálené vykreslování kvůli většímu objemu přenášených dat.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"b911b290-ce6a-4920-bc9c-90832459ff0b",correct:"Grafický server může pro rasterizaci využívat hardware.",incorrect:"Grafický server nikdy pro rasterizaci nevyužívá hardware.",sectionNumber:"4.2.8",sectionTitle:"Grafický server"},{uuid:"bbe200ad-eeb2-4b5f-8cf1-97f70659fc13",correct:"Výstup zvukového rozhraní lze virtualizovat mixováním několika zvukových proudů do jednoho.",incorrect:"Výstup zvukového rozhraní lze virtualizovat pouze přepínáním zvukových proudů, nikoliv mixováním.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"be8a2c25-769e-40b9-9167-096aaac58b7e",correct:"Vstup zvukového rozhraní, například mikrofon, lze v operačním systému pouze přepínat, nikoliv mixovat.",incorrect:"Vstup zvukového rozhraní, například mikrofon, lze v operačním systému mixovat i přepínat současně.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"22a740b9-0fd4-4d4d-b416-5e5288e766f9",correct:"Větší vyrovnávací paměť zvukového subsystému snižuje pravděpodobnost výpadku zvuku, ale zvyšuje latenci.",incorrect:"Větší vyrovnávací paměť zvukového subsystému zvyšuje pravděpodobnost výpadku zvuku a snižuje latenci.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"10fbe5ce-d8cb-4ec6-a2d3-98d8f2d2dc75",correct:"Zvuková rozhraní, podobně jako grafické zobrazení, jsou v operačních systémech citlivá na latenci a nepřerušenost datového proudu.",incorrect:"Zvuková rozhraní, na rozdíl od grafického zobrazení, nejsou v operačních systémech citlivá na latenci a nepřerušenost datového proudu.",sectionNumber:"4.2.9",sectionTitle:"Audio"},{uuid:"c1523ff2-46f4-457c-8f5a-cf5247784ca8",correct:"Tiskárny jsou z pohledu operačního systému charakteristické dávkovým zpracováním úloh.",incorrect:"Tiskárny jsou z pohledu operačního systému charakteristické interaktivním zpracováním úloh.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"c0855a42-b3ef-4d13-b69c-2d8ad625d97a",correct:"Virtualizace tiskáren je řešena frontou úloh, což je analogické k plánování úloh v dávkových systémech.",incorrect:"Virtualizace tiskáren je řešena interaktivním plánováním úloh, na rozdíl od dávkových systémů.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"0ef94a64-ba76-4a6b-8274-612865e159d2",correct:"Abstrakce tiskáren v operačním systému má za cíl skrýt rozdíly mezi různými modely tiskáren pro aplikace.",incorrect:"Abstrakce tiskáren v operačním systému má za cíl zdůraznit rozdíly mezi různými modely tiskáren pro aplikace.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"30340687-0308-47de-9855-7bb60bce5dfc",correct:"PDF a PostScript slouží jako formáty pro popis dokumentů, které mají zahladit rozdíly mezi tiskárnami.",incorrect:"PDF a PostScript slouží jako formáty pro popis dokumentů, které jsou specifické pro konkrétní tiskárny.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"cf73bc7b-46e9-481a-944d-768853fc3da4",correct:"Některé síťové tiskárny mohou obsahovat interní frontu úloh, čímž virtualizaci řeší i mezi počítači.",incorrect:"Síťové tiskárny nikdy neobsahují interní frontu úloh, virtualizaci vždy plně řeší operační systém.",sectionNumber:"4.2.10",sectionTitle:"Tiskárny"},{uuid:"e1adf9c7-8ec3-417e-909c-9a497e8dfe25",correct:"Základní funkcí počítačové sítě je umožnit komunikaci a přenos dat mezi počítači.",incorrect:"Základní funkcí počítačové sítě je pouze fyzicky propojit počítače, nikoliv přenášet data.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"1e192443-1499-4e96-8ac2-abd137378460",correct:"Pro připojení k síti počítače využívají síťová rozhraní a propojovací média, která mohou být drátová.",incorrect:"Pro připojení k síti počítače využívají pouze síťová rozhraní, propojovací média nejsou nutná.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"1dfeb48c-6f92-4ac2-9aa7-58d8e8abe5e3",correct:"Síťové rozhraní se připojuje k počítači sběrnicí a k síti přenosovým médiem, podobně jako řadič sběrnice.",incorrect:"Síťové rozhraní se připojuje k počítači přímo, bez sběrnice, a k síti přenosovým médiem.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"56087fc0-e7ac-4835-9137-635c3d26f325",correct:"Architektura počítačové sítě se liší od sběrnice absencí význačného centrálního prvku.",incorrect:"Architektura počítačové sítě je identická se sběrnicí, včetně centrálního prvku.",sectionNumber:"4.3.1",sectionTitle:"Počítačová síť"},{uuid:"cc4ff1e0-f837-49d6-8f19-cb23a62c3432",correct:"Fyzická vrstva ISO/OSI modelu je primárně záležitostí hardwaru.",incorrect:"Fyzická vrstva ISO/OSI modelu je primárně záležitostí operačního systému.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"ebd98871-5672-4e32-aca9-91940aba2576",correct:"Linková vrstva ISO/OSI modelu tvoří rozhraní mezi hardwarem a operačním systémem.",incorrect:"Linková vrstva ISO/OSI modelu je primárně aplikační vrstvou.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"ea4b089d-cbf3-4c2c-842a-da2409821079",correct:"Síťová vrstva ISO/OSI modelu zajišťuje komunikaci mezi koncovými uzly.",incorrect:"Síťová vrstva ISO/OSI modelu se zabývá doručováním dat mezi aplikacemi.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"4f2681de-6f21-45c7-81a2-b4a38956cb87",correct:"Virtualizace se v ISO/OSI modelu typicky uplatňuje mezi transportní a aplikační vrstvou.",incorrect:"Virtualizace se v ISO/OSI modelu typicky uplatňuje mezi linkovou a síťovou vrstvou.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"606b02d4-3c45-442c-895b-cceb6bc2eef7",correct:"Vrstvy 1 a 2 ISO/OSI modelu jsou převážně hardwarové, vrstvy 3 a 4 převážně softwarové.",incorrect:"Vrstvy 1 a 2 ISO/OSI modelu jsou převážně softwarové, vrstvy 3 a 4 převážně hardwarové.",sectionNumber:"4.3.2",sectionTitle:"Vrstvy"},{uuid:"b492a33c-349f-4bbd-906c-01102edfd6b7",correct:"Abstrakce pro potřeby operačního systému se nachází mezi druhou a třetí vrstvou.",incorrect:"Abstrakce pro potřeby operačního systému se nachází mezi čtvrtou a pátou vrstvou.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"65510fb6-54b1-4d07-92bb-8e6836720976",correct:"Virtualizace síťové komunikace je hlavně založena na multiplexingu paketů.",incorrect:"Virtualizace síťové komunikace není založena na principu multiplexingu paketů.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"c207fd6e-3876-4f3a-9c9b-71e360902944",correct:"Adresa aplikace v síti se skládá z adresy uzlu a čísla portu.",incorrect:"Adresa aplikace v síti se skládá pouze z adresy uzlu, bez portu.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"274494fe-069a-4eb5-ae75-50fcc1f2c31d",correct:"Pro aplikační potřeby se virtualizace i abstrakce nachází mezi čtvrtou a pátou vrstvou.",incorrect:"Pro aplikační potřeby se virtualizace i abstrakce nachází mezi druhou a třetí vrstvou.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"7c8ede80-8a49-46b8-a9d4-9dc27f9d7992",correct:"Čtvrtá vrstva síťového modelu přidává virtuální koncové body aplikací pomocí portů.",incorrect:"Třetí vrstva síťového modelu přidává virtuální koncové body aplikací pomocí portů.",sectionNumber:"4.3.3",sectionTitle:"Abstrakce a virtualizace"},{uuid:"879e8a1d-1102-4f59-81bf-c77829ada6f4",correct:"Operační systém přímo komunikuje pouze s částí MAC ethernetového rozhraní.",incorrect:"Operační systém přímo komunikuje s fyzickou i MAC vrstvou ethernetového rozhraní.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"a7d7accf-f799-445a-a8fc-d98345646aa6",correct:"Ethernetový rámec obsahuje preambuli, která slouží k synchronizaci přijímače.",incorrect:"Ethernetový rámec obsahuje preambuli, která slouží k adresování cílového zařízení.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"1fdb217e-238a-4e58-9a37-a264ecbe17f6",correct:"V moderním Ethernetu se propojování point-to-point realizuje pomocí aktivních přepínačů.",incorrect:"V moderním Ethernetu se propojování point-to-point realizuje pomocí pasivních hubů.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"b88139f8-d8d1-4544-bee0-619518342e79",correct:"Maximální velikost užitných dat v ethernetovém rámci je patnáct set bajtů.",incorrect:"Maximální velikost užitných dat v ethernetovém rámci je šestnáct set bajtů.",sectionNumber:"4.3.4",sectionTitle:"Ethernet (IEEE 802.3)"},{uuid:"b899da8c-5a65-40a4-87e9-78a4dd10c8c2",correct:"Adresace na ethernetové úrovni funguje pouze lokálně v rámci segmentu.",incorrect:"Adresace na ethernetové úrovni funguje globálně napříč sítěmi.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"92ea230d-d3b8-4335-aa82-e71abdd5bc9d",correct:"Každé ethernetové rozhraní má přidělenu tovární MAC adresu pro identifikaci.",incorrect:"MAC adresa ethernetového rozhraní je přidělena operačním systémem.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"5f0b95e2-61b3-4235-9778-7714f3d9b0ea",correct:"Přepínače v ethernetové síti mapují MAC adresy na porty pro přeposílání rámců.",incorrect:"Přepínače v ethernetové síti mapují IP adresy na porty pro přeposílání rámců.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"c84561c2-4304-4b3f-a440-8d6b9366f858",correct:"Pro doručení paketu třetí vrstvy je nutné získat odpovídající adresu druhé vrstvy.",incorrect:"Pro doručení paketu třetí vrstvy se adresa druhé vrstvy nevyužívá.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"78cb4bfe-0925-4df3-b277-cba5147e527c",correct:"V sítích IP/Ethernet se překlad adres zajišťuje protokolem ARP.",incorrect:"V sítích IP/Ethernet se překlad adres zajišťuje protokolem DHCP.",sectionNumber:"4.3.5",sectionTitle:"Adresace"},{uuid:"d8e98629-275e-48d9-af74-6b0bd02d4c18",correct:"Síťové rozhraní autonomně čte rámce z odchozí fronty pomocí DMA a odesílá je do sítě.",incorrect:"Síťové rozhraní autonomně čte rámce z odchozí fronty pomocí CPU a odesílá je do sítě.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"afedf95b-f056-49bb-b05c-286c390f712e",correct:"Odchozí fronta je implementována jako kruhová fronta pevné velikosti uložená v operační paměti.",incorrect:"Odchozí fronta je implementována jako lineární fronta proměnné velikosti uložená v operační paměti.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"6ee7a8ec-baf9-4ddd-b230-57ec74a8e2ea",correct:"Pro odeslání rámce operační systém upravuje koncový ukazatel odchozí fronty po zápisu dat.",incorrect:"Pro odeslání rámce operační systém upravuje hlavový ukazatel odchozí fronty před zápisem dat.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"69355fb6-fc2d-4210-aa62-81ddfec85e24",correct:"Ukazatele hlavový a koncový dělí kruhovou odchozí frontu na část pro operační systém a síťové rozhraní.",incorrect:"Ukazatele hlavový a koncový dělí kruhovou odchozí frontu na část pouze pro operační systém.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"4086f9ed-bbe1-4272-beff-d1ab803d0d75",correct:"Síťové rozhraní signalizuje události související se zpracováním odchozí fronty pomocí přerušení.",incorrect:"Síťové rozhraní signalizuje události související se zpracováním odchozí fronty pomocí pollingu.",sectionNumber:"4.3.6",sectionTitle:"Odchozí fronta"},{uuid:"27e0aacc-fdf7-4c21-9dcf-a0f78e90e8c6",correct:"Síťové rozhraní signalizuje příchod nových dat do fronty pomocí přerušení.",incorrect:"Síťové rozhraní signalizuje příchod nových dat do fronty pomocí dotazování.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"a4084662-33fd-4e32-85c6-12b32f57c098",correct:"Pokud je příjmová fronta plná a přichází další rámce, dojde ke ztrátě dat.",incorrect:"Pokud je příjmová fronta plná a přichází další rámce, rámce se uloží do vyrovnávací paměti.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"addfb8b1-86c2-465b-a00d-327cc5b7dfba",correct:"Operační systém alokuje paměť pro rámce v příjmové frontě.",incorrect:"Síťové rozhraní alokuje paměť pro rámce v příjmové frontě.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"81c6feb2-e170-433d-b290-cc626b927e5c",correct:"Události signalizující nová data v příjmové frontě mohou být sdružovány pro více rámců.",incorrect:"Události signalizující nová data v příjmové frontě nemohou být sdružovány a jsou generovány pro každý rámec zvlášť.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"66d6324d-c550-4d4f-b9a6-de988de2fbcf",correct:"Operační systém dává najevo síťovému rozhraní, že paměť může být přepsána, přesunutím položky do kruhové fronty.",incorrect:"Síťové rozhraní dává najevo operačnímu systému, že paměť může být přepsána, přesunutím položky do kruhové fronty.",sectionNumber:"4.3.7",sectionTitle:"Příjmová fronta"},{uuid:"cd6bcea2-4127-4a57-88ce-e7235d9a1aab",correct:"Moderní síťové adaptéry mohou dosáhnout takové rychlosti, že jedno procesorové jádro nemusí stačit na jejich plné využití.",incorrect:"Moderní síťové adaptéry jsou navrženy tak, aby jedno procesorové jádro vždy dokázalo plně saturovat jejich výkon.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"cce0ee3d-c551-4d58-b3a7-6dd142606232",correct:"Rozhraní s více frontami umožňují operačnímu systému rozdělit zátěž zpracování síťového provozu mezi různá procesorová jádra.",incorrect:"Rozhraní s více frontami jsou navržena pro zvýšení výkonu jediného procesorového jádra při zpracování síťového provozu.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"d8ca55b8-ae4f-48ef-9027-38a81f11366f",correct:"Operační systém typicky nastavuje pro každé procesorové jádro jednu vysílací a jednu přijímací frontu u moderních síťových karet.",incorrect:"Operační systém obvykle sdílí jednu vysílací a jednu přijímací frontu mezi všechna procesorová jádra pro snížení režie.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"39dca947-376e-4a66-be4a-0a6e49ad07b5",correct:"Při odesílání paketů operační systém rozhoduje o výběru vysílací fronty, kterou síťové rozhraní použije.",incorrect:"Při odesílání paketů síťové rozhraní automaticky vybírá vysílací frontu bez zásahu operačního systému.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"73f6743e-2538-4a91-8ddc-c9084f54cd61",correct:"Při příjmu paketů síťové rozhraní samo rozhoduje o zařazení rámců do front na základě filtrování nebo hashování.",incorrect:"Při příjmu paketů operační systém aktivně rozhoduje o zařazení každého rámce do konkrétní přijímací fronty.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"7b3840cf-079d-4170-8b36-0e1189e0c1e6",correct:"Cílem rozřazování rámců do front na síťovém rozhraní je zvýšit lokalitu zpracování a rovnoměrně zaplnit fronty.",incorrect:"Cílem rozřazování rámců do front je primárně minimalizovat latenci doručení paketů do aplikace bez ohledu na lokalitu.",sectionNumber:"4.3.8",sectionTitle:"Vícefrontové adaptéry"},{uuid:"8613db6d-7a6f-42dc-8fd4-9beab13c8c33",correct:"Protokoly WiFi jsou implementovány částečně ve firmwaru a částečně v softwaru operačního systému.",incorrect:"Protokoly WiFi jsou implementovány výhradně v softwaru operačního systému.",sectionNumber:"4.3.9",sectionTitle:"WiFi"},{uuid:"b6dbb5fc-bee5-4e78-aa5f-fd00975d35e7",correct:"Šifrování je u bezdrátových sítí prakticky povinné kvůli snadnému odposlouchávání sdíleného média.",incorrect:"Šifrování u bezdrátových sítí je volitelné a není nutné kvůli obtížnému odposlouchávání.",sectionNumber:"4.3.9",sectionTitle:"WiFi"},{uuid:"c60358cf-b1c2-47ad-8d3a-332a9cdca1c8",correct:"Autentizace v WiFi sítích je nezbytná pro prevenci útoků typu man in the middle.",incorrect:"Autentizace v WiFi sítích není nutná pro prevenci útoků typu man in the middle.",sectionNumber:"4.3.9",sectionTitle:"WiFi"}]},{uuid:"f6afeeb0-aa47-4201-82b3-c1b185f65e50",sectionNumber:"5",sectionTitle:"Souběžnost a synchronizace",statements:[{uuid:"bc13ed0f-7024-45f3-b277-442a139c31bb",correct:"V grafu předcházení vrcholy reprezentují události a hrany reprezentují akce.",incorrect:"V grafu předcházení hrany reprezentují události a vrcholy reprezentují akce.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"51965a94-8a98-4bec-b66f-7a7dd791d684",correct:"Graf předcházení je tranzitivní redukcí relace uspořádání 'muselo se stát před'.",incorrect:"Graf předcházení je tranzitivním uzávěrem relace uspořádání 'muselo se stát před'.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"5b7ab34f-7d35-40f5-88f4-cc1faab84938",correct:"Akce v grafu předcházení nemohou přímo spojovat události, mezi kterými existuje cesta délky dva.",incorrect:"Akce v grafu předcházení mohou přímo spojovat události, mezi kterými existuje cesta délky dva.",sectionNumber:"5.1.1",sectionTitle:"Relace předcházení"},{uuid:"cfd01452-1939-4a98-8bd6-c30f648a9350",correct:"Souběžné události jsou takové, mezi kterými v grafu závislostí nevede cesta.",incorrect:"Souběžné události jsou takové, mezi kterými v grafu závislostí vždy vede cesta.",sectionNumber:"5.1.2",sectionTitle:"Souběžnost"},{uuid:"a5e1f9cd-5fce-454c-8e75-d852e7f7609a",correct:"Pokud událost A nepředchází události B a B nepředchází A, události A a B jsou souběžné.",incorrect:"Pokud událost A nepředchází události B a B nepředchází A, událost A musí předcházet události B.",sectionNumber:"5.1.2",sectionTitle:"Souběžnost"},{uuid:"1d83812e-e73b-401a-a0e6-1c2e31ee850a",correct:"Časový sled událostí je lineární uspořádání, kde pro každou dvojici událostí jedna předchází druhou.",incorrect:"Časový sled událostí je nelineární uspořádání, kde pro každou dvojici událostí jedna předchází druhou.",sectionNumber:"5.1.3",sectionTitle:"Časový sled"},{uuid:"aa67e4d5-f959-47c7-992b-8e23ccce4228",correct:"V časovém sledu událostí, reprezentovaném časovými razítky, nemohou dvě události nastat ve stejný okamžik.",incorrect:"V časovém sledu událostí, reprezentovaném časovými razítky, mohou dvě události nastat ve stejný okamžik.",sectionNumber:"5.1.3",sectionTitle:"Časový sled"},{uuid:"2540b410-8043-4424-9e93-331de40e38e1",correct:"Relace předcházení je abstrakce, která v operačních systémech popisuje vnější chování procesů.",incorrect:"Relace předcházení je konkrétní implementace, která v operačních systémech popisuje vnitřní chování procesů.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"c049f981-17af-420e-9b3f-22c9ea678e4a",correct:"Hazard souběhu nastává, pokud různé časové sledy událostí vedou k rozdílnému vnějšímu chování systému.",incorrect:"Hazard souběhu nastává, pokud stejné časové sledy událostí vedou k rozdílnému vnějšímu chování systému.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"27741294-9d19-4026-9f45-f8b1eb0cf30f",correct:"Porušení abstrakce relace předcházení, tedy hazard souběhu, je nežádoucí, i když nemusí být chybou.",incorrect:"Porušení abstrakce relace předcházení, tedy hazard souběhu, je žádoucí, protože zlepšuje výkon systému.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"c132ba29-dca0-438e-91e9-4081245231a0",correct:"Vnější chování systému závisí pouze na relaci předcházení, nikoliv na konkrétním časovém rozložení událostí.",incorrect:"Vnější chování systému závisí na relaci předcházení a také na konkrétním časovém rozložení událostí.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"4a30a4f4-40e2-48e4-84a9-4cd7aea265f0",correct:"Abstrakce relace předcházení se snaží skrýt vnitřní detaily procesů a jejich časové uspořádání v systému.",incorrect:"Abstrakce relace předcházení se snaží odhalit vnitřní detaily procesů a jejich časové uspořádání v systému.",sectionNumber:"5.1.4",sectionTitle:"Hazard souběhu"},{uuid:"1581885d-6ab6-4634-a66a-e66962e02261",correct:"Akce v grafu předcházení jsou vždy prováděny hybatelem, typicky vláknem nebo periferií.",incorrect:"Akce v grafu předcházení jsou prováděny nezávisle na hybatelích, jako jsou vlákna a periferie.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"873903b1-afd2-461c-bfc6-966ab742fac0",correct:"V grafu předcházení můžeme hranám, reprezentujícím akce, přisoudit hybatele, například vlákno či periferii.",incorrect:"Hranám v grafu předcházení nelze přisoudit hybatele, protože hrany reprezentují pouze samotné akce.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"f4c0f57e-a8e1-42f0-8b8b-2b4d6cd3817d",correct:"Hybatele, jako vlákna nebo periferie, lze v grafu předcházení chápat jako pešky pohybující se po hranách své barvy.",incorrect:"Hybatele v grafu předcházení se nepovažují za pešky pohybující se po hranách, ale za pasivní prvky grafu.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"c5110ce6-27c1-450e-a21e-c7f4e45f829c",correct:"V příkladu jsou vlákna A a B, která provádějí prakticky stejný program s rozdílnými registry.",incorrect:"V příkladu vlákna A a B vykonávají zcela odlišné programy bez jakékoliv programové podobnosti.",sectionNumber:"5.1.5",sectionTitle:"Hybatel"},{uuid:"cd38a771-700a-41b7-ac61-541c7612ce68",correct:"Akce jsou souběžné právě tehdy, když jsou souběžné libovolné dvě události, kterých se tyto akce týkají.",incorrect:"Akce jsou souběžné pouze tehdy, když jsou souběžné všechny události, kterých se tyto akce týkají.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"43ccac0f-1bd1-4ab9-863f-fcb6202b9d87",correct:"Událost nemůže být souběžná sama se sebou, ani nemohou být souběžné události spojené akcí.",incorrect:"Událost může být souběžná sama se sebou, ale nemůže být souběžná s událostí spojenou akcí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"fd98f772-cc0b-495f-9bad-43c56feacd55",correct:"Nezávislé akce mohou proběhnout v libovolném pořadí, protože vedou do souběžných událostí.",incorrect:"Nezávislé akce musí proběhnout v předem daném pořadí, i když vedou do souběžných událostí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"36a81eba-3ec8-40c4-8b4b-43f56854d71c",correct:"Synchronizace akcí nastává, když se akce 'sejdou' ve společné události a musí proběhnout 'najednou'.",incorrect:"Synchronizace akcí nastává, když se akce 'sejdou' ve společné události a mohou proběhnout v libovolném pořadí.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"c418330b-51ad-4c38-bcae-a2a2449b333a",correct:"Souběžné sledy jsou takové, které nesdílí žádnou událost, s výjimkou první a/nebo poslední události.",incorrect:"Souběžné sledy jsou takové, které sdílí alespoň jednu událost kromě první nebo poslední události.",sectionNumber:"5.1.6",sectionTitle:"Synchronizace"},{uuid:"9790890a-abcf-4e98-a590-bf7e1d51a3d4",correct:"Akce v operačním systému propojují události a stavy systému.",incorrect:"Akce v operačním systému popisují pouze stavy, nikoli události.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"5d11a343-732f-4692-8e82-096b6e3790db",correct:"Výpočet je vnímán jako posloupnost stavů a akcí v operačním systému.",incorrect:"Výpočet je chápán pouze jako lineární posloupnost stavů bez akcí.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"91d47ccb-11f3-4f28-a3eb-f0880f489317",correct:"Stavový prostor je orientovaný graf, kde vrcholy jsou stavy a hrany akce.",incorrect:"Stavový prostor je neorientovaný graf stavů, kde hrany nereprezentují akce.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"eb5eb2ac-cd55-4623-ae99-83c78c51237f",correct:"Stav systému zahrnuje registry procesoru a obsah paměťových buněk.",incorrect:"Stav systému zahrnuje pouze registry procesoru, nikoli paměťové buňky.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"7d384cf5-4395-4735-9921-52e84576dd2e",correct:"Vstupní periferie mění svůj stav nezávisle na operačním systému.",incorrect:"Vstupní periferie mění svůj stav výhradně na základě řízení operačním systémem.",sectionNumber:"5.1.7",sectionTitle:"Stavový prostor"},{uuid:"7908140c-be17-44e8-a693-065f352cad21",correct:"Běh v stavovém prostoru je orientovaná cesta, která reprezentuje posloupnost stavů propojených akcemi.",incorrect:"Běh v stavovém prostoru je neorientovaná cesta, která reprezentuje posloupnost stavů propojených událostmi.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"3849cda1-8458-4531-8ad1-b9d38bac01bb",correct:"Sekvence akcí může být chápána jako běh i jako sled, pokud je určen počáteční stav.",incorrect:"Sekvence akcí může být chápána jako běh i jako sled, i když není určen počáteční stav.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"95409ff1-a978-4f53-a703-0a35dde88cf5",correct:"V situacích souběhu může vést odlišné pořadí akcí k rozdílným výsledným stavům systému.",incorrect:"V situacích souběhu vždy vede odlišné pořadí akcí ke stejným výsledným stavům systému.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"9a5ce9e7-11ab-48c9-8fcd-d61acc42e1eb",correct:"Časový sled událostí má jasnou korespondenci s během, který je posloupností stavů.",incorrect:"Časový sled událostí nemá žádnou korespondenci s během, který je posloupností stavů.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"c7fa9fb7-2f50-474d-8413-45cbdc060944",correct:"Pojem běhu v stavovém prostoru je zobecněním výpočtu, který zahrnuje posloupnost stavů a akcí.",incorrect:"Pojem běhu v stavovém prostoru je zúžením výpočtu, který zahrnuje pouze posloupnost stavů.",sectionNumber:"5.1.8",sectionTitle:"Běh"},{uuid:"2913d7e0-2c36-4f14-b745-54f1435c9442",correct:"Kritická sekce je běh, jehož přerušení jiným souběžným během může vést k chybě.",incorrect:"Kritická sekce je běh, jehož přerušení jiným souběžným během nikdy nevede k chybě.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"20632c90-3d58-4540-bb07-a37c9b4b10d0",correct:"Porušení atomicity kritické sekce je z definice považováno za chybu běhu.",incorrect:"Porušení atomicity kritické sekce není nikdy považováno za chybu běhu.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"2c2c4695-764d-4e3d-9a41-74165ca624b7",correct:"Kritická sekce se týká běhů, které jsou relativní vůči jiným souběžným běhům.",incorrect:"Kritická sekce se týká běhů, které jsou zcela nezávislé na jiných souběžných bězích.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"37758615-e2c3-40d3-a2e4-8cc7dccff000",correct:"V příkladu s inkrementací proměnné V, běh vlákna A může být kritickou sekcí vůči běhu vlákna B.",incorrect:"V příkladu s inkrementací proměnné V, běh vlákna A nikdy nemůže být kritickou sekcí vůči běhu vlákna B.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"07a87655-41f0-4687-acd2-6ca8ce85ef38",correct:"Chyba atomicity nastává, když souběžné běhy vedou k nežádoucímu uspořádání akcí.",incorrect:"Chyba atomicity nastává, když jednotlivé běhy samy o sobě, bez souběhu, vedou k chybě.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"03151cf8-9a7b-42a4-a1b8-08eb894aa84d",correct:"Kritická sekce je speciálním případem obecnějšího konceptu hazardu souběhu.",incorrect:"Kritická sekce je obecným případem a hazard souběhu je jejím speciálním případem.",sectionNumber:"5.2.1",sectionTitle:"Kritická sekce"},{uuid:"c49f9dbf-81a4-4f26-93f1-cbf0a848f620",correct:"Čtenáři v problému čtenářů a písařů nejsou vzájemně kritickou sekcí.",incorrect:"Čtenáři v problému čtenářů a písařů jsou vzájemně kritickou sekcí.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"ffbf1f9a-4373-468b-9783-d172d9b1c88d",correct:"Čtenář je v problému čtenářů a písařů kritickou sekcí vůči písaři.",incorrect:"Čtenář v problému čtenářů a písařů není kritickou sekcí vůči písaři.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"b2dcb296-5faf-4cd1-8763-5914d3851253",correct:"Písaři jsou v problému čtenářů a písařů vzájemně kritickou sekcí.",incorrect:"Písaři v problému čtenářů a písařů nejsou vzájemně kritickou sekcí.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"46e97811-e887-4ea1-b630-8a86621f7c68",correct:"Čtenáři v problému čtenářů a písařů sdílená data pouze čtou.",incorrect:"Čtenáři v problému čtenářů a písařů sdílená data čtou a modifikují.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"49709dbf-fa30-4d55-9e83-8151d0162b2b",correct:"Písaři v problému čtenářů a písařů sdílená data modifikují.",incorrect:"Písaři v problému čtenářů a písařů sdílená data pouze čtou.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"f408ca91-6879-4536-9392-c83bedf50213",correct:"Efektivní řešení problému čtenářů a písařů umožňují souběh čtenářů.",incorrect:"Efektivní řešení problému čtenářů a písařů zakazují souběh čtenářů.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"9806482c-3dbc-49e2-b6e6-15a7289795ed",correct:"Nejjednodušší řešení problému čtenářů a písařů je neefektivní.",incorrect:"Nejjednodušší řešení problému čtenářů a písařů je efektivní.",sectionNumber:"5.2.2",sectionTitle:"Čtenáři a písaři"},{uuid:"4b06b700-9cba-45a9-b85e-e345f4d5d13a",correct:"Neustálá aktivita čtenářů může způsobit, že písaři budou trvale zablokováni v problému čtenářů a písařů.",incorrect:"Neustálá aktivita čtenářů nikdy nemůže způsobit trvalé zablokování písařů v problému čtenářů a písařů.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"905986a6-834a-4ffb-8cf2-5a6dbf1262d1",correct:"Hladovění je definováno jako situace, kdy vlákno nemůže pokračovat ve svém výpočtu a vykonávat užitečné akce.",incorrect:"Hladovění je definováno jako situace, kdy vlákno může nerušeně pokračovat ve svém výpočtu a vykonávat užitečné akce.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"08a5800a-c460-4a65-9e5b-5577167e9063",correct:"Uváznutí, kdy vlákna čekají v kruhu, je v operačních systémech považováno za běžnou příčinu hladovění.",incorrect:"Uváznutí, kdy vlákna čekají v kruhu, není v operačních systémech nikdy považováno za příčinu hladovění.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"b4c70a1c-4c8e-48b0-88d9-2e1498181fab",correct:"Synchronizace sama o sobě není řešením problému hladovění a může být dokonce jeho častou příčinou.",incorrect:"Synchronizace je vždy efektivním řešením problému hladovění v operačních systémech a nikdy není jeho příčinou.",sectionNumber:"5.2.3",sectionTitle:"Hladovění"},{uuid:"b5d429c6-f2e4-4531-acca-b998742d925c",correct:"Datová závislost vzniká, když akce čte data z paměti, do které předtím zapisovala jiná akce.",incorrect:"Datová závislost vzniká, když akce zapisuje data do paměti, ze které předtím četla jiná akce.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"b2154442-bf81-45b5-9136-d9d2ebddb7e9",correct:"Chyba pořadí se projevuje v souběžných systémech, kde existují datové závislosti mezi akcemi.",incorrect:"Chyba pořadí se projevuje pouze v sekvenčních systémech, kde neexistují datové závislosti.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"4fd45015-cbad-40da-99c8-66d0ab64f3ff",correct:"Datová závislost je specifický typ hazardu souběhu, odlišný od problémů kritické sekce.",incorrect:"Datová závislost je typ hazardu souběhu, který je totožný s problémy kritické sekce.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"c04c5112-a193-4d49-bda0-0fa8f53deec4",correct:"Odhalení chyb datové závislosti může být obtížné, zvláště pokud jsou některé akce časově nenáročné.",incorrect:"Odhalení chyb datové závislosti je snadné, i když jsou všechny souběžné akce časově nenáročné.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"226f64ca-ce6b-483b-b1ad-01a87baf4cf1",correct:"Příliš brzký pokus o použití dat v datové závislosti může způsobit běhovou chybu programu.",incorrect:"Příliš brzký pokus o použití dat v datové závislosti nikdy nezpůsobí běhovou chybu programu.",sectionNumber:"5.2.4",sectionTitle:"Souběžná datová závislost"},{uuid:"0c1888d1-553f-4cee-9dc3-a7a88bc10a00",correct:"Producenti a konzumenti vláken pracují souběžně, což umožňuje distribuci úloh a urychlení celkového procesu.",incorrect:"Producenti a konzumenti vláken pracují sekvenčně, což zajišťuje snadnější synchronizaci, ale snižuje výkon systému.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"4e4d758f-b5c0-4d13-b974-dc9c022b041f",correct:"Při převaze produkce nad konzumací hrozí zahlcení paměti hromadícími se mezivýsledky, pokud není zavedena synchronizace.",incorrect:"Při převaze produkce nad konzumací dochází k efektivnějšímu využití procesoru a zrychlení zpracování dat bez nutnosti synchronizace.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"804706cf-5cea-49a2-a4b3-013bc86c7ac4",correct:"Synchronizace producentů a konzumentů je klíčová pro zamezení opakovaného zpracování stejných mezivýsledků a chyb.",incorrect:"Synchronizace producentů a konzumentů je zbytečná, protože operační systém automaticky zajišťuje správné pořadí zpracování.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"63b74db5-107a-4fac-b7fe-15c1098cb3b5",correct:"Ideální synchronizace producentů a konzumentů by měla omezit počet nezpracovaných mezivýsledků z důvodu paměťové efektivity.",incorrect:"Ideální synchronizace producentů a konzumentů by měla maximalizovat počet nezpracovaných mezivýsledků pro zvýšení propustnosti systému.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"c3391303-6ae8-48a3-823b-46aaaa05dad3",correct:"Jedním z rizik souběžné produkce a konzumace je přepsání mezivýsledku producentem dříve, než bude zpracován konzumentem.",incorrect:"Souběžná produkce a konzumace nikdy nezpůsobí přepsání mezivýsledku, protože producent vždy čeká na zpracování konzumentem.",sectionNumber:"5.2.5",sectionTitle:"Producenti a konzumenti"},{uuid:"5bca3968-549b-4f58-89fb-3940e239eacf",correct:"Nedostatek souběžnosti v systému může vést k neefektivnímu využití hardwarových zdrojů, zejména jader procesoru.",incorrect:"Nedostatek souběžnosti v systému zefektivňuje využití hardwarových zdrojů, zejména jader procesoru.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"1eebad1b-19e8-4ffc-98fc-aaafb3b38347",correct:"Rozvětvení vláken může být řešením pro nedostatek souběžnosti, ale vyžaduje synchronizaci a čekání na dokončení všech větví.",incorrect:"Rozvětvení vláken řeší problém nadměrné souběžnosti a nevyžaduje synchronizaci ani čekání na dokončení všech větví.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"279ffd03-9751-42ad-bf4a-eb2e971449be",correct:"Akce, které nejsou souběžné, nelze provádět paralelně, což omezuje potenciální paralelizaci výpočtu.",incorrect:"Akce, které nejsou souběžné, lze provádět paralelně, což maximalizuje potenciální paralelizaci výpočtu.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"},{uuid:"2f4164ef-6ffa-42d0-a702-9efa40ba36e9",correct:"Předčasné pokračování výpočtu před dokončením všech souběžných bloků může vést k výpočetním závislostem a chybám.",incorrect:"Předčasné pokračování výpočtu před dokončením některých souběžných bloků nikdy nevede k výpočetním závislostem.",sectionNumber:"5.2.6",sectionTitle:"Rozvětvení a setkání"}]},{uuid:"41ff3bb9-a775-4b6f-8856-da38b718acc5",sectionNumber:"6",sectionTitle:"Synchronizace",statements:[{uuid:"996e4d1b-df67-4582-9635-6f338e55c678",correct:"Synchronizační zařízení slouží k omezení souběžnosti procesů nebo vláken.",incorrect:"Synchronizační zařízení slouží k úplnému odstranění souběžnosti procesů nebo vláken.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"b0e47a53-cfc8-44d5-84b3-434580669247",correct:"Synchronizační zařízení jsou datové struktury uzpůsobené k řešení specifických problémů souběžnosti.",incorrect:"Synchronizační zařízení jsou hardwarové komponenty uzpůsobené k řešení specifických problémů souběžnosti.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"1a289831-e7dd-49ef-9442-3d1b2dbfee4e",correct:"Instance synchronizačního zařízení spolu navzájem neinteragují a pracují nezávisle.",incorrect:"Instance synchronizačního zařízení spolu navzájem interagují a ovlivňují se.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"2ff046aa-9c53-4a4b-a3d8-4430bfd52558",correct:"Instance synchronizačního zařízení je ztotožněna s adresou, na které je uložen její stav.",incorrect:"Instance synchronizačního zařízení je ztotožněna s názvem proměnné, která na ni odkazuje.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"1519bdeb-9b8c-46a8-8aaf-b2f9a4793838",correct:"V prostředí více procesů může být synchronizační zařízení viditelné pod různými virtuálními adresami.",incorrect:"V prostředí více procesů je synchronizační zařízení vždy viditelné pod stejnou virtuální adresou.",sectionNumber:"6.1.1",sectionTitle:"Společné vlastnosti"},{uuid:"68c52c8c-0123-431d-b836-66c6936f431d",correct:"Mutex je synchronizační zařízení určené k ochraně kritické sekce před souběžným přístupem.",incorrect:"Mutex je synchronizační zařízení určené k ochraně všech sekcí kódu, nejen kritických sekcí.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"e0d5bade-47ae-45f1-bd97-433cadce2f67",correct:"Operace lock na mutexu může způsobit, že vlákno čeká, pokud je mutex již zamčený jiným vláknem.",incorrect:"Operace lock na mutexu nikdy nezpůsobí, že vlákno čeká, ale okamžitě získá zámek.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"f8d995ce-b03c-4462-858f-816531b48da5",correct:"Pro správnou ochranu kritické sekce je nutné chránit kritickou sekci a všechny běhy vůči ní kritické stejným mutexem.",incorrect:"Pro ochranu kritické sekce stačí chránit pouze kritickou sekci, běhy vůči ní kritické nemusí být chráněny.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"aa986ca6-10db-42fb-9488-f526e3cf0020",correct:"Klasický mutex, jak je popsán v textu, nedetekuje a nezabraňuje odemčení mutexu vláknem, které ho nevlastní.",incorrect:"Klasický mutex detekuje a zabrání pokusu o odemčení mutexu vláknem, které mutex nevlastní.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"617bd170-ff12-406a-9409-40059b7445f6",correct:"Mutex má dva základní abstraktní stavy: zamčený a odemčený, které určují jeho aktuální stav.",incorrect:"Mutex má tři abstraktní stavy: zamčený, odemčený a čekající, pro detailnější kontrolu synchronizace.",sectionNumber:"6.1.2",sectionTitle:"Vzájemné vyloučení (mutex)"},{uuid:"d4e40463-2a43-430f-aab1-2eac18e40601",correct:"Nejjednodušší implementace spinlocku využívá aktivní čekání a stav je reprezentován jedním bitem.",incorrect:"Nejjednodušší implementace spinlocku nevyužívá aktivní čekání a stav je reprezentován bajtem.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"52df82c3-862d-40de-9966-f7988a6d0d52",correct:"Soutěž o spinlock na jednom CPU je neefektivní kvůli aktivnímu čekání, které plýtvá výpočetním časem.",incorrect:"Soutěž o spinlock na jednom CPU je efektivní, protože minimalizuje režii plánovače a zrychluje běh programu.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"5843e3c6-47b0-43f5-8d18-3a839431dcfc",correct:"V moderních systémech se spinlock implementuje pomocí atomické instrukce cmpxchg, která zajistí atomicitu operace lock.",incorrect:"V moderních systémech se spinlock implementuje pomocí Petersonova algoritmu, který je jednodušší než atomické instrukce.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"e53c4834-655b-4c2c-bf31-40b17cea8ba4",correct:"Instrukce cmpxchg atomicky porovná hodnotu na dané adrese s očekávanou hodnotou a v případě shody ji vymění za novou hodnotu.",incorrect:"Instrukce cmpxchg atomicky pouze porovná hodnotu na dané adrese s očekávanou hodnotou, ale hodnotu nikdy nevymění.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"815fe43f-18a1-4423-8133-19a702e99f1b",correct:"Operace unlock u spinlocku spočívá v atomickém zápisu hodnoty 0 na adresu paměti, která reprezentuje zámek.",incorrect:"Operace unlock u spinlocku spočívá v atomickém zápisu hodnoty 1 na adresu paměti, která reprezentuje zámek.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"400b9380-c1a3-4dc8-a57c-6f1082158a1c",correct:"Výhodou spinlocku je jeho jednoduchost implementace, paměťová nenáročnost a nízká latence v případě, že nedochází k soutěži.",incorrect:"Výhodou spinlocku je jeho složitá implementace, paměťová náročnost a vysoká latence i v případě, že nedochází k soutěži.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"35e0cefa-d5cd-4178-8700-0ad568c7ca77",correct:"Použití spinlocku v uživatelských programech může být nevhodné, pokud vlákna sdílejí procesorové jádro kvůli aktivnímu čekání.",incorrect:"Použití spinlocku v uživatelských programech je vždy vhodné, protože spinlock minimalizuje režii plánování procesů.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"61931a44-8051-4a10-8463-0d5f9b8fb23a",correct:"Spinlock je vhodný pro ochranu kritických sekcí s krátkou dobou trvání, aby se minimalizoval čas strávený aktivním čekáním.",incorrect:"Spinlock je vhodný pro ochranu kritických sekcí s dlouhou dobou trvání, protože efektivně využívá výpočetní čas procesoru.",sectionNumber:"6.1.3",sectionTitle:"Spinlock"},{uuid:"713fc67f-bcbd-4479-90e9-6cc8d421bd73",correct:"Operace ‹lock› uspávajícího mutexu je realizována jako systémové volání operačního systému.",incorrect:"Operace ‹lock› uspávajícího mutexu je realizována jako atomická instrukce procesoru.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"550e6187-d12c-402f-913b-1540654aded7",correct:"Pokud je uspávající mutex zamčený, jádro zařadí vlákno do fronty a nechá plánovač probudit jiné vlákno.",incorrect:"Pokud je uspávající mutex zamčený, jádro vlákno uspí bez interakce s plánovačem.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"4ead4002-07ba-45e0-a641-20c8f0c710df",correct:"Systémové volání uspávajícího mutexu má řádově stovky instrukcí režie oproti atomické instrukci.",incorrect:"Systémové volání uspávajícího mutexu má režii srovnatelnou s atomickou instrukcí.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"12d5fc7f-9013-41ad-91d0-f181d8f37ac4",correct:"Odemčení uspávajícího mutexu předá zámek prvnímu vláknu z fronty čekající na tento mutex.",incorrect:"Odemčení uspávajícího mutexu odemkne zámek bez ohledu na čekající vlákna.",sectionNumber:"6.1.4",sectionTitle:"Uspávající mutex"},{uuid:"e37742df-61d3-4434-a582-08990fd48695",correct:"O zámku rozhoduje vlákno samo pomocí atomické instrukce, podobně jako spinlock.",incorrect:"O zámku rozhoduje operační systém výhradně pomocí systémového volání futex.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"d71cf699-3aff-4f2b-a6a5-2ad697cbddfc",correct:"Systémové volání futex se provádí jen když pokus o zamčení zámku selže v uživatelském prostoru.",incorrect:"Systémové volání futex se provádí vždy při každém pokusu o zamčení zámku.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"e87497c8-edaf-44ed-b544-601361074416",correct:"Uživatelská část stavu mutexu obsahuje počítadlo vláken, která se pokusila o zamčení.",incorrect:"Uživatelská část stavu mutexu obsahuje pouze jeden bit indikující, zda je zámek odemčen.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"c1550210-9a35-458a-ba44-cb8acdb52bc8",correct:"Systémová část futex obsahuje frontu uspaných vláken čekajících na odemčení mutexu.",incorrect:"Systémová část futex obsahuje počítadlo vláken a spinlock pro rychlé zamčení.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"56c00e08-78b7-449b-9e4b-a36c0dbf427e",correct:"Při odemykání mutexu se systémové volání pro probuzení volá jen pokud je počítadlo pokusů o zamčení větší než jedna.",incorrect:"Při odemykání mutexu se vždy volá systémové volání pro probuzení čekajícího vlákna.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"0c702fee-7acb-469c-8a13-d71c4a328310",correct:"Futexy jsou svázány s uživatelskými mutexy pomocí adres, což řeší problém virtuálních a fyzických adres při synchronizaci mezi procesy.",incorrect:"Futexy jsou svázány s uživatelskými mutexy pomocí fyzických adres, což zjednodušuje synchronizaci mezi procesy.",sectionNumber:"6.1.5",sectionTitle:"Rychlý mutex (spinlock + futex)"},{uuid:"57b960a1-158d-4393-bfd4-55ff440cda28",correct:"Naivní implementace mutexů zablokuje vlákno při pokusu o opětovné uzamčení stejným vláknem.",incorrect:"Naivní implementace mutexů nikdy nezablokuje vlákno při pokusu o opětovné uzamčení stejným vláknem.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"68b78fb1-5da1-4428-a41a-39f0cfc820f5",correct:"Reentrantní mutex vyžaduje identifikátor vlastníka a počítadlo zanoření pro správnou funkci opakovaného zamykání.",incorrect:"Reentrantní mutex nepotřebuje počítadlo zanoření, pouze identifikátor vlastníka pro opakované zamykání.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"5849dbdd-ca8f-4a22-8711-5ebfda83fc1b",correct:"Refaktorování programu může být v některých případech řešením problému s mutexy namísto reentrantního mutexu.",incorrect:"Refaktorování programu je vždy nutné řešení problému s mutexy a reentrantní mutex není nikdy potřeba.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"56cb547f-5d04-497a-9489-55c17ea5641b",correct:"Rozšířený mutex s počítadlem zanoření dokáže spolehlivě poznat pokus o odemčení zámku nesprávným vláknem.",incorrect:"Rozšířený mutex s počítadlem zanoření nedokáže poznat pokus o odemčení zámku nesprávným vláknem.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"ef12476c-f512-4279-8ade-6b5989b20305",correct:"Operace unlock u reentrantního mutexu sníží počítadlo zanoření a zámek odemkne až po dosažení nuly.",incorrect:"Operace unlock u reentrantního mutexu odemkne zámek okamžitě a nesnižuje počítadlo zanoření.",sectionNumber:"6.1.6",sectionTitle:"Rekurzivní mutex"},{uuid:"b29f7a87-e754-4f57-80db-c98b86b79c7b",correct:"Rwlock je rozšíření mutexu o stavy pro čtení a zápis.",incorrect:"Rwlock je zjednodušená verze mutexu pro základní synchronizaci.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"1ae3035e-3dcd-42e2-b27f-7703396ec21f",correct:"Operace rdlock blokuje, pokud je rwlock ve stavu zápis.",incorrect:"Operace rdlock blokuje pouze, pokud je rwlock ve stavu čtení.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"5fc053ee-128a-41e7-a6c4-b26ed478078a",correct:"Operace wrlock uspěje jen když je rwlock ve stavu odemčeno.",incorrect:"Operace wrlock uspěje i když je rwlock ve stavu čtení.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"000be13a-dc99-4621-8877-57d220dbab38",correct:"Operace unlock ve stavu zápis změní stav rwlock na odemčeno.",incorrect:"Operace unlock ve stavu zápis změní stav rwlock na čtení.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"da998fd3-2f2f-47c8-a991-884ece77c71a",correct:"Rwlock má stavy odemčeno, čtení a zápis pro řízení přístupu.",incorrect:"Rwlock má pouze stavy odemčeno a zamčeno, podobně jako mutex.",sectionNumber:"6.1.7",sectionTitle:"Zařízení ‹rwlock›"},{uuid:"e0744c65-4d20-4e13-a533-f9dfb1d49861",correct:"Mechanismus RCU řeší problém čtenářů a písařů bez použití zámků a kritických sekcí.",incorrect:"Mechanismus RCU řeší problém čtenářů a písařů s použitím zámků a kritických sekcí.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"17234fd8-83be-48eb-82b3-2d19130731c1",correct:"Písař v RCU vytvoří kopii datové struktury a upraví ji mimo původní strukturu.",incorrect:"Písař v RCU upravuje datovou strukturu přímo na místě bez vytváření kopie.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"b6072488-a374-47f3-a3ed-7f05e2a675a3",correct:"Čtenáři v RCU vidí novou verzi dat až po přesměrování sdíleného ukazatele písařem.",incorrect:"Čtenáři v RCU vidí novou verzi dat ihned po zahájení úprav písařem.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"5d057a7e-9383-4a86-a6ed-60210bdef906",correct:"Stará verze dat v RCU se uvolní, když k ní nepřistupuje žádný čtenář, pomocí počítadla odkazů.",incorrect:"Stará verze dat v RCU se uvolní ihned po vytvoření nové verze písařem.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"d81c6974-887d-4987-bdec-c6bffff6873f",correct:"Při více písařích může RCU bez dalších mechanismů vést k hazardu souběhu písařů.",incorrect:"Při více písařích RCU vždy zaručuje atomické úpravy dat bez dalších mechanismů.",sectionNumber:"6.1.8",sectionTitle:"Read-Copy-Update"},{uuid:"adb4f7d0-3ee0-4ce3-97fe-4fb31ff10b28",correct:"Monitor je synchronizační koncept vyšší úrovně, nikoliv prostředek operačního systému.",incorrect:"Monitor je synchronizační prostředek poskytovaný operačním systémem na nízké úrovni.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"aaab54f3-6094-4f3c-844f-9869c643b357",correct:"Monitory jsou interně postaveny na vzájemném vyloučení, zajišťujícím vstup pouze jednoho vlákna.",incorrect:"Monitory umožňují souběžný vstup více vláken, čímž maximalizují paralelizaci bez omezení.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"3d43ef5f-af8e-4dff-aabe-44b63a7008e4",correct:"Implementace monitorů může využívat rekurzivní mutexy pro podporu vnořeného zamykání operací.",incorrect:"Implementace monitorů se striktně vyhýbá rekurzivním mutexům kvůli riziku deadlocku.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"004ecda2-e325-46f5-8d35-77f4cd1e5972",correct:"Monitor může snížit celkovou souběžnost programu výměnou za snazší prevenci chyb synchronizace.",incorrect:"Monitor vždy zvyšuje souběžnost programů a minimalizuje riziko chyb synchronizace zároveň.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"95fa5689-7011-420e-a2cd-bb1eb6d3551b",correct:"Monitor nezaručuje globální bezchybnost synchronizace, zejména u invariantů přesahujících jeho rozsah.",incorrect:"Monitor je univerzálním řešením, které zaručuje absolutní bezchybnost synchronizace v jakémkoliv programu.",sectionNumber:"6.1.9",sectionTitle:"Monitor"},{uuid:"34659fab-85ad-4822-bf4f-3c4b1d4bed36",correct:"Podmínková proměnná se používá k řešení problému souběžné datové závislosti mezi vlákny.",incorrect:"Podmínková proměnná se používá výhradně k zamezení uváznutí systému v důsledku chybějících zdrojů.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"b36d7b48-c7a9-4332-a310-faa86e783444",correct:"Operace wait na podmínkové proměnné blokuje vlákno, dokud jiné vlákno nezavolá operaci signal.",incorrect:"Operace wait na podmínkové proměnné vlákno pouze uspí na pevně stanovený časový interval.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"e7d0c87a-a477-4a3e-810e-a285a4b012d7",correct:"Stav podmínkové proměnné může být reprezentován jako množina vláken čekajících na signál.",incorrect:"Stav podmínkové proměnné je vždy reprezentován jediným bitem indikujícím, zda je proměnná uzamčena.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"5e7b1e44-cc0f-411b-99e5-40ced39ff967",correct:"Implementace podmínkové proměnné s aktivním čekáním je méně efektivní v problémech datové závislosti.",incorrect:"Implementace podmínkové proměnné s aktivním čekáním je preferovanou metodou pro synchronizaci v reálném čase.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"fcc1b0f1-287f-474c-97fc-acde000031dc",correct:"Při použití operace signal na podmínkové proměnné se může probudit jedno nebo více čekajících vláken.",incorrect:"Operace signal na podmínkové proměnné vždy probudí všechna vlákna, která na ni čekají.",sectionNumber:"6.1.10",sectionTitle:"Podmínková proměnná"},{uuid:"43426891-1c9e-456b-9bc8-96d76367ec5f",correct:"Klasický semafor sám o sobě neřeší problém producentů a konzumentů lépe než mutex.",incorrect:"Klasický semafor sám o sobě řeší problém producentů a konzumentů lépe než mutex.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"5605729a-c8eb-448d-9727-23c4c9c8c01b",correct:"Symetrický semafor blokuje operaci post, pokud by došlo k překročení maximální hodnoty počítadla n.",incorrect:"Symetrický semafor nikdy neblokuje operaci post, a to ani při překročení maximální hodnoty počítadla n.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"b64dd9dc-6581-498e-875a-31c848e72443",correct:"V klasickém řešení producent-konzument semafor E reprezentuje počet volných míst ve frontě mezivýsledků.",incorrect:"V klasickém řešení producent-konzument semafor F reprezentuje počet volných míst ve frontě mezivýsledků.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"db7e4825-d8e5-4c15-ae03-8cd3fb3d52c4",correct:"Operace wait na semaforu blokuje proces, pokud je aktuální hodnota semaforu rovna nule.",incorrect:"Operace wait na semaforu blokuje proces, pokud je aktuální hodnota semaforu větší než nula.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"306ba28c-3762-45c8-b653-44d70ed02445",correct:"Problém producentů a konzumentů lze řešit kombinací dvou klasických, asymetrických semaforů.",incorrect:"Problém producentů a konzumentů nelze řešit kombinací dvou klasických, asymetrických semaforů.",sectionNumber:"6.1.11",sectionTitle:"Semafor"},{uuid:"39fca68c-917c-447c-b118-c8696e87a064",correct:"Bariéra řeší problém rozvětvení a setkání vláken, zejména při synchronizaci většího počtu vláken.",incorrect:"Bariéra řeší problém pouze rozvětvení vláken, nikoliv setkání, a není určena pro synchronizaci více vláken.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"9c23f234-37e8-4da6-9a1d-82bb8504dcbb",correct:"Operace wait bariéry blokuje volající vlákno dokud operaci wait nezavolají všechna synchronizovaná vlákna.",incorrect:"Operace wait bariéry blokuje volající vlákno pouze do doby, než ji zavolá alespoň jedno další synchronizované vlákno.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"149e5ff8-f51d-4e69-9e4d-c085ce531752",correct:"Implementace bariéry s aktivním čekáním je vhodná pouze v situacích, kdy všechna vlákna dorazí přibližně ve stejnou dobu.",incorrect:"Implementace bariéry s aktivním čekáním je univerzálnější a efektivnější než implementace s podmínkovou proměnnou.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"24044a5c-7bf7-4943-b80f-b5506141aae8",correct:"Při implementaci bariéry s počítadlem operace init nastaví počítadlo na počet vláken, která se mají synchronizovat.",incorrect:"Při implementaci bariéry s počítadlem operace init nastaví počítadlo na nulu a operace wait ho inkrementuje.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"},{uuid:"dba6a30a-4646-400e-8a9f-542a52e74ff3",correct:"Vlákna čekající na bariéře, implementované pomocí podmínkové proměnné, obvykle spí a nezatěžují procesor aktivním čekáním.",incorrect:"Vlákna čekající na bariéře, implementované pomocí podmínkové proměnné, aktivně čekají a neustále kontrolují stav bariéry.",sectionNumber:"6.1.12",sectionTitle:"Bariéra"}]},{uuid:"9b09f7c6-79c5-43f7-ae95-751301b85594",sectionNumber:"7",sectionTitle:"Komunikace, uváznutí",statements:[{uuid:"5fdaf263-16da-4714-b696-e3609e4b6ae2",correct:"Každá komunikace je formou synchronizace, protože čtení informace musí být předcházeno zápisem.",incorrect:"Každá komunikace je formou produkce zpráv, nikoliv synchronizace mezi procesy.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"fb7816c7-260d-4571-a52e-3beb791e025d",correct:"Komunikační zařízení jsou často zároveň zařízeními synchronizačními kvůli nutné kauzalitě zápisu a čtení.",incorrect:"Komunikační zařízení jsou zřídka zařízeními synchronizačními, primárně slouží pouze k produkci zpráv.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"937e9372-f786-4040-b5ba-9d017d2bd0a0",correct:"Většina komunikace je zobecněnou verzí problému producentů a konzumentů, kde účastníci jsou producenty i konzumenty.",incorrect:"Většina komunikace je specifickou verzí problému producentů a konzumentů, kde účastníci jsou jen producenty nebo konzumenty.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"92d11021-ae0f-4e32-ac69-153188bd7f3c",correct:"Opačný vztah k implikaci komunikace → synchronizace neplatí, synchronizace neznamená vždy komunikaci.",incorrect:"Opačný vztah k implikaci komunikace → synchronizace platí, synchronizace vždy nutně znamená komunikaci.",sectionNumber:"7.1.1",sectionTitle:"Komunikace a synchronizace"},{uuid:"a3c178d4-1bd0-4f7d-a1c4-7df7e2dd2df8",correct:"Pro komunikaci lze použít libovolnou datovou strukturu, je-li chráněna mutexem.",incorrect:"Pro komunikaci lze použít pouze specializované datové struktury bez mutexu.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"10d48add-2aa6-4675-a1a6-e4e5d0d111fe",correct:"Soutěž o zámek mutexu může zpomalovat komunikaci při častém používání.",incorrect:"Soutěž o zámek mutexu nemá vliv na rychlost komunikace ani při častém používání.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"7910d167-8e91-449f-8d0a-fa3353d9bf89",correct:"Specializované fronty umožňují větší souběžnost než komunikace s mutexem při každém předání.",incorrect:"Mutexy při každém předání umožňují větší souběžnost než specializované komunikační fronty.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"c213f92a-0764-4aa3-b73c-f48188d90d1c",correct:"Pro občasnou komunikaci nepředstavuje použití mutexu zásadní problém z hlediska výkonu.",incorrect:"I pro občasnou komunikaci představuje použití mutexu zásadní problém z hlediska výkonu.",sectionNumber:"7.1.2",sectionTitle:"Datové struktury"},{uuid:"a7e2de84-5e60-4aee-9557-f171e983f7ca",correct:"Kruhová fronta s pevnou velikostí využívá dva ukazatele, čtecí a zapisovací, pro řízení operací.",incorrect:"Kruhová fronta s pevnou velikostí využívá pouze jeden ukazatel pro řízení operací čtení a zápisu.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"1e0791a5-8f6b-40a8-b684-d2af7d8ce613",correct:"Fronta je považována za plnou, pokud by zápisovací ukazatel měl předběhnout ukazatel čtecí.",incorrect:"Fronta je považována za plnou, pokud by čtecí ukazatel měl předběhnout ukazatel zapisovací.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"fd1f819e-2b56-45a2-95cf-8e3edb2d8db8",correct:"V kruhové frontě každá strana modifikuje pouze jeden ukazatel, čímž se minimalizuje potřeba kritických sekcí.",incorrect:"V kruhové frontě obě strany modifikují oba ukazatele, což vyžaduje rozsáhlé kritické sekce pro synchronizaci.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"4c8a4185-1685-4f8d-8459-5247157069ed",correct:"V kruhové frontě s S buňkami je efektivně využitelná kapacita o jednu buňku menší než S.",incorrect:"V kruhové frontě s S buňkami je plně využitelná kapacita rovna počtu buněk S.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"3f8cc3e2-18ee-44d1-aec7-0f250cdd7d65",correct:"Pro implementaci fronty producent-konzument lze efektivně použít kruhovou frontu nebo frontu s mutexem.",incorrect:"Pro implementaci fronty producent-konzument je nezbytné použít pouze jednostranně zřetězený seznam.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"d23dfc8c-6d62-49b0-8e44-57bd25d2cc6e",correct:"Algoritmus odebrání z kruhové fronty nejprve kontroluje, zda je fronta prázdná, porovnáním ukazatelů.",incorrect:"Algoritmus odebrání z kruhové fronty zahajuje operaci čtení bez předchozí kontroly, zda fronta není prázdná.",sectionNumber:"7.1.3",sectionTitle:"Komunikační fronta"},{uuid:"7510282f-81b1-49b0-a0cd-5b9d56408599",correct:"Roura je specializovaná fronta pracující s bajty, která se vyznačuje efektivními dávkovými operacemi.",incorrect:"Roura je specializovaná fronta pracující s bloky, která se vyznačuje neefektivními dávkovými operacemi.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"865d75f7-ce2f-4362-ab24-83aabd6d3b9b",correct:"Efektivní dávkové operace jsou klíčovou charakteristikou roury pro zápis a čtení většího množství bajtů najednou.",incorrect:"Jednotlivé operace s bajty jsou klíčovou charakteristikou roury pro zápis a čtení dat.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"7d9eceda-caf1-4dcb-a818-cacd41022bb3",correct:"Roura je obvykle poskytována operačním systémem a implementována jako omezená fronta.",incorrect:"Roura je obvykle poskytována uživatelskými knihovnami a implementována jako neomezená fronta.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"6a3cd7e0-d5af-48aa-9c95-3b21bdb3f6ae",correct:"Synchronizační chování roury, která je implementována jako omezená fronta, se podobá symetrickému semaforu.",incorrect:"Synchronizační chování roury, která je implementována jako neomezená fronta, se podobá binárnímu semaforu.",sectionNumber:"7.1.4",sectionTitle:"Roura"},{uuid:"994ba9a9-2dc5-4075-9100-520e08259dc5",correct:"Zobecněná komunikační fronta umožňuje vkládání a vybírání prvků více vlákny současně.",incorrect:"Zobecněná komunikační fronta umožňuje vkládání a vybírání prvků pouze jedním vláknem.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"12914746-430f-439f-b419-d31d3d41e256",correct:"Implementace zobecněné fronty bez zámků může být založena na zřetězeném seznamu.",incorrect:"Implementace zobecněné fronty bez zámků nemůže být založena na zřetězeném seznamu.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"f9d9eb4a-41ce-40dd-96b5-606fbeeb67a8",correct:"Zobecněná komunikační fronta se používá jako společný seznam úloh pro producenty a konzumenty.",incorrect:"Zobecněná komunikační fronta se nepoužívá jako společný seznam úloh pro producenty a konzumenty.",sectionNumber:"7.1.5",sectionTitle:"Sdílená fronta"},{uuid:"ad3fb5b6-c63e-4f2f-9f1d-253737af8e85",correct:"Implementace množiny ukončených úloh typicky podporuje operace dotazování a vkládání nových úloh.",incorrect:"Implementace množiny ukončených úloh typicky podporuje operace mazání a aktualizace existujících úloh.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"24c351e1-6cbb-4928-af35-c4b069cd93c0",correct:"Read-copy-update je jednou z možných implementací množiny ukončených úloh.",incorrect:"Read-copy-update není vhodná implementace pro množinu ukončených úloh.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"1fc371b2-1b79-42de-857a-9ff972ec6474",correct:"Pro implementaci množiny ukončených úloh lze použít hashovací tabulku kombinovanou se spinlockem v každé buňce.",incorrect:"Pro implementaci množiny ukončených úloh nelze použít hashovací tabulku kombinovanou se spinlockem v každé buňce.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"8c2b2575-bb04-44b1-83d6-160d714f3c59",correct:'Množina ukončených úloh se používá například pro správu "dirty" stránek v operačním systému.',incorrect:"Množina ukončených úloh se používá například pro plánování běhu procesů v operačním systému.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"250a9abf-1872-4729-80ed-4831d8ca3559",correct:"K synchronizaci operací nad množinou ukončených úloh lze využít atomické instrukce jako ‹cmpxchg›.",incorrect:"K synchronizaci operací nad množinou ukončených úloh nelze využít atomické instrukce jako ‹cmpxchg›.",sectionNumber:"7.1.6",sectionTitle:"Sdílená množina"},{uuid:"c97ca8d5-8d08-4765-8b6e-906f388b6766",correct:"Při předávání zpráv jsou metadata, zejména adresa, důležitější než samotný obsah zprávy.",incorrect:"Při předávání zpráv je obsah zprávy důležitější než metadata, která jsou k ní připojena.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"e32d421c-3eb4-4e93-9948-c73b014d98a7",correct:"Pro pevnou dvojici komunikujících vláken je předávání zpráv ekvivalentní dvojici komunikačních front.",incorrect:"Pro pevnou dvojici komunikujících vláken se předávání zpráv zásadně liší od dvojice komunikačních front.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"5b63d24e-6944-46d6-8510-182bbff641b1",correct:"Systém pro předávání zpráv obvykle interpretuje obsah zprávy jako neprůhledné bajty.",incorrect:"Systém pro předávání zpráv obvykle interpretuje obsah zprávy a analyzuje jeho strukturu.",sectionNumber:"7.2.1",sectionTitle:"Zpráva"},{uuid:"6a8f9d64-aba9-43ba-9c21-47f0a823c78a",correct:"Při rendezvous se odesílající a přijímající vlákno musí setkat, aby si mohly předat zprávu.",incorrect:"Při rendezvous se odesílající a přijímající vlákno nemusí setkat, aby si mohly předat zprávu.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"15f2129b-5ea2-4cc5-8ac9-dfc4c1b2c08b",correct:"Operace přijmi může blokovat, pokud není doručena žádná zpráva.",incorrect:"Operace přijmi nikdy neblokuje, i když není doručena žádná zpráva.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"1ff7ed48-4294-4b43-8686-6ee2ffb5aa3e",correct:"Asynchronní operace mohou snížit počet kopírování zpráv, ale komplikují správu paměti.",incorrect:"Asynchronní operace vždy vyžadují kopírování zpráv a zjednodušují správu paměti.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"676a5e04-958c-4b92-93df-9ed1f0691315",correct:"Operace odešli může blokovat kvůli omezené schopnosti systému pamatovat si odeslané zprávy.",incorrect:"Operace odešli nikdy neblokuje, protože systém má neomezenou schopnost pamatovat si zprávy.",sectionNumber:"7.2.2",sectionTitle:"Základní operace"},{uuid:"967fa638-0eb0-4ecf-888d-4cfdbfbe098d",correct:"Systém předávání zpráv může mít žádného, jednoho, nebo i více zprostředkovatelů.",incorrect:"Systém předávání zpráv musí mít vždy alespoň jednoho zprostředkovatele.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"53991ce7-010e-4e9f-b0b8-a30848a12d7c",correct:"Zprostředkovatel v systému zpráv přijímá zprávy od klientů a realizuje jejich doručení adresátovi.",incorrect:"Zprostředkovatel v systému zpráv pouze odesílá zprávy klientům, ale nepřijímá zprávy od klientů.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"4a3279f6-7ccf-46d6-b4a4-61dfeb42b66a",correct:"Pro předání zprávy mezi klientem a zprostředkovatelem je nutný komunikační kanál.",incorrect:"Pro předání zprávy mezi klientem a zprostředkovatelem není nutný komunikační kanál.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"f43c968a-263a-4a15-81a9-b11f1fe7fc08",correct:"Při synchronním odeslání a spolehlivém doručení je za zprávu odpovědný zprostředkovatel.",incorrect:"Při synchronním odeslání a spolehlivém doručení je za zprávu stále odpovědný odesílající klient.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"052219d2-e9eb-4eb8-9d70-a09bd8e62936",correct:"Při asynchronním odeslání musí klient uchovat zprávu, dokud zprostředkovatel nepotvrdí její převzetí.",incorrect:"Při asynchronním odeslání může klient zprávu smazat ihned po jejím odeslání zprostředkovateli.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"5035a9c4-d7ec-44d2-82c0-7c2e05c659fe",correct:"Při nespolehlivém doručení musí klient uchovat zprávu do potvrzení doručení příjemcem.",incorrect:"Při nespolehlivém doručení stačí, aby klient uchoval zprávu pouze do potvrzení od zprostředkovatele.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"09f37ed8-4e1a-41b9-bf13-61002b0a155a",correct:"Synchronní příjem zprávy znamená, že se příjemce aktivně dotazuje na existenci nové zprávy.",incorrect:"Synchronní příjem zprávy znamená, že zprostředkovatel aktivně oznamuje doručení nové zprávy příjemci.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"efcc209a-7d14-47a8-b999-e09cc45cf417",correct:"Asynchronní příjem umožňuje klientovi souběžně zpracovávat více zpráv na výzvu zprostředkovatele.",incorrect:"Asynchronní příjem nutí klienta zpracovávat zprávy sekvenčně, jednu po druhé, na výzvu zprostředkovatele.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"a906e282-548f-4f13-a1ca-c99bc02f36f4",correct:"Fibry jsou uživatelská vlákna s kooperativním plánováním a levnějším přepínáním kontextu.",incorrect:"Fibry jsou vlákna operačního systému s preemptivním plánováním a dražším přepínáním kontextu.",sectionNumber:"7.2.3",sectionTitle:"Zprostředkovatel"},{uuid:"ccd92a26-4f73-49f7-9fe2-20777c5a2295",correct:"Operace broadcast lze v principu realizovat pomocí point-to-point zpráv.",incorrect:"Operace broadcast nelze v principu realizovat pomocí point-to-point zpráv.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"06844704-d0e0-43d2-a3ef-44f656b67def",correct:"Centrální zprostředkovatel může zefektivnit operace jako scatter/gather.",incorrect:"Centrální zprostředkovatel nemůže zefektivnit operace jako scatter/gather.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"bd949331-0137-4635-a114-514ffdb6a97e",correct:"Synchronizační operace bariéra je efektivnější, pokud ji přímo podporuje zprostředkovatel.",incorrect:"Synchronizační operace bariéra není efektivnější, pokud ji přímo podporuje zprostředkovatel.",sectionNumber:"7.2.4",sectionTitle:"Odvozené operace"},{uuid:"94c73491-e065-4715-99e3-4c1f3a0af93b",correct:"V mikrojádrových systémech je předávání zpráv základním mechanismem meziprocesové komunikace.",incorrect:"V mikrojádrových systémech je sdílená paměť základním mechanismem meziprocesové komunikace.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"91764b56-fb21-4da2-b5d4-fb08090e1a83",correct:"Distribuované systémy běžně používají předávání zpráv jako metodu komunikace kvůli absenci sdílené paměti.",incorrect:"Distribuované systémy preferují sdílenou paměť jako metodu komunikace pro její výkonnost.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"57c7b906-633d-45de-86f0-4f45b1ee542d",correct:"Pro systémy s důrazem na bezpečnost je izolace komponent klíčová a předávání zpráv ji podporuje.",incorrect:"Izolace komponent nemá vliv na bezpečnost systémů a předávání zpráv se pro ni nehodí.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"4fa1d926-bfe2-4e13-8556-51050e3e0071",correct:"Mikrojádro v mikrojádrových systémech často funguje jako zprostředkovatel pro předávání zpráv.",incorrect:"Mikrojádro v mikrojádrových systémech nikdy nefunguje jako zprostředkovatel pro předávání zpráv.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"481cf175-a6db-4966-9cc4-355488e7f8de",correct:"Distribuované vědecké výpočty na superpočítačích často využívají efektivní předávání zpráv pro komunikaci.",incorrect:"Distribuované vědecké výpočty se obvykle vyhýbají předávání zpráv kvůli jeho neefektivitě na superpočítačích.",sectionNumber:"7.2.5",sectionTitle:"Využití"},{uuid:"8f1a25e3-293a-4394-818d-28925889e44f",correct:"Operační systém pracuje s konečným množstvím hardwarových zdrojů.",incorrect:"Operační systém má k dispozici neomezené množství hardwarových zdrojů díky virtualizaci.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"1a038973-e5de-4793-ade7-4eafc8fb8262",correct:"Virtualizace umožňuje sdílení hardwarových zdrojů, ale nepřekonává jejich fyzickou konečnost.",incorrect:"Virtualizace hardwarových zdrojů operačního systému dokáže eliminovat fyzické limity hardware.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"eddb5d39-2099-4e6a-bb28-441c2e5e3018",correct:"Některé periferie, kvůli svým specifickým vlastnostem, nelze efektivně virtualizovat.",incorrect:"Díky pokročilým technikám virtualizace lze virtualizovat naprosto všechny typy hardwarových periferií.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"1d3c38de-d73b-4f95-b7ba-65c03dfc2f73",correct:"Virtualizace zdrojů je nejúčinnější, pokud procesy využívají pouze část kapacity zdroje.",incorrect:"Virtualizace zdrojů je nejúčinnější, i když všechny procesy vyžadují plnou kapacitu daného zdroje.",sectionNumber:"7.3.1",sectionTitle:"Hardwarové zdroje"},{uuid:"e3e525c1-6bb6-470b-ab45-99041449c43b",correct:"Rezervace zdrojů představuje alternativu k virtualizaci, zvláště u zařízení jako jsou páskové jednotky.",incorrect:"Rezervace zdrojů je vždy preferovanou metodou správy zdrojů oproti virtualizaci ve všech situacích.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"1cbd783c-1d6e-4d03-aefb-d3f2b291fc5f",correct:"Virtualizace a rezervace zdrojů se mohou doplňovat, kdy rezervace zajistí garantovanou kapacitu i ve virtualizovaném prostředí.",incorrect:"Virtualizace a rezervace zdrojů jsou vždy vzájemně výlučné metody správy systémových zdrojů v operačním systému.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"baa47025-7fe2-43db-a48b-7a17b4da02a4",correct:"Operační systémy umožňují procesům rezervovat fyzickou paměť, čímž zamezí stránkování rezervované paměti.",incorrect:"Operační systémy nikdy neumožňují procesům rezervovat fyzickou paměť pro výhradní použití procesem.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"d13d4d9f-5885-4b84-aa89-a665a37ef8dc",correct:"Rezervace zdroje zahrnuje dvě fáze: vyžádání zdroje pro výhradní použití a následné uvolnění zdroje.",incorrect:"Rezervace zdroje je jednofázový proces, zahrnující pouze vyžádání zdroje pro daný proces.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"ba268505-ad19-43d1-84a5-f77ba962548c",correct:"Při rezervaci zdroje může dojít k situaci, kdy zdroj není dostupný, což může vést k zamítnutí nebo čekání.",incorrect:"Při rezervaci zdroje, pokud není zdroj okamžitě dostupný, systém vždy rezervaci automaticky zamítne.",sectionNumber:"7.3.2",sectionTitle:"Rezervace"},{uuid:"525047fd-05fa-4d75-a62f-1685a1839601",correct:"Mutex lze chápat jako abstraktní zdroj, který se rezervuje zamčením a uvolňuje odemčením.",incorrect:"Mutex nelze chápat jako abstraktní zdroj, protože reprezentuje pouze kritickou sekci.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"d0c13ccb-a152-4f03-a72e-607bfb1634c8",correct:"Semafor je abstraktní zdroj, jehož instance lze přidělovat nezávisle.",incorrect:"Semafor je abstraktní zdroj, jehož instance nelze přidělovat nezávisle.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"a07f6de8-75ce-4901-b69c-cbef4aeb5ea1",correct:"Kritickou sekci lze v určitém smyslu také chápat jako abstraktní zdroj.",incorrect:"Kritickou sekci nelze chápat jako abstraktní zdroj, protože se jedná pouze o kód.",sectionNumber:"7.3.3",sectionTitle:"Abstraktní zdroje"},{uuid:"9f43fd9f-2b73-4201-b178-2b5eef853153",correct:"Zdroje mohou existovat v několika zaměnitelných instancích, ale pouze v době rezervace.",incorrect:"Zdroje jsou vždy zaměnitelné, a to i po rezervaci instance zdroje.",sectionNumber:"7.3.4",sectionTitle:"Instance"},{uuid:"14247f46-f9c4-45b7-a075-e1dc293ab4e9",correct:"Jakmile je instance zdroje rezervována, nelze ji dodatečně vyměnit za jinou.",incorrect:"I po rezervaci instance zdroje je možné ji dodatečně vyměnit za jinou.",sectionNumber:"7.3.4",sectionTitle:"Instance"},{uuid:"a4c6a775-1f20-49fb-8959-2b7b8c4fc957",correct:"Komunikace mezi procesy může být považována za synchronizační mechanismus a abstraktní zdroj.",incorrect:"Komunikace mezi procesy není nikdy považována za synchronizační mechanismus.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"fa700980-3309-4a67-b528-be7d819d23a9",correct:"V kontextu komunikace, odeslání zprávy lze chápat jako rezervaci abstraktního zdroje.",incorrect:"V kontextu komunikace, odeslání zprávy se nikdy nechápe jako rezervace zdroje.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"8ffbc742-db67-4594-8067-71ef99361729",correct:"Přijetí zprávy v komunikačním kontextu odpovídá uvolnění dříve rezervovaného abstraktního zdroje.",incorrect:"Přijetí zprávy v komunikačním kontextu rezervuje abstraktní zdroj.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"3ed32274-badd-4573-ae3b-ea942059d291",correct:"Různá vlákna nebo procesy mohou provádět operace rezervace a uvolnění v rámci komunikace.",incorrect:"Pouze stejné vlákno může provádět rezervaci a uvolnění zdroje v komunikaci.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"e8684bf8-043d-4a8f-a180-c3b6a074e497",correct:"V problému producent-konzument je uložení mezivýsledku formou rezervace omezeného zdroje.",incorrect:"V problému producent-konzument uložení mezivýsledku není rezervací zdroje.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"9f766d0d-b0a5-4c79-8159-c4b506927bfe",correct:"Operační systém může asistovat při předávání zdrojů mezi programy a jejich následném uvolnění.",incorrect:"Operační systém nikdy neasistuje při předávání zdrojů mezi programy.",sectionNumber:"7.3.5",sectionTitle:"Komunikace"},{uuid:"d0cf1c03-515f-4167-8562-7a1702d7bd43",correct:"Implicitně se zdroje považují za neodnímatelné, což znamená, že uvolnění zdroje iniciuje vlastník.",incorrect:"Implicitně se zdroje považují za odnímatelné, což znamená, že uvolnění zdroje iniciuje operační systém.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"c397cc14-990a-4482-9ba7-d475e16e36df",correct:"U neodnímatelných zdrojů, jako je mutex, může násilné odebrání vést k problémům ve fungování programu.",incorrect:"U neodnímatelných zdrojů, jako je mutex, násilné odebrání nemá žádný vliv na fungování programu.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"40a6ffa6-d297-4098-9034-49f6f269ed2a",correct:"Virtualizované zdroje umožňují odebrání fyzického prostředku bez fatálních dopadů na běžící proces.",incorrect:"Virtualizované zdroje vyžadují, aby odebrání fyzického prostředku mělo vždy fatální dopady na běžící proces.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"8128f42b-b29e-4729-8273-0d14811ef538",correct:"Odnímatelnost zdroje se může měnit v závislosti na kontextu použití daného zdroje v systému.",incorrect:"Odnímatelnost zdroje je neměnná vlastnost, která nezávisí na kontextu použití v systému.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"eb12b2b2-beb5-4216-adfb-3c729cc8801a",correct:"Ztráta paketu v síti z důvodu plné vyrovnávací paměti je příkladem násilného odebrání zdroje.",incorrect:"Ztráta paketu v síti z důvodu plné vyrovnávací paměti není považována za odebrání zdroje.",sectionNumber:"7.3.6",sectionTitle:"Odnímatelné zdroje"},{uuid:"0f6d5cdd-c5dd-4c09-a570-c5fa217131b1",correct:"Uváznutí nastává, když vlákno P drží zdroj A a čeká na zdroj B, a vlákno Q drží zdroj B a čeká na zdroj A.",incorrect:"Uváznutí nastává, když vlákno P drží zdroj A a čeká na zdroj B, a vlákno Q drží zdroj A a čeká na zdroj B.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"1a380e55-adbe-45a6-abc2-a4e5887586c8",correct:"V situaci uváznutí nemohou vlákna P a Q pokračovat v činnosti bez vnějšího zásahu operačního systému.",incorrect:"V situaci uváznutí mohou vlákna P a Q pokračovat v činnosti bez vnějšího zásahu operačního systému.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"6fa766b5-6c78-4e94-8c3f-8e1c9395dad4",correct:"Podle textu, k uváznutí může dojít, i když souběžnost žádostí vláken P a Q není nutnou podmínkou.",incorrect:"Podle textu, k uváznutí může dojít, pouze pokud je souběžnost žádostí vláken P a Q nutnou podmínkou.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"2eb519ea-e0b0-43f5-9d6f-889b0142af6c",correct:"Uváznutí je stav, kdy vlákno čeká na zdroj, který drží jiné vlákno, a tím vzniká cyklická závislost čekání.",incorrect:"Uváznutí je stav, kdy vlákno čeká na zdroj, který není držen žádným jiným vláknem, což způsobuje jeho zablokování.",sectionNumber:"7.4.1",sectionTitle:"Uváznutí"},{uuid:"200260f2-1626-4b0a-8da2-2d6ac9be481b",correct:"Vzájemné vyloučení je přímým důsledkem rezervace zdrojů v operačním systému.",incorrect:"Vzájemné vyloučení není důsledkem rezervace zdrojů v operačním systému.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"0a1a2194-ccc0-470b-86c3-712b09db7afd",correct:"Podmínka čekající vlastník uváznutí nastává, když vlákno drží jeden zdroj a čeká na další.",incorrect:"Podmínka čekající vlastník uváznutí nastává, jen když vlákno nedrží žádné zdroje.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"07c9dc36-93d5-4bd0-8c17-f25303fa81f7",correct:"Neodnímatelnost zdrojů znamená, že operační systém nemůže odebrat zdroj vláknu násilím.",incorrect:"Neodnímatelnost zdrojů znamená, že operační systém může odebrat zdroj vláknu násilím.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"cb6ba26f-f161-4be7-a9bf-b39166801e61",correct:"Kruhové čekání je stav, kdy existuje cyklická závislost mezi vlákny čekajícími na zdroje.",incorrect:"Kruhové čekání je stav, kdy neexistuje žádná závislost mezi vlákny a zdroji.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"3f8c3e67-f717-4be9-9238-91fd0000d0fc",correct:"Podmínky uváznutí jsou nutné, ale ne postačující pro vznik uváznutí v systému.",incorrect:"Podmínky uváznutí jsou nutné a postačující pro vznik uváznutí v systému.",sectionNumber:"7.4.2",sectionTitle:"Podmínky uváznutí"},{uuid:"6e848669-049f-4038-a7fe-e42ff980df00",correct:"Uváznutí mohou být velmi vzácné, protože jsou často důsledkem hazardů souběhu.",incorrect:"Uváznutí jsou běžná a snadno se odhalují v moderních operačních systémech.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"6cc2dc9f-9df1-4fdc-9812-3303a720e4c8",correct:"Pštrosí algoritmus řeší uváznutí hrubou silou, například restartem systému.",incorrect:"Pštrosí algoritmus se snaží aktivně předcházet uváznutím sofistikovanými metodami.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"fcf39570-63ef-49a8-b3ab-db5e829bfbfa",correct:"Rozhodnutí, zda nastalo uváznutí, může být v některých případech ponecháno na uživateli.",incorrect:"Operační systém vždy automaticky a spolehlivě detekuje uváznutí bez zásahu uživatele.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"5a6a1181-7490-467d-823a-74f18a6f4899",correct:"Detekce uváznutí může být problematická, jak naznačuje text.",incorrect:"Detekce uváznutí je vždy jednoduchá a přímočará v operačních systémech.",sectionNumber:"7.4.3",sectionTitle:"Pštrosí algoritmus"},{uuid:"d086d9a7-830f-42e1-b5c1-d39b685b3c2e",correct:"Uváznutí lze detekovat pomocí grafu vlastnictví a čekání na zdroje.",incorrect:"Uváznutí lze detekovat pouze kontrolou kruhového čekání bez grafu zdrojů.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"aa6d0e5b-cb72-4a96-8c83-b57d22e24b72",correct:"Graf detekce uváznutí obsahuje dva typy uzlů: vlákna a zdroje, s hranami mezi nimi.",incorrect:"Graf detekce uváznutí obsahuje pouze jeden typ uzlů a hrany mezi uzly stejného typu.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"742c9753-ca28-45cd-9693-e5aa79a5ee97",correct:"Cyklická závislost v grafu vlastnictví a čekání indikuje uváznutí systému.",incorrect:"Cyklická závislost v grafu vlastnictví a čekání nikdy neindikuje uváznutí systému.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"00df0447-a746-4364-b06d-ec5604ce1ce8",correct:"Přístup detekce uváznutí pomocí grafu je primárně určen pro zdroje s jedinou instancí.",incorrect:"Přístup detekce uváznutí pomocí grafu je určen pro zdroje s více instancemi.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"a8afba46-71f1-4172-951e-b8678f273ae3",correct:"Mutexy, chránící kritické sekce, jsou považovány za zdroje s jedinou instancí v kontextu uváznutí.",incorrect:"Mutexy, chránící kritické sekce, jsou považovány za zdroje s více instancemi v kontextu uváznutí.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"16507fb7-9c6f-4668-baff-ddfbdaa263ae",correct:"Každý cyklus v grafu detekce uváznutí musí mít sudou délku a alespoň čtyři hrany.",incorrect:"Každý cyklus v grafu detekce uváznutí může mít lichou délku a alespoň tři hrany.",sectionNumber:"7.4.4",sectionTitle:"Detekce uváznutí"},{uuid:"9457dd1d-0b59-41a0-a50d-6b358bcfc4e5",correct:"Účastní-li se cyklického čekání odnímatelný zdroj, obvykle lze uváznutí vyřešit odebráním zdroje.",incorrect:"Účastní-li se cyklického čekání odnímatelný zdroj, nelze uváznutí vyřešit odebráním zdroje.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"260b0e27-b1b3-472d-b266-f8ac060d23c7",correct:"Pro zotavení z uváznutí s neodnímatelnými zdroji je možné násilně ukončit proces.",incorrect:"Pro zotavení z uváznutí s neodnímatelnými zdroji není možné násilně ukončit proces.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"ebe03cce-8b0c-4f3b-a149-034db7ec1836",correct:"Odnímatelnost zdroje umožňuje zotavení z uváznutí bez nutnosti násilného ukončování vláken.",incorrect:"Odnímatelnost zdroje neumožňuje zotavení z uváznutí bez nutnosti násilného ukončování vláken.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"5b9f51be-b015-42d5-9d8e-0ab0e0f6e352",correct:"Podle textu, striktní definice uváznutí vyžaduje účast pouze neodnímatelných zdrojů.",incorrect:"Podle textu, striktní definice uváznutí nevyžaduje účast pouze neodnímatelných zdrojů.",sectionNumber:"7.4.5",sectionTitle:"Zotavení z uváznutí"},{uuid:"ead47df6-98a9-49d4-afec-cf30a4c75480",correct:"Vyhýbání se uváznutí může zahrnovat zamítnutí některých požadavků na rezervaci zdrojů.",incorrect:"Vyhýbání se uváznutí spočívá pouze v přidělování zdrojů, pokud jsou všechny zdroje volné.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"601796ce-96e2-404c-8520-4dd575dba191",correct:"Bankéřův algoritmus vyžaduje znalost maximálních požadavků každého vlákna na zdroje.",incorrect:"Bankéřův algoritmus funguje i bez znalosti maximálních požadavků vláken.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"29e0816d-0d2a-44c4-8286-9ff73e670ba3",correct:"Technika vyhýbání se uváznutí využívá koncept bezpečných stavů systému.",incorrect:"Technika vyhýbání se uváznutí se obejde bez konceptu bezpečných stavů systému.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"1c116b67-62ae-4461-b0b5-0ae1fb0c2c1d",correct:"Bankéřův algoritmus počítá s nejhorším případem maximálních požadavků vláken na zdroje.",incorrect:"Bankéřův algoritmus se spoléhá na průměrné požadavky vláken, nikoli na maximální.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"ed95b63d-e666-4fb8-b63c-e1ce5113c057",correct:"Invariant bankéřova algoritmu zaručuje existenci vlákna, které může dokončit běh.",incorrect:"Invariant bankéřova algoritmu zaručuje, že všechna vlákna mohou souběžně dokončit běh.",sectionNumber:"7.4.6",sectionTitle:"Vyhýbání uváznutí"},{uuid:"a51f8e9c-bfe7-431b-80e3-a20daa2cd080",correct:"Vyhýbání se uváznutí je často nepraktické kvůli omezenému počtu instancí zdrojů.",incorrect:"Vyhýbání se uváznutí je praktické ve většině situací díky bankéřovu algoritmu.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"522af1f6-7ce6-4cc7-8172-9b84197d2b45",correct:"Zamezení uváznutí spočívá v eliminaci alespoň jedné ze čtyř nutných podmínek uváznutí.",incorrect:"Zamezení uváznutí vyžaduje eliminaci všech čtyř nutných podmínek uváznutí současně.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"dbba97ee-d619-4553-a2ba-e0bcfb512a57",correct:"Podmínku vzájemného vyloučení lze zamezit virtualizací zdrojů.",incorrect:"Podmínku vzájemného vyloučení lze zamezit předrezervací zdrojů.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"83314669-7878-4279-be49-f8a6d8842653",correct:"Technika zotavení z uváznutí je vhodná pro systémy s odnímatelnými zdroji.",incorrect:"Technika zotavení z uváznutí je primárně určena pro systémy s výhradně nepřenosnými zdroji.",sectionNumber:"7.4.7",sectionTitle:"Zamezení uváznutí"},{uuid:"44ac4454-c393-4147-9750-6f91baf6cf77",correct:"Předrezervace zdrojů se snaží zabránit čekání vlastníka zdroje na jiný zdroj.",incorrect:"Předrezervace zdrojů má za cíl umožnit čekání vlastníka zdroje na další zdroje.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"a294e72b-a300-48ec-b82f-3f3ea7a2d390",correct:"Dávková rezervace vyžaduje, aby vlákno rezervovalo všechny zdroje atomicky a najednou.",incorrect:"Dávková rezervace umožňuje vláknu rezervovat zdroje postupně, nikoliv atomicky.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"984a26d9-62d2-46de-9851-54299656f474",correct:"Vlákno musí uvolnit všechny držené zdroje před rezervací dalších zdrojů v systému s předrezervací.",incorrect:"Vlákno může držet zdroje a rezervovat další bez nutnosti uvolnění stávajících zdrojů v systému s předrezervací.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"74f2a2bb-bae6-455c-ab82-81b113c4add2",correct:"Pro rezervaci více zdrojů najednou předrezervace vyžaduje jedinou atomickou operaci.",incorrect:"Pro rezervaci více zdrojů najednou předrezervace umožňuje více postupných operací.",sectionNumber:"7.4.8",sectionTitle:"Zamezení předrezervací"},{uuid:"3f8ce394-4388-47d0-bed7-3b07de2f5b59",correct:"Virtualizované zdroje nepoužívají výlučnou rezervaci, a proto nemohou přímo způsobit uváznutí.",incorrect:"Virtualizované zdroje používají výlučnou rezervaci, a proto mohou přímo způsobit uváznutí.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"b3da32d7-ce1f-4ef5-8721-e8d42849b303",correct:"Virtualizace tiskáren obvykle používá frontu pro správu tiskových úloh.",incorrect:"Virtualizace tiskáren obvykle nepoužívá frontu pro správu tiskových úloh.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"67ae12a7-1d66-4356-8fb9-29bd91851edf",correct:"Virtualizace napadá vzájemné vyloučení, aby umožnila více programům využívat zdroj.",incorrect:"Virtualizace posiluje vzájemné vyloučení, aby umožnila více programům využívat zdroj.",sectionNumber:"7.4.9",sectionTitle:"Zamezení virtualizací"},{uuid:"fd3d31ef-0322-4a08-b04a-c80187facc4a",correct:"Zavedení globálního uspořádání zdrojů efektivně zamezuje vzniku kruhového čekání mezi vlákny.",incorrect:"Zavedení globálního uspořádání zdrojů nijak neovlivňuje vznik kruhového čekání mezi vlákny.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"},{uuid:"e98564b7-debf-4955-a67a-3758fd44662f",correct:"V systému s globálním uspořádáním musí vlákno rezervovat zdroje v pořadí určeném globálním uspořádáním.",incorrect:"V systému s globálním uspořádáním může vlákno rezervovat zdroje v libovolném pořadí.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"},{uuid:"d46e19b2-66c4-4722-858d-809489ac9a3e",correct:"Globální uspořádání zdrojů je praktické pro menší uzavřené systémy, ale pro rozsáhlý OS se příliš nehodí.",incorrect:"Globální uspořádání zdrojů je ideálním řešením pro zamezení uváznutí i v rozsáhlých operačních systémech.",sectionNumber:"7.4.10",sectionTitle:"Zamezení uspořádáním"}]},{uuid:"42cce62a-c42a-4f86-8698-6b4e060af424",sectionNumber:"8",sectionTitle:"Přerušení a periferie",statements:[{uuid:"3d20a6e2-2708-424c-adc7-7f78bfe7a54d",correct:"Přerušení je synchronizační zařízení, které slouží k synchronizaci periferie a softwaru.",incorrect:"Přerušení je synchronizační zařízení, které slouží k synchronizaci dvou softwarových vláken.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"759179ce-a4d6-48fa-964c-3666308dbd8e",correct:"Asymetrie přerušení spočívá v tom, že přerušení je vždy signalizováno periferií, nikoliv operačním systémem.",incorrect:"Asymetrie přerušení spočívá v tom, že přerušení může být signalizováno jak periferií, tak operačním systémem.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"bbd7c91b-36e1-49f9-9e86-df061de70f71",correct:"Operační systém je pasivním účastníkem přerušení, protože přerušení je vždy aktivováno periferií.",incorrect:"Operační systém je aktivním účastníkem přerušení a může aktivně vyvolávat přerušení pro periferie.",sectionNumber:"8.1.1",sectionTitle:"Synchronizace"},{uuid:"32ef6860-183e-4d8d-bc4a-4fcb25eeef41",correct:"Přerušení je hardwarový mechanismus, který operační systém využívá pro reakci na události.",incorrect:"Přerušení je softwarový mechanismus, který operační systém využívá pro plánování procesů.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"cdb8533b-e8f5-4652-bbce-ed19c41dc479",correct:"Operační systém je program, který musí být vykonáván procesorem, aby mohl řídit hardware.",incorrect:"Operační systém je program, který je vykonáván pamětí a nepotřebuje procesor k řízení hardware.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"c70a285f-d5b3-4fc6-aa27-3a1276c20675",correct:"Při preemptivním přerušení je aktuálně běžící program procesoru dočasně pozastaven a uložen do paměti.",incorrect:"Při preemptivním přerušení je aktuálně běžící program procesoru dokončen před zpracováním přerušení.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"f2f6bdb7-17db-49cb-8315-2a19cdfbe3e2",correct:"Obsluha přerušení je spuštěna procesorem až po uložení aktuálního stavu vlákna do operační paměti.",incorrect:"Obsluha přerušení je spuštěna procesorem ihned, bez ohledu na stav aktuálního vlákna.",sectionNumber:"8.1.2",sectionTitle:"Procesor"},{uuid:"fd221119-b188-4425-b97f-cdbca6efc319",correct:"Počet instancí přerušení je omezen hardwarem a typicky nepřesahuje 256 instancí.",incorrect:"Počet instancí přerušení je omezen softwarem a typicky nepřesahuje 256 instancí.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"90daac39-e284-4e11-8db0-33792d600935",correct:"Každá instance přerušení má přidruženou vlastní obsluhu, která je realizována jako podprogram.",incorrect:"Více instancí přerušení může sdílet jednu obsluhu, která je realizována jako podprogram.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"5fbc2539-dfd1-48d8-8df3-426ff3b46c5e",correct:"Adresa obslužného podprogramu pro každé přerušení je uložena v tabulce obsluhy přerušení.",incorrect:"Adresa obslužného podprogramu pro všechna přerušení je uložena na jednom místě v paměti.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"8ae4b340-5d5c-4aee-bf0c-17c97e13fdd0",correct:"Instance přerušení jsou rozlišeny a identifikovány pomocí čísel.",incorrect:"Instance přerušení jsou rozlišeny a identifikovány pomocí názvů.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"3977cfda-397e-4230-bed4-619df243a724",correct:"Tabulka obsluhy přerušení obsahuje pro každou instanci přerušení jednu položku.",incorrect:"Tabulka obsluhy přerušení obsahuje jednu položku pro všechny instance přerušení dohromady.",sectionNumber:"8.1.3",sectionTitle:"Instance"},{uuid:"75eae350-9bca-4f37-bf83-7f45ce25e147",correct:"Obslužný podprogram přerušení se podobá běžnému podprogramu s výjimkou speciálního prologu a epilogu.",incorrect:"Obslužný podprogram přerušení je zcela odlišný od běžného podprogramu a nevyužívá zásobník.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"8b02e038-94ed-4c96-ad5d-a9efaa3e02b7",correct:"Během obsluhy přerušení dochází k přepnutí na vyhrazený zásobník, protože původní zásobník nemusí být dostatečný.",incorrect:"Během obsluhy přerušení nikdy nedochází k přepnutí zásobníku a vždy se používá původní zásobník procesu.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"e99fbdd6-dbe6-4e3a-963a-5d5e75538bf7",correct:"Obsluha přerušení se provádí v privilegovaném režimu jádra, což jí umožňuje plný přístup k hardwarovým zdrojům.",incorrect:"Obsluha přerušení se provádí v uživatelském režimu a má omezený přístup k hardwarovým zdrojům systému.",sectionNumber:"8.1.4",sectionTitle:"Stav procesoru"},{uuid:"07020ccc-8254-44cf-9f28-21aa4b2a2b9d",correct:"Pro synchronizaci mezi CPU jádry lze v obsluze přerušení použít spinlocky.",incorrect:"Pro synchronizaci mezi CPU jádry nelze v obsluze přerušení použít spinlocky.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"e79e8c3e-0500-4c30-9d0b-170d3c25bb3b",correct:"Pro synchronizaci na stejném CPU jádře nelze v obsluze přerušení použít spinlocky.",incorrect:"Pro synchronizaci na stejném CPU jádře lze v obsluze přerušení použít spinlocky.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"b261759a-80a0-4c96-ae9b-cfa321215513",correct:"Obslužný podprogram přerušení nemůže být uspán plánovačem operačního systému.",incorrect:"Obslužný podprogram přerušení může být uspán plánovačem operačního systému.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"143d12bf-cba4-4615-ba84-707e1e9ad5e7",correct:"Zákaz přerušení představuje formu vzájemného vyloučení specifickou pro obslužné podprogramy.",incorrect:"Zákaz přerušení není forma vzájemného vyloučení specifická pro obslužné podprogramy.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"a9d6df07-6f81-4e60-b986-4ca8b22e0881",correct:"Obsluha druhé úrovně se používá v případech, kdy obsluha přerušení potřebuje čekat na událost.",incorrect:"Obsluha druhé úrovně se používá i v případech, kdy obsluha přerušení nepotřebuje čekat.",sectionNumber:"8.1.5",sectionTitle:"Souběžnost"},{uuid:"ebfdac16-3e60-4b32-a5ff-e2db74d69cd2",correct:"Zákaz přerušení je asymetrický mechanismus synchronizace, působící pouze směrem k obsluze přerušení.",incorrect:"Zákaz přerušení je symetrický mechanismus synchronizace, působící oběma směry, jak k obsluze, tak i k jádru.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"37d433c9-35f9-4097-8330-4707260b4ba4",correct:"Obsluha přerušení je na jednom CPU atomická z hlediska zbytku jádra díky zákazu přerušení.",incorrect:"Obsluha přerušení není na jednom CPU atomická z hlediska zbytku jádra, i když je zákaz přerušení aktivní.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"8732cfd8-35f5-4a57-bbeb-803b854bc6a4",correct:"Kritické sekce v operačním systému, zejména ty sdílené mezi jádrem a obsluhou přerušení, vyžadují ochranu.",incorrect:"Kritické sekce v operačním systému, i když jsou sdílené mezi jádrem a obsluhou přerušení, ochranu nevyžadují.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"dbe85709-765b-45f6-b6c6-fd6becc666e0",correct:"Zákaz přerušení by neměl být používán po příliš dlouhou dobu, aby se předešlo latenci systému.",incorrect:"Zákaz přerušení může být používán libovolně dlouho, bez negativního vlivu na latenci systému.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"3f835c75-384f-4c59-be9f-2ac8bed7a4e1",correct:"Jádro může využít zákaz přerušení pro synchronizaci i v jiných částech kódu, nejen v obsluze přerušení.",incorrect:"Jádro může využít zákaz přerušení pro synchronizaci výhradně jen v obsluze přerušení, nikoliv jinde.",sectionNumber:"8.1.6",sectionTitle:"Reentrance"},{uuid:"2c8588f1-8a93-4754-891d-74a323a5aa31",correct:"Vlákno je výpočet, který vznikne nepřerušenou činností procesoru řízeného programem.",incorrect:"Vlákno je proces, který vznikne přerušenou činností procesoru řízeného programem.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"0addde2d-e507-4e8d-bfcf-cb9ea5787248",correct:"Vlákno není vázáno na adresní prostor a jeden proces může obsahovat více vláken.",incorrect:"Vlákno je vázáno na adresní prostor a jeden proces může obsahovat jen jedno vlákno.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"2b088017-ab66-4369-97fd-bacdc066e121",correct:"Při aktivaci obsluhy přerušení se proces nepřepíná, protože se nemění mapování paměti.",incorrect:"Při aktivaci obsluhy přerušení se proces přepíná, protože se mění mapování paměti.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"879819cd-f20f-40bf-b073-46d2218b162e",correct:"Paměť obsluhy přerušení musí být dostupná ve všech virtuálních adresních prostorech na stejných adresách.",incorrect:"Paměť obsluhy přerušení musí být dostupná pouze v adresním prostoru aktuálního procesu.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"6cb82750-aa66-4b65-b670-506fb35952e5",correct:"Aktivace procesu je drahá operace, protože vyžaduje změnu mapování paměti.",incorrect:"Aktivace procesu je levná operace, protože nevyžaduje změnu mapování paměti.",sectionNumber:"8.2.1",sectionTitle:"Kontext"},{uuid:"9abb82d4-754f-466d-b450-1c668db42470",correct:"Obsluha přerušení běží v provizorních podmínkách a blokuje přerušené vlákno.",incorrect:"Obsluha přerušení běží v běžných podmínkách a neblokuje přerušené vlákno.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"6a9359f9-b88d-4268-a634-8627b4ad8569",correct:"Běžnými synchronizačními prostředky nelze synchronizovat obsluhu přerušení s přerušeným vláknem.",incorrect:"Běžnými synchronizačními prostředky lze synchronizovat obsluhu přerušení s přerušeným vláknem.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"173ce717-73f8-4109-ade6-2ba2721b93e1",correct:"Adresy obsluhy přerušení jsou přístupné výhradně v privilegovaném režimu procesoru.",incorrect:"Adresy obsluhy přerušení jsou přístupné i v uživatelském režimu procesoru.",sectionNumber:"8.2.2",sectionTitle:"Prodleva"},{uuid:"52c4e5a4-b978-4ebc-ad3d-5a3c5a12ff4b",correct:"Při vstupu do obsluhy přerušení se obvykle zakazují další přerušení, minimálně stejného typu.",incorrect:"Při vstupu do obsluhy přerušení se nikdy nezakazují další přerušení, aby systém zůstal plně responzivní.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"a39b33e1-4e04-4a4d-a818-a4c8eca7d428",correct:"Obsluha přerušení vykonává minimální nutnou akci pro uvedení systému do provozuschopného stavu.",incorrect:"Obsluha přerušení vykonává kompletní obsluhu události, včetně všech souvisejících úkonů.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"3f8ce31f-2525-4c0a-a719-ed73d2dd8f46",correct:"Zbytek akcí obsluhy přerušení se plánuje na pozdější vykonání jinou částí jádra.",incorrect:"Veškeré akce obsluhy přerušení jsou vykonávány okamžitě a kompletně v rámci obsluhy přerušení.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"f6729b60-2c85-480d-91b9-378ba99e422b",correct:"Existují nemaskovatelná přerušení, která nelze zakázat a jsou určena pro závažné události.",incorrect:"Všechna přerušení v systému mohou být zakázána během obsluhy přerušení, včetně kritických událostí.",sectionNumber:"8.2.3",sectionTitle:"Struktura obsluhy"},{uuid:"1057d610-d7d9-4fee-8f14-fc3ea9ecd154",correct:"Přerušení typu notifikace, jako například vsync, jsou obvykle nezávazná a jejich zpoždění neohrozí systém.",incorrect:"Přerušení typu notifikace, jako například vsync, jsou kritická a jejich zpoždění vážně ohrozí systém.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"41d46de5-5b13-4522-a434-e9a187fa7bfa",correct:"U periferií s malou šířkou pásma, jako UART, se data obvykle čtou z registrů periferie v reakci na přerušení.",incorrect:"U periferií s velkou šířkou pásma, jako UART, se data obvykle čtou z registrů periferie v reakci na přerušení.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"ee0c6574-94b9-4e39-8953-6058e87fb546",correct:"Vsync přerušení informuje o výměně obrazu na displeji a obvykle není časově kritické pro operační systém.",incorrect:"Vsync přerušení informuje o výměně obrazu na displeji a je vysoce časově kritické pro operační systém.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"e9fd56d6-1825-47d7-a8a9-d7724505b298",correct:"UART zařízení s vyrovnávací pamětí 128 bitů a plným vytížením generuje přerušení s frekvencí do 900Hz.",incorrect:"UART zařízení s vyrovnávací pamětí 128 bitů a plným vytížením generuje přerušení s frekvencí nad 10kHz.",sectionNumber:"8.3.1",sectionTitle:"Notifikace"},{uuid:"7c2f0c73-8fcd-466e-8e8b-c3ee5543229d",correct:"Zařízení s větší šířkou pásma obvykle používají DMA pro souběžný přenos dat.",incorrect:"Zařízení s větší šířkou pásma obvykle používají přerušení pro souběžný přenos dat.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"d3de0537-5bfe-4ccb-8293-7a31188e0426",correct:"Synchronizace směrem k periferii u DMA se provádí zápisem do registru zařízení.",incorrect:"Synchronizace směrem k periferii u DMA se provádí pomocí přerušení od periferie.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"a97c72ad-dd34-45fc-9e70-623c55b1a354",correct:"Periferie využívající DMA signalizuje dokončení přenosu do systému pomocí přerušení.",incorrect:"Periferie využívající DMA signalizuje dokončení přenosu do systému zápisem do registru.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"c39ce50c-820a-4454-9e0b-db443aaabf75",correct:"Přenosy DMA vyžadují synchronizaci s operačním systémem prostřednictvím ovladače zařízení.",incorrect:"Přenosy DMA jsou zcela autonomní a nevyžadují synchronizaci s operačním systémem.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"21650403-13f7-4538-81f1-bdcbb3e638fa",correct:"Vysoká přenosová rychlost u DMA zvyšuje riziko přetečení dostupné operační paměti.",incorrect:"Vysoká přenosová rychlost u DMA snižuje riziko přetečení dostupné operační paměti.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"a5feb468-80a8-488a-8122-183308241e1a",correct:"Síťová rozhraní Intel E1000 podporují příjmové fronty s maximální délkou 256 rámců.",incorrect:"Síťová rozhraní Intel E1000 podporují příjmové fronty s maximální délkou 512 rámců.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"90cf6795-02e1-4945-9802-afb6d6552a39",correct:"Při 1Gb/s a 1kHz přerušení DMA je nutné zpracovat přibližně 1Mb dat na každé přerušení.",incorrect:"Při 1Gb/s a 1kHz přerušení DMA je nutné zpracovat přibližně 1Kb dat na každé přerušení.",sectionNumber:"8.3.2",sectionTitle:"DMA"},{uuid:"8723a78b-1c9a-40d0-a2fc-9a9a14240022",correct:"Přerušení časovače je složité kvůli interakci s plánovačem vláken a řízení pravidelných činností OS.",incorrect:"Přerušení časovače je jednoduché, protože se nezabývá plánováním vláken a řídí pouze nepravidelné činnosti OS.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"d41fc288-9f6a-4ae8-af63-70ae144426a6",correct:"Manipulace s frontami vláken v obsluze přerušení časovače musí probíhat v první úrovni obsluhy.",incorrect:"Manipulace s frontami vláken v obsluze přerušení časovače se může odložit do obsluhy druhé úrovně.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"6b034ef9-9cbd-444d-85d5-7ac44c9fc15d",correct:"Synchronizace při manipulaci s frontami vláken musí být chráněna spinlockem a zákazem přerušení.",incorrect:"Synchronizace při manipulaci s frontami vláken se může spoléhat pouze na spinlocky bez nutnosti zakazovat přerušení.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"56996f03-641d-4bbe-9a99-9226a9f4d794",correct:"Přepnutí kontextu mezi vlákny různých procesů vyžaduje přepnutí stránkovacích tabulek.",incorrect:"Přepnutí kontextu mezi vlákny různých procesů se obejde bez přepnutí stránkovacích tabulek.",sectionNumber:"8.3.3",sectionTitle:"Časovač"},{uuid:"696cf28f-5470-40f3-9ebe-e3997680af8c",correct:"Každý procesor v systému obvykle disponuje vlastním časovačem pro řízení událostí.",incorrect:"V systému s více procesory se obvykle používá jeden sdílený časovač pro všechny procesory.",sectionNumber:"8.3.3",sectionTitle:"Časovač"}]},{uuid:"89a152f1-f487-4028-a450-1f5daa715b14",sectionNumber:"9",sectionTitle:"Interacting with the World",statements:[{uuid:"782627c8-2b0f-49cb-91a2-1175fe89a859",correct:"Shell skriptování se zaměřuje na interakci s operačním systémem.",incorrect:"Shell skriptování se primárně zaměřuje na vývoj grafického uživatelského rozhraní.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"1620b5cf-14b0-4f6b-9341-9e46a2f0a449",correct:"Shell skripty implementují základní řízení toku programu.",incorrect:"Shell skripty postrádají jakékoliv mechanismy pro řízení toku programu.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"85f9bd82-1194-49d7-bcca-61380588b563",correct:"Proměnné v shell skriptování slouží jako zástupné symboly v příkazech.",incorrect:"Proměnné v shell skriptování se používají výhradně pro matematické operace.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"7834efe5-5b75-45d7-932a-6754d0b3be21",correct:"Zpracování chyb v shell skriptech je tradičně považováno za nedostatečné.",incorrect:"Shell skripty se vyznačují sofistikovaným a detailním zpracováním chyb.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"6a4d535b-69c8-49b1-9a95-c0737e2b39f6",correct:"Shell skriptovací jazyky typicky nevyžadují explicitní deklaraci typů proměnných.",incorrect:"Shell skriptovací jazyky vyžadují striktní typovou kontrolu všech proměnných.",sectionNumber:"9.1.1",sectionTitle:"Shell"},{uuid:"61fb0a3a-79f0-4268-93ef-1350de7d1874",correct:"Většina shellů disponuje interaktivním režimem.",incorrect:"Jen málo shellů disponuje interaktivním režimem.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"ec8912b0-a448-41f1-a2a8-eec45a9a7685",correct:"V interaktivním režimu uživatel zadává jeden příkaz na klávesnici a řádek.",incorrect:"V interaktivním režimu uživatel zadává více příkazů najednou na klávesnici.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"6b3f0b8b-2de4-45b5-aac8-8ce41349fe68",correct:"Příkazy v interaktivním režimu se provedou okamžitě po potvrzení uživatelem.",incorrect:"Příkazy v interaktivním režimu se provedou až po delší prodlevě.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"2811d76d-e50a-4c34-ad52-0b0ab19d54a2",correct:"Rozhraní příkazového řádku jsou založena na principu interaktivního režimu.",incorrect:"Grafická uživatelská rozhraní jsou založena na principu interaktivního režimu.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"3fc320ab-7503-4acb-97be-f806b3def3b8",correct:"Mezi shell skripty a interaktivním příkazovým řádkem není syntaktický rozdíl.",incorrect:"Mezi shell skripty a interaktivním příkazovým řádkem existuje syntaktický rozdíl.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"3db4286e-1979-413a-ab30-060cb342120f",correct:"Interaktivní režim umožňuje psaní krátkých skriptů, takzvaných one-linerů, přímo v příkazovém řádku.",incorrect:"Interaktivní režim neumožňuje psaní krátkých skriptů, one-linerů, přímo v příkazovém řádku.",sectionNumber:"9.1.2",sectionTitle:"Interactive Shells"},{uuid:"22c9a85f-f650-4d13-b462-838cd930768d",correct:"Shell script je spustitelný soubor obsahující sekvenci příkazů.",incorrect:"Shell script je spustitelný soubor obsahující pouze jeden příkaz.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"5a915eb1-5397-4ad2-ab24-15d65d9f277e",correct:"Spuštění shell scriptu se podobá postupnému zadávání příkazů v terminálu.",incorrect:"Spuštění shell scriptu se zásadně liší od postupného zadávání příkazů v terminálu.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"b573ab70-28f5-443f-8f1f-9203e4639cc6",correct:"Shell scripty mohou využívat konstrukce strukturovaného programování pro řízení toku.",incorrect:"Shell scripty nemohou využívat konstrukce strukturovaného programování pro řízení toku.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"91ddf9ab-62bd-4857-8605-7fe1acebfe88",correct:"Proměnné v shell scriptu umožňují substituci částí příkazů mezi spuštěními.",incorrect:"Proměnné v shell scriptu se používají pouze pro interaktivní zadávání příkazů.",sectionNumber:"9.1.3",sectionTitle:"Shell Scripts"},{uuid:"77e904a5-9763-4099-a8fd-7c8f4d7c8d0c",correct:"Shell skripty jsou velmi snadné na psaní pro jednoduché automatizační úlohy.",incorrect:"Shell skripty jsou komplikované na psaní i pro základní automatizační úlohy.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"fdd30e26-f7df-41ec-b7bf-90f299423b19",correct:"Pro rozsáhlé programy se shell skripty obvykle nedoporučují kvůli jejich omezením.",incorrect:"Shell skripty jsou ideální pro vývoj rozsáhlých a komplexních programů.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"c7ea7025-6baf-48f5-bb5c-c2819e86fb78",correct:"Nedostatek typového systému v shell skriptech komplikuje údržbu větších projektů.",incorrect:"Typový systém v shell skriptech usnadňuje vývoj a údržbu rozsáhlých aplikací.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"3dcc6732-ff82-4205-b3ef-1b845c344c0a",correct:"Shell skripty jsou efektivní pro automatizaci opakovaných úkonů v operačním systému.",incorrect:"Shell skripty jsou nevhodné pro automatizaci opakovaných úkonů v operačním systému.",sectionNumber:"9.1.4",sectionTitle:"Shell Upsides"},{uuid:"0eeac9cd-b86e-427f-ba60-b654939d4ed8",correct:"Bourne shell, vytvořený v roce 1976, definoval duální povahu shellů jako interaktivních a programovatelných.",incorrect:"Bourne shell, vytvořený v roce 1986, definoval pouze interaktivní povahu shellů.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"564966b2-56e8-4b1b-a9d9-fe6c51648179",correct:"Bash, zkratka pro Bourne Again Shell, je široce známá implementace Bourne shellu.",incorrect:"Bash je jediná existující implementace shellu a nemá nic společného s Bourne shellem.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"1fb60dfc-950b-47f1-8f57-4b0bbe2531c8",correct:"Standard POSIX vyžaduje přítomnost shellu sh, obvykle umístěného v adresáři /bin.",incorrect:"Standard POSIX vyžaduje přítomnost shellu sh výhradně v adresáři /usr/bin.",sectionNumber:"9.1.5",sectionTitle:"Bourne Shell"},{uuid:"7486b51c-b317-48b2-a981-eecc63d61d21",correct:"C shell byl druhý známý UNIXový shell, vydaný v roce 1978.",incorrect:"C shell byl prvním známým UNIXovým shellem, vydaný v roce 1978.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"b89550d8-7272-4ada-a2af-54836f1cff53",correct:"C shell nabídl vylepšený interaktivní režim oproti shellu Bourne.",incorrect:"C shell nabídl horší interaktivní režim oproti shellu Bourne.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"bed26cdd-1830-475b-80b3-364ff6356c8a",correct:"Tcsh je variantou C shellu s dodatečnými funkcemi, udržovanou od 80. let.",incorrect:"Tcsh je starší verzí C shellu bez dodatečných funkcí a není udržována.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"a77da248-6669-4aba-a86c-818c6ed96b1b",correct:"Mezi interaktivní vylepšení C shellu patřila historie příkazů a aliasy.",incorrect:"Mezi interaktivní vylepšení C shellu patřilo pouze automatické dokončování souborů.",sectionNumber:"9.1.6",sectionTitle:"C Shell"},{uuid:"05d23b8b-6ef5-47dc-a9d1-b91094b6f310",correct:"Korn shell, známý také jako ksh, byl poprvé vydán v roce 1983.",incorrect:"Korn shell, známý také jako ksh, byl poprvé vydán v roce 1973.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"8e374e78-7f57-456f-8943-8f30c3e625f3",correct:"Korn shell kombinuje prvky Bourne shell a C shell, přičemž syntaxe skriptů zůstává věrná sh.",incorrect:"Korn shell kombinuje prvky Bourne shell a C shell, přičemž syntaxe skriptů je převzata z csh.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"9f364017-2585-4a70-805f-6e112d3f51ff",correct:"Korn shell slouží jako vzor pro standard POSIX.2 pro shell /bin/sh.",incorrect:"Bourne shell slouží jako vzor pro standard POSIX.2 pro shell /bin/sh.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"fd4fcf4f-919a-4a1b-a458-af4e2ce80eff",correct:"Původní implementace Korn shell byla založena na zdrojovém kódu Bourne shell.",incorrect:"Původní implementace Korn shell byla založena na zdrojovém kódu C shell.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"a4ddc110-25be-4658-855e-a37f1827dc92",correct:"Korn shell je považován za kompromis mezi Bourne shell a C shell.",incorrect:"Korn shell je považován za přímého nástupce C shell.",sectionNumber:"9.1.7",sectionTitle:"Korn Shell"},{uuid:"54b5bbed-f344-421c-b18f-812e1ef22101",correct:"Příkaz shellu je typicky jméno spustitelného souboru.",incorrect:"Příkaz shellu je vždy jméno interního příkazu shellu.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"f7c8049f-748a-4019-9857-068f3a0a7a94",correct:"Shell pro spuštění externího příkazu využívá systémová volání fork a exec.",incorrect:"Shell pro spuštění externího příkazu využívá pouze systémové volání exec.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"d0e2df99-7f6d-4bb0-a574-060ff5edbebd",correct:"Vytváření nových procesů pro každý příkaz může být relativně nákladné.",incorrect:"Vytváření nových procesů pro každý příkaz je velmi levná operace.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"b4675a5d-e3ab-45b4-a816-7faa29e8d02c",correct:"Shell nejprve kontroluje, zda zadaný příkaz není interní příkaz.",incorrect:"Shell nikdy nekontroluje, zda zadaný příkaz je interní příkaz.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"27c51927-9996-45af-8f47-35a0f7a2e939",correct:"Hlavní proces shellu čeká na ukončení spuštěného programu pomocí volání wait.",incorrect:"Hlavní proces shellu nikdy nečeká na ukončení spuštěného programu.",sectionNumber:"9.1.8",sectionTitle:"Commands"},{uuid:"44970c7e-ca8a-44de-b332-0b8bc2da452d",correct:"Příkaz `echo` je často implementován jako vestavěný příkaz shellu z důvodu optimalizace výkonu.",incorrect:"Příkaz `echo` je implementován jako vestavěný příkaz shellu primárně z funkčních důvodů, nikoli z optimalizace výkonu.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"aa1d9be8-e872-408f-bb9c-dc65f336edbc",correct:"Příkaz `cd` musí být vestavěný, protože změna pracovního adresáře ovlivňuje hlavní proces shellu.",incorrect:"Příkaz `cd` může být implementován jako externí příkaz spouštěný v novém procesu bez ovlivnění hlavního shellu.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"17cd473c-6f5b-46d8-8790-78bc337a03dd",correct:"Příkaz `exec` bez použití `fork` nahrazuje aktuální shell proces novým programem.",incorrect:"Příkaz `exec` bez použití `fork` vytváří nový proces shellu, zatímco původní shell proces pokračuje.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"6f8fd754-e81a-4bff-b51b-584cda868e8e",correct:"Vestavěné příkazy shellu se liší od externích příkazů tím, že nepoužívají proces `fork` a `exec`.",incorrect:"Vestavěné příkazy shellu se od externích příkazů liší tím, že vždy používají proces `fork` a `exec`, ale optimalizovaně.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"9fbc9bff-76f2-4441-af43-f7b34ef059b1",correct:"Příkaz `export` je vestavěný, protože modifikuje prostředí hlavního shell procesu.",incorrect:"Příkaz `export` může být externí, protože modifikace prostředí se snadno propagují do hlavního shell procesu.",sectionNumber:"9.1.9",sectionTitle:"Built-in Commands"},{uuid:"1c470eef-8bd9-4470-b057-b3516730216a",correct:"Názvy proměnných v shellu se skládají pouze z písmen a číslic.",incorrect:"Názvy proměnných v shellu mohou obsahovat i speciální znaky jako pomlčky a podtržítka.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"da10324e-99d3-4505-9849-183e0a6c2735",correct:"Pro získání hodnoty proměnné v shellu se používá znak dolaru '$' před jménem proměnné.",incorrect:"Pro získání hodnoty proměnné v shellu se používá znak dolaru '$' za jménem proměnné.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"da334124-84e9-47e9-bb58-318f0c497e74",correct:"Při nastavování hodnoty proměnné se znak dolaru '$' před jménem proměnné nepoužívá.",incorrect:"Při nastavování hodnoty proměnné je nutné uvést znak dolaru '$' před jménem proměnné.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"1ec5d137-dbe9-47d2-9965-d79fc16d135c",correct:"Bílé znaky okolo operátoru '=' při přiřazování hodnoty proměnné nejsou v shellu povoleny.",incorrect:"Bílé znaky okolo operátoru '=' při přiřazování hodnoty proměnné jsou v shellu ignorovány.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"80761a99-5e11-4c2f-9705-9ea2dbd65a68",correct:"Uvozovky nejsou nutné při definici proměnné, pokud její hodnota neobsahuje bílé znaky.",incorrect:"Uvozovky jsou vždy nutné při definici proměnné v shellu, bez ohledu na obsah hodnoty.",sectionNumber:"9.1.10",sectionTitle:"Parameters"},{uuid:"ff5c2094-7294-4923-baf0-b42cdf6cbc84",correct:"Substituce proměnných v shellu probíhá výhradně textově, bez ohledu na kontext použití proměnné.",incorrect:"Substituce proměnných v shellu probíhá kontextově, přičemž se rozlišuje, zda je proměnná použita v aritmetickém výrazu.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"0833251a-a461-463d-8761-13fa70e20678",correct:"Pro provádění aritmetických operací v shellu je nezbytné použít konstrukci `$((výraz))`.",incorrect:"Pro provádění aritmetických operací v shellu je doporučeno, ale není nezbytné, použít konstrukci `$((výraz))`.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"11f5f682-8c50-4a67-b46e-bef2072edd31",correct:"V aritmetických výrazech `$((...))` není nutné uvádět znak dolaru před názvy proměnných pro jejich substituci.",incorrect:"V aritmetických výrazech `$((...))` je nutné uvádět znak dolaru před názvy proměnných pro jejich substituci, podobně jako mimo aritmetické výrazy.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"af57004b-0fdb-412f-90ef-99e06ab9500a",correct:"Substituce proměnných bez dolaru uvnitř `$((...))` jsou interpretovány jako uzavřené v závorkách pro účely aritmetického vyhodnocení.",incorrect:"Substituce proměnných bez dolaru uvnitř `$((...))` nejsou interpretovány jako uzavřené v závorkách a jsou vyhodnocovány lineárně.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"19666cf7-ac03-4b19-be0f-0df7538f2b57",correct:"Rozdíl v použití dolaru před proměnnou v `$((...))` ovlivňuje způsob substituce a výslednou hodnotu aritmetického výrazu.",incorrect:"Rozdíl v použití dolaru před proměnnou v `$((...))` nemá žádný vliv na způsob substituce ani výslednou hodnotu aritmetického výrazu.",sectionNumber:"9.1.11",sectionTitle:"Parameter Expansion"},{uuid:"291582c6-a119-45f4-9c18-f1094bc80cc2",correct:"Příkazová substituce pomocí `$(command)` provede příkaz a nahradí výstup do původního příkazu.",incorrect:"Příkazová substituce pomocí `$(command)` pouze zachytí vstup příkazu a neprovede ho.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"a8364843-396f-4868-b1ba-4790feefcff5",correct:"V příkazové substituci `$(command)` je příkaz proveden jako shell příkaz, potenciálně zahrnující fork a exec.",incorrect:"V příkazové substituci `$(command)` je příkaz proveden přímo v aktuálním shell procesu bez fork nebo exec.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"3614c9d9-c1f0-401a-84f4-7cc495775710",correct:"Výstup příkazu v `$(command)` je zachycen jako standardní výstup a použit pro substituci.",incorrect:"Výstup příkazu v `$(command)` je zachycen jako standardní chybový výstup a použit pro substituci.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"611aea89-efa0-4b13-8477-3545ec1511e0",correct:"Příklad `cat $(ls)` nejprve provede `ls` pro výpis souborů, a poté použije `cat` pro zobrazení obsahu těchto souborů.",incorrect:"Příklad `cat $(ls)` nejprve provede `cat` pro zřetězení souborů, a poté použije `ls` pro výpis zřetězených souborů.",sectionNumber:"9.1.12",sectionTitle:"Command Substitution"},{uuid:"08018da6-d103-4d9c-837a-c578d631af16",correct:"Mezera slouží jako oddělovač argumentů v shellu.",incorrect:"Mezera není považována za oddělovač argumentů v shellu.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"28682975-e37d-4059-85da-7e3767d1a58f",correct:"Víceslovné argumenty v shellu musí být obaleny uvozovkami.",incorrect:"Víceslovné argumenty v shellu mohou být použity bez uvozovek.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"5d0f348b-009e-4151-ad66-c546ffa732c4",correct:"Dvojité uvozovky v shellu umožňují substituci proměnných.",incorrect:"Dvojité uvozovky v shellu neumožňují substituci proměnných.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"929d0ea2-2928-40bf-9a1d-561cc06cdeca",correct:"Jednoduché uvozovky v shellu zabraňují substituci proměnných.",incorrect:"Jednoduché uvozovky v shellu umožňují substituci proměnných.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"17ea422a-f231-4e3d-ab7c-8a57f89dd41d",correct:"V shellu lze pro uvozování řetězců použít jednoduché i dvojité uvozovky.",incorrect:"V shellu lze pro uvozování řetězců použít pouze dvojité uvozovky.",sectionNumber:"9.1.13",sectionTitle:"Quoting"},{uuid:"0ff13076-6d3e-4f4b-883b-f992537632c9",correct:"Substituce parametrů se provádí před rozdělením argumentů, což může vést k neočekávanému chování při práci s mezerami.",incorrect:"Rozdělení argumentů předchází substituci parametrů, takže mezery v proměnných nemají vliv na interpretaci argumentů.",sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"32a5c533-5df2-415c-8291-f51001a821cd",correct:'Použití uvozovek kolem proměnné v příkazu shellu, například "$foo", zajistí, že hodnota proměnné bude považována za jediný argument.',incorrect:"Uvozovky kolem proměnné v příkazu shellu, jako '$foo', nemají žádný vliv na to, zda je hodnota proměnné považována za jeden nebo více argumentů.",sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"e24c7beb-fddb-4ef0-a4f2-921d155394e9",correct:"Pokud proměnná obsahuje mezeru a není uzavřena v uvozovkách, interpretuje shell mezeru jako oddělovač argumentů.",incorrect:"Shell vždy interpretuje obsah proměnné jako jediný argument, i když proměnná obsahuje mezery a není v uvozovkách.",sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"5ae1b4ae-6553-4cb7-b78c-7b77c8d08f42",correct:"Příkaz `ls $foo`, kde `$foo` je 'hello world', se chová jinak než `ls \"$foo\"`, protože v prvním případě `ls` obdrží více argumentů.",incorrect:'Příkazy `ls $foo` a `ls "$foo"` se chovají identicky, i když proměnná `$foo` obsahuje mezery, protože shell je automaticky zpracuje.',sectionNumber:"9.1.14",sectionTitle:"Quoting and Substitution"},{uuid:"ecee10d0-f3ba-46d5-a680-398a94f35b5c",correct:"Speciální proměnná `$?` v shellu udává návratový kód posledního spuštěného příkazu.",incorrect:"Speciální proměnná `$?` v shellu udává PID aktuálního shellu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"7d68b6cf-fce6-4e2c-af97-8f64c8eb1d52",correct:"Proměnná `$$` v shellu obsahuje PID aktuálního shell procesu.",incorrect:"Proměnná `$$` v shellu obsahuje PID posledního procesu na pozadí.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"d349ea76-9224-4929-aa47-a9da6e10528b",correct:"Proměnné `$1` až `$9` v shell skriptu reprezentují poziční parametry.",incorrect:"Proměnné `$1` až `$9` v shell skriptu reprezentují speciální proměnné shellu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"fcd89922-0525-495b-af4e-55083dfaaec5",correct:"Speciální proměnná `$#` udává počet pozičních parametrů předaných shell skriptu.",incorrect:"Speciální proměnná `$#` udává počet speciálních proměnných shellu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"ff36a6c6-f995-4b28-a690-ade8a1ea0dbc",correct:"Proměnná `$0` obsahuje jméno shellu, které odpovídá `argv[0]` v jazyce C.",incorrect:"Proměnná `$0` obsahuje návratový kód posledního příkazu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"dc460987-cd40-4307-9d72-5f77f0fbc1a7",correct:"Proměnná `$@` expanduje do všech pozičních parametrů a chová se speciálně v dvojitých uvozovkách.",incorrect:"Proměnná `$@` expanduje pouze do prvního pozičního parametru, bez ohledu na uvozovky.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"e46b3985-4cc2-4b90-9699-c39c41fa79b1",correct:"Proměnná `$*` expanduje do všech pozičních parametrů bez speciálního chování v dvojitých uvozovkách.",incorrect:"Proměnná `$*` expanduje do všech pozičních parametrů se stejným chováním v dvojitých uvozovkách jako `$@`.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"5fe447f7-a641-45bb-82c8-bd4b3706f37c",correct:"Speciální proměnná `$!` obsahuje PID posledního procesu spuštěného na pozadí.",incorrect:"Speciální proměnná `$!` obsahuje PID aktuálního shell procesu.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"c97e00e0-dc45-4e5a-b5e4-fe7346975914",correct:"Proměnná `$-` v shellu reprezentuje aktuální nastavení shell options.",incorrect:"Proměnná `$-` v shellu reprezentuje počet pozičních parametrů.",sectionNumber:"9.1.15",sectionTitle:"Special Variables"},{uuid:"1eb86b65-005b-47a5-8c3f-230a5691a628",correct:"Proměnné prostředí se předávají mezi procesy pomocí fork a exec.",incorrect:"Proměnné prostředí se předávají pouze novým procesům vytvořeným pomocí exec, nikoli fork.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"7c7861ee-c5fc-4330-9b2b-711fb24ea253",correct:"Změny proměnných prostředí se šíří pouze k potomkům procesu.",incorrect:"Změny proměnných prostředí se šíří i k rodičovskému procesu.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"0641f5d0-0a83-4326-af2c-ec4fb297397d",correct:"Potomkovský proces nemůže ovlivnit proměnné prostředí svého rodiče.",incorrect:"Potomkovský proces může přímo modifikovat proměnné prostředí svého rodiče.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"3df168e9-2a51-4a71-9d07-3af23c7be103",correct:"Shell interpretuje proměnné prostředí podobně jako své vlastní interní proměnné.",incorrect:"Shell interpretuje proměnné prostředí zcela odlišně od svých interních proměnných.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"8c2d2342-9d5f-4705-8b2b-310e35c25ef9",correct:"Proměnné prostředí POSIX jsou nezávislé na konkrétním shellu.",incorrect:"Proměnné prostředí POSIX jsou specifické pro shell, ve kterém byly nastaveny.",sectionNumber:"9.1.16",sectionTitle:"Environment"},{uuid:"4425f598-950c-486a-a396-3faaff594f14",correct:"Konvence pro pojmenování proměnných prostředí je používat výhradně velká písmena.",incorrect:"Konvence pro pojmenování proměnných prostředí je používat výhradně malá písmena.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"a938044d-2be8-4b94-963a-bfae4d51750b",correct:"Proměnná prostředí `$PATH` udává systému, kde má hledat spustitelné programy.",incorrect:"Proměnná prostředí `$PATH` udává systému, kde má hledat konfigurační soubory uživatelů.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"cc5e8a3f-b8fd-416d-b13c-16ee6a183f5a",correct:"Proměnná prostředí `$HOME` určuje domovský adresář aktuálního uživatele.",incorrect:"Proměnná prostředí `$HOME` určuje aktuální pracovní adresář.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"87354b4a-b712-40b9-a1b9-ca3f3fe50512",correct:"Proměnná prostředí `$PWD` je nastavena shellem.",incorrect:"Proměnná prostředí `$PWD` je nastavena systémovým administrátorem.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"8af0de9f-ef43-4503-b5bf-ca55095ea4a5",correct:"Proměnnou prostředí `$PATH` mohou uživatelé měnit, i když je obvykle konfigurována administrátorem.",incorrect:"Proměnnou prostředí `$PATH` uživatelé nemohou měnit, pouze systémový administrátor má tuto možnost.",sectionNumber:"9.1.17",sectionTitle:"Important Environment Variables"},{uuid:"b8d42534-e090-4a6a-8a66-9250203bdd3f",correct:"Globbing v shellu slouží k rychlému vypisování více souborů pomocí vzorů.",incorrect:"Globbing v shellu slouží k úpravě obsahu souborů pomocí speciálních vzorů.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"e1f7d29e-104e-4a33-a101-2959da8e7a4f",correct:"V globbingu znak '*' odpovídá libovolnému počtu znaků v názvu souboru.",incorrect:"V globbingu znak '*' odpovídá právě jednomu znaku v názvu souboru.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"3d0e643c-429f-4432-9ad2-1c3123bf656b",correct:"Expanzi glob vzorů provádí samotný shell, nikoliv volaný program.",incorrect:"Expanzi glob vzorů provádí volaný program, nikoliv samotný shell.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"97abc6ad-d089-40ba-b60e-a69b0faeaca1",correct:"Jednoduché i dvojité uvozovky zabraňují expanzi glob vzorů v shellu.",incorrect:"Jednoduché i dvojité uvozovky umožňují expanzi glob vzorů v shellu.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"bc82f528-0142-4fa9-8c23-bcf8fafee768",correct:"Globbing je možné použít i v celých cestách, například 'ls src/*/*.c'.",incorrect:"Globbing je možné použít pouze v aktuálním adresáři, nikoliv v celých cestách.",sectionNumber:"9.1.18",sectionTitle:"Globbing"},{uuid:"18b59486-fcc4-4f38-a591-0bdde3210927",correct:"Příkaz `cond` v konstrukci `if` je interpretován jako pravdivý, pokud skončí s návratovým kódem 0.",incorrect:"Příkaz `cond` v konstrukci `if` je interpretován jako pravdivý, pokud skončí s návratovým kódem 1.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"3579d729-9796-4bb7-a818-d789833cdbd3",correct:"V shellových skriptech, klíčové slovo `if` umožňuje provádět podmíněné spuštění příkazů.",incorrect:"V shellových skriptech, klíčové slovo `while` umožňuje provádět podmíněné spuštění příkazů.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"2fdca52a-8dbd-456e-b793-b35504ea6739",correct:"Konstrukce `if` v shellu používá návratový kód příkazu `cond` pro vyhodnocení podmínky.",incorrect:"Konstrukce `if` v shellu používá výstup příkazu `cond` pro vyhodnocení podmínky.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"6f85b84d-756e-4ae6-a8b3-58552db478eb",correct:"Klauzule `elif` a `else` jsou volitelné součásti konstrukce `if` v shellových skriptech.",incorrect:"Klauzule `elif` a `else` jsou povinné součásti konstrukce `if` v shellových skriptech.",sectionNumber:"9.1.19",sectionTitle:"Conditionals"},{uuid:"b16699a2-0522-4ed4-8f2a-d1213f458ab1",correct:"Příkaz `test` byl původně externí program, ale nyní je často zabudován do shellů.",incorrect:"Příkaz `test` je vždy externí program a nikdy není zabudován do shellů.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"4a771ff6-294b-419c-bac6-54f5bb706a89",correct:"Příkaz `test` slouží k obcházení nedostatku výrazů v shell skriptech a vrací logickou hodnotu.",incorrect:"Příkaz `test` slouží k definování nových výrazů v shell skriptech a vrací číselnou hodnotu.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"82b6afe1-8a1b-4b23-ba48-22dcd9bbbe79",correct:"Standard POSIX specifikuje příkaz `test` jako speciální program pro vyhodnocování podmínek.",incorrect:"Standard POSIX definuje, že příkaz `test` není speciální program, ale běžná součást shellu.",sectionNumber:"9.1.20",sectionTitle:"‹test› (evaluating boolean expressions)"},{uuid:"c0efd6de-84fe-4dcc-932a-eb4e649de6f9",correct:"Příkaz `test` v shellu umožňuje kombinovat predikáty s substitucí proměnných.",incorrect:"Příkaz `test` v shellu nepodporuje kombinování predikátů s substitucí proměnných.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"5179b998-f329-4bae-834f-e77f1b779db3",correct:"Příkaz `test` poskytuje tři třídy predikátů: pro soubory, čísla a řetězce.",incorrect:"Příkaz `test` poskytuje pouze dvě třídy predikátů: pro čísla a řetězce.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"cc200b8c-c408-43b5-9c12-32dcfeba18af",correct:"Predikáty pro soubory v příkazu `test` usnadňují psaní skriptů závislých na existenci souborů.",incorrect:"Predikáty pro soubory v příkazu `test` jsou primárně určeny pro porovnávání číselných hodnot v souborech.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"74960d7b-3fdb-4414-84f4-7c5b3449b3df",correct:"Syntaxe pro porovnávání čísel a řetězců v příkazu `test` se liší od běžných programovacích jazyků.",incorrect:"Syntaxe pro porovnávání čísel a řetězců v příkazu `test` je identická s běžnými programovacími jazyky.",sectionNumber:"9.1.21",sectionTitle:"‹test› Examples"},{uuid:"27ae8435-6d42-4f1f-9a91-afb2f9b7d1c2",correct:"Příkaz `while` v shell skriptech opakuje cyklus dokud daný příkaz neuspěje.",incorrect:"Příkaz `while` v shell skriptech opakuje cyklus dokud daný příkaz uspěje.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"7f335984-c6a1-49bc-ae4f-264481d2dd77",correct:"Cyklus `for` v shellu umožňuje použití globů, například pro iteraci přes všechny `.c` soubory.",incorrect:"Cyklus `for` v shellu neumožňuje použití globů pro iteraci přes soubory.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"f7a8cf75-c35b-48b3-a076-d9372054d171",correct:"Příkazová substituce může být použita v cyklu `for` k dynamickému generování seznamu prvků.",incorrect:"Příkazová substituce nemůže být použita v cyklu `for`.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"a7954f14-4380-4a8a-8f03-647668695800",correct:"Utilita `seq` je v shell skriptech nestandardní nástroj pro generování číselných sekvencí.",incorrect:"Utilita `seq` je v shell skriptech standardní nástroj pro generování číselných sekvencí.",sectionNumber:"9.1.22",sectionTitle:"Loops"},{uuid:"f39fc374-af4e-4f22-97d2-f388bee99306",correct:"Příkaz `case` vybírá příkaz na základě porovnávání vzorů.",incorrect:"Příkaz `case` vybírá příkaz na základě glob expanze jmen souborů.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"1eae6965-50d9-4394-a3cb-bda80e41d858",correct:"V příkazu `case` se používají nevyvážené závorky.",incorrect:"V příkazu `case` se používají vyvážené závorky.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"e7200ec6-a66d-4b14-9ef0-6f33443cb6d1",correct:"`case analýza` umožňuje použití vzorů podobných glob na libovolné řetězce.",incorrect:"`case analýza` umožňuje použití pouze regulárních výrazů na libovolné řetězce.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"5ba02fac-2d4e-43a5-a781-2012d9fb68d0",correct:"Vzory v klauzuli `in` příkazu `case` nejsou glob expanzí jmen souborů.",incorrect:"Vzory v klauzuli `in` příkazu `case` jsou glob expanzí jmen souborů.",sectionNumber:"9.1.23",sectionTitle:"Case Analysis"},{uuid:"2e070c2a-404d-4fb9-a20f-58df6440fbb1",correct:"Operátor středník (;) umožňuje sekvenční spuštění příkazů.",incorrect:"Operátor středník (;) umožňuje paralelní spuštění příkazů.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"4399c821-6733-4b06-9f32-ccd669e851b6",correct:"Operátor '&&' spustí druhý příkaz pouze pokud první příkaz uspěje.",incorrect:"Operátor '&&' spustí druhý příkaz i když první příkaz selže.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"513aecfb-1504-44fb-b439-2b15259fcfd4",correct:"Operátor '||' spustí druhý příkaz pouze pokud první příkaz selže.",incorrect:"Operátor '||' spustí druhý příkaz i když první příkaz uspěje.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"05648df6-90d0-4966-a665-9e79138a8c13",correct:"Operátory '&&' a '||' fungují jako booleovské kombinátory pro řízení toku příkazů.",incorrect:"Operátory '&&' a '||' primárně slouží k optimalizaci paměti, nikoliv k řízení toku.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"99580e7f-1682-4b4a-8c19-789988b96979",correct:"Operátor '&&' může snížit interakční latenci tím, že zastaví provádění příkazů při prvním neúspěchu.",incorrect:"Operátor '&&' zvyšuje interakční latenci tím, že vždy čeká na dokončení všech příkazů.",sectionNumber:"9.1.24",sectionTitle:"Command Chaining"},{uuid:"e9f5a6ff-19a8-4aad-b9db-7ab0526edcd6",correct:"Příkazové interprety umožňují spouštění rour příkazů.",incorrect:"Příkazové interprety nepodporují spouštění rour příkazů.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"f30fc8a8-b44e-41a4-a8d7-1545add9aac7",correct:"Všechny příkazy v rouře jsou spouštěny paralelně.",incorrect:"Všechny příkazy v rouře jsou spouštěny sekvenčně.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"d0796529-546a-423e-b017-26a670237f11",correct:"Výstup prvního příkazu se stává vstupem druhého příkazu v rouře.",incorrect:"Výstup prvního příkazu je ignorován a nepředává se dál v rouře.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"799e34ea-5981-4d5f-a43c-0559e9409f56",correct:"Roury nabízejí flexibilní způsob, jak kombinovat více příkazů.",incorrect:"Roury omezují flexibilitu kombinování příkazů v systémech.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"18628be0-4b9b-4770-a6b9-b86125a29cc7",correct:"Standard POSIX specifikuje utility navržené pro práci v rourách.",incorrect:"Standard POSIX se nezabývá utilitami pro efektivní práci v rourách.",sectionNumber:"9.1.25",sectionTitle:"Pipes"},{uuid:"7eb3921d-56a2-43ce-953c-0a62b6eb92bf",correct:"Shell funkce jsou odlehčenou alternativou k shell skriptům.",incorrect:"Shell funkce jsou těžkopádnou alternativou k shell skriptům.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"f36227b8-04f5-4ed0-b102-349026ccfafd",correct:"Shell funkce nevyžadují export proměnných, aby byly přístupné uvnitř funkce.",incorrect:"Shell funkce vyžadují export proměnných, aby byly přístupné uvnitř funkce.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"42cbd7da-db51-4464-88a8-068e491bbcc3",correct:"Shell funkce nemohou být volány programy, které nejsou shell skripty.",incorrect:"Shell funkce mohou být volány programy, které nejsou shell skripty.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"2f78b971-d2a1-44b2-b56e-a8277e8f64bc",correct:"Změny proměnných uvnitř shell funkce mohou ovlivnit rodičovský shell.",incorrect:"Změny proměnných uvnitř shell funkce neovlivní rodičovský shell.",sectionNumber:"9.1.26",sectionTitle:"Functions"},{uuid:"85b747b2-134d-4f51-888d-d4076fc8f006",correct:"Hostname je pro člověka čitelné jméno počítače v síti.",incorrect:"Hostname je strojově čitelné binární číslo reprezentující počítač v síti.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"568a66f2-91a6-46d0-9f72-64cb484dfd78",correct:"Plně kvalifikované jméno (FQDN) udává jméno počítače a sítě.",incorrect:"Plně kvalifikované jméno (FQDN) udává pouze jméno počítače bez sítě.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"8a22706d-9123-4478-8bf0-2eeebcb6fc82",correct:"U lokálních hostnamech může být lokální přípona sítě vynechána.",incorrect:"U lokálních hostnamech musí být lokální přípona sítě vždy uvedena.",sectionNumber:"9.2.1",sectionTitle:"Host and Domain Names"},{uuid:"f521dee4-3c07-4d15-a14b-4b4bcb58fe34",correct:"IPv4 adresa se skládá ze čtyř oktetů, což je pro počítače srozumitelný numerický formát.",incorrect:"IPv4 adresa se skládá ze šesti oktetů, což je formát používaný pro Ethernet protokoly.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"629c815f-cf26-460b-834c-7819e8a3249d",correct:"IPv6 adresy využívají šestnáct oktetů pro adresování v moderních počítačových sítích.",incorrect:"IPv6 adresy využívají pouze čtyři oktety, podobně jako starší IPv4 adresy.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"6ce9b629-8e60-40d7-a550-7c881669663c",correct:"MAC adresy, typické pro Ethernet, mají délku šesti oktetů a slouží k identifikaci síťových rozhraní.",incorrect:"MAC adresy, typické pro IPv6, mají délku šestnáct oktetů a slouží k identifikaci síťových rozhraní.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"7a99872b-88d5-48cd-ab02-46377b2dda9f",correct:"Pro komunikaci v síti počítače používají numerické adresy, které jsou strojově čitelné, na rozdíl od lidsky čitelných jmen.",incorrect:"Pro komunikaci v síti počítače používají lidsky čitelné názvy, které jsou srozumitelnější než numerické adresy.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"0725766d-2acc-48dd-afff-a7a4cadba7fe",correct:"Oktety v IPv4 adrese jsou řazeny od nejvýznamnějšího bytu (MSB) jako první, což je označováno jako big endian.",incorrect:"Oktety v IPv4 adrese jsou řazeny od nejméně významného bytu (LSB) jako první, což je označováno jako little endian.",sectionNumber:"9.2.2",sectionTitle:"Network Addresses"},{uuid:"754be9ec-2855-4ef3-9dc2-a53c9ca54e5d",correct:"Lokální sítě (LAN) obvykle pokrývají kanceláře, domácnosti nebo budovy a často tvoří jednu broadcastovou doménu.",incorrect:"Lokální sítě (LAN) obvykle pokrývají rozsáhlá území a vždy tvoří více broadcastových domén.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"7017085d-bfe0-4a24-a330-fb91861ed756",correct:"Mezi technologie používané v lokálních sítích (LAN) patří Ethernet a WiFi.",incorrect:"Mezi technologie používané výhradně v rozsáhlých sítích (WAN) patří Ethernet a WiFi.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"c5931aba-28ef-46fb-b660-79e43f106842",correct:"Ethernet, používaný v LAN sítích, dosahuje rychlosti 1 Gb/s nebo i 10 Gb/s.",incorrect:"Ethernet, používaný v LAN sítích, dosahuje rychlosti maximálně 100 Mb/s.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"07d61cc3-ca49-49de-aefa-9eec4d164d72",correct:"Rozsáhlé sítě (WAN) se často používají pro internet a sítě poskytovatelů internetových služeb (ISP).",incorrect:"Rozsáhlé sítě (WAN) se používají výhradně pro lokální sítě v rámci jedné budovy.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"9fffd132-0ef3-49f7-bfb9-9bdf2ecea999",correct:"WiFi, standard IEEE 802.11, je bezdrátová technologie používaná v lokálních sítích (LAN) s rychlostí do 1 Gb/s.",incorrect:"WiFi, standard IEEE 802.11, je výhradně kabelová technologie používaná v rozsáhlých sítích (WAN) s rychlostí nad 10 Gb/s.",sectionNumber:"9.2.3",sectionTitle:"Network Types"},{uuid:"fb6e52d6-5446-4d5b-a1df-5062a38debc5",correct:"TCP/IP model síťové komunikace má čtyři vrstvy.",incorrect:"TCP/IP model síťové komunikace má sedm vrstev.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"303dd3fb-73a2-4f7f-b846-1403e3417a71",correct:"Linková vrstva TCP/IP modelu odpovídá fyzické a datové vrstvě OSI modelu.",incorrect:"Linková vrstva TCP/IP modelu odpovídá pouze fyzické vrstvě OSI modelu.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"552a7d29-cd0e-4055-9ed1-6fcd8575c5dc",correct:"Internetová vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 3.",incorrect:"Internetová vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 4.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"c139d1c0-295a-4ce5-b84d-038d5cd910cd",correct:"Transportní vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 4.",incorrect:"Transportní vrstva TCP/IP modelu je v OSI modelu označována jako vrstva 3.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"bba60e2e-fbc4-4ac6-8ee8-9414a9d43473",correct:"Aplikační vrstva TCP/IP modelu zahrnuje v OSI modelu vrstvy 5 až 7.",incorrect:"Aplikační vrstva TCP/IP modelu zahrnuje v OSI modelu pouze vrstvu 7.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"0264c03e-05a7-4bf7-b24f-c57651e3dadd",correct:"Protokol IP je v OSI modelu definován jako protokol 3. vrstvy.",incorrect:"Protokol IP je v OSI modelu definován jako protokol 4. vrstvy.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"c535a064-5234-4645-9516-ee573eb26bfe",correct:"Protokol TCP je v OSI modelu definován jako protokol 4. vrstvy.",incorrect:"Protokol TCP je v OSI modelu definován jako protokol 3. vrstvy.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"b17649f2-cee8-4323-93b5-233dc4bfa40c",correct:"Číslování vrstev, na které se odkazuje text, odpovídá číslování OSI modelu.",incorrect:"Číslování vrstev, na které se odkazuje text, odpovídá číslování TCP/IP modelu.",sectionNumber:"9.2.4",sectionTitle:"Networking Layers"},{uuid:"efbbb8fc-9af0-4086-9528-883129b59670",correct:"Síťové služby jsou standardní součástí operačních systémů posledních dvacet let.",incorrect:"Síťové služby se staly standardní součástí operačních systémů teprve nedávno.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"1081ae19-701e-46bf-a49f-5604cd70a6ec",correct:"V monolitických kernelech je významná část síťového stacku součástí jádra.",incorrect:"V monolitických kernelech je pouze malá část síťového stacku součástí jádra.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"3b2a5324-03d8-4428-9ea0-101673980bde",correct:"Rozhraní sockets API zpřístupňuje síťový stack uživatelským programům v monolitických kernelech.",incorrect:"Rozhraní sockets API se nepoužívá k zpřístupnění síťového stacku uživatelským programům.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"6f8bef01-d174-4abb-b1fb-39053ab326c9",correct:"Funkce aplikační vrstvy jako DNS a TLS jsou obvykle dostupné v systémových knihovnách.",incorrect:"Funkce aplikační vrstvy jako DNS a TLS jsou obvykle součástí jádra operačního systému.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"14f48799-3298-4ab3-bfdb-e52c41078698",correct:"TLS je technologie aplikační vrstvy, i když se jmenuje Transport Layer Security.",incorrect:"TLS je technologie transportní vrstvy, jak naznačuje její jméno Transport Layer Security.",sectionNumber:"9.2.5",sectionTitle:"Networking and Operating Systems"},{uuid:"0948ad06-ac88-4eb5-986f-b244b9d075a9",correct:"Routování a filtrování paketů může být implementováno v jádře operačního systému.",incorrect:"Routování a filtrování paketů je vždy implementováno mimo jádro operačního systému.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"b0eb89a4-5831-44a3-a185-27bc530d80c5",correct:"Síťové souborové systémy mohou být implementovány v jádře operačního systému.",incorrect:"Síťové souborové systémy nemohou být implementovány v jádře operačního systému.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"96894be6-d118-41d8-89cd-ecef3bee6b69",correct:"Socket API zpřístupňuje klientskou i serverovou stranu TCP/IP.",incorrect:"Socket API zpřístupňuje pouze klientskou stranu TCP/IP.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"c8e790fb-44ef-4074-a38c-1dbcba93e853",correct:"Softwarové mosty a přepínače jsou zřídka praktické, ale operační systémy je implementují kvůli virtualizaci.",incorrect:"Softwarové mosty a přepínače jsou běžné a praktické řešení v operačních systémech.",sectionNumber:"9.2.6",sectionTitle:"Kernel-Side Networking"},{uuid:"20151c94-6f36-4658-b84b-d9b1c57e70c7",correct:"Socket API je součástí systémových knihoven, ale v monolitických jádrech často mapuje 1:1 na systémová volání.",incorrect:"Socket API je výhradně doménou operačního systému a nikdy není součástí systémových knihoven.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"5c53b5ed-70b7-4a78-81aa-340000a317f5",correct:"V mikrokernelech se síťový stack dělí jinak a systémové knihovny pravděpodobně přebírají větší podíl práce s Socket API.",incorrect:"V mikrokernelech je Socket API vždy přímo implementováno v jádře operačního systému.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"5a3c735f-d986-46a0-91a1-bc6cd1f7fd35",correct:"Překlad hostnames na IP adresy, tedy DNS klient, obvykle spadá do kompetence systémových knihoven.",incorrect:"Překlad hostnames na IP adresy je typicky prováděn výhradně na straně serveru, nikoliv klientských systémových knihoven.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"6626904e-48f3-41bd-909e-871cec3c1a28",correct:"Většina moderních operačních systémů poskytuje SSL/TLS stack, který zahrnuje i správu a validaci certifikátů.",incorrect:"Správa certifikátů v rámci SSL/TLS stacku je obvykle ponechána na externích aplikacích, nikoliv na operačním systému.",sectionNumber:"9.2.7",sectionTitle:"System Libraries"},{uuid:"2ab9f359-054e-4f29-b638-008ab0c4d926",correct:"Konfigurační nástroje jako dhclient slouží k automatické konfiguraci síťových rozhraní.",incorrect:"Konfigurační nástroje jako dhclient slouží výhradně k manuální konfiguraci tiskáren.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"ceb42778-6623-44d2-80ab-842bd9244516",correct:"Správa směrování je klíčová pro systémy fungující jako softwarové směrovače.",incorrect:"Správa směrování je irelevantní pro systémy fungující jako softwarové směrovače.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"985ff976-296b-491f-9143-480fc3118194",correct:"Diagnostické nástroje jako ping a traceroute pomáhají při ověřování síťové konektivity.",incorrect:"Diagnostické nástroje jako ping a traceroute slouží k monitorování využití procesoru.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"d80db21a-2fa8-4776-a7af-1cf67898b7c4",correct:"Tcpdump umožňuje inspekci síťových paketů na úrovni rozhraní.",incorrect:"Tcpdump primárně slouží k nastavení firewallu operačního systému.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"503e89cd-b179-4f74-bdf6-d2697ad795d9",correct:"Síťové služby jako ntpd zajišťují synchronizaci systémového času.",incorrect:"Síťové služby jako ntpd slouží k správě uživatelských účtů v systému.",sectionNumber:"9.2.8",sectionTitle:"System Utilities & Services"},{uuid:"d1ce154c-cb6b-43da-9339-3beaf5240692",correct:"Síťové protokoly se zabývají třemi hlavními aspekty komunikace: pakety, adresováním a doručením.",incorrect:"Síťové protokoly se zabývají pouze dvěma hlavními aspekty komunikace: adresováním a doručením.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"383ac0f1-84f4-4a44-9de3-ce746a2b947d",correct:"Paket je základní komunikační jednotka, která nese informace v síťových protokolech.",incorrect:"Paket je pouze pomocná datová struktura, která nenese informace v síťových protokolech.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"d9b1c339-58ae-4872-9d77-e8882045bd0f",correct:"Adresování v síťových protokolech slouží k identifikaci cílových počítačů nebo programů v síti.",incorrect:"Adresování v síťových protokolech slouží pouze k identifikaci fyzických síťových zařízení.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"96c3e22b-8635-4a4d-b608-089118218da0",correct:"Doručení paketů zahrnuje směrování a případný překlad adres mezi různými vrstvami sítě.",incorrect:"Doručení paketů se týká výhradně fyzického přenosu dat a nezahrnuje směrování.",sectionNumber:"9.2.9",sectionTitle:"Networking Aspects"},{uuid:"4818ddc8-95ab-4d78-add4-0f1bf7742986",correct:"Protokoly v síťovém stacku běží nad sebou, přičemž vyšší vrstvy využívají abstrakcí poskytovaných nižšími vrstvami.",incorrect:"Protokoly v síťovém stacku běží paralelně vedle sebe a nevyužívají abstrakcí poskytovaných jinými vrstvami.",sectionNumber:"9.2.10",sectionTitle:"Protocol Nesting"},{uuid:"c748069f-d2c2-42f7-a215-ffccf5910046",correct:"Síťový stack je struktura, kde protokoly vyšších úrovní, jako HTTP, využívají abstrakce nižších úrovní, jako TCP a IP.",incorrect:"Síťový stack je struktura, kde protokoly nižších úrovní, jako IP, poskytují abstrakce protokolům vyšších úrovní, jako HTTP a TCP.",sectionNumber:"9.2.10",sectionTitle:"Protocol Nesting"},{uuid:"37b09e7e-f3b0-48e1-8cb1-020dcecb3373",correct:"HTTP protokol využívá abstrakce poskytované protokolem TCP, což ilustruje vrstvenou povahu síťového stacku.",incorrect:"HTTP protokol poskytuje abstrakce pro protokol TCP, což ilustruje hierarchickou povahu síťového stacku.",sectionNumber:"9.2.10",sectionTitle:"Protocol Nesting"},{uuid:"eef93758-bb8a-45ae-8311-1c7fd9191b55",correct:"Ethernetový rámec obaluje IP paket, podobně jako matrjoška obaluje menší loutku.",incorrect:"IP paket obaluje Ethernetový rámec, podobně jako matrjoška obaluje menší loutku.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"0d9084cf-ea70-46b2-9274-2f1638cecf0f",correct:"Pro nižší vrstvy síťového modelu jsou pakety vyšších vrstev považovány za data.",incorrect:"Pro vyšší vrstvy síťového modelu jsou pakety nižších vrstev považovány za data.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"1c04f2ea-89e5-4fd3-b76b-91f7fb391fb5",correct:"TCP stream může přenášet HTTP request jako svůj obsah.",incorrect:"HTTP request může přenášet TCP stream jako svůj obsah.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"decc194b-64b3-48a3-ba26-4014fbd23229",correct:"Přidávání záhlaví k paketům je úkolem nižších vrstev při zapouzdření dat.",incorrect:"Přidávání záhlaví k paketům je úkolem vyšších vrstev při zapouzdření dat.",sectionNumber:"9.2.11",sectionTitle:"Packet Nesting"},{uuid:"d81f72b9-451a-4f46-9002-289dba31dad3",correct:"Abstraktní doručování je typu point-to-point.",incorrect:"Abstraktní doručování není typu point-to-point.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"6f4d270b-b812-4e8f-a7ac-ff4b90e12899",correct:"Routing je pro vyšší vrstvy převážně skryté.",incorrect:"Routing není pro vyšší vrstvy skryté.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"eae6ed57-e90f-4927-9435-2c860c9f5468",correct:"Vyšší vrstva požaduje doručení na adresu.",incorrect:"Vyšší vrstva požaduje doručení na jméno.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"aed9d97b-ad25-44e6-99c7-15aeae8e5435",correct:"Nižší vrstvy jsou obvykle orientované na pakety.",incorrect:"Nižší vrstvy nejsou orientované na pakety.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"a556e734-ae72-409c-b470-9219ab6fcb5b",correct:"Paket může překročit hranice domén nízké úrovně.",incorrect:"Paket nemůže překročit hranice domén nízké úrovně.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"c9b10436-faea-4061-94ec-159865ee2350",correct:"Doručování v internetové vrstvě má širší rozsah než v linkové vrstvě.",incorrect:"Doručování v linkové vrstvě má širší rozsah než v internetové vrstvě.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"dbd0fd8d-b76b-4f5c-9b63-93859464b3eb",correct:"IP paket běžně prochází několika linkovými doménami.",incorrect:"IP paket nikdy neprochází několika linkovými doménami.",sectionNumber:"9.2.12",sectionTitle:"Stacked Delivery"},{uuid:"3fe8d9c9-56fe-4f7e-831b-40fe2d63a517",correct:"Pro překlad IP adres na MAC adresy se používá protokol ARP.",incorrect:"Pro překlad IP adres na MAC adresy se používá protokol DNS.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"08435a4e-e173-4f1a-b2da-61b3d58d54b6",correct:"Adresa TCP vrstvy typicky zahrnuje adresu IP vrstvy a číslo portu.",incorrect:"Adresa TCP vrstvy zahrnuje pouze číslo portu, nikoli adresu IP vrstvy.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"1b2aecb4-37fa-4a08-a292-375ed70c0aaa",correct:"Protokol DNS logicky patří do aplikační vrstvy, i když využívá adresy transportní vrstvy.",incorrect:"Protokol DNS logicky patří do transportní vrstvy a využívá adresy transportní vrstvy.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"fbe355d3-c1e7-49e1-bf04-9cd67904457d",correct:"Vyšší vrstvy musí poskytovat správné adresy nižším vrstvám pro doručení dat.",incorrect:"Nižší vrstvy musí poskytovat správné adresy vyšším vrstvám pro doručení dat.",sectionNumber:"9.2.13",sectionTitle:"Layers vs Addressing"},{uuid:"5c5512f2-37b6-4d2f-83bf-b296bb5882f6",correct:"ARP protokol slouží k nalezení MAC adresy odpovídající dané IP adrese v lokální síti.",incorrect:"ARP protokol slouží k nalezení IP adresy odpovídající dané MAC adrese v lokální síti.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"957ef112-25dc-49de-87b6-a42f9176b3ff",correct:"Pro doručení IP paketu linkovou vrstvou je nezbytné znát MAC adresu cílového zařízení.",incorrect:"Pro doručení IP paketu linkovou vrstvou není nutné znát MAC adresu cílového zařízení.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"4a26e58f-bde9-47b9-81ec-49002bf948c9",correct:"Operační systém buduje mapu překladů IP adres na MAC adresy pomocí ARP protokolu.",incorrect:"Operační systém buduje mapu překladů MAC adres na IP adresy pomocí ARP protokolu.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"9a94f2aa-bd61-4327-baab-29ff4d4373df",correct:"ARP protokol umožňuje internetové vrstvě doručovat pakety s využitím služeb linkové vrstvy.",incorrect:"ARP protokol umožňuje linkové vrstvě doručovat pakety s využitím služeb internetové vrstvy.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"fb7cb2b2-12a2-47b9-9fae-05835f5524d5",correct:"Routery v lokální síti používají ARP protokol pro zjištění MAC adresy cílových zařízení.",incorrect:"Routery v lokální síti nepoužívají ARP protokol pro zjištění MAC adresy cílových zařízení.",sectionNumber:"9.2.14",sectionTitle:"ARP (Address Resolution Protocol)"},{uuid:"6e85952d-0faf-4300-a4e0-a0b76e8deabc",correct:"Komunikační protokol linkové vrstvy je z velké části implementován hardwarově.",incorrect:"Komunikační protokol linkové vrstvy je implementován výhradně v softwaru operačního systému.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"d2824fc1-ea7c-4d42-b211-be49b25f5223",correct:"Operační systém používá pro příjem a odesílání ethernetových rámců unifikované rozhraní s MAC adresami.",incorrect:"Operační systém používá pro příjem a odesílání ethernetových rámců rozhraní s IP adresami.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"c16a2612-47cc-479c-920e-89f9c8c287c4",correct:"Ethernet je běžně používaný protokol linkové vrstvy.",incorrect:"Ethernet je protokol síťové vrstvy, který se stará o směrování paketů.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"afb381f0-b309-4570-8cc0-3b7262226c74",correct:"Ethernetové sítě s přepínači typicky využívají hvězdicovou topologii fyzických připojení.",incorrect:"Ethernetové sítě s přepínači typicky využívají sběrnicovou topologii fyzických připojení.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"0e04e7ec-221c-4433-bcb4-c8c6bee2ab5e",correct:"Funkce mostů v počítačových sítích se odehrává na linkové vrstvě.",incorrect:"Funkce mostů v počítačových sítích spadá do kompetence síťové vrstvy.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"3466b549-a34f-41ad-8f48-7367184b68d6",correct:"Přepínače se liší od mostů tím, že jsou optimalizovány pro větší počet portů s jednou MAC adresou na port.",incorrect:"Přepínače a mosty se liší pouze počtem portů, ale oba jsou optimalizovány pro mnoho MAC adres na port.",sectionNumber:"9.2.15",sectionTitle:"Ethernet"},{uuid:"43dfca3e-8029-4f16-a486-f71f300363eb",correct:"Kromě Ethernetu existuje mnoho dalších protokolů linkové vrstvy.",incorrect:"Ethernet je jediný protokol linkové vrstvy.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"bbbf0a03-1b9d-4cad-b60a-f463901cec15",correct:"PPP je zkratka pro Point-to-Point Protocol.",incorrect:"PPP je zkratka pro Protokol pro přenos paketů.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"7de61677-09f6-4218-84d7-8fcf14d10e53",correct:"WiFi lze považovat za bezdrátovou verzi Ethernetu.",incorrect:"WiFi je rychlejší a spolehlivější než Ethernet.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"2bcab80c-3d01-4577-a691-7b1488984ea4",correct:"Protokol PPP je určen pro sítě s dvěma uzly.",incorrect:"Protokol PPP je primárně určen pro rozsáhlé sítě LAN.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"046b62a6-acd9-4c1f-bd60-7091037e961e",correct:"WiFi vyžaduje šifrování z důvodu možné odposlouchávání komunikace.",incorrect:"WiFi nevyžaduje šifrování, protože je inherentně bezpečný.",sectionNumber:"9.2.16",sectionTitle:"Link-Layer Protocols"},{uuid:"07564f88-98b0-4cb5-931f-0c6d18ebe307",correct:"Tunely jsou virtuální zařízení druhé nebo třetí vrstvy.",incorrect:"Tunely jsou fyzická zařízení druhé nebo třetí vrstvy.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"47e0b888-72a2-409a-aea3-87970cde8be3",correct:"Tunely zapouzdřují provoz v protokolu vyšší vrstvy.",incorrect:"Tunely zapouzdřují provoz v protokolu stejné vrstvy.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"634b11a7-0e74-47e3-b0a4-8a3887f5c846",correct:"Tunely se používají ve virtuálních privátních sítích.",incorrect:"Tunely se nepoužívají ve virtuálních privátních sítích.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"34b872ad-6501-4953-8fec-5dff6a8fe24e",correct:"Tunelování umožňuje vnoření provozu nižší vrstvy do aplikační vrstvy.",incorrect:"Tunelování umožňuje vnoření provozu aplikační vrstvy do linkové vrstvy.",sectionNumber:"9.2.17",sectionTitle:"Tunneling"},{uuid:"54018ced-766b-4671-9db0-28a59f41fba7",correct:"IP protokol je paketově orientovaný protokol s nízkou režií.",incorrect:"IP protokol je spojitě orientovaný protokol s nízkou režií.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"e142b421-ed15-4905-8e02-08ab4c2eaace",correct:"IP protokol negarantuje doručení paketů ani integritu dat.",incorrect:"IP protokol garantuje spolehlivé doručení paketů a integritu dat.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"0d41884e-adb4-4b00-a629-7211986cca26",correct:"V rámci jedné IP sítě se doručení paketů stará linková vrstva.",incorrect:"V rámci jedné IP sítě se o doručení paketů stará transportní vrstva.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"0989ed6d-5e63-4f28-9704-b231770e2fbc",correct:"Routery přeposílají pakety mezi sítěmi a pracují na třetí vrstvě.",incorrect:"Routery přeposílají pakety v rámci jedné sítě a pracují na druhé vrstvě.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"36f2b3a7-ab43-41da-8f71-402cc21d238b",correct:"Porty jsou 16bitová čísla, která identifikují služby běžící na počítači.",incorrect:"Porty jsou 32bitová čísla, která identifikují služby běžící na počítači.",sectionNumber:"9.3.1",sectionTitle:"IP (Internet Protocol)"},{uuid:"bf6e735c-0fab-4754-b3af-fb28677b4b18",correct:"ICMP protokol slouží pro diagnostiku, hlášení chyb a správu sítě.",incorrect:"ICMP protokol slouží výhradně pro diagnostiku aplikačních chyb.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"195d9b71-16b2-4e99-8fa7-c3fa2a85b29f",correct:"S příchodem IPv6 byla role ICMP rozšířena o automatickou konfiguraci sítě.",incorrect:"S příchodem IPv6 byla role ICMP omezena pouze na hlášení chyb.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"171e9f49-90e3-4820-871c-9c5b1ff8155c",correct:"ICMP protokol neposkytuje přímé služby aplikační vrstvě.",incorrect:"ICMP protokol poskytuje přímé služby aplikační vrstvě pro spolehlivý přenos dat.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"ea4d4caa-5a48-4130-96da-3ad89d6649dd",correct:"Příkaz ping využívá ICMP echo request a echo reply zprávy a v kombinaci s TTL je základem pro traceroute.",incorrect:"Příkaz ping využívá výhradně TCP protokol pro diagnostiku spojení a traceroute je založen na UDP.",sectionNumber:"9.3.2",sectionTitle:"ICMP: Control Messages"},{uuid:"084a3f6c-8281-409c-9bca-94caa3449ba8",correct:"TCP je spojově orientovaný protokol, který zaručuje spolehlivé doručení dat.",incorrect:"TCP je bezespjojový protokol, který zaručuje spolehlivé doručení dat.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"85f51e02-5423-4b5a-9cd6-e80a1779caf2",correct:"Pro navázání spojení TCP využívá trojcestný handshake: SYN, SYN/ACK a ACK.",incorrect:"Pro navázání spojení TCP využívá čtyřcestný handshake: SYN, SYN/ACK, ACK a FIN.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"f5d7fe58-1bc8-4547-9ca3-b5906e594c29",correct:"TCP musí implementovat mechanismy pro rozdělení datového proudu na pakety pro IP vrstvu.",incorrect:"TCP nemusí implementovat mechanismy pro rozdělení datového proudu na pakety pro IP vrstvu, jelikož IP vrstva je proudově orientovaná.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"8e236c7a-35b1-43ba-8702-b5bc80b049cb",correct:"TCP spojení je obousměrné, umožňující obousměrný tok dat současně.",incorrect:"TCP spojení je jednosměrné, umožňující tok dat pouze v jednom směru.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"086711b4-4c4e-4a56-bdfd-4f65d2935169",correct:"TCP zajišťuje doručení dat ve správném pořadí a retransmisi ztracených paketů.",incorrect:"TCP nezajišťuje doručení dat ve správném pořadí a retransmisi ztracených paketů.",sectionNumber:"9.3.3",sectionTitle:"TCP: Transmission Control Protocol"},{uuid:"2e025574-d2be-4ea2-95fb-bcb6055d4342",correct:"TCP pakety využívají sekvenční čísla k zajištění správného pořadí doručení dat.",incorrect:"TCP pakety nepoužívají sekvenční čísla, pořadí doručení dat není garantováno.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"87d2a062-153b-478a-8e60-0c633dc8768f",correct:"Sekvenční čísla v TCP umožňují příjemci znovu sestavit datový proud i při změně pořadí IP paketů.",incorrect:"Sekvenční čísla v TCP slouží pouze k šifrování dat, nikoliv k sestavení datového proudu.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"5b3bea46-305b-4f27-b05f-b09374a4fb79",correct:"Potvrzování příjmu (ACK) v TCP se provádí pomocí sekvenčních čísel, což umožňuje identifikaci přijatých paketů.",incorrect:"Potvrzování příjmu (ACK) v TCP se provádí bez použití sekvenčních čísel.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"948c73ff-49b6-49e1-b7f7-11f4e02b2d46",correct:"Ztráta paketů v TCP je detekována odesílatelem, pokud není včas obdrženo potvrzení (ACK).",incorrect:"Ztrátu paketů v TCP detekuje pouze příjemce na základě chybějících dat.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"6205b1ed-eae7-4870-b2aa-4baabea20460",correct:"Pokud odesílatel TCP neobdrží potvrzení (ACK) v dynamicky upraveném časovém limitu, paket je znovu odeslán.",incorrect:"Při ztrátě paketu v TCP se automaticky navýší rychlost odesílání dat.",sectionNumber:"9.3.4",sectionTitle:"Sequence Numbers"},{uuid:"b5ec31b9-c234-4f09-ada3-376c3037ebfa",correct:"TCP protokol má významnou režii kvůli svým garancím spolehlivosti a doručení v pořadí.",incorrect:"TCP protokol má minimální režii, protože se jedná o jednoduchý protokol nad IP.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"b0c1bed2-018c-401e-a0ac-218f26c90d22",correct:"UDP je mnohem jednodušší protokol než TCP a představuje tenkou vrstvu nad IP.",incorrect:"UDP je složitější protokol než TCP a přidává komplexní mechanismy pro spolehlivost.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"e45b6d4f-666e-49a8-9d00-9f93dc9bb642",correct:"UDP přidává k IP minimální režii, v podstatě jen port a 16bitový kontrolní součet.",incorrect:"UDP přidává k IP významnou režii, včetně mechanismů pro spolehlivé doručení dat.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"343a221f-d6dc-4671-a19f-c9020715b68a",correct:"Hlavička UDP paketu je celkově dlouhá pouze 64 bitů a zahrnuje porty a kontrolní součet.",incorrect:"Hlavička UDP paketu je delší než 128 bitů a zahrnuje komplexní pole pro řízení toku.",sectionNumber:"9.3.5",sectionTitle:"UDP: User Datagram Protocol"},{uuid:"25868332-fadd-41a3-868a-4e68329a2904",correct:"Firewall odděluje sítě a působí jako jediný router mezi nimi, kontroluje pakety a blokuje škodlivé pokusy o přístup.",incorrect:"Firewall odděluje sítě, ale nikdy nepůsobí jako router a nekontroluje pakety, pouze slepě propouští provoz.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"026c5e29-da42-4c2d-934d-dccecfff2119",correct:"Paketový filtr je implementací firewallu a může být umístěn jak na routeru, tak i na koncovém zařízení pro zvýšení bezpečnosti.",incorrect:"Paketový filtr není považován za implementaci firewallu, ale za doplňkový bezpečnostní prvek, který nemůže fungovat samostatně.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"8ee422a8-2755-4f8b-ba79-ad5f8e3f911c",correct:"Paketové filtry klasifikují příchozí pakety na základě pravidel definovaných operátorem a mohou je propustit, zahodit nebo odmítnout.",incorrect:"Paketové filtry automaticky klasifikují pakety bez nutnosti definování pravidel operátorem a mohou je pouze propustit nebo zahodit.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"67b12d3c-40a6-4dee-ae07-878360d93cd3",correct:"Pro paketové filtry existují dvě hlavní komponenty: nástroj pro správu pravidel a kernelová část pro samotnou klasifikaci paketů.",incorrect:"Paketové filtry se skládají pouze z jedné komponenty, která je zodpovědná jak za správu pravidel, tak za klasifikaci paketů.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"aede42f7-7f40-46ad-87c4-e3a14e491922",correct:"Stavový paketový filtr si pamatuje stav spojení a díky tomu může lépe rozhodovat o propouštění paketů v rámci daného spojení.",incorrect:"Stavový paketový filtr neudržuje informace o stavu spojení a rozhoduje o propouštění paketů pouze na základě hlaviček jednotlivých paketů.",sectionNumber:"9.3.6",sectionTitle:"Firewalls"},{uuid:"5ab9df1d-a313-435d-bfe4-af0b820a9791",correct:"Číselné adresy je obtížné si zapamatovat, proto se používají hostitelská jména.",incorrect:"Číselné adresy je snadné si zapamatovat, proto se hostitelská jména nepoužívají.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"d68f21f8-116d-4a30-9503-c7bd3e676d7b",correct:"Hostitelská jména mohou být uložena v souboru jako například `/etc/hosts`, ale to je nepraktické pro více než 3 počítače.",incorrect:"Hostitelská jména nemohou být uložena v souboru jako například `/etc/hosts`, protože to je praktické i pro více než 3 počítače.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"0cc8ceb5-c1ce-4f3f-afb6-f6e11de9a8f3",correct:"Systém DNS je navržen jako škálovatelný adresář pro miliony jmen, který je efektivně aktualizován a dotazován.",incorrect:"Systém DNS není navržen jako škálovatelný adresář pro miliony jmen a není efektivně aktualizován.",sectionNumber:"9.3.7",sectionTitle:"Name Resolution"},{uuid:"2a0b3eab-6400-43ef-adc0-73b7935c4619",correct:"DNS je hierarchický protokol pro překlad jmen, který běží nad protokoly TCP nebo UDP.",incorrect:"DNS je centralizovaný protokol pro překlad jmen, který běží pouze nad protokolem TCP.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"b401561e-6b0d-412b-8f0a-5e2b9da7c43b",correct:"Doménová jména jsou v DNS rozdělena na části oddělené tečkami, což umožňuje distribuovanou databázi jmen.",incorrect:"Doménová jména jsou v DNS rozdělena na části oddělené čárkami, což zjednodušuje správu centralizované databáze jmen.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"3115344e-9b8f-4040-a61f-8bc02b55feb0",correct:"DNS servery typu NS slouží k udávání informací o dalších DNS serverech, které mohou poskytnout další informace o doméně.",incorrect:"DNS servery typu NS slouží k udávání IP adres koncových zařízení pro danou doménu.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"b198045c-26ad-4611-b1e2-03a11007ccc5",correct:"Proces rekurze v DNS obvykle provádí specializovaný typ DNS serveru, který ukládá výsledky do cache pro budoucí dotazy.",incorrect:"Proces rekurze v DNS se provádí pouze na klientském počítači a výsledky se nikdy neukládají do cache.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"fe6828d5-67c3-4f58-ad1a-9b591d4dc084",correct:"Nástroj `dig` je součástí sady nástrojů ISC a slouží k diagnostice a pozorování rekurze v DNS.",incorrect:"Nástroj `dig` je součástí operačního systému Windows a slouží pouze k zobrazení IP adresy pro dané doménové jméno.",sectionNumber:"9.3.8",sectionTitle:"DNS: Domain Name System"},{uuid:"759791c6-5a6d-478e-a2b1-cca299752f23",correct:"V moderních operačních systémech koncept 'uživatele' primárně reprezentuje jednotku vlastnictví.",incorrect:"V moderních operačních systémech koncept 'uživatele' primárně reprezentuje jednotku správy procesů.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"1b202e87-f06d-4870-bbc7-a7e670283688",correct:"Význam 'uživatele' v operačních systémech se rozšířil z pouhého reprezentování jednotlivých osob na obecnější abstrakci.",incorrect:"Význam 'uživatele' v operačních systémech zůstal striktně omezen na reprezentování jednotlivých osob.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"55f9a72d-db64-49bf-a492-b0fa07e34033",correct:"Mechanizmy řízení přístupu v operačních systémech jsou často navrženy s 'uživatelem' jako centrální entitou.",incorrect:"Mechanizmy řízení přístupu v operačních systémech jsou primárně navrženy s 'procesem' jako centrální entitou, nikoli 'uživatelem'.",sectionNumber:"9.4.1",sectionTitle:"Users"},{uuid:"3b355e7c-34b8-4cc3-b198-0faaf23077f8",correct:"Efektivní využití počítačových zdrojů bylo hlavním důvodem pro zavedení multi-tenancy.",incorrect:"Efektivní využití počítačových zdrojů nebylo důvodem pro zavedení multi-tenancy.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"80641d84-93ad-42c5-8fac-8598232a9acf",correct:"Sdílení dat mezi uživateli vyžaduje zavedení kontroly přístupu v systémech.",incorrect:"Sdílení dat mezi uživateli nevyžaduje zavedení kontroly přístupu v systémech.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"c2c8f6f1-5742-4e78-b063-7a441ef6d706",correct:"Globální sdílený souborový systém zvýšil potřebu kontroly přístupu k datům uživatelů.",incorrect:"Globální sdílený souborový systém snížil potřebu kontroly přístupu k datům uživatelů.",sectionNumber:"9.4.2",sectionTitle:"Computer Sharing"},{uuid:"738d85c3-a73a-44e8-b36d-a8b06fa07da7",correct:"V operačním systému mohou být různé objekty vlastněny, zejména soubory a procesy.",incorrect:"V operačním systému mohou být vlastněny pouze procesy, soubory vlastnictví nemají.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"8691c49b-6a7f-462b-bdb0-84ba1d8f61e0",correct:"Procesy v operačním systému jednají jménem uživatele, kterému patří, a mají stejná oprávnění.",incorrect:"Procesy v operačním systému jednají nezávisle na uživateli a nemají žádná uživatelská oprávnění.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"e1acb22e-356a-4d09-92ca-c6832a77737f",correct:"Vlastnictví souboru v operačním systému dává uživateli práva číst soubor, zapisovat do něj a měnit jeho oprávnění.",incorrect:"Vlastnictví souboru v operačním systému dává uživateli právo pouze soubor číst, nikoliv do něj zapisovat nebo měnit jeho oprávnění.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"b0f2b7f5-c7ab-4868-9dd1-b0bda92c5a20",correct:"Procesy jsou v operačním systému považovány za aktivní účastníky, zatímco soubory jsou pasivní.",incorrect:"Jak procesy, tak soubory jsou v operačním systému považovány za aktivní účastníky.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"b888ebaf-7d2c-40d6-8c02-481768be354a",correct:"Vlastnictví objektu v operačním systému může být převedeno původním vlastníkem nebo systémovým administrátorem.",incorrect:"Vlastnictví objektu v operačním systému nemůže být nikdy převedeno a zůstává trvale původnímu vlastníkovi.",sectionNumber:"9.4.3",sectionTitle:"Ownership"},{uuid:"2b48f950-40c0-4019-b6ff-ceac8b49862a",correct:"V modelu DAC vlastníci objektů rozhodují o přístupových právech.",incorrect:"V modelu DAC centrální autorita rozhoduje o přístupových právech k objektům.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"3480c4d7-6b73-451c-bbbd-f099b118dfb2",correct:"Model MAC je typicky používán v prostředích s vysokými nároky na bezpečnost.",incorrect:"Model MAC je běžně používán v běžných operačních systémech pro domácí použití.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"28949b88-7310-4e39-b444-6766f8401421",correct:"V obou modelech, DAC i MAC, OS rozhoduje o přístupu na základě politiky řízení přístupu.",incorrect:"Pouze v modelu DAC operační systém rozhoduje o přístupu na základě politiky řízení přístupu.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"154d9537-3e89-4122-8c2c-6cbc4499cce9",correct:"Politika řízení přístupu v modelu MAC je obvykle koherentnější než v modelu DAC.",incorrect:"Politika řízení přístupu je stejně koherentní v modelech DAC i MAC.",sectionNumber:"9.4.4",sectionTitle:"Access Control Models"},{uuid:"7e6bc301-5814-4ca6-9e62-a1147beb4f89",correct:"Uživatelé se ukázali být užitečnou abstrakcí pro správu systémových prostředků.",incorrect:"Uživatelé se neukázali být užitečnou abstrakcí pro správu systémových prostředků.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"caffc52e-7676-4440-8910-15596afb4391",correct:"Systémové služby často běží pod vlastními speciálními uživatelskými účty.",incorrect:"Systémové služby nikdy neběží pod vlastními speciálními uživatelskými účty.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"2ebc9b16-f49c-46d2-a8f5-81d2c0b27baf",correct:"Díky uživatelům mohou služby vlastnit soubory a být omezeny v přístupu k systému.",incorrect:"Uživatelé nezajišťují, aby služby mohly vlastnit soubory v systému.",sectionNumber:"9.4.5",sectionTitle:"(Virtual) System Users"},{uuid:"75ad4c5e-57fd-458e-b12c-052c773b4994",correct:"Princip nejmenšího privilegia se vztahuje jak na softwarové komponenty, tak na lidské uživatele systému.",incorrect:"Princip nejmenšího privilegia se vztahuje pouze na softwarové komponenty systému, nikoli na lidské uživatele.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"2eb9df33-f341-41e0-8ffc-b119b9a37d1a",correct:"Cílem principu nejmenšího privilegia je omezit rozsah škod způsobených chybami nebo bezpečnostními kompromitacemi.",incorrect:"Cílem principu nejmenšího privilegia je maximalizovat rozsah škod způsobených chybami nebo bezpečnostními kompromitacemi.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"540e54cf-6578-4e54-ba83-b5ae1db9240d",correct:"Podle principu nejmenšího privilegia by měla být oprávnění udělena pouze tehdy, když existuje skutečná potřeba pro manipulaci s objektem.",incorrect:"Podle principu nejmenšího privilegia by měla být oprávnění udělena i bez skutečné potřeby pro manipulaci s objektem.",sectionNumber:"9.4.6",sectionTitle:"Principle of Least Privilege"},{uuid:"774139e4-976f-46a1-8f14-50a425e53664",correct:"Systémy s principem nejmenších privilegií se dělí na nezávislé komponenty.",incorrect:"Systémy s principem nejmenších privilegií se nesmí dělit na nezávislé komponenty.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"06960c65-53f4-40f4-9084-62e3fcde98ab",correct:"Komponenty v systémech s oddělením privilegií spolu komunikují pomocí IPC.",incorrect:"Komponenty v systémech s oddělením privilegií spolu nekomunikují.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"329a389e-814b-46d1-b5d1-11baf6853b9a",correct:"Oddělení privilegií je návrhový vzor založený na principu nejmenších privilegií.",incorrect:"Oddělení privilegií je návrhový vzor nesouvisející s principem nejmenších privilegií.",sectionNumber:"9.4.7",sectionTitle:"Privilege Separation"},{uuid:"23367b71-e69d-4fe4-bfcc-2b7508491569",correct:"Každý proces má přidělený vlastní adresní prostor, který je implicitně oddělený od ostatních procesů.",incorrect:"Procesy sdílejí jeden společný adresní prostor, což umožňuje implicitní sdílení paměti mezi nimi.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"402e3918-5027-4974-97a0-bc2b8b205901",correct:"Sdílení paměti mezi procesy vyžaduje explicitní souhlas a nastavení, není implicitní.",incorrect:"Sdílení paměti mezi procesy je implicitní a automatické, bez nutnosti explicitního nastavení.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"44726b2b-a7ab-42a0-a8f7-34b27e3138f7",correct:"Systém souborů poskytuje globální sdílený jmenný prostor pro všechny uživatele a procesy.",incorrect:"Každý uživatel má izolovaný jmenný prostor systému souborů, oddělený od ostatních uživatelů.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"a30b1643-0095-4ef6-bbe3-0bd1cc4cd826",correct:"Cesty k souborům nejsou považovány za bezpečnostní tokeny pro kontrolu přístupu.",incorrect:"Cesty k souborům slouží jako primární bezpečnostní mechanismus pro kontrolu přístupu.",sectionNumber:"9.4.8",sectionTitle:"Process Separation"},{uuid:"a3b1bf08-9d8b-4ba0-bb41-aa5b1ee67f91",correct:"Politika řízení přístupu definuje pravidla, která určují, zda subjekt smí provést danou akci s objektem.",incorrect:"Politika řízení přístupu definuje pravidla, která určují, jaké akce musí subjekt provést s objektem.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"25210fd1-48fd-4820-8db2-bab168594fd6",correct:"Subjekty v systémech řízení přístupu jsou typicky uživatelé, programy nebo role.",incorrect:"Subjekty v systémech řízení přístupu jsou výhradně fyzické osoby, nikoliv programy.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"25cb4e25-96dc-461e-9ab3-b85f76ec3d88",correct:"Dostupné akce, jako čtení nebo zápis, se liší v závislosti na typu objektu, například souboru nebo adresáři.",incorrect:"Dostupné akce jsou univerzální a nezávisí na typu objektu, ke kterému subjekt přistupuje.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"61c8069c-cac1-45a5-929c-bbd854156a5e",correct:"Oprávnění ke čtení souboru se ověřuje při otevření souboru, nikoliv při každém volání operace čtení.",incorrect:"Oprávnění ke čtení souboru se ověřuje při každém volání operace čtení, nikoliv při otevření souboru.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"76a49be0-11b3-40d8-a143-791485bf25fb",correct:"Mezi objekty řízení přístupu v operačním systému patří soubory, adresáře a síťová připojení.",incorrect:"Mezi objekty řízení přístupu v operačním systému patří pouze fyzická paměť a procesor.",sectionNumber:"9.4.9",sectionTitle:"Access Control Policy"},{uuid:"a10b33bb-3b4e-4efe-9d88-1691f485d874",correct:"Jádro operačního systému běží v privilegovaném režimu CPU.",incorrect:"Uživatelské programy běží v privilegovaném režimu CPU.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"6f1f1df2-dbb2-4c18-9c49-76e1f5510793",correct:"MMU zajišťuje izolaci procesů v operačním systému.",incorrect:"MMU nezajišťuje izolaci procesů v operačním systému.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"852bb691-0627-42fb-a2a9-26b7a65a0a3a",correct:"Přístup k hardwarovým zdrojům je zprostředkován systémovými voláními.",incorrect:"Přímý přístup k hardwarovým zdrojům je povolen bez systémových volání.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"4cdb9809-979b-4bbd-9ff0-65eeffd20c6d",correct:"Souborové systémy jsou integrální součástí jádra operačního systému.",incorrect:"Souborové systémy běží mimo jádro operačního systému jako uživatelský prostor.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"ab308c40-64b4-4dcb-90d1-e4f0442b3a15",correct:"Operační systém využívá hardwarové prostředky k prosazování bezpečnostní politiky.",incorrect:"Operační systém se spoléhá výhradně na software pro prosazování bezpečnostní politiky.",sectionNumber:"9.4.10",sectionTitle:"Enforcement"},{uuid:"d2a1bd86-c64a-421c-b476-cca7e307524e",correct:"Uživatelské procesy mohou vynucovat řízení přístupu s pomocí jádra operačního systému.",incorrect:"Uživatelské procesy mohou vynucovat řízení přístupu zcela nezávisle na jádru operačního systému.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"c3e335c3-ef2a-4263-919d-f77bc1a75f06",correct:"Systémové služby často poskytují IPC API, například systémové volání getpeereid().",incorrect:"Systémové služby obvykle neposkytují IPC API, a getpeereid() není příkladem takového API.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"177ae90b-f221-4ce2-9d21-4f1d0b76d5dd",correct:"Řízení přístupu na uživatelské úrovni se spoléhá na mechanismy poskytované jádrem operačního systému.",incorrect:"Řízení přístupu na uživatelské úrovni je zcela nezávislé na jádru operačního systému.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"6dd1ba5e-697b-4c3d-9be3-349e24990eaf",correct:"Databázový server může používat systémové volání getpeereid() k získání ID uživatele klienta.",incorrect:"Databázový server používá systémové volání open() k získání ID uživatele klienta.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"2d901671-09c0-45d9-be50-d7acc31d8205",correct:"Jádro operačního systému zabraňuje procesům v přímém přístupu k souborům databáze, pokud nemají oprávnění.",incorrect:"Jádro operačního systému umožňuje všem procesům přímý přístup k souborům databáze bez omezení.",sectionNumber:"9.4.11",sectionTitle:"User-space Enforcement"},{uuid:"7b2425a2-6fe7-4aae-88ab-2eeee611c957",correct:"V systémech POSIX existují dva základní typy subjektů: uživatelé a skupiny.",incorrect:"V systémech POSIX existují tři základní typy subjektů: uživatelé, skupiny a procesy.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"77128b13-836d-4061-b7a5-3c912b2f18eb",correct:"Uživatel v systémech POSIX může patřit do více skupin.",incorrect:"Uživatel v systémech POSIX může patřit pouze do jedné skupiny.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"899300b4-ebe7-4190-a78d-a08b9a45a0b7",correct:"Uživatel root v systémech POSIX nepodléhá kontrole oprávnění.",incorrect:"Uživatel root v systémech POSIX podléhá kontrole oprávnění jako běžní uživatelé.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"7a0468f1-daed-4b19-bed9-9f29a02e74e7",correct:"Pouze uživatel root může v systémech POSIX provádět určité akce, například restartovat počítač.",incorrect:"Každý uživatel může v systémech POSIX provádět všechny akce, včetně restartování počítače.",sectionNumber:"9.4.12",sectionTitle:"Subjects in POSIX"},{uuid:"026de7b6-6976-4a83-94e7-ba9c7224039c",correct:"Uživatelé a skupiny jsou reprezentovány číselnými identifikátory pro zvýšení efektivity operací v systému.",incorrect:"Uživatelé a skupiny jsou reprezentovány textovými řetězci pro zvýšení efektivity operací v systému.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"eb8a3b01-c89b-41bf-a498-882fdd53626c",correct:"Číselné identifikátory uživatelů umožňují efektivní porovnávání a kompaktní uložení v i-node.",incorrect:"Textové identifikátory uživatelů umožňují efektivní porovnávání a kompaktní uložení v i-node.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"407f4a3a-84a2-4b6f-b6ee-8545b2067c12",correct:"Databáze uživatelů mapuje uživatelská jména na číselné identifikátory, které systém interně používá.",incorrect:"Databáze uživatelů mapuje číselné identifikátory na uživatelská jména, která systém interně používá.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"8037d44f-5620-47e9-90a1-d65c839a9f53",correct:"V lokálních sítích je žádoucí sdílet uživatelské identity a jejich číselné mapování mezi počítači.",incorrect:"V lokálních sítích není žádoucí sdílet uživatelské identity a jejich číselné mapování mezi počítači.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"f6190c75-3db4-45be-adbc-ee840a165c33",correct:"Soubory /etc/passwd a /etc/group mohou fungovat jako jednoduchá lokální databáze uživatelů.",incorrect:"Soubory /etc/passwd a /etc/group fungují jako komplexní distribuovaná databáze uživatelů.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"f11e60ed-9751-4487-83ef-11fd33a0c1ff",correct:"LDAP a Active Directory jsou příklady centralizovaných databází uživatelů pro lokální sítě.",incorrect:"LDAP a Active Directory jsou příklady decentralizovaných databází uživatelů pro lokální sítě.",sectionNumber:"9.4.13",sectionTitle:"User and Group Identifiers"},{uuid:"ba7b2f13-9282-4c84-a3d7-a94012427421",correct:"Každý proces v systému patří konkrétnímu uživateli.",incorrect:"Ne všechny procesy v systému patří konkrétnímu uživateli.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"cd768ff1-dde4-4589-aa92-7b424028e289",correct:"Vlastnictví procesu se dědí při volání fork().",incorrect:"Vlastnictví procesu se nedědí při volání fork().",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"acf5cafb-1086-4959-abcb-cdfc3e892099",correct:"Procesy s oprávněními superuživatele mohou měnit vlastníka pomocí setuid().",incorrect:"Procesy s oprávněními superuživatele nemohou měnit vlastníka pomocí setuid().",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"4ff4e3a0-f697-4202-ada4-8693017cf3a7",correct:"Volání exec() může někdy změnit vlastníka procesu.",incorrect:"Volání exec() nikdy nemůže změnit vlastníka procesu.",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"ad8b921a-d893-4a22-84ad-86eddb5ea8a8",correct:"S výjimkou init, všechny procesy vznikají voláním fork().",incorrect:"Všechny procesy, včetně init, vznikají voláním fork().",sectionNumber:"9.4.14",sectionTitle:"Changing Identities"},{uuid:"079b9f19-7772-4d64-8f00-2434b3d5f0e9",correct:"Program login autentizuje uživatele pomocí jména a hesla.",incorrect:"Program login autorizuje uživatele pomocí jména a hesla.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"50bbd9a0-101f-4ae2-8cf5-12d6775ca557",correct:"Funkce setuid() se používá pro změnu vlastníka procesu na přihlášeného uživatele.",incorrect:"Funkce exec() se používá pro změnu vlastníka procesu na přihlášeného uživatele.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"fab177a3-fedf-4c6b-b2ce-bcae269ae962",correct:"Program login kontroluje přihlašovací údaje oproti uživatelské databázi.",incorrect:"Program login kontroluje přihlašovací údaje oproti systémové databázi.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"56440692-ac22-4716-a6e0-21ccb4ba87fd",correct:"Proces login se spouští na konci bootovacího procesu systému.",incorrect:"Proces login se spouští na začátku bootovacího procesu systému.",sectionNumber:"9.4.15",sectionTitle:"Login"},{uuid:"bf55cf5e-71a0-4a3d-98bf-aacf0f11354d",correct:"Nejběžnější metodou autentizace uživatelů je zadání hesla nebo přístupové fráze.",incorrect:"Nejběžnější metodou autentizace uživatelů je veřejné sdílení osobních údajů.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"d1091d95-58e3-4324-9ad8-88c12e6b3125",correct:"Systém by měl ideálně ukládat pouze informaci potřebnou k ověření hesla, nikoliv heslo samotné.",incorrect:"Systém by měl ideálně ukládat hesla uživatelů v nezašifrované podobě pro snadnější přístup.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"034040f5-483b-4694-a6bc-fc74a8bdc8f7",correct:"Kromě hesel existují i jiné metody autentizace, například biometrické metody.",incorrect:"Kromě hesel neexistují žádné další široce používané metody autentizace uživatelů.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"d2d27564-9dd7-4f27-b57b-5e9685f933e0",correct:"Účelem autentizace je ověřit, zda je uživatel skutečně tím, za koho se vydává.",incorrect:"Účelem autentizace je pouze přidělit uživateli přístupová práva k souborům.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"dd86bcce-04cd-468b-a202-9d78e76d15f4",correct:"Pro ověření hesla se běžně používají kryptografické hashovací funkce.",incorrect:"Pro ověření hesla se běžně používá prosté porovnání zadaného hesla s uloženým heslem v databázi.",sectionNumber:"9.4.16",sectionTitle:"User Authentication"},{uuid:"6737744d-7f05-4431-a16f-cfb5e068b3ae",correct:"Autentizace přes síť představuje větší bezpečnostní výzvy než lokální autentizace kvůli nezabezpečeným sítím.",incorrect:"Autentizace přes síť je stejně bezpečná jako lokální autentizace, protože sítě jsou ze své podstaty bezpečné.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"2c6dde03-3cd1-46a8-9969-42efe9315b8a",correct:"Hesla, i když se snadno používají, vyžadují šifrování pro bezpečný přenos přes síť.",incorrect:"Hesla, kvůli své jednoduchosti, nevyžadují šifrování pro bezpečný přenos přes síť.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"7c90a4b3-987c-4dc9-b5b2-36ea7d08b919",correct:"Dvoufaktorová autentizace může zvýšit bezpečnost nad rámec pouhého používání silných hesel pro síťovou autentizaci.",incorrect:"Dvoufaktorová autentizace je zbytečná, pokud jsou pro síťovou autentizaci použita silná hesla.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"8b64ed6c-98b5-4ab8-9c3d-34246d2431a4",correct:"I při šifrování hesla je autentizace počítače klíčová pro prevenci útoků ze strany škodlivých počítačů.",incorrect:"Šifrování hesla samotné je dostačující pro bezpečnou síťovou autentizaci, takže autentizace počítače je zbytečná.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"4d3e2ded-5dda-4a72-b0a1-4d9fe22f5799",correct:"Riziko útoků se významně zvyšuje při síťové autentizaci, protože uživatelé nemusí být fyzicky přítomni.",incorrect:"Riziko útoků se významně nezvyšuje při síťové autentizaci, protože fyzická přítomnost je vždy vyžadována.",sectionNumber:"9.4.17",sectionTitle:"Remote Login"},{uuid:"962270f7-9dec-4202-91d9-2630f14ee4c7",correct:"Dvoufaktorová autentizace kombinuje znalost hesla a vlastnictví tokenu pro zvýšení bezpečnosti.",incorrect:"Dvoufaktorová autentizace využívá pouze biometrické údaje pro ověření identity uživatele.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"7a2d68bb-b7aa-40a4-afa0-2a27946cc2b6",correct:"Pro vzdálenou autentizaci je dvoufaktorová autentizace s heslem a kryptografickým tokenem běžnější než biometrická autentizace.",incorrect:"Pro vzdálenou autentizaci je biometrická autentizace praktičtější a běžnější než dvoufaktorová autentizace s tokenem.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"e7fab4f1-bf7a-44be-87cf-a7958f2ee4d4",correct:"Kryptografické tokeny pro lokální autentizaci obvykle komunikují s počítačem přímo, nikoliv přes uživatele.",incorrect:"Kryptografické tokeny pro lokální autentizaci vyžadují, aby uživatel ručně přepisoval kódy pro ověření.",sectionNumber:"9.4.18",sectionTitle:"2-factor Authentication"},{uuid:"00c30f93-170b-44b6-bf7f-5e743481bc90",correct:"Ověření identity vzdáleného počítače je klíčové pro zabránění odeslání citlivých dat nechtěným příjemcům.",incorrect:"Ověření identity vzdáleného počítače je důležité hlavně pro zajištění integrity dat, nikoliv důvěrnosti.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"2247cb79-ca68-4eef-bc26-6bf3ad239dea",correct:"Asymetrická kryptografie umožňuje ověření identity vzdáleného počítače pomocí digitálních podpisů generovaných soukromými klíči.",incorrect:"Symetrická kryptografie se běžně používá pro ověření identity vzdáleného počítače pomocí digitálních podpisů a soukromých klíčů.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"18f46685-8a71-45e9-bd34-b65926fedde9",correct:"Při ověřování identity vzdáleného počítače klient odesílá výzvu, kterou server musí podepsat svým soukromým klíčem.",incorrect:"Při ověřování identity vzdáleného počítače server odesílá výzvu, kterou klient musí podepsat svým soukromým klíčem pro ověření identity klienta.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"},{uuid:"35aae33d-e647-44c7-b52c-6e271ef030e8",correct:"Každý počítač má unikátní soukromý klíč a jeho veřejný protějšek je distribuován pro ověření identity.",incorrect:"Každý počítač má unikátní veřejný klíč a jeho soukromý protějšek je distribuován pro ověření identity.",sectionNumber:"9.4.19",sectionTitle:"Computer Authentication"}]},{uuid:"045b187c-821b-4a56-9ef5-19b8812653de",sectionNumber:"10",sectionTitle:"POSIX a jazyk C",statements:[{uuid:"3c285e0d-d26a-4079-9219-0776beb8b0dd",correct:"Jazyk C má v kontextu operačních systémů výjimečné postavení.",incorrect:"Jazyk Python má v kontextu operačních systémů výjimečné postavení.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"0c4d5980-2315-4b5c-9d7a-6f112d012c61",correct:"Většina jazyků, s nimiž se studenti setkají, spadá do kategorie jazyků vyšší úrovně abstrakce.",incorrect:"Většina jazyků, s nimiž se studenti setkají, spadá do kategorie jazyků nižší úrovně abstrakce.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"d4db40d9-8801-4d50-970e-dd3e78737d75",correct:"Jazyky C++, Java a C# jsou příklady jazyků odvozených od C a spadají mezi jazyky vyšší úrovně.",incorrect:"Jazyky C++, Java a C# jsou příklady jazyků odvozených od C a spadají mezi jazyky nižší úrovně.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"dc40e836-b915-4d28-a1c6-7f461800f6ba",correct:"Pro účely kurzu se budeme zabývat především jazykem C a shellem POSIX, který je také považován za programovací jazyk.",incorrect:"Pro účely kurzu se budeme zabývat především jazykem Python a shellem POSIX, který není považován za programovací jazyk.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"e8a18231-8a9d-48be-8ce6-1dea498b815a",correct:"Různé programovací jazyky existují na různých úrovních abstrakce a mají odlišné účely použití.",incorrect:"Všechny programovací jazyky existují na stejné úrovni abstrakce a mají stejné účely použití.",sectionNumber:"10.1.1",sectionTitle:"Programming Languages"},{uuid:"6c82ac37-5b6d-4708-bb1a-f88891e04731",correct:"C lze považovat za přenosný assembler s několika málo doplňky ve formě standardní knihovny.",incorrect:"C je považován za moderní jazyk s mnoha pokročilými funkcemi, který se používá pro vývoj webových aplikací.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"c0fab552-2096-49d4-9801-16d2bf7e5f83",correct:"Hlavní výhodou jazyka C oproti assembleru je abstrakce od strojových instrukcí a strukturované řízení toku programu.",incorrect:"Hlavní výhodou jazyka C oproti assembleru je automatická správa paměti a podpora objektově orientovaného programování.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"980b7c49-ae21-4e88-b7da-f94477b5a2bd",correct:"Popularita jazyka C v systémovém programování pramení z jeho schopnosti snadno propojovat se s kódem napsaným v jiných jazycích.",incorrect:"Popularita jazyka C v systémovém programování pramení z jeho složitosti a obtížné integrace s jinými programovacími jazyky.",sectionNumber:"10.1.2",sectionTitle:"C: The Least Common Denominator"},{uuid:"55d8be60-3e9d-4cba-90c9-99b9ff948c29",correct:"Většina operačních systémových jader je napsána v jazyce C.",incorrect:"Všechna operační systémová jádra jsou napsána v jazyce C.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"c3e3f924-c064-46c5-b0e7-c1c2718b55ef",correct:"Systémové knihovny jsou obvykle psány v jazyce C, stejně jako jádro operačního systému.",incorrect:"Systémové knihovny jsou obvykle psány v jazyce C++, na rozdíl od jádra operačního systému.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"7c64b75d-608d-46ef-a057-38e7cb0c8b39",correct:"I operační systémy nenapsané v jazyce C poskytují C API pro programy.",incorrect:"Operační systémy nenapsané v jazyce C nikdy neposkytují C API.",sectionNumber:"10.1.3",sectionTitle:"The Language of Operating Systems"},{uuid:"d896a2d6-597d-466c-8902-c12c48c78e3a",correct:"C knihovny se skládají z hlavičkových souborů a kompilovaného kódu knihovny.",incorrect:"C knihovny obsahují pouze hlavičkové soubory, které definují implementaci funkcí.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"f3bc978d-b42f-447d-8a17-638a64a39453",correct:"Hlavičkové soubory v C knihovnách poskytují deklarace funkcí, nikoliv jejich definice.",incorrect:"Hlavičkové soubory v C knihovnách obsahují kompletní definice všech funkcí knihovny.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"cc8ab086-44ae-4d76-bb1d-8e89ad2267b5",correct:"Statické knihovny v C, jako například libc.a, se liší od sdílených knihoven, například libc.so.",incorrect:"Statické i sdílené knihovny v C mají stejnou příponu souboru a funkční princip.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"01efce0e-407f-42be-9786-a537af45d0ae",correct:"Deklarace funkce v C specifikuje rozhraní funkce, tedy její jméno, argumenty a návratový typ.",incorrect:"Deklarace funkce v C zahrnuje kompletní implementaci funkce, včetně těla a prováděných operací.",sectionNumber:"10.1.4",sectionTitle:"(System) Libraries"},{uuid:"8fadd642-e2b4-493c-95fe-491b310c0966",correct:"Knihovna libc obsahuje funkce standardu ISO C, jako například printf, fopen a fread.",incorrect:"Knihovna libc neobsahuje žádné funkce standardu ISO C, ale pouze POSIX funkce.",sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"5bfd966c-ff32-4e4b-a2c9-ff42d8382008",correct:"POSIX funkce v knihovně libc, jako například open a read, jsou C obálky systémových volání.",incorrect:"POSIX funkce v knihovně libc, jako například open a read, nejsou C obálky systémových volání.",sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"542d4dee-77aa-4a4f-9780-7cca27acb74d",correct:"V systémech UNIX tradičně knihovna libc kombinuje základní C knihovnu a knihovnu POSIX.",incorrect:"V systémech UNIX knihovna libc odděluje funkce základní C knihovny a knihovny POSIX do samostatných celků.",sectionNumber:"10.1.5",sectionTitle:"The POSIX C Library"},{uuid:"9e5e79a6-5e6a-4a5e-a63c-7ce6a87bb9fe",correct:"Knihovna `libc` je klíčová, avšak v systémech UNIX existuje mnoho dalších specializovaných knihoven.",incorrect:"Knihovna `libc` je nejdůležitější knihovna v UNIXU a ostatní knihovny jsou jen doplňkové.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"d94c3f30-ebfc-471b-9abc-0fa1aa9832cb",correct:"Matematická knihovna `libm` poskytuje funkce pro výpočty s plovoucí desetinnou čárkou, jako sinus a kosinus.",incorrect:"Knihovna `libm` se v UNIXU používá primárně pro operace s řetězci a textem.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"fb88c322-1211-47d9-aee2-9a1138777d97",correct:"Knihovna `libpthread` obsahuje funkce pro tvorbu vícevláknových programů, včetně `pthread_create`.",incorrect:"Knihovna `libpthread` slouží pouze pro správu procesů, nikoliv pro vlákna.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"65985ef8-e612-41d6-ac9b-d8b1b8b090e7",correct:"Standardní knihovna C++ v UNIXU, často `libstdc++`, nelze přímo používat z programů v jazyce C.",incorrect:"Standardní knihovna C++ v UNIXU, `libstdc++`, je plně kompatibilní a zaměnitelná s knihovnou `libc`.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"e7c5489d-7eff-4130-92d2-4042c2fdddda",correct:"Kryptografická knihovna `libcrypto` nabízí symetrické šifry jako AES a asymetrické algoritmy jako RSA.",incorrect:"Knihovna `libcrypto` v UNIXU poskytuje pouze hashovací funkce a digitální podpisy.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"8381601e-e903-4c6a-8cdd-ea593d7a801a",correct:"Knihovna `libcurses` umožňuje programům pracovat přenositelně s různými typy hardwarových a softwarových terminálů.",incorrect:"Knihovna `libcurses` je zastaralá a v moderních systémech UNIX se již nepoužívá.",sectionNumber:"10.1.6",sectionTitle:"Additional System Libraries"},{uuid:"1a7e8937-5cb0-4ef2-927a-7f305a3154fa",correct:"V mnoha systémech UNIX lze systémové knihovny nalézt v `/usr/lib` a uživatelské knihovny v `/usr/local/lib`.",incorrect:"Ve všech systémech UNIX se systémové knihovny nacházejí výhradně v `/lib` a uživatelské knihovny výhradně v `/usr/local/lib`.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"ec73af1f-82c6-49a5-bed1-33ef13fd2097",correct:"Konkrétně v systémech založených na Linuxu lze systémové a uživatelské knihovny nalézt smíšené dohromady v adresáři `/usr/lib`.",incorrect:"Konkrétně v systémech založených na Linuxu se systémové knihovny nacházejí v `/lib` a uživatelské knihovny v `/usr/local/lib`.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"45dc8f7c-afb0-43c8-860f-5f5282a5909b",correct:"V systému Windows jsou systémové i aplikační knihovny často instalovány ve společném umístění, například `C:\\Windows\\System32`.",incorrect:"V systému Windows se systémové knihovny nacházejí v `C:\\Windows\\System32` a aplikační knihovny se instalují samostatně s každým programem.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"024d8666-77b9-4637-9ff9-98afb2ff22aa",correct:"V systémech Windows a macOS jsou sdílené knihovny často instalovány společně s aplikací samotnou.",incorrect:"Sdílené knihovny jsou instalovány pouze v systémových adresářích a nikdy společně s aplikací v systémech Windows a macOS.",sectionNumber:"10.1.7",sectionTitle:"Library Files"},{uuid:"bbee2aa2-076e-4a59-85f6-fa76ea0405d5",correct:"Statické knihovny se používají během fáze linkování při kompilaci programů.",incorrect:"Statické knihovny se používají během fáze běhu programů.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"a2050c26-6826-4fb2-b962-2b83e5fc84fb",correct:"Při použití statických knihoven se potřebný kód kopíruje přímo do spustitelného souboru.",incorrect:"Při použití statických knihoven se potřebný kód dynamicky linkuje během běhu programu.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"fcc73947-9163-493a-b3e4-aec45642530f",correct:"Spustitelné soubory vytvořené se statickými knihovnami jsou soběstačné a nezávisí na externích knihovních souborech za běhu.",incorrect:"Spustitelné soubory vytvořené se statickými knihovnami závisí na externích knihovních souborech za běhu.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"fb58138d-8fa7-41ea-bc74-415cb63eab92",correct:"Statické linkování může vést k duplicitě kódu v mnoha spustitelných souborech v systému.",incorrect:"Statické linkování eliminuje duplicitě kódu v mnoha spustitelných souborech v systému.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"3843d3bc-07e7-4aa0-880c-7c2f124707fd",correct:"Operační systémy nemusí standardně obsahovat statické knihovny a vyžadují samostatnou instalaci.",incorrect:"Operační systémy vždy standardně obsahují statické knihovny pro všechny uživatele.",sectionNumber:"10.1.8",sectionTitle:"Static Libraries"},{uuid:"5df6b259-edcc-485c-a723-6947cd28cdfd",correct:"Pro spuštění programů využívajících dynamické knihovny je přítomnost těchto knihoven nezbytná.",incorrect:"Pro spuštění programů využívajících dynamické knihovny není přítomnost těchto knihoven nezbytná.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"7054ccd9-cbf7-4e66-aecd-32380a8ca404",correct:"Linkování dynamických knihoven se provádí až při spuštění programu, nikoliv během kompilace.",incorrect:"Linkování dynamických knihoven se provádí během kompilace programu, nikoliv až při spuštění.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"df663c85-cbfe-4a45-b7de-305caa2d1c19",correct:"Sdílené knihovny redukují redundanci kódu jak v operační paměti, tak i v souborovém systému.",incorrect:"Sdílené knihovny zvyšují redundanci kódu jak v operační paměti, tak i v souborovém systému.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"5f27b574-b756-4e5d-b40f-417fb543a60f",correct:"Aktualizace dynamické knihovny může proběhnout odděleně od aplikací, které na ní závisejí.",incorrect:"Aktualizace dynamické knihovny musí proběhnout současně s aktualizací všech aplikací, které na ní závisejí.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"745569c8-a798-4faf-985b-5e2be0fbd06d",correct:"Problémy se závislostmi jsou běžným negativem spojeným s používáním dynamických knihoven.",incorrect:"Problémy se závislostmi se nikdy nevyskytují při používání dynamických knihoven.",sectionNumber:"10.1.9",sectionTitle:"Shared (Dynamic) Libraries"},{uuid:"c6423309-e218-4e36-8486-f75702af3f32",correct:"Hlavičkové soubory obsahují prototypy funkcí v jazyce C a definice datových struktur.",incorrect:"Hlavičkové soubory obsahují implementace funkcí v jazyce C a definice datových struktur.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"531cd101-db4e-4501-ac70-f9b8f05b2b65",correct:"Hlavičkové soubory jsou vyžadovány při kompilaci programů v jazycích C a C++, ale ne při jejich používání.",incorrect:"Hlavičkové soubory jsou vyžadovány jak při kompilaci, tak i při používání programů v jazycích C a C++.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"ca314db8-fac1-4236-8ba7-575341caf0c2",correct:"Na systémech UNIX jsou systémové hlavičkové soubory tradičně uloženy v adresáři `/usr/include`.",incorrect:"Na systémech UNIX jsou systémové hlavičkové soubory tradičně uloženy v adresáři `/usr/lib`.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"91e4e9fb-747d-4652-8396-94afcadc4ef9",correct:"Rozložení datových struktur definovaných v hlavičkových souborech je součástí aplikačního binárního rozhraní (ABI).",incorrect:"Rozložení datových struktur definovaných v hlavičkových souborech není součástí aplikačního binárního rozhraní (ABI).",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"52dce79e-8e9e-4561-b72b-28451f8f01d6",correct:"Hlavičkové soubory jsou fragmenty zdrojového kódu v jazyce C.",incorrect:"Hlavičkové soubory jsou binární soubory obsahující kompilovaný kód.",sectionNumber:"10.1.10",sectionTitle:"Header Files"},{uuid:"19a434ed-76dc-47b2-93c5-868a08ce9772",correct:"Manuálové stránky v UNIXu jsou obvykle součástí instalace operačního systému.",incorrect:"Manuálové stránky v UNIXu jsou dodávány pouze jako externí doplněk k operačnímu systému.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"eb515284-5bf9-4b67-99fd-62835e39b90f",correct:"Příkaz `man` v UNIXu umožňuje prohlížet dokumentaci k systémovým voláním.",incorrect:"Příkaz `man` v UNIXu slouží pouze k manipulaci s procesy.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"e4d717c2-2fbe-487f-85f1-4b006c2f30d9",correct:"MSDN poskytuje rozsáhlou dokumentaci pro programátory operačního systému Windows.",incorrect:"MSDN poskytuje dokumentaci pouze pro uživatele operačního systému Windows, nikoliv programátory.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"61ded96e-dcc0-4be0-9f72-930a00368022",correct:"Sekce 2 manuálových stránek v UNIXu popisuje systémová volání.",incorrect:"Sekce 2 manuálových stránek v UNIXu popisuje knihovní funkce.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"93b6c918-8de7-4c41-8d0b-94b5aa839e6e",correct:"Dokumentace pro Windows byla dříve dostupná i na optických médiích.",incorrect:"Dokumentace pro Windows byla dříve dostupná výhradně v tištěné podobě.",sectionNumber:"10.1.11",sectionTitle:"Documentation"},{uuid:"2c7769d5-9cd3-49c8-9302-3ffde570cfa2",correct:"Systémy POSIX často obsahují překladač jazyka C.",incorrect:"Systémy POSIX nikdy neobsahují překladač jazyka C.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"a7767baa-86a9-4f7e-a082-0c9936db490d",correct:"Výstupem překladače je objektový soubor obsahující strojový kód.",incorrect:"Výstupem překladače je zdrojový soubor v textové podobě.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"3d7bb553-75ca-4e0f-a100-b5ddf821a39c",correct:"Objektový soubor sice obsahuje strojový kód, ale není přímo spustitelný.",incorrect:"Objektový soubor je přímo spustitelný, protože obsahuje strojový kód.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"f9e5c4a7-847c-4f98-b931-b9b8da8cf74b",correct:"Program nelze spustit dokud není spojen linkovacím programem.",incorrect:"Program lze spustit ihned po kompilaci bez linkování.",sectionNumber:"10.2.1",sectionTitle:"C Compiler"},{uuid:"81c3d086-788f-40b8-a9e4-449923bf1bb2",correct:"Objektové soubory obsahují spustitelný kód a statická data.",incorrect:"Objektové soubory obsahují pouze spustitelný kód bez statických dat.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"b5ae588c-7c50-4ce0-98d4-837506c059af",correct:"Objektové soubory mohou být rozděleny do sekcí jako .text, .rodata a .data.",incorrect:"Objektové soubory jsou vždy rozděleny do sekcí .text, .rodata a .data.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"36240eb7-0abe-43c4-87c1-f7c9dfe17843",correct:"Sekce .text v objektovém souboru typicky obsahuje strojový kód.",incorrect:"Sekce .text v objektovém souboru typicky obsahuje metadata.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"4e338e06-d8c1-4e95-abb8-628618f83a71",correct:"Tabulka symbolů v metadatech objektového souboru udává adresy funkcí relativní k souboru.",incorrect:"Tabulka symbolů v metadatech objektového souboru udává absolutní adresy funkcí.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"11c7b529-7cd1-4c9d-ab07-7f17ea68892a",correct:"Sekce .rodata je určena pro data určená jen pro čtení, jako jsou řetězcové literály.",incorrect:"Sekce .rodata je určena pro spustitelný kód.",sectionNumber:"10.2.2",sectionTitle:"Object Files"},{uuid:"e51d615c-e196-4078-94ec-78f4e43d48f7",correct:"Formát ELF je nejběžnější formát objektových souborů v systémech POSIX.",incorrect:"Formát PE je nejběžnější formát objektových souborů v systémech POSIX.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"82c66b80-7813-40b4-96e8-259b1cadee75",correct:"Formát Mach-O je formát objektových souborů používaný v systémech macOS.",incorrect:"Formát Mach-O je formát objektových souborů používaný v systémech Windows.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"024ebc75-7cfe-40e4-9903-98f140d37af6",correct:"Formát COFF rozšiřuje formát a.out o podporu sekcí.",incorrect:"Formát COFF je starší formát než a.out a nepodporuje sekce.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"e13e3442-ec3b-43ca-9c52-2a99080a586f",correct:"Formáty PE, Mach-O a ELF jsou běžně používané formáty objektových souborů v současných systémech.",incorrect:"Formáty PE, Mach-O a ELF jsou zastaralé formáty objektových souborů a již se nepoužívají.",sectionNumber:"10.2.3",sectionTitle:"Object File Formats"},{uuid:"1819a68f-2165-40f1-9170-6640aa80ac61",correct:"Statické knihovny v UNIXu se nazývají archivy a mají příponu .a.",incorrect:"Statické knihovny v UNIXu se nazývají dynamické knihovny a mají příponu .a.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"3ad16b29-b924-448f-8feb-b1f737b7aede",correct:"Archiv statické knihovny obsahuje kromě objektových souborů i tabulku symbolů.",incorrect:"Archiv statické knihovny obsahuje pouze objektové soubory, nikoliv tabulku symbolů.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"2146e0b6-47ed-40b3-8622-3d4cb0fd39b0",correct:"Symbolová tabulka v archivu urychluje linkování tím, že linker nemusí prohledávat všechny objektové soubory.",incorrect:"Symbolová tabulka v archivu zpomaluje linkování, protože linker musí prohledávat tabulku symbolů i objektové soubory.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"346f4ced-061e-40ed-a150-3ea5e1bd7eb2",correct:"Archiv statické knihovny je sbírka objektových souborů, kde každý soubor si zachovává svou identitu.",incorrect:"Archiv statické knihovny je sloučený soubor, kde objektové soubory ztrácejí svou původní identitu.",sectionNumber:"10.2.4",sectionTitle:"Archives (Static Libraries)"},{uuid:"62b1ba4f-6def-4d82-bb1e-24d3c24a5dff",correct:"Linker kombinuje objektové soubory za účelem vytvoření spustitelného souboru.",incorrect:"Linker kombinuje zdrojové soubory za účelem vytvoření spustitelného souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"4e35b24b-27a8-41e9-9dfd-b0aee34e2ec0",correct:"Objektové soubory mohou používat symboly definované v knihovnách nebo jiných objektových souborech.",incorrect:"Objektové soubory mohou používat pouze symboly definované v samotném objektovém souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"d5386b67-d1dd-4e16-8313-315b76fdaf56",correct:"Objektové soubory poskytnuté linkeru přímo se vždy stanou součástí výsledného spustitelného souboru.",incorrect:"Objektové soubory poskytnuté linkeru přímo se nikdy nestanou součástí výsledného spustitelného souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"f92c386c-33ab-491b-aec4-5e7a777071e2",correct:"Objektové soubory v archivech jsou použity pouze pokud poskytují symboly potřebné k dokončení spustitelného souboru.",incorrect:"Objektové soubory v archivech jsou použity vždy, bez ohledu na to, zda poskytují symboly potřebné k dokončení spustitelného souboru.",sectionNumber:"10.2.5",sectionTitle:"Linker"},{uuid:"f91496d7-7452-43b5-b271-671a9067ce8b",correct:"Linker je zodpovědný za přiřazení adres symbolům, které jsou definovány v programu.",incorrect:"Kompilátor je zodpovědný za přiřazení adres symbolům, které jsou definovány v programu.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"fa802ccd-ed7a-466b-a703-d2c703c4aec5",correct:"Symbolická jména v programovacím jazyce jsou překládána na adresy až v fázi linkování.",incorrect:"Symbolická jména v programovacím jazyce jsou překládána na adresy již v fázi kompilace.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"d0aab571-a599-4feb-a8c8-dbd05f22840c",correct:"Strojové instrukce používají adresy pro volání podprogramů a přístup k datům v paměti.",incorrect:"Strojové instrukce používají symbolická jména přímo pro volání podprogramů a přístup k datům.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"ae1b8428-be73-44fe-9ac1-0136fe65a314",correct:"Programátor při psaní kódu obvykle pracuje se symbolickými jmény, nikoliv s fyzickými adresami paměti.",incorrect:"Programátor při psaní kódu musí manuálně přiřazovat fyzické adresy paměti proměnným a funkcím.",sectionNumber:"10.2.6",sectionTitle:"Symbols vs Addresses"},{uuid:"dd6a8951-1f36-43ad-9cdf-c2bb5f92afdc",correct:"Linker postupně zpracovává objektové soubory a aktualizuje tabulku symbolů pro každý z nich.",incorrect:"Linker zpracovává všechny objektové soubory najednou a tabulku symbolů aktualizuje až po jejich kompletním načtení.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"83a4cebf-68ed-4d47-9575-d87e00cba554",correct:"Symbolová tabulka v linkeru slouží k mapování symbolických jmen na jejich absolutní adresy v paměti.",incorrect:"Symbolová tabulka v linkeru slouží pouze k dočasnému uložení symbolických jmen bez vazby na adresy.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"741f7083-78c3-4fa2-a3a8-179957dd1604",correct:"Aktualizace symbolové tabulky linkeru probíhá inkrementálně s každým dalším zpracovaným objektovým souborem.",incorrect:"Aktualizace symbolové tabulky linkeru probíhá jednorázově až po načtení všech objektových souborů.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"648fa573-18d7-492f-9a41-d6590b349c1e",correct:"Proces relokace symbolů, spočívající v nalezení a dosazení adres, se provádí až po kompletním sloučení všech sekcí.",incorrect:"Proces relokace symbolů se provádí průběžně ihned po načtení každé sekce z objektových souborů.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"682cbed0-dded-4283-bab3-89d7cecb896d",correct:"Výstupní spustitelný soubor linkeru obsahuje pro každý typ sekce, jako .text a .data, právě jednu souhrnnou sekci.",incorrect:"Výstupní spustitelný soubor linkeru obsahuje pro každý vstupní objektový soubor oddělené sekce .text a .data.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"bb5ae495-0884-49db-8eaa-743a00df41bf",correct:"Relokační tabulka zaznamenává adresy instrukcí, které vyžadují doplnění o konkrétní adresy symbolů pro správné provedení.",incorrect:"Relokační tabulka zaznamenává pouze symboly, jejichž adresy je nutné dodatečně doplnit, bez ohledu na instrukce.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"870c47f6-5e93-4ab0-85d9-3bbfc5988930",correct:"Zachování symbolové tabulky ve výstupním souboru je volitelné a může být užitečné pro účely ladění a analýzy.",incorrect:"Symbolová tabulka je vždy povinně odstraněna z výstupního souboru, protože není potřebná pro běh programu.",sectionNumber:"10.2.7",sectionTitle:"Resolving Symbols"},{uuid:"16dd1410-8315-42c9-812f-a97cb09b48f5",correct:"Výstupem linkeru je spustitelný soubor, který má obvykle stejný formát jako objektové soubory.",incorrect:"Výstupem linkeru je spustitelný soubor, který má formát zcela odlišný od objektových souborů.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"80e2983b-9cd6-48d6-9a20-7e531116d428",correct:"Statické spustitelné soubory mohou být přímo spuštěny CPU bez nutnosti dalších úprav adres.",incorrect:"Statické spustitelné soubory vyžadují další úpravy adres a relokací před spuštěním CPU.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"38cfc969-3c9e-44f1-8730-25437f371f22",correct:"Virtuální adresy ve spustitelných souborech umožňují různým programům používat překrývající se adresy.",incorrect:"Virtuální adresy ve spustitelných souborech vyžadují, aby různé programy používaly disjunktní adresní prostory.",sectionNumber:"10.2.8",sectionTitle:"Executable"},{uuid:"6108905b-3140-4338-ac27-66aa5827b7cd",correct:"Sdílené knihovny se načítají do paměti pouze jednou, i když je používá více programů.",incorrect:"Sdílené knihovny se načítají do paměti pro každý program, který je používá, zvlášť.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"e642617f-f8b2-493f-bf77-03c86b040767",correct:"Závislosti sdílených knihoven tvoří orientovaný acyklický graf (DAG).",incorrect:"Závislosti sdílených knihoven tvoří orientovaný cyklický graf.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"7dfc7a01-1655-4874-a6ab-383d6bc65c20",correct:"Pro řešení symbolických jmen v sdílených knihovnách se používá runtime linker v operačním systému.",incorrect:"Pro řešení symbolických jmen v sdílených knihovnách se používá standardní kompilátor.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"d4013a72-2c0a-4138-aa90-7eced300fac8",correct:"Sdílené knihovny mohou mít závislosti na jiných sdílených knihovnách.",incorrect:"Sdílené knihovny nemohou mít závislosti na jiných sdílených knihovnách a jsou zcela izolované.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"a1fc1bea-284a-4665-872c-951d3c8b2c75",correct:"Runtime linker je podobný linkeru z doby kompilace, ale funkčně se od něj liší.",incorrect:"Runtime linker je v podstatě identický s linkerem používaným v době kompilace.",sectionNumber:"10.2.9",sectionTitle:"Shared Libraries"},{uuid:"431cb2f0-15e9-4026-b5d1-2cd28953f988",correct:"Pro spuštění programu musí být program zaveden do paměti.",incorrect:"Pro spuštění programu nemusí být program zaveden do paměti.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"93a8ce8d-d2ba-44ad-bd4d-8db1ff7b5ea3",correct:"Sdílené knihovny používají kód nezávislý na pozici, aby mohly být zavedeny na libovolné adrese.",incorrect:"Sdílené knihovny používají absolutní adresy, aby mohly být zavedeny pouze na pevně dané adrese.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"14536c05-7ce0-4cef-84be-0ca7e2fd118f",correct:"Kód nezávislý na pozici umožňuje sdíleným knihovnám být zavedeny na různých adresách v paměti pro různé programy.",incorrect:"Kód nezávislý na pozici vyžaduje, aby sdílené knihovny byly zavedeny na stejné adrese v paměti pro všechny programy.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"0649b74b-f1e0-46c0-9a0a-ee75bddb31b3",correct:"Použití kódu nezávislého na pozici v sdílených knihovnách může způsobit mírnou režii při provádění.",incorrect:"Použití kódu nezávislého na pozici v sdílených knihovnách nezpůsobuje žádnou režii při provádění.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"65324b63-a738-4538-9a80-a171b83eea0d",correct:"Naivní přístup s fixními adresami pro sdílené knihovny se stává nepraktickým s rostoucím počtem knihoven kvůli konfliktům adres.",incorrect:"Naivní přístup s fixními adresami pro sdílené knihovny je praktický i s rostoucím počtem knihoven bez konfliktů adres.",sectionNumber:"10.2.10",sectionTitle:"Addresses Revisited"},{uuid:"997c272b-494b-44b4-aedc-93d57313029e",correct:"Na mnoha systémech UNIX jsou překladač a linker standardně součástí systému.",incorrect:"Na všech systémech UNIX jsou překladač a linker standardně součástí systému.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"2ab02509-b827-479b-9aa6-aeb53b9d0633",correct:"Překladač jazyka C se obvykle vyvolává příkazem ‹cc›.",incorrect:"Překladač jazyka C se nikdy nevyvolává příkazem ‹cc›.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"f88c6e42-467a-47e3-b061-b3bd0de4bae0",correct:"Pro správu archivů, statických knihoven, se používá program ‹ar›.",incorrect:"Pro správu archivů, statických knihoven, se používá program ‹ld›.",sectionNumber:"10.2.11",sectionTitle:"Compiler, Linker &c."},{uuid:"9e423ee2-60ca-4630-b1c9-e42985718eeb",correct:"V souladu s filozofií Unixu jsou adresáře považovány za speciální typ souborů umožňující čtení metadat.",incorrect:"V souladu s filozofií Unixu jsou adresáře považovány za speciální typ souborů umožňující přímou editaci obsahu textovým editorem.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"79fe0847-480c-49cd-98f9-537a2f459174",correct:"V Unixu je koncept souboru zobecněn natolik, že zahrnuje i hardwarová zařízení jako tiskárny a zvukové karty.",incorrect:"V Unixu je koncept souboru omezen pouze na fyzické soubory uložené na diskovém úložišti.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"9f5c818e-e533-4104-81f6-de172c7e66a0",correct:"Roury (pipes) v Unixu představují formu souboru, která umožňuje jednosměrnou komunikaci mezi dvěma procesy.",incorrect:"Roury (pipes) v Unixu jsou implementovány výhradně pomocí síťových protokolů a nemají nic společného s konceptem souboru.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"be9a1a00-66e1-4b66-9475-babd5b338068",correct:"Síťová připojení v Unixu sdílejí princip abstrakce souboru, což zjednodušuje práci se sítí.",incorrect:"Síťová připojení v Unixu obcházejí koncept souboru a vyžadují specializované systémové volání pro komunikaci.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"6e792b84-0475-4031-9733-8e5d044d00f1",correct:"Základní abstrakcí souboru v Unixu je možnost sekvenčního i přímého čtení a zápisu bajtů.",incorrect:"Základní abstrakcí souboru v Unixu je pouze sekvenční přístup pro čtení a zápis dat.",sectionNumber:"10.3.1",sectionTitle:"Everything is a File"},{uuid:"2c9896b5-5f74-41cb-b36b-90cf9df39148",correct:"Opakované použití API souborového systému pro objekty podobné souborům zvyšuje flexibilitu a zjednodušuje systém.",incorrect:"Opakované použití API souborového systému pro objekty podobné souborům snižuje flexibilitu a komplikuje systém.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"d7e71ba8-7f5b-4a5e-a2ed-330aad2dba04",correct:"Díky existujícímu API pro abstraktní soubory je rozumné ho použít i pro jiné objekty, které se chovají jako soubory.",incorrect:"Díky existujícímu API pro abstraktní soubory není rozumné ho použít i pro jiné objekty, které se chovají jako soubory.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"56091e65-b3d5-4b4f-bccb-76f9f8b1fa94",correct:"Opakované použití mechanismů, jako API souborů, obecně vede k flexibilnějším a jednodušším systémům.",incorrect:"Opakované použití mechanismů, jako API souborů, obecně vede k méně flexibilním a složitějším systémům.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"60d3dc4e-19a9-4625-a07e-15d2252130ca",correct:"Pro práci s objekty podobnými souborům je výhodné používat existující nástroje příkazové řádky založené na souborech.",incorrect:"Pro práci s objekty podobnými souborům není výhodné používat existující nástroje příkazové řádky založené na souborech.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"08653595-4ad1-4ff4-92e1-181dcdc10ae0",correct:"Snaha o jednoduchost návrhu operačního systému je žádoucí, protože snižuje pravděpodobnost výskytu chyb.",incorrect:"Snaha o jednoduchost návrhu operačního systému není žádoucí, protože nezáleží na pravděpodobnosti výskytu chyb.",sectionNumber:"10.3.2",sectionTitle:"Why is Everything a File"},{uuid:"5433e846-78f0-4eb2-b17a-397c570e24af",correct:"Cesty v souborových systémech slouží k navigaci a odkazování na soubory a adresáře.",incorrect:"Cesty v souborových systémech slouží pouze k pojmenování souborů, nikoliv k navigaci.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"c9db1be2-e915-4203-91f4-0aae849671ab",correct:"Úvodní lomítko v cestě, například /usr/include, značí začátek od kořenového adresáře.",incorrect:"Úvodní lomítko v cestě, například /usr/include, značí začátek od aktuálního adresáře.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"6a4607d7-32e1-4c1c-8393-93510eb04058",correct:"V cestách souborového systému se jako oddělovač adresářů používá znak lomítko.",incorrect:"V cestách souborového systému se jako oddělovač adresářů používá znak tečka.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"d0b2f7cb-5600-4816-afd1-c99c553c13ed",correct:"Každý prvek cesty, kromě kořenového adresáře, představuje jméno adresáře nebo souboru.",incorrect:"Každý prvek cesty představuje fyzické umístění dat na disku.",sectionNumber:"10.3.3",sectionTitle:"Reminder: File Paths"},{uuid:"8a46943f-ba53-4ddf-bdbb-b9d6d9a244c1",correct:"V systémech typu Plan9 je souborový systém koncipován tak, že téměř vše, co může být souborovým systémem, je jím.",incorrect:"V systémech typu Plan9 je souborový systém méně centrální než v tradičních systémech UNIX.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"c5a2d79e-aefe-49cf-86c7-a72ffd2755c9",correct:"Většina systémů UNIX, včetně Linuxu, používá souborový systém jako klíčový prvek pro přístup k různým funkcím OS, například skrze /proc a /sys.",incorrect:"Většina systémů UNIX se spoléhá na souborový systém jen pro ukládání dat, nikoliv pro přístup k funkcím operačního systému.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"2e4d13c9-cc4a-4612-aa58-6ed0c87d11c2",correct:"Systémy Android a iOS záměrně omezují přístup běžných aplikací a uživatelů k souborovému systému, ačkoliv jsou založeny na POSIXu.",incorrect:"Systémy Android a iOS plně zpřístupňují souborový systém aplikacím a uživatelům, podobně jako tradiční systémy POSIX.",sectionNumber:"10.3.4",sectionTitle:"The Role of Files and Filesystems"},{uuid:"b1a6f7c0-82e5-4061-b0a2-90cd3646db55",correct:"Pro práci se souborem je obvykle nutné jej nejprve otevřít pomocí systémového volání `open()`.",incorrect:"Pro práci se souborem není nutné jej otevírat, stačí rovnou použít systémová volání `read()` nebo `write()`.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"ecb0611f-6a3b-40ef-a065-41daf4889b06",correct:"Po otevření souboru je možné z něj číst data a také do něj zapisovat data pomocí systémových volání `read()` a `write()`.",incorrect:"Po otevření souboru je možné z něj pouze číst data, ale nelze do něj zapisovat, to vyžaduje speciální režim otevření.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"77cb9da7-ed59-4126-ae11-074e4681d942",correct:"Systémové volání `close()` slouží k uvolnění systémových zdrojů, které byly alokovány při operaci `open()` souboru.",incorrect:"Systémové volání `close()` slouží k okamžitému fyzickému smazání souboru z disku, pokud s ním již nepracujeme.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"2bf102ed-77b8-408c-92ec-65e6e5c08b11",correct:"Přejmenování souboru pomocí `rename()` je považováno za operaci s adresářem, nikoliv přímo se souborem.",incorrect:"Přejmenování souboru pomocí `rename()` je operace, která se provádí přímo na souboru a adresáře se jí netýkají.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"5bda4468-00c0-469d-976e-d05c9edd99a1",correct:"Systémové volání `unlink()` odstraňuje záznam o souboru z adresáře, čímž soubor přestane být dostupný v systému souborů.",incorrect:"Systémové volání `unlink()` fyzicky smaže data souboru z diskového prostoru, záznam v adresáři zůstává zachován.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"d2201560-4258-4819-9645-131c345a5364",correct:"Pro vytváření nových adresářů v systému souborů se používá systémové volání `mkdir()`.",incorrect:"Pro vytváření nových adresářů v systému souborů se používá systémové volání `create_dir()`.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"52595e6d-56e4-42ff-8c13-6f16f95bc9ea",correct:"Pro běžnou práci s adresáři není nutné je explicitně otevírat pomocí systémového volání `open()`, i když to systém POSIX umožňuje.",incorrect:"Pro jakoukoliv práci s adresáři, včetně výpisu obsahu nebo vytváření souborů v nich, je nutné adresář nejprve otevřít.",sectionNumber:"10.3.5",sectionTitle:"The Filesystem API"},{uuid:"f3506e67-063c-48f6-a900-2e6d8a378915",correct:"Jádro operačního systému udržuje tabulku otevřených souborů a souborový deskriptor je index do této tabulky.",incorrect:"Jádro operačního systému udržuje tabulku otevřených souborů, ale souborový deskriptor není index do této tabulky.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"ce35ffea-158f-48b3-bc2b-2c13f0b79842",correct:"Souborové deskriptory umožňují jádru operačního systému vyhledat metadata souboru v konstantním čase.",incorrect:"Souborové deskriptory umožňují jádru operačního systému vyhledat metadata souboru v lineárním čase.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"5ca79ad3-d391-45a7-8d33-b2702ebb25de",correct:"V systémech Windows se koncept souborového deskriptoru označuje termínem handle.",incorrect:"V systémech Windows se koncept souborového deskriptoru označuje termínem pointer.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"caacd468-0e76-4984-b128-8917cf7d6c9f",correct:"Cesta k souboru není ideální pro jeho identifikaci kvůli možnosti přejmenování nebo nahrazení souboru.",incorrect:"Cesta k souboru je ideální pro jeho identifikaci, protože soubory nemohou být přejmenovány nebo nahrazeny.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"71926f11-a5df-4be3-b452-1cd4122d99a9",correct:"Vyhledávání souboru pomocí cesty je výpočetně nákladnější operace než vyhledávání pomocí deskriptoru.",incorrect:"Vyhledávání souboru pomocí cesty je stejně rychlé jako vyhledávání pomocí souborového deskriptoru.",sectionNumber:"10.3.6",sectionTitle:"File Descriptors"},{uuid:"688db036-7491-4085-8b99-2ccad04907c4",correct:"V systému UNIX jsou všechny souborové systémy sjednoceny do jediné hierarchie.",incorrect:"V systému UNIX má každý souborový systém vlastní hierarchii reprezentovanou písmenem disku.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"ec02628e-f669-4d6a-a14e-58b7940ff8cb",correct:"V UNIXu se kořenový adresář jednoho souborového systému stává připojovacím bodem v jiném souborovém systému.",incorrect:"V UNIXu se kořenový adresář jednoho souborového systému stává kořenovým adresářem celého systému.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"67f91806-d973-4b6a-90c3-ecf9400bdc0d",correct:"Systém Windows používá písmena jednotek, jako například C: a D:, k reprezentaci samostatných souborových systémů.",incorrect:"Systém Windows sjednocuje všechny souborové systémy do jediné hierarchie, podobně jako UNIX.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"21a70d91-3455-443d-8e3c-09528ff14a03",correct:"Pokud se v UNIXu připojí souborový systém na neprázdný adresář, původní obsah tohoto adresáře se skryje.",incorrect:"Pokud se v UNIXu připojí souborový systém na neprázdný adresář, původní obsah tohoto adresáře se sloučí s obsahem připojeného systému.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"b33cb1ac-8e75-4a69-8261-ecab7ac51b3a",correct:"V systému UNIX je jeden souborový systém vybrán jako kořenový, jehož kořenový adresář '/' je stejný jako kořenový adresář systému.",incorrect:"V systému UNIX jsou všechny souborové systémy považovány za kořenové a mají kořenový adresář '/’.",sectionNumber:"10.3.7",sectionTitle:"Mounts"},{uuid:"384cc2cb-6874-404b-b7bf-95dadae4eb61",correct:"Socket API pochází z raného BSD Unixu.",incorrect:"Socket API pochází z moderního Linuxového jádra.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"cadf904c-27f6-48f2-b8d4-84f70b060c3b",correct:"Socket reprezentuje síťové připojení mezi procesy.",incorrect:"Socket reprezentuje lokální souborový deskriptor.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"63ab3d5f-af58-49af-b9a3-eeda87939db6",correct:"Pro otevřený socket získáte deskriptor souboru.",incorrect:"Pro otevřený socket získáte ukazatel do paměti.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"7e951387-8c00-4b26-aed5-54c3ecaac212",correct:"Můžete číst a zapisovat do socketů pomocí funkcí read() a write().",incorrect:"Můžete číst a zapisovat do socketů pomocí fopen() a fprintf().",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"71ee7766-dbb3-4b1e-a5e8-68e5a3e05334",correct:"Existují tři hlavní typy socketů: poslouchající, připojený a datagramový.",incorrect:"Existují pouze dva typy socketů: streamový a datagramový.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"d1565bf6-c773-4237-9925-6bfe88e47478",correct:"Poslouchající socket neslouží k přenosu dat, ale k navazování spojení.",incorrect:"Poslouchající socket primárně slouží k přímému přenosu dat mezi klienty.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"174138cf-c9bf-4a97-b1d2-30b380372a3a",correct:"Připojený socket se chová podobně jako obousměrná roura.",incorrect:"Připojený socket se chová jako jednosměrná roura pro výstup dat.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"3bd54446-435d-4dfd-be5a-eb69a877dd18",correct:"Datagramový socket umožňuje posílat data bez navazování trvalého spojení.",incorrect:"Datagramový socket vyžaduje navázání spojení před každým odesláním dat.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"8e0fc99b-dda5-4c18-89c5-77df18f79509",correct:"Servery poslouchají na specifické adrese, aby klienti mohli navázat spojení.",incorrect:"Klienti poslouchají na adrese serveru a aktivně iniciují spojení.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"b357c12d-737d-4b24-bdf9-b7e88f9837fd",correct:"Sockets jsou v jistém smyslu zobecněním konceptu rour pro síťovou komunikaci.",incorrect:"Roury jsou modernější a flexibilnější variantou socketů pro síťovou komunikaci.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"e34a0dbe-d776-4b4d-a947-039d8737ee8d",correct:"Navazování spojení u socketů je složitější než práce s běžnými soubory.",incorrect:"Navazování spojení u socketů je stejně jednoduché jako otevření běžného souboru.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"fd98cbb0-f890-4af1-a72d-86e7851f7c4d",correct:"Ztráta paketů je běžným jevem při komunikaci přes sockety v síti.",incorrect:"Ztráta paketů je u socketů extrémně vzácná díky spolehlivosti sítě.",sectionNumber:"10.3.8",sectionTitle:"Sockets"},{uuid:"8f23d085-885d-4366-8079-7fc2add9f7e7",correct:"Internetové sockety slouží pro komunikaci mezi různými počítači a využívají protokol TCP/IP.",incorrect:"Internetové sockety slouží výhradně pro lokální komunikaci v rámci jednoho počítače.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"488a720f-6b43-40e3-b31a-5677b256af2b",correct:"Unixové sockety pro lokální komunikaci mají cestu v systému souborů podobně jako pojmenované roury.",incorrect:"Unixové sockety pro lokální komunikaci nemají cestu v systému souborů a nepodobají se pojmenovaným rourám.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"ba25fd89-2c9d-4b46-aff7-4eff3270afe2",correct:"Streamové sockety umožňují zápis souvislého proudu dat, podobně jako fungují roury v operačním systému.",incorrect:"Streamové sockety slouží k posílání jednotlivých zpráv a neumožňují souvislý proud dat.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"54fa157b-7cc3-4f13-95a7-bdcc81047386",correct:"Datagramové sockety se používají pro posílání jednotlivých zpráv, zatímco streamové sockety pro souvislý tok dat.",incorrect:"Datagramové sockety se používají pro souvislý tok dat, zatímco streamové sockety pro posílání jednotlivých zpráv.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"},{uuid:"6b6b17b0-0080-472e-bbbc-2d2c58a0c7be",correct:"Existují dva základní typy adres socketů: internetové a unixové, lišící se účelem komunikace.",incorrect:"Existuje pouze jeden základní typ adres socketů, který je univerzální pro všechny druhy komunikace.",sectionNumber:"10.3.9",sectionTitle:"Socket Types"}]},{uuid:"a696dee9-3091-4a3e-9d9b-88b4bf4c1266",sectionNumber:"11",sectionTitle:"The Kernel",statements:[{uuid:"4b49ab24-d1dc-470f-aa4b-71b15da88249",correct:"Moderní univerzální procesory typicky disponují režimem supervizora a uživatelským režimem.",incorrect:"Moderní univerzální procesory pracují pouze v uživatelském režimu bez režimu supervizora.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"dafc8566-7f7e-4694-8b3d-618dcb8470ea",correct:"Architektura x86 poskytuje čtyři odlišné úrovně oprávnění, označované jako ringy 0 až 3.",incorrect:"Architektura x86 poskytuje pouze dvě úrovně oprávnění, ring 0 a ring 3.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"009dae67-d7a4-4e00-8b38-4050a8e62ca9",correct:"Hypervisor Xen může využívat ring 1 pro běh kernelů hostovaných operačních systémů.",incorrect:"Hypervisor Xen nikdy nevyužívá ring 1 a spoléhá se pouze na ring 0 a ring 3.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"3560bc97-8d2a-42ee-b687-c84b2aa55581",correct:"Pouze programy běžící v supervizorském režimu mohou provádět určité privilegované operace.",incorrect:"Programy v uživatelském režimu mají stejná oprávnění k provádění operací jako programy v supervizorském režimu.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"2cf06d06-58a1-4572-81cf-26c3949338c9",correct:"Ovladače zařízení mohou běžet v méně privilegované úrovni než jádro operačního systému.",incorrect:"Ovladače zařízení musí běžet ve stejném nebo vyšším privilegovaném režimu jako jádro operačního systému.",sectionNumber:"11.1.1",sectionTitle:"CPU Modes"},{uuid:"a86a00fc-e3c1-4a63-a529-3c5f4f26bccc",correct:"Kernel operačního systému běží v privilegovaném režimu procesoru.",incorrect:"Kernel operačního systému běží v uživatelském režimu procesoru.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"4ced23a5-7a0e-46e6-9d8a-8d00042dd7b5",correct:"V privilegovaném režimu může software programovat jednotku správy paměti MMU.",incorrect:"V uživatelském režimu může software programovat jednotku správy paměti MMU.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"4626ab91-e36c-4e11-bfb9-2a0d7de3f43a",correct:"Většina kódu operačního systému, včetně knihoven a démonů, běží v uživatelském režimu.",incorrect:"Většina kódu operačního systému, včetně knihoven a démonů, běží v privilegovaném režimu.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"8c9dc983-6051-4310-8cb1-b5b50b626f80",correct:"Uživatelský režim procesoru je navržen jako více omezený než privilegovaný režim.",incorrect:"Uživatelský režim procesoru je navržen jako méně omezený než privilegovaný režim.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"6d984243-7970-4e45-8e3c-4268e477c36a",correct:"Kód běžící v privilegovaném režimu má možnost měnit paměť libovolného běžícího programu.",incorrect:"Kód běžící v uživatelském režimu má možnost měnit paměť libovolného běžícího programu.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"fbb55a61-e03a-4308-9261-62cb92f4d8f1",correct:"Jednotka správy paměti (MMU) je klíčová pro implementaci oddělení paměti mezi programy.",incorrect:"Jednotka správy paměti (MMU) není relevantní pro implementaci oddělení paměti mezi programy.",sectionNumber:"11.1.2",sectionTitle:"Privileged Mode"},{uuid:"ae545e08-651c-4465-bab8-4a19fa2c1b58",correct:"MMU je subsystém procesoru, který se stará o překlad virtuálních adres na fyzické.",incorrect:"MMU je subsystém paměti, který se stará o přidělování fyzické paměti procesům.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"bcbbad53-2866-420d-8e97-12c1cb820863",correct:"Programy používají virtuální adresy, které jsou překládány MMU na fyzické adresy.",incorrect:"Programy používají fyzické adresy, které jsou překládány MMU na virtuální adresy.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"d78720e9-bdf4-4077-b7c7-9de544661c10",correct:"Operační systém (jádro) spravuje mapování virtuálních adres na fyzické adresy v MMU.",incorrect:"Uživatelský prostor spravuje mapování virtuálních adres na fyzické adresy v MMU.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"542524db-9bc4-461c-a770-5c1422f6c4e8",correct:"Jádro operačního systému poskytuje MMU překladové tabulky pro adresový překlad.",incorrect:"MMU si dynamicky vytváří překladové tabulky bez zásahu jádra operačního systému.",sectionNumber:"11.1.3",sectionTitle:"Reminder: Memory Management Unit"},{uuid:"96121a78-cdff-4335-96dd-d6857208cd7b",correct:"Mapování jádra do všech procesů zvyšuje výkon, ale přináší i bezpečnostní rizika jako Meltdown.",incorrect:"Mapování jádra pouze do některých procesů je běžná technika pro zvýšení bezpečnosti systému.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"55f97d20-0acd-43ba-a5ab-de3c4013e749",correct:"Stránky jádra chrání speciální příznak supervizora, který zakazuje přístup z uživatelského režimu.",incorrect:"Uživatelský režim má plný přístup ke stránkám jádra, což umožňuje flexibilní správu paměti.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"facaf35b-c295-4f42-8b84-9e6641afc43b",correct:"Operační systémy se snaží minimalizovat nahrazování tabulek stránek kvůli jeho vysoké náročnosti.",incorrect:"Nahrazování tabulek stránek je nenáročná operace, běžně využívaná při systémových voláních.",sectionNumber:"11.1.4",sectionTitle:"Kernel Protection"},{uuid:"2f1f7f5c-127e-48c8-9ca7-afa7d6bf6037",correct:"Po zapnutí napájení je systém v implicitním stavu kvůli volatilitě RAM paměti.",incorrect:"Po zapnutí napájení je systém v plně funkčním stavu s operačním systémem v RAM.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"ad3df8f4-cac6-453a-95b1-8cf55f853f47",correct:"Dynamická RAM paměť po odpojení napájení rychle ztrácí svůj uložený obsah.",incorrect:"Dynamická RAM paměť uchovává data i po odpojení napájení díky stálému napájení z baterie.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"d60abf0d-7f73-4d20-b698-5464899f9328",correct:"Po zapnutí počítače je nutné inicializovat CPU a další hardwarové komponenty platformy.",incorrect:"Po zapnutí počítače se inicializuje pouze operační systém, hardware je již inicializován z výroby.",sectionNumber:"11.2.1",sectionTitle:"Starting the OS"},{uuid:"ba19d638-74b9-40fc-811e-616b2a2a13fc",correct:"Firmware zavádí bootloader z trvalého úložiště před zavedením kernelu.",incorrect:"Firmware zavádí kernel z trvalého úložiště před zavedením bootloaderu.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"dfd5d64c-240e-4046-8694-926615950961",correct:"Bootloader je považován za součást operačního systému a má za úkol zavést kernel.",incorrect:"Bootloader je považován za součást firmwaru a má za úkol zavést kernel.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"52a50014-d24d-4c49-a5d0-a37aa542204e",correct:"Jednoduchý bootloader může pro zavedení kernelu používat seznam diskových bloků.",incorrect:"Jednoduchý bootloader vždy rozumí složitým souborovým systémům pro zavedení kernelu.",sectionNumber:"11.2.2",sectionTitle:"Boot Process"},{uuid:"ea34eab6-b72e-4261-a60a-77e7aa57bf64",correct:"CPU x86 se po startu spouští v 16bitovém režimu z důvodu zpětné kompatibility.",incorrect:"CPU x86 se po startu spouští v 64bitovém režimu z důvodu zpětné kompatibility.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"c8ded9ef-f8c1-4386-95a7-0bf156ee2ba0",correct:"V 16bitovém režimu procesoru x86 je MMU standardně deaktivována.",incorrect:"V 16bitovém režimu procesoru x86 je MMU standardně aktivována.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"be3e0601-eec7-4fc0-ac71-16f990362a7b",correct:"Jádro operačního systému přepíná CPU x86 do chráněného režimu z 16bitového režimu.",incorrect:"Jádro operačního systému ponechává CPU x86 v 16bitovém režimu.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"31afcfec-f431-44e3-be3f-653346c75f45",correct:"Firmware může u moderních 64bitových x86 procesorů přepnout CPU do 64bitového režimu před bootloaderem.",incorrect:"Firmware u moderních 64bitových x86 procesorů nikdy nepřepíná CPU do 64bitového režimu.",sectionNumber:"11.2.3",sectionTitle:"CPU Init"},{uuid:"71dce89f-b12f-41d6-b120-0441db225210",correct:"Bootloader je krátký program specifický pro platformu, který zavádí jádro z trvalého úložiště do RAM.",incorrect:"Bootloader je rozsáhlý program nezávislý na platformě, který zavádí ovladače zařízení z operační paměti.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"0bbb2f79-ade4-40f0-9b3d-292e7dc0d2ba",correct:"V moderních x86 systémech firmware s rozhraním FAT usnadňuje bootování načítáním souborů do paměti.",incorrect:"V moderních x86 systémech firmware nerozumí souborovému systému FAT a musí používat nízkoúrovňový přístup k disku.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"d50c875c-25ef-4044-b6c4-a104f37066ac",correct:"Bootování ARM systémů je komplikovanější kvůli menší standardizaci a nutnosti přizpůsobení bootloaderu pro SoC.",incorrect:"Bootování ARM systémů je jednodušší než x86 díky jednotnému firmware rozhraní a vysoké standardizaci hardwaru.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"23a8bcf8-2d1d-4545-91ec-b8c48192a9ca",correct:"U-boot se stal de-facto standardem pro bootování ARM systémů, i když vyžaduje adaptaci pro každý SoC.",incorrect:"U-boot je pouze okrajově používaný pro bootování ARM systémů a většina výrobců používá vlastní bootloadery.",sectionNumber:"11.2.4",sectionTitle:"Bootloader"},{uuid:"ee08fb82-fa00-482c-a40d-cb9facc8d33a",correct:"Kernel inicializuje ovladače zařízení před hledáním root filesystemu.",incorrect:"Kernel inicializuje root filesystem před inicializací ovladačů zařízení.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"5390e66c-4b9d-4c87-9064-d2963434fd68",correct:"Po inicializaci root filesystemu kernel spouští init proces a předává mu řízení.",incorrect:"Před inicializací root filesystemu kernel spouští init proces a předává mu řízení.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"3cf7b58f-79e5-4e3a-8aae-fc0c7fba21cd",correct:"Bootloader zavádí kernel do RAM a skáče na předem určenou adresu pro start inicializace.",incorrect:"Bootloader zavádí kernel do persistentního úložiště a skáče na předem určenou adresu pro start inicializace.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"c34679b7-979e-4aee-88f1-2717d08f83cf",correct:"Po spuštění init procesu se uživatelský prostor ujímá kontroly nad systémem.",incorrect:"Po spuštění init procesu kernel nadále řídí veškeré akce v systému.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"7f4bae10-0dda-479e-a413-f61a092a2690",correct:"Inicializace kernelu začíná nízkoúrovňovým nastavením CPU a základních periferií.",incorrect:"Inicializace kernelu začíná inicializací uživatelského prostoru a aplikací.",sectionNumber:"11.2.5",sectionTitle:"Kernel Boot"},{uuid:"9efa779a-ee25-42e7-b39a-59aafdadf21a",correct:"Proces init po zavedení systému připojí souborové systémy a spouští systémové služby uživatelského režimu.",incorrect:"Proces init po zavedení systému spouští pouze aplikační služby a nepřipojuje souborové systémy.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"60812212-0bcc-4ff2-a7ef-9af6f05162d6",correct:"Proces init spouští aplikační služby, které zahrnují i démoni, jež nejsou součástí operačního systému.",incorrect:"Proces init spouští aplikační služby, které jsou vždy klíčovou součástí samotného operačního systému.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"b1ac5469-6a53-4c1e-adb4-09650e297e00",correct:"Proces login je spuštěn procesem init až po dokončení startu všech nezbytných systémových služeb.",incorrect:"Proces login je spuštěn procesem init ještě před zahájením jakýchkoliv systémových služeb.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"0612cc31-c1cc-4ec4-aee6-d51b5015c0b6",correct:"Po spuštění procesu login se uživateli zobrazí přihlašovací obrazovka pro zadání jména a hesla.",incorrect:"Po spuštění procesu login se automaticky spustí grafické uživatelské rozhraní bez nutnosti přihlášení.",sectionNumber:"11.2.6",sectionTitle:"User-mode Initialisation"},{uuid:"d96003fd-98ad-42eb-af95-78e6cb3ccfd2",correct:"Přihlašovací proces inicializuje uživatelskou relaci.",incorrect:"Přihlašovací proces neinicializuje uživatelskou relaci.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"f464c73f-534e-4685-b907-1178806b062b",correct:"Během přihlášení se zavádí moduly desktopu a aplikační software.",incorrect:"Během přihlášení se zavádí pouze aplikační software, nikoli moduly desktopu.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"5cca15bd-35b5-4038-be88-d3d59cfed3bc",correct:"Po přihlášení je uživatel přesměrován do textového nebo grafického shellu.",incorrect:"Po přihlášení je uživatel přesměrován přímo do spuštěné aplikace.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"a562de58-6e31-4e2d-ab00-f6378997ee12",correct:"Nastavení relace po přihlášení umožňuje uživateli pracovat s počítačem.",incorrect:"Nastavení relace po přihlášení je zbytečné pro práci uživatele s počítačem.",sectionNumber:"11.2.7",sectionTitle:"After Log-In"},{uuid:"c1ac4671-66e1-4c19-9b7d-f15724733a14",correct:"Monolitické jádra představují nejrozsáhlejší a mikrokernelová jádra nejmenší návrh mainstreamových jader operačních systémů.",incorrect:"Mikrokernelová jádra jsou nejrozsáhlejší a monolitické jádra nejmenší návrh mainstreamových jader operačních systémů.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"f964119b-5f39-443e-943a-a90ce109edfc",correct:"Hybridní jádra kombinují mikrokernel a takzvaný superserver, což je osekané monolitické jádro.",incorrect:"Hybridní jádra kombinují monolitické jádro a takzvaný superserver, který je rozšířený mikrokernel.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"e303a469-5e39-405f-8f21-98d1e220d19a",correct:"Hypervisory typu 1 jsou považovány za specifický typ operačního systému, kde jsou aplikace virtuální stroje.",incorrect:"Hypervisory typu 1 jsou běžným typem operačního systému, který přímo spouští aplikace bez virtualizace.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"7c4309e6-30d4-482a-9294-40959405187a",correct:"Exokernelové operační systémy radikálně omezují služby poskytované aplikacím ve srovnání s monolitickými jádry.",incorrect:"Exokernelové operační systémy rozšiřují služby poskytované aplikacím nad rámec běžných monolitických jader.",sectionNumber:"11.3.1",sectionTitle:"Architecture Types"},{uuid:"f2d51065-ad61-4e7b-a66b-f68533b54e5d",correct:"Mikrokernel se stará o ochranu paměti programováním MMU.",incorrect:"Mikrokernel se nestará o ochranu paměti a nechává to na uživatelský prostor.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"c73ca7f7-9ebf-4e0f-81f7-7bf26f9348f0",correct:"Obsluha hardwarových přerušení je klíčovou součástí mikrokernelu.",incorrect:"Obsluha hardwarových přerušení se obvykle provádí mimo mikrokernel v uživatelském prostoru.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"040d8b21-b3b5-4edc-a9b2-dec757c5d8b6",correct:"Plánování úloh a procesů typicky spadá do kompetencí mikrokernelu.",incorrect:"Plánování úloh a procesů je obvykle implementováno jako samostatná služba mimo mikrokernel.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"4a2eb192-5dc4-4caa-8750-c7b46ec87a96",correct:"Mikrokernel poskytuje mechanismy pro předávání zpráv mezi procesy.",incorrect:"Mikrokernel se nezabývá předáváním zpráv mezi procesy a spoléhá na sdílenou paměť.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"8b932d21-fdd6-412d-bee6-ae16fd0e9f76",correct:"Mikrokernel poskytuje nízkoúrovňové služby pro ovladače zařízení, jako je programování DMA.",incorrect:"Mikrokernel neposkytuje žádné specifické služby pro ovladače zařízení kromě základních služeb pro procesy.",sectionNumber:"11.3.2",sectionTitle:"Microkernel"},{uuid:"d96345eb-70a3-4879-a3e0-2d26aa061360",correct:"Monolitické jádro zahrnuje vše, co mikrokernel, a navíc ovladače zařízení a souborové systémy.",incorrect:"Mikrokernel zahrnuje vše, co monolitické jádro, a navíc ovladače zařízení a souborové systémy.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"16eff613-f5ed-455c-9c6b-d037c68e6f24",correct:"Monolitické jádro integruje výkonově kritické ovladače zařízení přímo do kernelu.",incorrect:"Monolitické jádro neintegruje výkonově kritické ovladače zařízení přímo do kernelu.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"92bada91-be33-4a35-b4c3-480e8b48538c",correct:"TCP/IP stack je téměř vždy součástí monolitického jádra.",incorrect:"TCP/IP stack nikdy není součástí monolitického jádra.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"ede57709-07f9-4a07-99a5-2a0a8f1903a7",correct:"Kód monolitického jádra běží v privilegovaném režimu a má úplnou kontrolu nad systémem.",incorrect:"Kód monolitického jádra běží v uživatelském režimu a má omezenou kontrolu nad systémem.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"3baede32-c805-43f5-8fb3-02732ce3513d",correct:"Mikrokernel obvykle neobsahuje souborové systémy a správu svazků.",incorrect:"Mikrokernel obvykle obsahuje souborové systémy a správu svazků.",sectionNumber:"11.3.3",sectionTitle:"Monolithic Kernels"},{uuid:"360d8d6e-64ea-4e1e-be98-687a5c426b25",correct:"V mikrokernelovém operačním systému běží každý ovladač zařízení v samostatném procesu.",incorrect:"V mikrokernelovém operačním systému běží všechny ovladače zařízení v jednom procesu.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"3cee2233-1c29-4748-a3b8-2eeee7b6c368",correct:"Pravý mikrokernelový operační systém se skládá z mnoha modulů, které se nazývají servery.",incorrect:"Pravý mikrokernelový operační systém se skládá pouze z mikrokernelu a několika málo modulů.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"ece0c989-196c-4e51-b529-3af71cd6ac2c",correct:"V mikrokernelu jsou souborové systémy a síťové služby implementovány jako samostatné procesy, zvané servery.",incorrect:"V mikrokernelu jsou souborové systémy a síťové služby implementovány přímo v mikrokernelu.",sectionNumber:"11.3.4",sectionTitle:"Microkernel Redux"},{uuid:"a481ba7c-48dd-44c9-b478-743e51c2d0cb",correct:"Hybridní jádra operačních systémů jsou založena na mikrokernelu.",incorrect:"Hybridní jádra operačních systémů jsou založena na monolitickém kernelu.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"ce92704f-6e97-49a7-852b-4ecfe0734d9e",correct:"V hybridním jádře operačního systému je většina služeb poskytována superserverem.",incorrect:"V hybridním jádře operačního systému je většina služeb poskytována mikrokernelem.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"a76e8d93-1a7b-4f4f-9b53-f07c3a54ee72",correct:"Implementace hybridního jádra je jednodušší než implementace čistého mikrokernelu.",incorrect:"Implementace hybridního jádra je složitější než implementace čistého mikrokernelu.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"dc772c42-4d39-4c38-871a-0dc51ec47490",correct:"Hybridní jádra operačních systémů představují kompromis z hlediska výkonu.",incorrect:"Hybridní jádra operačních systémů dosahují nejlepšího možného výkonu.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"861b93dc-ed1b-4947-9cc8-31270acc7454",correct:"Superserver v hybridním jádře je částečně izolován od hardwaru.",incorrect:"Superserver v hybridním jádře je plně integrován s hardwarem.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"e5e4f8e6-899c-43c9-8aa3-5bf2365568f7",correct:"Server hybridního jádra je často založen na monolitickém kernelu.",incorrect:"Server hybridního jádra je často založen na distribuovaném systému.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"ec1d0d9d-22f3-4c87-9a3b-31b8bddf23c3",correct:"Návrh hybridních jader je levnější než návrh čistých mikrokernelových systémů.",incorrect:"Návrh hybridních jader je dražší než návrh čistých mikrokernelových systémů.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"fb3ea2d6-922d-42d1-9cef-3303a480dcb7",correct:"Hybridní jádra teoreticky dosahují lepšího výkonu než čisté mikrokernelové systémy.",incorrect:"Hybridní jádra teoreticky dosahují horšího výkonu než čisté mikrokernelové systémy.",sectionNumber:"11.3.5",sectionTitle:"Hybrid Kernels"},{uuid:"a4f4f0c5-147d-460a-bba5-75dd0ac92e92",correct:"Mikrokernelové architektury jsou robustnější díky menšímu jádru a izolaci serverů.",incorrect:"Monolitické architektury jsou robustnější díky menšímu jádru a izolaci serverů.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"f66de558-6a83-4336-a52c-4e50a31a9da9",correct:"Monolitická jádra nabízejí vyšší výkon, hlavně díky menšímu kontextovému přepínání.",incorrect:"Mikrokernelová jádra nabízejí vyšší výkon, hlavně díky menšímu kontextovému přepínání.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"676d86fa-9b86-4805-8a1a-3fe28e2c13c8",correct:"Monolitická jádra umožňují psát kód přímým synchronním stylem a snadněji sdílet datové struktury.",incorrect:"Mikrokernelová jádra umožňují psát kód přímým synchronním stylem a snadněji sdílet datové struktury.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"20788971-5faf-44f9-be8b-cbf0a4c4ee85",correct:"Mikrokernelové systémy často vyžadují asynchronní komunikaci a předávání zpráv, což ztěžuje implementaci.",incorrect:"Monolitické systémy často vyžadují asynchronní komunikaci a předávání zpráv, což ztěžuje implementaci.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"7b006219-7a01-4663-b60c-2a0304bc33ef",correct:"Výkonnostní rozdíl mezi monolitickými a mikrokernelemi se zmenšuje díky bezpečnostním vylepšením monolitických jader.",incorrect:"Výkonnostní rozdíl mezi monolitickými a mikrokernelemi se zvětšuje díky bezpečnostním vylepšením monolitických jader.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"c5b55400-786e-47ac-985f-220f3025da27",correct:"Z dlouhodobého hlediska mikrokernele nabízejí lepší modularitu a izolaci komponent.",incorrect:"Z dlouhodobého hlediska monolitické kernele nabízejí lepší modularitu a izolaci komponent.",sectionNumber:"11.3.6",sectionTitle:"Micro vs Mono"},{uuid:"c1f760eb-2c77-49df-bd23-8232abc1dc26",correct:"Exokernely poskytují aplikační izolaci na úrovni procesů, ale s velmi omezenými abstrakcemi operačního systému.",incorrect:"Exokernely neposkytují aplikační izolaci na úrovni procesů a nabízejí plnohodnotné abstrakce operačního systému.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"57b2d7d0-7f77-464c-b834-33b68db46975",correct:"Hypervizor může používat hrubší abstrakce než operační systém, například celé úložné zařízení místo systému souborů.",incorrect:"Hypervizor používá jemnější abstrakce než operační systém, například systém souborů místo celého úložného zařízení.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"7bf8d5ed-02c9-49be-a993-4005003ac390",correct:"Unikernely jsou navrženy pro běh jediné aplikace a poskytují podmnožinu tradičních abstrakcí operačního systému.",incorrect:"Unikernely jsou navrženy pro běh více aplikací a poskytují plnohodnotné tradiční abstrakce operačního systému.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"f070309b-1512-4c37-8281-43868e6a5572",correct:"Exokernely poskytují méně abstrakcí než mikrokernelové operační systémy.",incorrect:"Exokernely poskytují více abstrakcí než mikrokernelové operační systémy.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"8c331bc9-8516-43ff-a822-bd42eaa1c081",correct:"Unikernely se často spouštějí přímo na hypervizoru, aby se minimalizovala režie obecného operačního systému.",incorrect:"Unikernely se nikdy nespouštějí přímo na hypervizoru, protože vyžadují plnohodnotný operační systém pod nimi.",sectionNumber:"11.3.7",sectionTitle:"Other Kernel Types"},{uuid:"0b23a227-27bd-42a3-8aad-ac6714d688e3",correct:"Jádro operačního systému běží v privilegovaném režimu procesoru.",incorrect:"Uživatelský kód běží v privilegovaném režimu procesoru.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"b9746ae4-cae8-481e-a5c5-9cf9554feae3",correct:"Paměť jádra je chráněna před přímým přístupem z uživatelského kódu.",incorrect:"Uživatelský kód může přímo číst a zapisovat do paměti jádra.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"447ec85b-34b1-412d-a3af-4e77c3ac8af3",correct:"Uživatelský kód musí žádat jádro o služby pomocí systémových volání.",incorrect:"Uživatelský kód může přímo volat funkce jádra bez systémových volání.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"7f5a038c-8380-4144-b8b1-5c2ff23f067d",correct:"Systémová volání umožňují bezpečný přechod mezi uživatelským prostorem a jádrem.",incorrect:"Systémová volání umožňují uživatelskému kódu obejít bezpečnostní mechanismy jádra.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"69748e73-bd79-445e-b78b-ee03d40d948b",correct:"Mechanismus systémových volání přepíná CPU do privilegovaného režimu pro provedení kódu jádra.",incorrect:"Mechanismus systémových volání ponechává CPU v uživatelském režimu i během běhu kódu jádra.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"ac70523d-a23b-4b76-9a27-1c24f3e400cf",correct:"Aplikace nemůže spustit svůj vlastní kód v privilegovaném režimu pomocí systémových volání.",incorrect:"Aplikace může pomocí systémových volání spustit libovolný kód v privilegovaném režimu.",sectionNumber:"11.4.1",sectionTitle:"Reminder: Kernel Protection"},{uuid:"e0c5bd79-efc7-4f54-979d-1371efc09f4f",correct:"Systémová volání se chovají podobně jako standardní podprogramy z knihoven.",incorrect:"Systémová volání se chovají zcela odlišně od standardních podprogramů z knihoven.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"5faae2cd-a47c-4738-abf2-b2c1e37ef76d",correct:"Při systémovém volání se provádění předává kernelové rutině pro provedení operace.",incorrect:"Při systémovém volání se provádění ponechává uživatelskému prostoru bez zásahu kernelu.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"0edd8909-4102-46bb-8d59-0174e510765f",correct:"Argumenty pro systémové volání musí být předány do jádra bezpečným způsobem.",incorrect:"Argumenty pro systémové volání se předávají do uživatelského prostoru pro manipulaci jádrem.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"79eda6f3-cf7f-4b65-a3f4-971d084153d5",correct:"Z uživatelského prostoru by nemělo být možné číst ani modifikovat paměť jádra.",incorrect:"Uživatelský prostor má plný přístup ke čtení a modifikaci paměti jádra během volání.",sectionNumber:"11.4.2",sectionTitle:"System Calls"},{uuid:"67226360-3bf7-4653-b445-787052fbc88b",correct:"Systémová volání v operačních systémech jsou závislá na architektuře a spoléhají na pevnou vstupní adresu nastavenou jádrem.",incorrect:"Systémová volání v operačních systémech jsou nezávislá na architektuře a spoléhají na dynamicky určenou vstupní adresu.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"9e1b68ad-c7f2-4ab7-9afc-1b7be5cc56d4",correct:"Mechanismus systémových volání, ač závislý na architektuře, univerzálně zajišťuje eskalaci privilegií s přenosem na pevnou adresu.",incorrect:"Mechanismus systémových volání je nezávislý na architektuře a univerzálně umožňuje eskalaci privilegií bez přenosu na pevnou adresu.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"f1dc243e-3a6c-4320-8d1d-106df8806ae9",correct:"Na architektuře x86 mohou být systémová volání implementována pomocí instrukce softwarového přerušení, jako je `int`.",incorrect:"Na architektuře x86 jsou systémová volání implementována výhradně pomocí hardwarových přerušení, nikoli softwarových.",sectionNumber:"11.4.3",sectionTitle:"Trapping into the Kernel"},{uuid:"48beee78-bb3a-4513-84fc-993dd33adba4",correct:"Softwarová přerušení nejsou obecně příliš efektivní pro systémová volání kvůli režii spojené s ukládáním stavu procesoru.",incorrect:"Softwarová přerušení jsou obecně velmi efektivní pro systémová volání díky minimální režii spojené s ukládáním stavu procesoru.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"6d9d7462-07c0-4715-8e21-9c36acba962a",correct:"Adresa obslužné rutiny softwarového přerušení se získává z paměti, konkrétně z tabulky vektorů přerušení.",incorrect:"Adresa obslužné rutiny softwarového přerušení se získává přímo z registru procesoru, což zrychluje zpracování.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"abaa2ad7-36d0-4b27-bb6b-0bf703709c57",correct:"Mechanismus softwarových přerušení vyžaduje uložení značného množství stavu procesoru, což přispívá k latenci systémových volání.",incorrect:"Mechanismus softwarových přerušení vyžaduje uložení pouze minimálního stavu procesoru, čímž se minimalizuje latence systémových volání.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"c0192c84-ed22-433a-97e8-e2565318b14c",correct:"Na architektuře x86 byla softwarová přerušení preferovaným mechanismem pro systémová volání do konce 32bitové éry procesorů.",incorrect:"Na architektuře x86 jsou softwarová přerušení stále preferovaným a nejefektivnějším mechanismem pro systémová volání i v 64bitové éře.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"7bd455e0-3874-424c-9ba4-c05478fecdb4",correct:"Procesory x86 od modelu 80386 nabízely mechanismus syscall, který byl však operačními systémy zpočátku spíše ignorován.",incorrect:"Procesory x86 od modelu 80386 nabízely mechanismus syscall, který byl operačními systémy okamžitě široce přijat a využíván.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"b7144b30-ab84-4c6a-8dd3-97163a3e2660",correct:"Softwarová přerušení se používala jak v reálném módu, například pro BIOS a MS-DOS, tak i v chráněném módu pro moderní OS.",incorrect:"Softwarová přerušení se používala výhradně v chráněném módu moderních operačních systémů a nikdy nebyla využívána v reálném módu.",sectionNumber:"11.4.4",sectionTitle:"Aside: Software Interrupts"},{uuid:"41ce1d53-6e26-4d71-a0b4-9ca17a1d4b8a",correct:"Instrukce sysenter a syscall pro eskalaci privilegií mají pouze jeden vstupní bod.",incorrect:"Instrukce sysenter a syscall pro eskalaci privilegií mají více vstupních bodů.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"bc8acec1-31c8-45f9-9989-dd7f65399164",correct:"Mechanismus sysenter a syscall je rychlejší než softwarová přerušení díky minimalizaci režie.",incorrect:"Mechanismus sysenter a syscall je pomalejší než softwarová přerušení kvůli větší režii.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"3c879767-9c17-4b18-8d95-9b162929efb8",correct:"Stav výpočtu je u sysenter a syscall spravován softwarově, na rozdíl od přerušení.",incorrect:"Stav výpočtu je u sysenter a syscall spravován hardwarově, podobně jako u přerušení.",sectionNumber:"11.4.5",sectionTitle:"Syscall instructions: ‹amd64› / ‹x86_64›"},{uuid:"a0bffc50-8062-40ad-ab47-c823ff7c4a3b",correct:"Moderní operační systémy, jako Linux a Windows, typicky poskytují stovky systémových volání.",incorrect:"Moderní operační systémy, jako Linux a Windows, poskytují pouze desítky systémových volání.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"99016920-e64b-44a9-b4e7-4b3fc6e85cdb",correct:"Pro zpracování systémových volání operační systémy obvykle využívají jediný vstupní bod.",incorrect:"Pro každé systémové volání operační systémy vyžadují dedikovaný vstupní bod.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"2ae210fe-7b40-4e0b-a5e9-a17d12504120",correct:"Operační systém identifikuje požadovanou službu systémového volání na základě čísla volání předaného v registru procesoru.",incorrect:"Operační systém identifikuje požadovanou službu systémového volání na základě názvu volání předaného v paměti.",sectionNumber:"11.4.6",sectionTitle:"Which System Call?"},{uuid:"8b82e19a-d4c3-4337-9428-09749f16e313",correct:"První fáze systémového volání se provádí v uživatelském režimu a je obvykle implementována v knihovně ‹libc›.",incorrect:"První fáze systémového volání se provádí v privilegovaném režimu a je obvykle implementována v jádře operačního systému.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"22c0e333-5eaf-486c-af46-7f04a18a0f1f",correct:"Po přepnutí do privilegovaného režimu začne provádění rutina jádra – obslužný program systémových volání.",incorrect:"Před přepnutím do privilegovaného režimu začne provádění rutina jádra – obslužný program systémových volání.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"d25c9346-01a4-4944-a963-e371c26ed86e",correct:"V moderních systémech, jako je amd64 Linux, se argumenty systémových volání předávají v registrech CPU.",incorrect:"V moderních systémech, jako je amd64 Linux, se argumenty systémových volání předávají v paměti na uživatelském zásobníku.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"6781d2a5-e908-485c-9e18-2bff94279cbb",correct:"Zpracování argumentů systémového volání se provádí až po Dispatch systémového volání na základě jeho čísla.",incorrect:"Zpracování argumentů systémového volání se provádí před Dispatch systémového volání na základě jeho čísla.",sectionNumber:"11.4.7",sectionTitle:"System Call Sequence"},{uuid:"24a94a05-43ee-46ef-af40-4464e8f00c8f",correct:"Správa paměti a plánování procesů jsou klíčové funkce jádra operačního systému.",incorrect:"Správa paměti a plánování procesů jsou obvykle outsourcovány do externích služeb.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"22e9b880-f2fb-456a-9e31-a04d8e7ae117",correct:"Ovladače zařízení jsou nezbytnou součástí operačního systému, ale nemusí být vždy součástí jádra.",incorrect:"Ovladače zařízení jsou vždy implementovány výhradně jako součást jádra operačního systému.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"14ffd357-f1fe-4e4c-a752-96f43f068e07",correct:"Souborové systémy jsou považovány za klíčovou součást operačního systému, ačkoli nejsou vždy součástí jádra.",incorrect:"Souborové systémy nejsou považovány za klíčovou součást moderního operačního systému.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"1cce98b0-cdf2-475b-ac87-7a33af4df0c6",correct:"Síťové služby jsou klíčovou součástí moderního operačního systému, i když tradičně mohly být součástí jádra.",incorrect:"Síťové služby jsou spíše doplňkovou funkcí operačního systému než jeho klíčovou součástí.",sectionNumber:"11.5.1",sectionTitle:"What Does a Kernel Do?"},{uuid:"04757062-3387-40c6-a623-13ebe2b2354a",correct:"Monolitické jádro může poskytovat různé doplňkové služby, například správu časovačů.",incorrect:"Monolitické jádro vždy poskytuje všechny doplňkové služby uvedené v seznamu.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"61b4b1ca-80a3-440d-858f-ce58a0719e15",correct:"Implementace IPC se mohou mezi různými monolitickými operačními systémy značně lišit.",incorrect:"Implementace IPC jsou v monolitických jádrech napříč systémy vždy zcela identické.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"6b529d35-9b5d-4cad-9ec8-f401614bf11e",correct:"IPC mechanismy jsou v mikrokernelech ještě důležitější než v monolitických jádrech.",incorrect:"IPC mechanismy hrají v mikrokernelech méně významnou roli než v monolitických jádrech.",sectionNumber:"11.5.2",sectionTitle:"Additional Services"},{uuid:"2a5ac551-4c54-4e4e-b57e-8ca8734851dd",correct:"Mikrokernel poskytuje pouze služby, které nelze rozumně implementovat mimo něj.",incorrect:"Mikrokernel poskytuje širokou škálu služeb, podobně jako monolitické jádro.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"9fc9156f-483c-4b7d-8f63-b8100f24c0e9",correct:"V systémech s pravým mikrokernelem běží každá služba ve vlastním procesu.",incorrect:"V systémech s pravým mikrokernelem běží všechny služby v jediném procesu superserveru.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"a1d4c8a4-0e45-4bde-972a-c0cb1b16ec23",correct:"Hybridní systémy jsou obvykle rychlejší než systémy s pravým mikrokernelem kvůli menšímu počtu přepnutí kontextu.",incorrect:"Hybridní systémy jsou obvykle pomalejší než systémy s pravým mikrokernelem kvůli většímu počtu přepnutí kontextu.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"23f22994-776a-4906-85a9-b74513252030",correct:"Superservery v hybridních systémech mají vnitřní architekturu podobnou monolitickým jádrům.",incorrect:"Superservery v hybridních systémech mají distribuovanou architekturu, na rozdíl od monolitických jader.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"18763896-6d40-4283-a265-de8b8c2960ee",correct:"Systémy s pravým mikrokernelem jsou teoreticky lépe škálovatelné na velké SMP systémy než hybridní systémy.",incorrect:"Systémy s pravým mikrokernelem jsou teoreticky hůře škálovatelné na velké SMP systémy než hybridní systémy.",sectionNumber:"11.5.3",sectionTitle:"Reminder: Microkernel Systems"},{uuid:"e5cf3ec5-ef5a-4652-b6c4-1b5799360feb",correct:"Z pohledu uživatelského prostoru aplikace využívají systémové knihovny pro komunikaci s kernelem bez ohledu na architekturu.",incorrect:"Z pohledu uživatelského prostoru aplikace musí detailně znát architekturu kernelu pro správnou komunikaci.",sectionNumber:"11.5.4",sectionTitle:"Kernel Services"},{uuid:"4e296ed0-c2e5-4990-a3c4-3ee5a184b407",correct:"Programy v uživatelském prostoru se nestarají o to, který server poskytuje služby, protože je to abstrahováno.",incorrect:"Programy v uživatelském prostoru musí aktivně vyhledávat a adresovat specifické servery pro služby.",sectionNumber:"11.5.4",sectionTitle:"Kernel Services"},{uuid:"a6bfc807-bc9d-419c-9685-120eb5e9b580",correct:"Ovladače tiskáren mají významné komponenty v uživatelském prostoru operačního systému.",incorrect:"Ovladače tiskáren jsou výhradně součástí jádra operačního systému.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"6ee10307-da70-4826-a9b8-8d4a596474fb",correct:"U grafických karet je nízkoúrovňový přístup k hardwaru zajištěn jádrem, ale velká část ovladače běží v uživatelském prostoru.",incorrect:"U grafických karet běží kompletní ovladač, včetně nízkoúrovňového přístupu k hardwaru, výhradně v uživatelském prostoru.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"d6b6e4c5-d2d1-4246-9806-3e3817d93939",correct:"Ne všechny ovladače zařízení jsou nutně součástí jádra operačního systému, například ovladače tiskáren.",incorrect:"Všechny ovladače zařízení, včetně ovladačů tiskáren, jsou vždy integrální součástí jádra operačního systému.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"e1fbb28e-48a0-42d9-8c55-b47f8407eda5",correct:"Většina OpenGL se obvykle nachází v uživatelském prostoru operačního systému.",incorrect:"Většina OpenGL se pro svůj výkon obvykle nachází přímo v jádře operačního systému.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"},{uuid:"c77db53a-9c97-4014-a425-4d6f406f691d",correct:"I v monolitických jádrech operačních systémů mohou mít některé ovladače významné komponenty v uživatelském prostoru.",incorrect:"V monolitických jádrech operačních systémů jsou všechny ovladače vždy výhradně součástí jádra.",sectionNumber:"11.5.5",sectionTitle:"User-Space Drivers"}]},{uuid:"2bac8616-733e-44f0-a50a-b3818d8199c2",sectionNumber:"12",sectionTitle:"OS Virtualization",statements:[{uuid:"418de05c-da86-45b0-86e5-1b1a322701f4",correct:"Hypervisor, také známý jako Virtual Machine Monitor, umožňuje spouštění více operačních systémů.",incorrect:"Hypervisor, také známý jako Virtual Machine Monitor, umožňuje spouštění pouze jednoho operačního systému.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"3a2646ed-2618-4057-a772-523432499395",correct:"Hypervisor se chová jako kernel, který běží mezi hardwarem a virtualizovanými operačními systémy.",incorrect:"Hypervisor se chová jako běžná aplikace, která běží nad operačním systémem a virtualizuje hardware.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"a75ee7a1-dd71-4c1a-af17-ee04609055d5",correct:"Virtualizované operační systémy sdílejí procesory a jsou izolovány v fyzické paměti pomocí MMU.",incorrect:"Virtualizované operační systémy sdílejí procesory, ale nejsou izolovány v fyzické paměti.",sectionNumber:"12.1.1",sectionTitle:"What is a Hypervisor"},{uuid:"9b05a169-c6b4-4aa6-98e5-33c0a274ee93",correct:"Rozhraní hypervizoru a operačního systému je jednodušší než rozhraní operačního systému a aplikace.",incorrect:"Rozhraní hypervizoru a operačního systému je složitější než rozhraní operačního systému a aplikace.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"3f245951-66b3-4c15-8a5e-02078ee80ad9",correct:"Virtualizované operační systémy umožňují stupeň autonomie, který není běžný, když více uživatelů sdílí jeden OS.",incorrect:"Virtualizované operační systémy umožňují menší stupeň autonomie, než když více uživatelů sdílí jeden OS.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"d1ec81e0-7325-4e6b-921b-8584b2007fdb",correct:"Mezi hypervizorem a operačním systémem neexistují systémy souborů pro komunikaci.",incorrect:"Mezi hypervizorem a operačním systémem existují sdílené systémy souborů pro komunikaci.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"6d2ccad6-a7a7-40c6-893b-0e03e740ede5",correct:"Virtuální stroje sdružují zdroje a zpřístupňují je operačnímu systému.",incorrect:"Virtuální stroje poskytují přímý přístup k hardwaru operačnímu systému.",sectionNumber:"12.1.2",sectionTitle:"Motivation"},{uuid:"99bccb9d-095c-4f78-aedc-0f08736b401b",correct:"MMU virtualizuje fyzickou paměť, což je klíčový aspekt virtualizace zdrojů v počítačích.",incorrect:"MMU virtualizuje virtuální paměť, což přímo zjednodušuje správu fyzických periferií systému.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"cff85e9f-83cb-4dab-b25b-5b869bb2a8f7",correct:"Operační systém virtualizuje periferie, aby umožnil bezpečné a spravedlivé sdílení hardwarových zdrojů.",incorrect:"Operační systém virtualizuje pouze paměť, přičemž periferie jsou spravovány přímo hardwarem.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"9db6dbb9-7d59-45a4-9b36-5d01fa7c3f91",correct:"Virtualizace usnadňuje správu zdrojů a umožňuje izolaci komponent v operačním systému.",incorrect:"Virtualizace komplikuje správu zdrojů a ztěžuje izolaci komponent v operačním systému.",sectionNumber:"12.1.3",sectionTitle:"Virtualisation in General"},{uuid:"3b3fd330-be19-4e73-8a96-2aedb2ba3f74",correct:"Hypervizory typu 1 jsou umístěny přímo nad hardwarem a fungují jako jednoduchý mikrokernel.",incorrect:"Hypervizory typu 1 běží jako aplikace nad běžným operačním systémem.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"9e290401-7468-4405-a2a5-fcc100677838",correct:"Hypervizory typu 2 využívají plánovač a správu paměti hostitelského operačního systému.",incorrect:"Hypervizory typu 2 si samy spravují plánování procesoru a paměť, nezávisle na hostitelském systému.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"27c7f614-f6a5-479b-9230-9538c9212cb5",correct:"Hlavní rozdíl mezi hypervizory typu 1 a 2 spočívá v jejich umístění v softwarovém zásobníku systému.",incorrect:"Hypervizory typu 1 a 2 se liší pouze v podpoře různých typů hardwaru, nikoli v architektuře.",sectionNumber:"12.1.4",sectionTitle:"Hypervisor Types"},{uuid:"b849cf44-53c6-4e82-802c-ffa47004a133",correct:"Z/VM, Xen a Hyper-V jsou příklady hypervizorů typu bare metal.",incorrect:"VMWare, VirtualBox a Hyper-V jsou příklady hypervizorů typu bare metal.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"495e0a55-d70c-499d-aea9-20ab02085a88",correct:"VMWare a VirtualBox jsou uvedeny jako příklady hosted hypervizorů.",incorrect:"Xen a VirtualBox jsou uvedeny jako příklady hosted hypervizorů.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"f28e3a1e-5e8f-4afd-b4a5-0f314cba7d18",correct:"IBM provedla první pokusy s provozováním více OS na stejném hardwaru v 60. letech.",incorrect:"Microsoft provedla první pokusy s provozováním více OS na stejném hardwaru v 60. letech.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"afac5d09-a74d-47f8-8690-9c4e12994c9a",correct:"CP/CMS z roku 1968 a VM/370 z roku 1972 jsou rané systémy pro virtualizaci od IBM.",incorrect:"CP/CMS z roku 2000 a VM/370 z roku 1972 jsou rané systémy pro virtualizaci od IBM.",sectionNumber:"12.1.5",sectionTitle:"Examples & History"},{uuid:"50947234-b11e-4536-bba4-19deb08263a5",correct:"Architektura x86 postrádá režim virtuálního supervizora.",incorrect:"Architektura x86 disponuje režimem virtuálního supervizora.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"c65b1ca0-d291-49ae-9f63-d2eefa94d94a",correct:"Softwarová virtualizace se stala proveditelnou řešením koncem 90. let.",incorrect:"Softwarová virtualizace byla proveditelná řešením již v raných 90. letech.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"ab7560f7-fbe0-4375-bfce-487bdf532677",correct:"Výkon procesorů PC se stal dostatečným pro emulaci PC-na-PC v polovině 90. let.",incorrect:"Výkon procesorů PC se stal dostatečným pro emulaci PC-na-PC až na začátku 21. století.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"3c29d622-1197-460b-87b8-99e570660cc6",correct:"Bochs byl uveden v roce 1994, VMWare v roce 1999 a QEMU v roce 2003.",incorrect:"Bochs byl uveden v roce 1999, VMWare v roce 1994 a QEMU v roce 2003.",sectionNumber:"12.1.6",sectionTitle:"Desktop Virtualisation"},{uuid:"6bb7a057-d7d7-423e-8703-676b174f0de4",correct:"Paravirtualizace, představená společností VMWare v roce 2005, vyžaduje modifikace hostovaného operačního systému.",incorrect:"Paravirtualizace, představená společností VMWare v roce 2005, nevyžaduje modifikace hostovaného operačního systému.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"f5a01684-2e63-43a3-b7d3-1ba13451faf5",correct:"Alternativní přístup k paravirtualizaci byl představen v Xenu v roce 2006.",incorrect:"Alternativní přístup k plné virtualizaci byl představen v Xenu v roce 2006.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"4899f107-3f39-41b8-993c-8c5c362d7ff8",correct:"Paravirtualizace umožňuje dosáhnout téměř nativní rychlosti bez hardwarové podpory.",incorrect:"Paravirtualizace umožňuje dosáhnout téměř nativní rychlosti pouze s hardwarovou podporou.",sectionNumber:"12.1.7",sectionTitle:"Paravirtualisation"},{uuid:"b26ae74d-529a-4af0-89ad-73e4ef516431",correct:"Virtualizační rozšíření pro x86 architekturu se objevila okolo roku 2005.",incorrect:"Virtualizační rozšíření pro x86 architekturu se objevila až po roce 2010.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"fdb8f4eb-5bf8-44f6-99c7-fc658c902ec9",correct:"Virtualizace MMU se stala běžnou součástí desktopových procesorů přibližně v roce 2008.",incorrect:"Virtualizace MMU se stala běžnou součástí desktopových procesorů již v roce 2000.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"15d1ff47-af0c-438e-ac6e-cc1ea15a90ed",correct:"Díky virtualizačním rozšířením není v principu nutné modifikovat hostovaný operační systém.",incorrect:"Díky virtualizačním rozšířením je nutné modifikovat hostovaný operační systém.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"1f75a261-3ada-4d4f-ad34-940e4f05fcba",correct:"MMU virtualizace přispěla ke zjednodušení návrhu hypervizorů pro x86 architekturu.",incorrect:"MMU virtualizace zkomplikovala návrh hypervizorů pro x86 architekturu.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"d806ce22-ccef-44c2-86ee-f6789dc98bb7",correct:"Softwarová virtualizační řešení se stala zastaralými s nástupem hardwarové virtualizace.",incorrect:"Softwarová virtualizační řešení zůstala dominantní i po nástupu hardwarové virtualizace.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"ca5351dd-3832-46c9-8ad7-ede86e6452a9",correct:"Procesory s virtualizačními rozšířeními umožňují běh nemodifikovaného hostovaného OS téměř nativní rychlostí.",incorrect:"Procesory s virtualizačními rozšířeními výrazně zpomalují běh hostovaného operačního systému.",sectionNumber:"12.1.8",sectionTitle:"The Virtual ‹x86› Revolution"},{uuid:"f3857e91-3c0d-435d-979d-b152ab02269a",correct:"Paravirtualizované periferie vyžadují speciální ovladače v hostovaném operačním systému.",incorrect:"Paravirtualizované periferie **ne**vyžadují speciální ovladače v hostovaném operačním systému.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"b5036837-f74a-4e54-b3ad-a216967361a8",correct:"Hardwarová virtualizace periférií je ekonomicky náročnější než paravirtualizace.",incorrect:"Hardwarová virtualizace periférií je **ekonomicky výhodnější** než paravirtualizace.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"6bb4d60e-adeb-4770-82a2-c2ee9cf8261b",correct:"Paravirtualizované periferie nevyžadují změny v hostovaném operačním systému.",incorrect:"Paravirtualizované periferie **vyžadují rozsáhlé** změny v hostovaném operačním systému.",sectionNumber:"12.1.9",sectionTitle:"Paravirtual Devices"},{uuid:"682a206e-c03c-4a4f-af97-3a3ab154692d",correct:"Virtualizace může být realizována hardwarově za pomoci technologií jako VT-x a EPT.",incorrect:"Virtualizace je výhradně softwarová záležitost a nepoužívá hardwarové technologie.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"143f1be0-8519-40d3-abff-7e3fb5b9018d",correct:"Virtuální stroj obvykle poskytuje procesor, paměť, blokové úložiště a síťové připojení.",incorrect:"Virtuální stroj typicky poskytuje jen procesor a paměť, ostatní zdroje nejsou nutné.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"862bfd9b-3a9d-4481-bb9e-2f87fecb8d93",correct:"Systém běžící pod virtualizovaným operačním systémem se označuje jako virtuální stroj.",incorrect:"Systém běžící pod virtualizovaným operačním systémem se nazývá hostitelský systém.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"63c1073d-7070-4cb8-8823-dff4c5734849",correct:"Správa virtuálních strojů je obecně považována za jednodušší než správa fyzického hardwaru.",incorrect:"Správa virtuálních strojů je obvykle složitější než správa fyzického hardwaru.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"22335399-ecb8-4e8c-b35d-a0a91a2deca4",correct:"Mezi běžné zdroje poskytované virtuálním strojem patří i konzolové zařízení pro správu.",incorrect:"Konzolové zařízení pro správu není typickým zdrojem poskytovaným virtuálním strojem.",sectionNumber:"12.1.10",sectionTitle:"Virtual Computers"},{uuid:"a04de73a-56f7-4cc8-a1b1-6b4af239857d",correct:"Hypervisor obsahuje plánovač procesů, který je však jednodušší než u běžného operačního systému.",incorrect:"Hypervisor neobsahuje plánovač procesů, protože plánování je plně delegováno na hostitelský operační systém.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"23329e8c-f1f0-4527-8615-2e9b5a7ef709",correct:"Privilegované instrukce jsou zachytávány hypervizorem a zpracovávány softwarově.",incorrect:"Privilegované instrukce jsou vykonávány přímo hostitelským CPU bez zásahu hypervizoru.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"b5723a26-336e-479b-aee0-1d2b02f38ecb",correct:"Hypervisor spravuje virtualizovanou MMU, což umožňuje izolaci paměti virtuálních strojů.",incorrect:"Hypervisor nesprávuje virtualizovanou MMU, správu paměti virtuálních strojů zajišťuje hostitelský OS.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"8b9ddc28-bd5c-4f97-aa0f-d29ef6a64d03",correct:"Většina instrukcí uživatelského prostoru je vykonávána hostitelským CPU nativně, bez režie hypervizoru.",incorrect:"Všechny instrukce, včetně instrukcí uživatelského prostoru, jsou emulovány hypervizorem.",sectionNumber:"12.1.11",sectionTitle:"CPU Sharing"},{uuid:"badf8917-1b80-4360-a98b-1552086781ef",correct:"Virtualizace paměti se opírá o stejné principy jako izolace procesů v OS, využívající stránkování a MMU.",incorrect:"Virtualizace paměti využívá zcela odlišné mechanismy než izolace procesů v OS a nepoužívá stránkování.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"072e2beb-f37d-451d-9853-f4aa33e40ce6",correct:"Shadow page tables představují softwarovou metodu virtualizace paměti, kde hostující systém nemá přímý přístup k MMU.",incorrect:"Shadow page tables jsou hardwarová metoda virtualizace paměti, umožňující hostujícímu systému přímý přístup k MMU.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"7e2aba11-7330-46f9-bc83-edd5ef29d1ca",correct:"V shadow page tables hypervisor synchronizuje guest page tables se shadow page tables, které odrážejí virtuální adresy hosta.",incorrect:"V shadow page tables jsou guest page tables synchronizovány přímo s fyzickou pamětí, bez účasti hypervisoru.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"8076ed93-ac8e-4bd7-9dbd-19bdd799ebfe",correct:"Druhá úroveň překladu, hardwarové řešení, zjednodušuje VMM a nabízí vyšší výkon než shadow page tables.",incorrect:"Druhá úroveň překladu, softwarové řešení, komplikuje VMM a je méně výkonná než shadow page tables.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"ed2a8990-6dc2-4db2-b8ba-28e51dd0bcc8",correct:"Moderní procesory umožňují hostujícímu OS modifikovat page tables přímo díky hardwarové virtualizaci MMU.",incorrect:"I s hardwarovou virtualizací MMU hostující OS nemůže přímo modifikovat page tables kvůli izolaci.",sectionNumber:"12.1.12",sectionTitle:"RAM Sharing"},{uuid:"dfe39581-5901-4b7a-96d1-00756eb942dc",correct:"Současná virtualizační řešení používají paravirtualizovanou síťovou kartu.",incorrect:"Starší virtualizační řešení běžně používají paravirtualizovanou síťovou kartu.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"ddc162b0-f48f-4bf0-884a-504a516b2052",correct:"Paravirtualizovaná síťová karta přenáší rámce mezi hostem a hostitelem.",incorrect:"Paravirtualizovaná síťová karta přenáší pakety mezi hostem a hostitelem.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"bc129d84-04ff-4102-ade7-4d8736b2a325",correct:"V hostitelském systému je paravirtualizovaná síťová karta obvykle připojena k softwarovému mostu.",incorrect:"V hostitelském systému je paravirtualizovaná síťová karta obvykle připojena k hardwarovému mostu.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"b9fa1cd5-4390-4bb1-b1ae-5061aedb284f",correct:"Alternativou k softwarovému mostu v hostiteli je směrování.",incorrect:"Jedinou alternativou k softwarovému mostu v hostiteli je směrování.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"4cc35ca5-a95c-41e8-9648-0aea3aad6453",correct:"Ethernetový tunel pseudo-zařízení v hostiteli funguje jako virtuální síťová karta.",incorrect:"Ethernetový tunel pseudo-zařízení v hostiteli funguje jako fyzická síťová karta.",sectionNumber:"12.1.13",sectionTitle:"Network Sharing"},{uuid:"15bb8e28-dda0-4125-aef0-b367c8640ca6",correct:"Blokové úložiště je obvykle založeno na paravirtualizaci.",incorrect:"Blokové úložiště není nikdy založeno na paravirtualizaci.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"746de823-2658-4d79-88fe-e2eb57d4169a",correct:"Hostitelská strana blokového zařízení může být podložena běžným souborem v systému hostitele.",incorrect:"Hostitelská strana blokového zařízení nemůže být podložena běžným souborem v systému hostitele.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"4c6db57e-a61f-4721-81a0-a48028e1d244",correct:"Soubory pro blokové úložiště mohou být ve speciálním formátu, například copy-on-write.",incorrect:"Soubory pro blokové úložiště nikdy nejsou ve speciálním formátu jako copy-on-write.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"1597bfdd-0989-4778-95a0-4566d9c8b562",correct:"Blokové úložiště může být podloženo skutečným blokovým zařízením.",incorrect:"Blokové úložiště nemůže být nikdy podloženo skutečným blokovým zařízením.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"003a8d9b-4b89-43c6-817e-4929ec3a763d",correct:"LVM a device-mapper jsou technologie používané pro virtualizaci blokových zařízení.",incorrect:"LVM a device-mapper nejsou technologie používané pro virtualizaci blokových zařízení.",sectionNumber:"12.1.14",sectionTitle:"Virtual Block Devices"},{uuid:"d87660d1-e3e1-4bba-af26-f87c7bd9427b",correct:"Periferie jsou užitečné hlavně v desktopových systémech.",incorrect:"Periferie jsou užitečné hlavně v serverové virtualizaci.",sectionNumber:"12.1.15",sectionTitle:"Special Resources"},{uuid:"2376e8f8-a533-4220-9462-b42120f1cf32",correct:"Grafické karty, zvuková zařízení a tiskárny patří mezi periferie.",incorrect:"Servery a virtualizační software patří mezi periferie.",sectionNumber:"12.1.15",sectionTitle:"Special Resources"},{uuid:"d21db130-382f-4a57-8158-fd67d4959205",correct:"Anti-virtualizační technologie využívá I/O MMU pro přímý přístup virtuálního operačního systému k hardwaru.",incorrect:"Anti-virtualizační technologie obchází I/O MMU a umožňuje přímý přístup virtuálního operačního systému k hardwaru.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"2aa897ab-34d5-4078-981f-c0f7073fe803",correct:"I/O MMU zabraňuje virtuálnímu operačnímu systému přímý zápis do paměti hostitelského systému.",incorrect:"I/O MMU umožňuje virtuálnímu operačnímu systému přímý zápis do paměti hostitelského systému.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"262023e2-9b93-4ace-a97d-f1dcab0b0bd4",correct:"Při přímém přístupu virtuálního OS k PCI zařízení, hostitelský systém s tímto zařízením nesmí komunikovat.",incorrect:"Při přímém přístupu virtuálního OS k PCI zařízení, hostitelský systém může s tímto zařízením komunikovat.",sectionNumber:"12.1.16",sectionTitle:"PCI Passthrough"},{uuid:"b0d49f49-5cde-4944-aa40-f1dc567bc46e",correct:"GPU může být přidělena jednomu operačnímu systému pomocí VT-d.",incorrect:"GPU může být sdílena více operačními systémy současně pomocí VT-d.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"bf7d6262-ac60-4df9-9f1f-d34d3ac8f078",correct:"Moderní GPU umožňují časové sdílení, které vyžaduje ovladače v hypervizoru.",incorrect:"Moderní GPU umožňují časové sdílení bez nutnosti ovladačů v hypervizoru.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"3d1828d5-7f5f-4e3e-9e94-adcd3f41bd1a",correct:"Paravirtualizace GPU využívá vendor-neutrální protokol pro komunikaci s hypervizorem.",incorrect:"Paravirtualizace GPU vyžaduje vendor-specifické ovladače na straně hosta i hypervizoru.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"44829cd7-15af-42e5-afe8-d6c9ffd57fec",correct:"Síťové grafické protokoly jako X11 jsou pro sdílení GPU méně efektivní než specializované metody.",incorrect:"Síťové grafické protokoly jako X11 poskytují pro sdílení GPU nejvyšší možnou efektivitu.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"66527bad-4aa1-4126-b0be-452346497847",correct:"Při paravirtualizaci GPU hostující systém potřebuje uživatelskou část ovladače GPU pro generování příkazů.",incorrect:"Při paravirtualizaci GPU hostující systém nepotřebuje žádnou část ovladače GPU.",sectionNumber:"12.1.17",sectionTitle:"GPUs and Virtualisation"},{uuid:"f85bfee8-1e2f-4560-96ad-ef82bed97e4a",correct:"Periferní zařízení jako tiskárny a skenery mohou být sdíleny přes standardní sítě bez ztráty výkonu.",incorrect:"Periferní zařízení jako tiskárny a skenery nemohou být sdíleny přes standardní sítě bez ztráty výkonu.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"5ede9177-5d47-4378-8fa4-729889b63437",correct:"Sdílení periférií typu passthrough využívá virtualizaci sběrnic PCI, USB nebo SATA.",incorrect:"Sdílení periférií typu passthrough využívá virtualizaci pouze sběrnice PCI.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"ccd005a4-9014-476d-9be4-21773205c089",correct:"Některá audio zařízení mohou být sdílena přes standardní sítě s mírným zvýšením latence.",incorrect:"Všechna audio zařízení nemohou být sdílena přes standardní sítě.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"e2ee40c1-e310-4198-a216-eff82d0af26e",correct:"Passthrough periférií zahrnuje přesměrování na skutečné zařízení, například USB disk.",incorrect:"Passthrough periférií zahrnuje virtualizaci celého fyzického zařízení.",sectionNumber:"12.1.18",sectionTitle:"Peripherals"},{uuid:"017ca9ae-ead4-48fe-8d10-c4a2c4ab1dc3",correct:"Virtuální stroj lze snadno zastavit a uložit jeho stav do souboru na hostitelském systému.",incorrect:"Virtuální stroj lze zastavit, ale jeho stav nelze uložit do souboru.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"3e32e59c-4138-4e80-883f-026e439bce2e",correct:"RAM paměť zastaveného virtuálního stroje může být zkopírována do souboru spolu s registry.",incorrect:"RAM paměť běžícího virtuálního stroje může být zkopírována do souboru.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"83dc46a8-7d62-41f4-a733-ce7c63d2bdac",correct:"Pro uspání virtuálního stroje není nutná spolupráce hostovaného operačního systému.",incorrect:"Pro uspání virtuálního stroje je nezbytná aktivní spolupráce hostovaného operačního systému.",sectionNumber:"12.1.19",sectionTitle:"Suspend & Resume"},{uuid:"c7e80b4b-ef46-462f-99d3-3dcbffc58229",correct:"Stav virtuálního stroje může být uložen a odeslán po síti pro pozdější obnovení.",incorrect:"Stav virtuálního stroje nemůže být uložen a odeslán po síti pro pozdější obnovení.",sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"1ad48848-304f-462a-90c2-44e6d568b278",correct:'Obnovení virtuálního stroje na jiném hostiteli se nazývá "paused migration".',incorrect:'Obnovení virtuálního stroje na jiném hostiteli se nazývá "live migration".',sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"7a356cb8-80e2-400d-8a0f-e9a9f616d566",correct:"Pauzovaná migrace vyžaduje, aby virtuální prostředí bylo na obou hostitelích kompatibilní.",incorrect:"Pauzovaná migrace nevyžaduje, aby virtuální prostředí bylo na obou hostitelích kompatibilní.",sectionNumber:"12.1.20",sectionTitle:"Migration Basics"},{uuid:"c886789a-11ab-486b-8fb8-a1b982b0489a",correct:"Živá migrace virtuálního stroje využívá asynchronní snímky paměti.",incorrect:"Živá migrace virtuálního stroje využívá synchronní snímky paměti.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"d25b9519-fbe9-42ea-9b58-733fd89b7152",correct:"Při živé migraci hostitel kopíruje stránky paměti a označuje je jako read-only.",incorrect:"Při živé migraci hostitel kopíruje stránky paměti a označuje je jako write-only.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"3db4bd96-632a-41a6-9ce7-3944ea62bee7",correct:"Během živé migrace se nejprve odešle snímek paměti a poté změněné stránky.",incorrect:"Během živé migrace se nejprve odešlou změněné stránky a poté snímek paměti.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"bbd4f3d3-c4d5-4fd2-9b00-d02e663e1f5b",correct:"Copy-on-write mechanism v živé migraci spočívá v označení stránek jako read-only před jejich kopírováním.",incorrect:"Copy-on-write mechanism v živé migraci spočívá v označení stránek jako read-write před jejich kopírováním.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"e9a2fb4c-5a71-4ff8-b743-7000746fbbc3",correct:"VM je pozastaven pouze krátce na konci živé migrace pro odeslání registrů a posledních stránek.",incorrect:"VM je pozastaven na začátku živé migrace, aby se mohl odeslat snímek paměti.",sectionNumber:"12.1.21",sectionTitle:"Live Migration"},{uuid:"3ae9e15c-cf37-4c4d-8b1c-ead9366226b2",correct:"Hypervisor alokuje paměť virtuálním strojům na vyžádání, ale operační systémy obvykle nemají koncept dealokace fyzické paměti.",incorrect:"Hypervisor alokuje paměť virtuálním strojům staticky a operační systémy běžně dealokují fyzickou paměť.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"7b9f7558-373a-4740-823f-4fd319621773",correct:'Paměťový ballooning driver vrací nevyužitou "fyzickou" paměť hostitelskému operačnímu systému ve virtualizovaném prostředí.',incorrect:'Paměťový ballooning driver alokuje dodatečnou "fyzickou" paměť pro hostitelský operační systém ve virtualizovaném prostředí.',sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"22648213-6569-4e6a-ad24-de01b18bd87e",correct:"Při použití memory ballooning driveru dochází k odmapování paměti na straně hostitele, což pro hosta znamená ztrátu obsahu paměti.",incorrect:"Při použití memory ballooning driveru dochází k mapování paměti na straně hostitele, což pro hosta znamená zachování obsahu paměti.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"cc496e1e-0f0f-46cb-9836-a66f8d13763f",correct:"Operační systémy běžící ve virtuálních strojích obvykle nemají zabudovanou funkcionalitu pro vracení fyzické paměti hypervizoru.",incorrect:"Operační systémy běžící ve virtuálních strojích mají zabudovanou funkcionalitu pro automatické vracení fyzické paměti hypervizoru.",sectionNumber:"12.1.22",sectionTitle:"Memory Ballooning"},{uuid:"b19f1df7-945d-4709-a752-df067031f146",correct:"Kontejnery využívají virtualizaci na úrovni operačního systému, ale nejsou plnohodnotné virtuální počítače.",incorrect:"Kontejnery jsou plnohodnotné virtuální počítače s vlastním jádrem operačního systému.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"9034c8ef-372f-4812-809f-179541cab466",correct:"Virtualizované síťové zásobníky v kontejnerech sdílejí hardware, ale mají oddělené IP adresy a směrovací tabulky.",incorrect:"Virtualizované síťové zásobníky v kontejnerech sdílejí hardware i IP adresy s hostitelským systémem.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"6619ff66-c5ea-408b-a3d5-28d67920c29e",correct:"Kontejnery umožňují rozdělení přístupu k systému souborů, například pomocí nástroje chroot.",incorrect:"Kontejnery mají plný přístup k systému souborů hostitelského operačního systému bez omezení.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"c92523e6-fb80-4765-b07e-eeaac8014e19",correct:"Kontejnerizace je založena na procesech a rozšiřuje jejich izolaci pomocí virtualizace na úrovni OS.",incorrect:"Kontejnerizace je založena na hardwarové virtualizaci a nikoliv na procesech operačního systému.",sectionNumber:"12.2.1",sectionTitle:"What are Containers?"},{uuid:"99fad027-44f8-4e14-9be3-7135fee2bf52",correct:"Kontejnery se spouští rychleji než virtuální stroje díky sdílení jádra operačního systému.",incorrect:"Kontejnery se spouští pomaleji než virtuální stroje kvůli složitější izolaci procesů.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"9b96e5cf-ca5a-47dc-a85b-14abceab91db",correct:"Virtuální stroje vyžadují inicializaci vlastního jádra, což zpomaluje jejich spouštění oproti kontejnerům.",incorrect:"Virtuální stroje sdílejí jádro hostitelského systému, což urychluje jejich spouštění oproti kontejnerům.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"fdb79068-3d7e-48fe-9479-0857d11343cd",correct:"Díky sdílenému jádru mohou kontejnery efektivněji sdílet paměť a systémové prostředky.",incorrect:"Kvůli odděleným jádrům mohou kontejnery efektivněji sdílet paměť než virtuální stroje.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"666dd68f-30a2-47fb-94ec-c979df8b0564",correct:"Kontejnery umožňují dosáhnout vyšší efektivity využití zdrojů díky sdílení jádra a menší režii.",incorrect:"Kontejnery snižují efektivitu využití zdrojů kvůli nutnosti dodatečné izolace na úrovni jádra.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"ca9849e7-1bfb-4a46-bccd-eded0c4ea47f",correct:"Sdílení jádra mezi kontejnery umožňuje rychlejší zprovoznění nových systémů.",incorrect:"Sdílení jádra mezi kontejnery zpomaluje zprovoznění nových systémů kvůli nutnosti správy konfliktů.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"60e65ad6-d1a1-4284-959c-de9fc0a1e8cc",correct:"Kernel musí explicitně podporovat izolaci kontejnerů, aby mohl sdílet jádro mezi nimi.",incorrect:"Kernel nemusí explicitně podporovat izolaci kontejnerů, izolace je zajištěna virtualizací hardwaru.",sectionNumber:"12.2.2",sectionTitle:"Why Containers"},{uuid:"5b53108a-b165-47c2-838b-5350288a720c",correct:"Kontejnery mohou být spuštěny až dvacetkrát rychleji než běžné virtuální stroje.",incorrect:"Kontejnery potřebují ke spuštění řádově sekundy, podobně jako běžné virtuální stroje.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"1a77a438-04b2-466a-bed3-66628e58322c",correct:"Virtuální stroje mají schopnost být uspány a následně obnoveny, což kontejnery postrádají.",incorrect:"Virtuální stroje nemohou být uspány a obnoveny, na rozdíl od kontejnerů.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"1232b5a2-eaec-46f9-aa9d-aea16e13f178",correct:"Neaktivní virtuální stroje zabírají významně více diskového prostoru než kontejnery.",incorrect:"Neaktivní virtuální stroje zabírají srovnatelné množství diskového prostoru jako kontejnery.",sectionNumber:"12.2.3",sectionTitle:"Boot Time"},{uuid:"2af12779-eddb-41aa-8e60-47ab2ae4ef89",correct:"Systém chroot dovoluje provozovat více instancí operačního systému s jedním sdíleným jádrem.",incorrect:"Systém chroot neumožňuje provozovat více instancí operačního systému s jedním sdíleným jádrem.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"13a1f6dd-1faa-4fbd-bc71-a1dc5d178603",correct:"Chroot kontejnery sdílejí systémové prostředky jako procesní tabulky s hostitelským systémem.",incorrect:"Chroot kontejnery mají izolované systémové prostředky jako procesní tabulky od hostitelského systému.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"353e3399-6952-4e2e-8e63-039c8e1e5b98",correct:"V chroot kontejnerech se bezpečnostní role superuživatele nepřenáší pouze na kontejner, ale i na hostitelský systém.",incorrect:"V chroot kontejnerech je bezpečnostní role superuživatele omezena výhradně na daný kontejner.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"3168de7e-1dc5-46c1-bfe9-57c6d33c21ea",correct:"Kvůli sdílení portů je v chroot kontejnerech problematické spustit dva nezávislé webové servery.",incorrect:"Díky izolaci portů je v chroot kontejnerech snadné spustit dva nezávislé webové servery.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"1d16e0f7-1ce8-4a3f-9218-fa75c9bc40ed",correct:"Ačkoliv chroot izoluje systém souborů, většina ostatních systémových prostředků zůstává sdílená.",incorrect:"Chroot izoluje nejen systém souborů, ale i většinu ostatních klíčových systémových prostředků.",sectionNumber:"12.2.4",sectionTitle:"‹chroot›"},{uuid:"d1f4c604-141e-42f4-b941-8b3615c77f1b",correct:"FreeBSD jail mechanismus je evolucí chroot, přidávající izolaci uživatelů a procesů.",incorrect:"FreeBSD jail mechanismus je pouhá implementace chroot bez další izolace.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"caa7588a-8b01-4a7c-8eda-a60941e338c5",correct:"Jail mechanismus FreeBSD virtualizuje síťový stack, umožňující jailům vlastní IP adresy.",incorrect:"Jail mechanismus FreeBSD nesdílí síťový stack, ale neumožňuje jailům vlastní IP adresy.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"674ac4af-012c-40b1-824e-5bdca0879c53",correct:"Root uživatel v jailu FreeBSD má omezené pravomoci oproti root uživateli mimo jail.",incorrect:"Root uživatel v jailu FreeBSD má stejné pravomoci jako root uživatel mimo jail.",sectionNumber:"12.2.5",sectionTitle:"BSD Jails"},{uuid:"5702df1d-2abe-49d2-9aca-25b0ed79f9cb",correct:"Compartmenty viditelnosti v jádře Linuxu virtualizují hierarchii souborového systému, tabulky procesů a sítě.",incorrect:"Compartmenty viditelnosti v jádře Linuxu virtualizují pouze hierarchii souborového systému a tabulky procesů.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"44fd423a-4e69-47c8-ad8d-0674fe46c944",correct:"Namespaces v Linuxu, na rozdíl od VServeru, jsou součástí oficiálního jádra Linuxu.",incorrect:"VServer, na rozdíl od namespaces v Linuxu, je součástí oficiálního jádra Linuxu.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"a7e14d2d-6104-4954-bb62-a43523abea6c",correct:"Při vytváření nového procesu pomocí `clone` může rodičovský proces specifikovat, které zdroje má sdílet.",incorrect:"Při vytváření nového procesu pomocí `fork` musí rodičovský proces specifikovat, které zdroje má sdílet.",sectionNumber:"12.2.6",sectionTitle:"Namespaces"},{uuid:"ed97f147-5429-4719-9f91-c471ddce1044",correct:"V Linuxu kontrolní skupiny řídí alokaci hardwarových zdrojů pro procesy.",incorrect:"V Linuxu kontrolní skupiny primárně monitorují využití softwarových zdrojů, nikoliv hardwarových.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"fcadbb59-bbf2-4bf3-a404-9c6bbd04f140",correct:"Paměťová skupina v kontrolních skupinách Linuxu definuje limity pro využití paměti procesy.",incorrect:"Paměťové skupiny v Linuxu slouží pouze k monitorování využití paměti, nikoliv k aktivnímu omezování.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"255c0843-84da-4f15-ae49-35520ba1254a",correct:"Kontrolní skupiny v Linuxu jsou převážně ortogonální k jmenným prostorům, což minimalizuje překrývání jejich funkcí.",incorrect:"Kontrolní skupiny v Linuxu jsou plně integrovány s jmennými prostory a sdílejí většinu mechanismů pro izolaci.",sectionNumber:"12.2.7",sectionTitle:"‹cgroups›"},{uuid:"ab9801de-1f24-4bc2-8e8e-4c68d79c560c",correct:"LXC kontejnery jsou založeny na Linuxových jmenných prostorech a kontrolních skupinách.",incorrect:"LXC kontejnery jsou založeny pouze na virtualizaci hardwaru, nikoliv na jmenných prostorech.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"1922d5cf-535c-4da5-a95d-fef7baf5fae0",correct:"LXC je sada nástrojů v uživatelském prostoru pro správu kontejnerů.",incorrect:"LXC je primárně nástroj pro správu virtualizace na úrovni hypervizoru.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"90e4b285-0848-4701-810a-895a332bb783",correct:"Od verze 1.0 LXC umožňuje neprivilegované kontejnery spravované běžnými uživateli.",incorrect:"Neprivilegované kontejnery v LXC vyžadují root oprávnění pro správu i po verzi 1.0.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"3f64c2dc-e3a0-46b4-8af0-f9356e83b68c",correct:"LXC se objevil později než VServer, přibližně o sedm let.",incorrect:"LXC byl vyvinut výrazně dříve než VServer, zhruba o sedm let.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"dd980b6d-875a-415e-9fc5-900ec9da09eb",correct:"Funkcionalita LXC je srovnatelná s VServer a OpenVZ v oblasti kontejnerizace.",incorrect:"Funkcionalita LXC je zásadně odlišná od VServer a OpenVZ a nabízí zcela jiné možnosti.",sectionNumber:"12.2.8",sectionTitle:"LXC"},{uuid:"7fa075be-f656-44e2-93e1-b7d1ff399f02",correct:"Uživatelské režimové jádra se nacházejí někde mezi kontejnery a virtuálními stroji.",incorrect:"Uživatelské režimové jádra se nacházejí ve stejné kategorii jako kontejnery.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"63ac9e8c-f181-47d2-aff3-5b792d28cdff",correct:"User-mode Linux byl integrován do jádra Linux verze 2.6 v roce 2003.",incorrect:"User-mode Linux byl integrován do jádra Linux verze 2.4 v roce 2001.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"ec7fc88a-0b94-4b11-9aae-5a5cbd794831",correct:"Uživatelské režimové jádra mohou využívat paravirtualizační techniky.",incorrect:"Uživatelské režimové jádra nemohou využívat paravirtualizační techniky.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"346e4f2e-3b4d-48b6-a11a-de0864544d94",correct:"Uživatelské režimové jádra jsou jednodušší na implementaci než kontejnery.",incorrect:"Uživatelské režimové jádra jsou složitější na implementaci než kontejnery.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"9635ecd1-8f0d-4a3f-aff8-25945c8d59d7",correct:"Z pohledu hostitelského OS se uživatelské režimové jádro jeví jako standardní proces.",incorrect:"Z pohledu hostitelského OS se uživatelské režimové jádro jeví jako virtualní stroj.",sectionNumber:"12.2.9",sectionTitle:"User-Mode Kernels"},{uuid:"9826bf9e-c706-4e08-8b2b-f68aad08b23a",correct:"Kontejnery a uživatelská jádra běžně nepodporují suspendování a obnovení stavu, což je jejich zásadní nevýhodou.",incorrect:"Kontejnery a uživatelská jádra plně podporují suspendování a obnovení stavu, podobně jako hypervizory.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"6a72a51c-a198-4b10-b02a-deb9732e6ba2",correct:"Serializace stavu procesu je u kontejnerů a uživatelských jader složitější než u virtuálních strojů kvůli deskriptorům souborů.",incorrect:"Serializace stavu procesu je u kontejnerů a uživatelských jader stejně jednoduchá jako u virtuálních strojů.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"f3fb660f-7265-4582-9a2a-9a13be9598d3",correct:"Rychlý čas vypnutí a spuštění kontejnerů částečně kompenzuje absenci nativní podpory suspendování a obnovení.",incorrect:"Pomalý čas vypnutí a spuštění kontejnerů plně kompenzuje absenci podpory suspendování a obnovení.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"719d15cc-5702-429e-ba20-e901597a247b",correct:"Pro kontejnery je absence suspendování a obnovení závažnější problém než pro uživatelská jádra z hlediska migrace.",incorrect:"Pro uživatelská jádra je absence suspendování a obnovení závažnější problém než pro kontejnery z hlediska migrace.",sectionNumber:"12.2.10",sectionTitle:"Migration"},{uuid:"6171dd6b-ac5e-4f5c-b896-cd310f3b4a7b",correct:"Na rozdíl od hypervizorů, kontejnery a uživatelská jádra nemají širokou podporu pro suspendování a obnovení stavu.",incorrect:"Podobně jako hypervizory, kontejnery a uživatelská jádra mají širokou podporu pro suspendování a obnovení stavu.",sectionNumber:"12.2.10",sectionTitle:"Migration"}]}],It=[{uuid:"4a3f319b-472d-4c93-8652-c96701b39b32",sectionNumber:"1",sectionTitle:"Virtualizace paměti",statements:[{uuid:"b3ffb5ea-e305-40f8-8543-f7af2e230990",correct:`instrukce tvaru ld reg_addr → reg_out načte hodnotu z paměti a uloží ji do registru; reg_addr je
registr, ve kterém je uložena adresa, kterou program požaduje

instrukce tvaru st reg_in → reg_addr naopak hodnotu do paměti uloží, a to opět na adresu zadanou registrem reg_addr.`,incorrect:`instrukce tvaru ld reg_addr → reg_out načte hodnotu z paměti a uloží ji do registru; reg_addr je
registr, ve kterém je uložena nějaká hodnota

instrukce tvaru st reg_in → reg_addr naopak hodnotu do paměti uloží, a to opět na adresu zadanou registrem reg_addr.`},{uuid:"f8ac38e3-28a3-47ab-ae7d-253a5539328b",correct:`Každá adresa je číslo, ale ne každé číslo je platná adresa. Adresním prostorem
tedy budeme nazývat zejména množinu platných adres, ale můžeme v tomto pojmu zahrnout i případnou další
zajímavou strukturu paměti (např. to, že nějaká část adres má jiné vlastnosti než ty ostatní).
Adresní prostor se obvykle skládá ze souvislých bloků, kde jednotlivé bloky obsahují mnoho po sobě
jdoucích adres (řádově miliony).`,incorrect:`Každá adresa je číslo, ale ne každé číslo je platná adresa. Adresním prostorem
tedy budeme nazývat zejména množinu platných adres, ale můžeme v tomto pojmu zahrnout i případnou dalš
 zajímavou strukturu paměti (např. to, že nějaká část adres má jiné vlastnosti než ty ostatní).
Adresní prostor se obvykle skládá bloků, kde jednotlivé bloky obsahují libovolné adresy.`},{uuid:"45bbaf51-d3af-4340-a66d-1f4874d94feb",correct:`Program má při svém běhu k dispozici nějaký adresní prostor, který může používat
k ukládání dat. Krom pracovní paměti (do které si program ukládá libovolná data jak uzná za vhodné) je
součástí adresního prostoru programu také kód – adresy, na kterých jsou uloženy instrukce, ze kterých
program samotný sestává, a obvykle také hardwarový zásobník, který se používá k realizaci podprogramů
(volání funkcí).`,incorrect:`Program má při svém běhu k dispozici nějaký adresní prostor, který může používat
k ukládání dat. Krom pracovní paměti (do které si program ukládá libovolná data jak uzná za vhodné) je
součástí adresního prostoru programu také kód – adresy, na kterých jsou uloženy instrukce, ze kterých
program samotný sestává, ovšem zásobník se zde obvykle nenachází.`},{uuid:"249a0cd3-fdd7-430e-9d0c-ef7d9ed03f08",correct:`Fyzická paměť
Fyzické adresy (tedy adresy, které patří fyzickému adresnímu prostoru) přímo
pojmenovávají fyzické paměťové buňky hardwarových zařízení, zejména paměti RAM. Přestože se jedná
o jeden adresní prostor, podobně jako v případě paměti programu může mít další strukturu.
Největší a nejdůležitější blok (případně několik bloků) fyzických adres zpravidla patří operační paměti
(paměti s přímým přístupem, random access memory, RAM). Toto je paměť v klasickém smyslu tohoto slova,
a slouží především k ukládáni pracovních dat programů`,incorrect:`Fyzická paměť
Fyzické adresy (tedy adresy, které patří fyzickému adresnímu prostoru) přímo
pojmenovávají fyzické paměťové buňky procesoru. Přestože se jedná o jeden adresní prostor
 podobně jako v případě paměti programu může mít další strukturu.
`},{uuid:"ba227eda-b390-4871-967e-054080f7404d",correct:`Virtualizace
V principu nic nebrání tomu, aby program používal k práci s pamětí přímo fyzické adresy.
V takovém případě bychom program přizpůsobili tomu, které fyzické adresy jsou na našem počítači platné
a odpovídají operační paměti.
Jakmile bychom ale chtěli na jednom počítači spustit několik programů najednou, začneme narážet na
problémy. Programy by mezi sebou musely použití adres koordinovat: používá-li program A adresu 0x1005
pro svoji proměnnou, nemůže ji zároveň používat program B.`,incorrect:`Virtualizace
V principu nic nebrání tomu, aby program používal k práci s pamětí přímo fyzické adresy.
V takovém případě bychom program přizpůsobili tomu, které fyzické adresy jsou na našem počítači platné
a odpovídají operační paměti.
Takto nemůžou vzniknout žádné problémy a tedy je virtualizace procesoru zbytečná.
`},{uuid:"4c00da3a-d5da-42d2-9345-de1fa8edc0a2",correct:`Virtuální a fyzické adresy
Bylo by tedy lepší, aby adresní prostor programu byl od toho fyzického
nezávislý. Proto procesory určené pro běžné počítače poskytují oddělený virtuální adresní prostor,
který je viditelný pro programy, a který je od toho fyzického důsledně oddělen. Fyzický adresní prostor
je uživatelským programům zcela nepřístupný.`,incorrect:`Virtuální a fyzické adresy
Bylo by tedy lepší, aby adresní prostor programu na tom fyzickém závislý.
Proto procesory určené pro běžné počítače poskytují spojení virtuálních adresních prostorů s těmi fyzickými. Fyzický adresní prostor
je tedy uživatelským programům libovolně přístupný.`},{uuid:"ab3a3c34-0bd9-4827-a6ae-70aab949fe10",correct:`Překlad adres
Virtuální adresy budeme překládat na adresy fyzické, které již určí, kde budou příslušná data skutečně uložena.
O fyzické buňce pak můžeme říct, že má právě jednu fyzickou adresu (a ta je této buňce přidělena
pevně) a nějaké virtuální adresy (to jsou ty, které se přeloží na její fyzickou adresu). Buňka může mít
virtuálních adres hned několik, ale také třeba žádnou`,incorrect:`Překlad adres
Virtuální adresy budeme překládat na adresy fyzické, které již určí, kde budou příslušná data skutečně uložena.
O fyzické buňce pak můžeme říct, že má právě jednu fyzickou adresu (a ta je této buňce přidělena
pevně) a právě jednu virtuální adresu (a ta není této buňce přidělena pevně).`},{uuid:"7a1fc979-d76f-4c1f-8c38-e2ec3af979f8",correct:`Jednotka správy paměti
Přístup do paměti (čtení, zápis) je časově kritickou operací – procesor
jich provádí miliony za vteřinu. Přitom adresní operand instrukce, která takový přístup realizuje,
představuje vždy virtuální adresu, která musí být ještě před samotným přístupem přeložena na adresu
fyzickou.`,incorrect:`Jednotka správy paměti
Přístup do paměti (čtení, zápis) je časově kritickou operací – procesor
jich provádí miliony za vteřinu. Přitom adresní operand instrukce, která takový přístup realizuje,
představuje vždy fyzickou adresu, která musí být ještě před samotným přístupem přeložena na adresu
virtuální.`},{uuid:"82019a92-bbab-455e-a02d-a23b1b44d1a4",correct:`Jednotka správy paměti
Překlad adres proto musí být velmi rychlý, a není nijak překvapivé, že je realizován specializovaným
hardwarem, který je přímo součástí procesoru. Zároveň ale potřebujeme zabezpečit, aby o konkrétní
podobě překladu mohl rozhodovat operační systém. Proto musí být tato tzv. jednotka správy paměti
programovatelná – pomocí vhodně sestavených tabulek může operační systém (konkrétně jeho jádro)
řídit mapování virtuálních adres na fyzické, a tedy i to, jak budou vypadat jednotlivé virtuální adresní
prostory.`,incorrect:`Jednotka správy paměti
Překlad adres proto musí být velmi rychlý, a není nijak překvapivé, že je realizován specializovaným
hardwarem, který je přímo součástí procesoru. Zároveň ale nesmíme dovolit aby operační systém jakkoli, jinak by došlo k porušení abstrakce.`},{uuid:"55366681-0aa7-4560-8d3b-04d25daaf52b",correct:`Stránky
Stránka je pak základní jednotkou překladu. Tím se jednak zmenší potřebné tabulky, jednak se tím
zjednoduší proces překladu. Budeme-li totiž požadovat, aby:

1. stránka obsahovala 2**n
adres (tj. měla velikost 2**n bajtů),
2. stránka začínala adresou, která je beze zbytku dělitelná 2**n
3. byla mapována na fyzickou adresu, která je také beze zbytku dělitelná 2**n,

můžeme spodních n bitů virtuální adresy přímo použít jako spodních n bitů adresy fyzické. Zbytek fyzické adresy již dopočítáme podle překladové tabulky.
To má mimo jiné za důsledek, že stránky se nemohou překrývat.`,incorrect:`Stránky
Stránka je pak základní jednotkou překladu. Tím se jednak zmenší potřebné tabulky, jednak se tím
zjednoduší proces překladu. Budeme-li totiž požadovat, aby:

1. stránka obsahovala 2**n
adres (tj. měla velikost 2**n bajtů),
2. stránka začínala adresou, která je beze zbytku dělitelná 2
3. byla mapována na fyzickou adresu, která je také beze zbytku dělitelná 2,

můžeme spodních n bitů virtuální adresy přímo použít jako spodních n bitů adresy fyzické. Zbytek fyzické adresy již dopočítáme podle překladové tabulky. 
To má mimo jiné za důsledek, že stránky se nemohou překrývat.`},{uuid:"c9aeb2a5-af9b-4795-8391-7b51e6b9b5b3",correct:`Stránkové tabulky
Stránkové tabulky jsou uloženy v operační paměti, ale jejich přesná struktura
je opět vlastností konkrétního hardwaru. Protože moderní počítače mají velké adresní prostory (2**32 nebo 2**64 virtuálních adres), 
používají obvykle řídké, víceúrovňové překladové tabulky.`,incorrect:`Stránkové tabulky
Stránkové tabulky jsou uloženy v operační paměti, ale jejich přesná struktura
je opět vlastností konkrétního hardwaru. Protože moderní počítače mají velké adresní prostory (2**32 nebo 2**64 virtuálních adres), 
používají obvykle husté, jednoúrovňové překladové tabulky.`},{uuid:"afc19ad0-8b8d-4b57-b248-d580fe1ed117",correct:`Proces
Pojem běžící program je poněkud vágní, proto si pro něj zavedeme formálnější alternativu
– proces. Tímto pojmem budeme označovat entitu, která:
• je spojena s virtuálním adresním prostorem, který
     ∘ obsahuje kód – instrukce – nějakého programu,
     ∘ veškerá data, která tento program potřebuje pro svůj běh,
• operační systém o ni vede záznam,
• může vlastnit krom paměti i další zdroje`,incorrect:`Proces
Pojem běžící program je poněkud vágní, proto si pro něj zavedeme formálnější alternativu
– proces. Tímto pojmem budeme označovat entitu, která:
• je spojena s fyzickým adresním prostorem, který
     ∘ obsahuje kód – instrukce – nějakého programu,
     ∘ veškerá data, která tento program potřebuje pro svůj běh,
• operační systém o ni vede záznam,
• může vlastnit krom paměti i další zdroje`},{uuid:"ae683a29-06e8-4423-bff3-431dcdeffe8c",correct:`Ochrana paměti
• Kód programu (a případná data, která jsou určena výhradně ke čtení) může být ve fyzické paměti uložen
pouze jednou i v případě, kdy tento kód využívá více procesů. Jedná se o užitečnou a zároveň bezpečnou
optimalizaci, protože odpovídající virtuální adresy jsou v obou procesech označeny příznakem pouze
pro čtení, a procesy se tak nemohou skrze tyto adresy vzájemně ovlivňovat.
• Na žádost programu může být dvěma procesům do jejich virtuálních adresních prostorů namapován
stejný blok fyzické paměti i v režimu umožňujícím zápis. Smyslem takto namapované paměti je umožnit
komunikaci mezi dotčenými procesy: mohou si tímto způsobem totiž jednoduše předávat data. Pozor:
virtuální adresy takto namapované paměti nebudou obecně v obou procesech stejné.`,incorrect:`Ochrana paměti
• Kód programu (a případná data, která jsou určena výhradně ke čtení) může být ve fyzické paměti uložen
pouze jednou i v případě, kdy tento kód využívá více procesů. Jedná se o užitečnou a zároveň bezpečnou
optimalizaci, protože odpovídající virtuální adresy jsou v obou procesech označeny příznakem pouze
pro čtení, a procesy se tak nemohou skrze tyto adresy vzájemně ovlivňovat.
• Na žádost programu může být dvěma procesům do jejich virtuálních adresních prostorů namapován
stejný blok fyzické paměti i v režimu umožňujícím zápis. Smyslem takto namapované paměti je umožnit
komunikaci mezi dotčenými procesy: mohou si tímto způsobem totiž jednoduše předávat data. Pozor:
virtuální adresy takto namapované paměti musí být v obou procesech stejné.`},{uuid:"2ef48559-386e-4d54-a758-d11535b9700f",correct:`Přepnutí procesu
Zatím jsme nezmínili, jak procesor (resp. jednotka správy paměti) najde
stránkovou tabulku první úrovně. Odpověď na tuto otázku je klíčem k přepínání procesů:
1. fyzická adresa stránkové tabulky 1. úrovně je uložena ve speciálním registru procesoru,
2. tuto adresu je možné nastavit privilegovanou instrukcí (privilegovanou v tomto případě znamená, že
ji může provést pouze jádro),
3. změnou hodnoty v tomto registru se aktivuje překlad adres podle nově zavedené stránkové tabulky`,incorrect:`Přepnutí procesu
Zatím jsme nezmínili, jak procesor (resp. jednotka správy paměti) najde
stránkovou tabulku první úrovně. Odpověď na tuto otázku je klíčem k přepínání procesů:
1. fyzická adresa stránkové tabulky 1. úrovně je uložena ve speciálním registru procesoru,
2. tuto adresu může nastavit libovolný uživatelský program ve speciálním režimu
3. změnou hodnoty v tomto registru se aktivuje překlad adres podle nově zavedené stránkové tabulky.`},{uuid:"a2d7aad3-93f4-4467-a206-2dc10342c61c",correct:`Vytvoření procesu
Asi nejjednodušší způsob, jak vytvořit nový proces, je duplikace nějakého
existujícího (POSIX této operaci říká fork). V mnoha operačních systémech je to dokonce způsob jediný.19
Mohlo by se zdát, že je to způsob dost neefektivní: procesy mohou mít virtuální adresní prostor
o velikosti mnoha GiB a duplikace takového množství paměti vyžaduje vynaložení značných prostředků.
Operační systémy proto používají trik, který zde vede k výrazné úspoře, a se kterým se setkáme ještě
v několika kontextech.
Tento trik nese název „copy on write“ a jeho myšlenka je poměrně jednoduchá:
1. vytvoříme kopii adresního prostoru (tedy relevantních stránkových tabulek, nikoliv samotných dat),
2. v obou kopiích označíme všechny stránky příznakem jen pro čtení a poznačíme si také, že se jedná o
„copy on write“ stránky.`,incorrect:`Vytvoření procesu
Asi nejjednodušší způsob, jak vytvořit nový proces, je duplikace nějakého
existujícího (POSIX této operaci říká fork). V mnoha operačních systémech je to dokonce způsob jediný.19
Mohlo by se zdát, že je to způsob dost neefektivní: procesy mohou mít virtuální adresní prostor
o velikosti mnoha GiB a duplikace takového množství paměti vyžaduje vynaložení značných prostředků.
Operační systémy proto používají trik, který zde vede k výrazné úspoře, a se kterým se setkáme ještě
v několika kontextech.
Tento trik nese název „copy on write“ a jeho myšlenka je poměrně jednoduchá:
1. vytvoříme kopii fyzických adres (tedy relevantních fyzických buněk, nikoliv samotných dat),
2. v obou kopiích označíme všechny stránky příznakem jen pro čtení a poznačíme si také, že se jedná o
„copy on write“ stránky.`},{uuid:"948a1dd0-0cbb-40e1-a5b7-331b19eccfb2",correct:`Externí stránkování 
Má-li OS nedostatek použitelných fyzických adres (například proto, že běží hodně programů, které využívají hodně
paměti), může některou stránku odstěhovat z operační paměti někam jinam – např. na externí (pevné)
úložiště, které je sice obvykle mnohem pomalejší, ale také má obvykle mnohem větší kapacitu. Nebude-li
se stávat příliš často, že program potřebuje k takto „odklizené“ stránce přistoupit, nemusí se jednat
o zásadní problém.`,incorrect:`Externí stránkování 
Má-li OS nedostatek použitelných fyzických adres (například proto, že běží hodně programů, které využívají hodně
paměti), může některou stránku odstěhovat z operační paměti někam jinam – např. na externí (pevné)
úložiště, které je sice obvykle mnohem pomalejší, ale také má obvykle mnohem větší kapacitu. Nebude-li
se stávat příliš často, že program k dané stránce dlouhodobě nepřistupuje, nemusí se jednat
o zásadní problém.`},{uuid:"11bf9d6c-eae4-42ed-b643-57e6575f149f",correct:`Rámce a stránky
• stránkou budeme i nadále označovat rozsah virtuálních adres,
   ∘ také stále platí, že stránky mají pevnou velikost (počet virtuálních adres, které obsahuje), a že
   ∘ nejnižší adresa stránky musí být beze zbytku dělitelná velikostí stránky,
• rámcem budeme označovat rozsah fyzických adres,
   ∘ které splňují stejné požadavky na velikost a zarovnání jako stránky,
   ∘ a na jeden rámec mapovat právě jednu stránku.
Lze pak mluvit o tom, že daná stránka je uložena v nějakém rámci, případně že daný rámec je volný.`,incorrect:`Rámce a stránky
• stránkou budeme i nadále označovat rozsah fyzických adres,
   ∘ také stále platí, že stránky mají pevnou velikost (počet virtuálních adres, které obsahuje), a že
   ∘ nejnižší adresa stránky musí být beze zbytku dělitelná velikostí stránky,
• rámcem budeme označovat rozsah virtuálních adres,
   ∘ které splňují stejné požadavky na velikost a zarovnání jako stránky,
   ∘ a na jeden rámec mapovat právě jednu stránku.
Lze pak mluvit o tom, že daná stránka je uložena v nějakém rámci, případně že daný rámec je volný.`},{uuid:"0c97920f-f8ce-4e4a-8288-4806281f481c",correct:`Líné načítání
Líné načítání lze také výhodně kombinovat s klasickým externím stránkováním – vybereme-li jako oběť
stránku s kódem (nebo konstantními daty) programu, není potřeba ji nikam ukládat – lze ji přímo odkázat
zpátky na spustitelný soubor.`,incorrect:`Líné načítání
Líné načítání lze také výhodně kombinovat s klasickým externím stránkováním – vybereme-li jako oběť
stránku s kódem (nebo konstantními daty) programu, stačí stránku uložit do operační paměti`},{uuid:"bede55a6-4eb7-495d-a782-db33aa4ddd6d",correct:`Mapování souborů
Posledním, jednoznačně nejdůležitějším, využitím externího stránkování je
mapování datových souborů do paměti (na žádost aplikace). V tomto režimu jsou externí stránky uloženy
v jinak běžném souboru. Místo komplikovaných vstupně-výstupních operací tak může program s obsahem
souboru pracovat stejně, jako by byl uložen v operační paměti. Využijeme-li tohoto mechanismu také
k zápisu změněných stránek zpátky do souboru, může program soubor i zcela transparentně upravovat.`,incorrect:`Mapování souborů
Posledním, jednoznačně nejdůležitějším, využitím externího stránkování je
mapování datových souborů do paměti (na žádost aplikace). V tomto režimu jsou externí stránky uloženy
v jinak běžném souboru. Místo komplikovaných vstupně-výstupních operací tak může program s obsahem
souboru pracovat stejně, jako by byl uložen v operační paměti. Toto ovšem zabraňujeprogramu soubor transparentně upravovat.`}]},{uuid:"b10b91c1-603f-4b7a-b0af-dc38ffdc198d",sectionNumber:"2",sectionTitle:"Virtualizace procesoru",statements:[{uuid:"264eddb9-905b-45b7-a88b-053ffde2a858",correct:`Výpočet
Procesor vykonává instrukce, čím realizuje výpočet. Nejjednodušší třídou instrukcí jsou
tzv. aritmetické a logické instrukce (tedy ty, které provádí ALU – aritmeticko-logická jednotka). Tím se
myslí zejména:
• aritmetika: sčítání, odečítání, násobení a dělení,
• bitové operace: and, or, xor po bitech, bitové posuvy,
• srovnání dvou hodnot (rovnost, nerovnost) – výsledek se uloží do běžného registru nebo do stavového
příznaku procesoru.`,incorrect:`Výpočet
Operační paměť vykonává instrukce, čím realizuje výpočet. Nejjednodušší třídou instrukcí jsou
tzv. aritmetické a logické instrukce (tedy ty, které provádí ALU – aritmeticko-logická jednotka). Tím se
myslí zejména:
• aritmetika: sčítání, odečítání, násobení a dělení,
• bitové operace: and, or, xor po bitech, bitové posuvy,
• srovnání dvou hodnot (rovnost, nerovnost) – výsledek se uloží do běžného registru nebo do stavového
příznaku procesoru.`},{uuid:"edb552d0-c513-4db9-bb3d-1e40efe1d267",correct:`Registry
Podobně jako paměť, registry slouží k ukládáni čísel – existují dva klíčové rozdíly mezi
registry a pamětí:
1. pojmenování registru je pevnou součástí instrukce, kdežto paměťovou adresu lze vypočítat (paměť
lze indexovat, registry nikoliv),
2. reprezentace čísla v registru je monolitická – registry nejsou složené z bajtů, daný registr obsahuje
celé slovo (částečně důsledek předchozího bodu: registr lze pojmenovat pouze jako celek).`,incorrect:`Registry
Podobně jako paměť, registry slouží k ukládáni čísel – existují dva klíčové rozdíly mezi
registry a pamětí:
1. pojmenování registru je pevnou součástí instrukce, kdežto paměťovou adresu lze vypočítat (paměť
lze indexovat, registry nikoliv),
2. reprezentace čísla v registru – registry jsou složené z bajtů, daný registr obsahuje
bajty jako každá jíná část paměti`},{uuid:"76747520-5f05-4cb6-8605-7e9de42684cd",correct:`Programový čítač
Vyhrazený registr (programový čítač, angl. program counter, někdy také instruction pointer, budeme
jej označovat pc) pak obsahuje virtuální adresu právě vykonávané instrukce. Tento registr rozhoduje
o tom, která instrukce se má vykonat, není do něj ale obvykle možné zapisovat běžnými (aritmetickými,
atp.) instrukcemi. K tomu jsou určeny instrukce řízení toku, kterých hlavním efektem je právě změna
hodnoty programového čítače.`,incorrect:`Programový čítač
Vyhrazený registr (programový čítač, angl. program counter, někdy také instruction pointer, budeme
jej označovat pc) pak obsahuje fyzickou adresu právě vykonávané instrukce. Tento registr rozhoduje
o tom, která instrukce se má vykonat, není do něj ale obvykle možné zapisovat běžnými (aritmetickými,
atp.) instrukcemi. K tomu jsou určeny instrukce řízení toku, kterých hlavním efektem je právě změna
hodnoty programového čítače.`},{uuid:"573e86fc-9431-48c3-aad6-4972ecb5d0d0",correct:`Instrukce
Instrukce je elementární příkaz strojového kódu; to znamená:
• elementární – je to nejmenší jednotka činnosti, kterou lze procesoru zadat,
• příkaz – instrukce řídí činnost procesoru, „přikazují“ mu provedení nějaké akce.
Instrukcí budeme nazývat pouze celek, který obsahuje veškeré informace potřebné k provedení konkrétních
akcí (zejména udává operaci, která se má provést, a konkrétní registry, se kterými se bude pracovat a
také konkrétní přímé operandy.
Instrukcí je pouze konečně mnoho, je tedy zejména možné je očíslovat (nebo jinak konečně kódovat,
např. do sekvencí bajtů). Každé takové číslo (kódování) popisuje konkrétní akci, kterou může procesor
provést.
`,incorrect:`Instrukce
Instrukce je elementární příkaz strojového kódu; to znamená:
• elementární – je to nejmenší jednotka činnosti, kterou lze procesoru zadat,
• příkaz – instrukce řídí činnost procesoru, „přikazují“ mu provedení nějaké akce.
Instrukcí budeme nazývat pouze celek, který obsahuje veškeré informace potřebné k provedení konkrétních
akcí (zejména udává operaci, která se má provést, a konkrétní registry, se kterými se bude pracovat a
také konkrétní přímé operandy.
Instrukcí je nekonečně mnoho, je tedy nepraktické je číslovat
`},{uuid:"0e3f7594-8a65-4e61-bc4b-82dc78ddcc80",correct:`Efekt instrukce
Každá instrukce má nějaký efekt na stav procesoru, a případně (podle konkrétní instrukce) na další připojená zařízení (zejména paměť). 
Tento efekt je zároveň definující charakteristikou dané instrukce.
Program totiž nedělá nic jiného, než že vhodnou manipulací stavu (procesoru, paměti, periferií) postupuje
od vstupů k požadovaným výstupům. Této posloupnosti změn stavu říkáme výpočet.
`,incorrect:`Efekt instrukce
Každá instrukce má nějaký efekt na stav procesoru, a případně (podle konkrétní instrukce) na další připojená zařízení (zejména paměť). 
Tento efekt není definující charakteristikou dané instrukce.
Program totiž nedělá nic jiného, než že vhodnou manipulací stavu (procesoru, paměti, periferií) postupuje
od vstupů k požadovaným výstupům. Této posloupnosti změn stavu říkáme výpočet.
`},{uuid:"cc602ec9-5701-467c-84e2-e820f207c2e4",correct:`Efekt instrukce
Jak vstupy tak výstupy programu jsou součástí stavu – vstupy na začátku, výstupy na konci výpočtu.
Vstup může být například hodnota zapsaná v nějaké buňce paměti; výstup může být třeba stav obrazovky,
kdy rozsvícené pixely vytváří obrazec, který přečteme jako slova hello world.
Efekt instrukce tedy není nic jiného, než elementární změna stavu, nebo jinak řečeno elementární výpočet.
Instrukci samotnou tak můžeme chápat jako pokyn k provedení takového elementárního výpočtu.`,incorrect:`Efekt instrukce
Jak vstupy tak výstupy programu jsou součástí stavu – vstupy na začátku, výstupy na konci výpočtu.
Vstup musí být hodnota zapsaná v nějaké buňce paměti; výstup může být třeba stav obrazovky,
kdy rozsvícené pixely vytváří obrazec, který přečteme jako slova hello world.
Efekt instrukce tedy není nic jiného, než elementární změna stavu, nebo jinak řečeno elementární výpočet.
Instrukci samotnou tak můžeme chápat jako pokyn k provedení takového elementárního výpočtu.`},{uuid:"f31297bb-3624-4a7a-8a8f-24dadc1c134f",correct:`Program
Co bude program počítat (resp. co bude počítat procesor řízený daným programem)
je určeno textem programu: instrukcemi uloženými v paměti. Instrukce, které nejsou skoky, obvykle
posouvají programový čítač za svůj vlastní konec, tedy na instrukci na nejbližší vyšší adrese. Většina
programu je tedy prováděna v pořadí od nižších k vyšším (virtuálním) adresám.
Výjimku samozřejmě tvoří instrukce skoku, které mohou některé adresy přeskočit (typicky podmíněné
příkazy – if), nebo se naopak vrátit k některé dřívější, už vykonané instrukci (typicky cykly – while)`,incorrect:`Program
Co bude program počítat (resp. co bude počítat procesor řízený daným programem)
je určeno textem programu: instrukcemi uloženými v paměti. Instrukce, které nejsou skoky, obvykle
posouvají programový čítač za svůj vlastní konec, tedy na instrukci na nejbližší nižší adrese. Většina
programu je tedy prováděna v pořadí od vyšších k nižším (virtuálním) adresám.
Výjimku samozřejmě tvoří instrukce skoku, které mohou některé adresy přeskočit (typicky podmíněné
příkazy – if), nebo se naopak vrátit k některé dřívější, už vykonané instrukci (typicky cykly – while)`},{uuid:"d7398ff5-6fa7-47e0-bd60-7d7f7de24b79",correct:`Zásobník
Za účelem aktivace podprogramu by se nám hodila jakási odlehčená verze virtualizace procesoru:
1. podprogram je dostatečně uzavřený celek na to, aby mělo smysl jej alespoň částečně oddělit od
ostatních výpočtů – často např. používá nějaká data, která mimo tento podprogram nemají žádný
význam (ve vyšším programovacím jazyce lokální proměnné),
2. protože takový podprogram je navíc často potřeba spouštět z různých míst programu, je žádoucí mít
nějaký mechanismus, který po ukončení výpočtu podprogramu vrátí řízení na místo, ze kterého byl
původně aktivován.
Obě tyto funkce zastává zásobník (hardwarový zásobník, zásobník volání, angl. call stack, atp.). Jedná
se o spojitou oblast virtuálního adresního prostoru, které rozsah je dán hodnotou ukazatele vrcholu
zásobníku (jedná se o druhý „speciální“ registr, vedle programového čítače) a pevným dnem.`,incorrect:`Zásobník
Za účelem aktivace podprogramu by se nám hodila jakási odlehčená verze virtualizace procesoru:
1. podprogram není dostatečně uzavřený celek na to, aby mělo smysl jej  oddělit od ostatních výpočtů, proto ho neoddělujeme
2. protože takový podprogram je navíc často potřeba spouštět z různých míst programu, je žádoucí mít
nějaký mechanismus, který po ukončení výpočtu podprogramu vrátí řízení na místo, ze kterého byl
původně aktivován.
Obě tyto funkce zastává zásobník (hardwarový zásobník, zásobník volání, angl. call stack, atp.). Jedná
se o spojitou oblast virtuálního adresního prostoru, které rozsah je dán hodnotou ukazatele vrcholu
zásobníku (jedná se o druhý „speciální“ registr, vedle programového čítače) a pevným dnem.`},{uuid:"db965fa7-a4ac-410b-8117-b95d4ce665c3",correct:`Aktivační záznam
Zásobník typického programu je složen z aktivačních záznamů, známých též
jako rámců (angl. call frame). Každý takový záznam odpovídá jedné aktivaci podprogramu, která
dosud neskončila. Jak jistě víte, podprogramy se mohou aktivovat (volat) vzájemně, nebo může dokonce
podprogram opakovaně aktivovat sám sebe – jev, který pravděpodobně znáte jako rekurzi.
Je také relativně logické, že má-li nějaký podprogram skončit (a tedy má být jeho aktivační záznam
odstraněn), musí nejprve skončit všechny podprogramy, které sám aktivoval (přímo či nepřímo). Tato
skutečnost je odpovědná za to, že aktivační rámce tvoří právě zásobník (a ne třeba frontu, strom,
graf, nebo jinou strukturu).`,incorrect:`Aktivační záznam
Zásobník typického programu je složen z aktivačních záznamů, známých též
jako rámců (angl. call frame). Každý takový záznam odpovídá jedné aktivaci podprogramu, který již skončil.
Jak jistě víte, podprogramy se mohou aktivovat (volat) vzájemně, nebo může dokonce
podprogram opakovaně aktivovat sám sebe – jev, který pravděpodobně znáte jako rekurzi.
Je také relativně logické, že má-li nějaký podprogram skončit (a tedy má být jeho aktivační záznam
odstraněn), musí nejprve skončit všechny podprogramy, které sám aktivoval (přímo či nepřímo). Tato
skutečnost je odpovědná za to, že aktivační rámce tvoří právě zásobník (a ne třeba frontu, strom,
graf, nebo jinou strukturu).`},{uuid:"6d7106a8-25f6-4fee-a1fa-22bc19ab9a5e",correct:`Stav procesoru
Stav procesoru tedy sestává z:
1. hodnot uložených v aritmetických registrech,
2. hodnoty programového čítače,
3. hodnoty ukazatele zásobníku.
V případě, že:
• program neobsahuje instrukce přístupu do paměti,
• nebo celý virtuální adresní prostor je přístupný pouze aktivnímu programu,
je celý výpočet jednoznačně určen programem samotným a počátečním stavem procesoru (a případně
paměti).`,incorrect:`Stav procesoru
Stav procesoru tedy sestává z:
1. hodnot uložených v aritmetických registrech,
2. hodnoty programového čítače,
3. hodnoty ukazatele zásobníku.
V případě, že:
• program neobsahuje instrukce přístupu do paměti,
• a celý virtuální adresní prostor je přístupný pouze aktivnímu programu
je celý výpočet jednoznačně určen programem samotným a počátečním stavem procesoru (a případně
paměti).`},{uuid:"93f63c6e-b694-4845-8406-08800e539e6c",correct:`Vlákno
Nyní jsme konečně připraveni definovat pojem vlákno: je to
• výpočet (posloupnost změn stavu), který vznikne
• nepřerušenou činností jednoho procesoru, který je
• po celou dobu řízen jedním programem.
Všimněte si, že neklademe žádné požadavky na adresní prostor. Takový výpočet tedy není jednoznačně
určen, protože není izolován – součástí takového výpočtu může být synchronizace, a tedy průběh výpočtu
krom samotného programu a počátečního stavu bude záviset také na vnějších událostech, které může
vlákno skrze svůj adresní prostor pozorovat.
Za povšimnutí také stojí, že definice nepovoluje, aby se stav procesoru měnil jakkoliv jinak, než
řízením programu. Bude také výhodné předpokládat, že zásobník je pro externí entity nepřístupný a že
jej tedy chápat jako součást stavu vlákna (který je jinak shodný se stavem procesoru).`,incorrect:`Vlákno
Nyní jsme konečně připraveni definovat pojem vlákno: je to
• výpočet (posloupnost změn stavu), který vznikne
• nepřerušenou činností jednoho procesoru, který je
• po celou dobu řízen jedním programem.
Všimněte si, že neklademe žádné požadavky na adresní prostor. Takový výpočet tedy je jednoznačně určen.
Za povšimnutí také stojí, že definice nepovoluje, aby se stav procesoru měnil jakkoliv jinak, než
řízením programu. Bude také výhodné předpokládat, že zásobník je pro externí entity nepřístupný a že
jej tedy chápat jako součást stavu vlákna (který je jinak shodný se stavem procesoru).`},{uuid:"9fb6a8a7-7b14-4017-b677-8de65c98e3b2",correct:`Logický procesor
Definice vlákna se odvolává na nepřerušenou činnost procesoru. Pro účely této
definice si ale vystačíme s velmi abstraktním chápáním procesoru:
1. procesor má stav, který sestává právě z hodnot registrů,
2. procesor svůj stav mění vykonáváním instrukcí (a nijak jinak).
Takto popsaný procesor budeme nazývat logickým procesorem. Má několik zajímavých vlastností:
1. je zřejmé, že výpočet logického procesoru lze přímočaře realizovat na fyzickém procesoru,
2. stav logického procesoru je velmi jednoduchý a tedy není těžké si představit, že bychom ho mohli
například uložit do paměti (to se nakonec částečně děje i při aktivaci podprogramu),
3. lze si také představit, že bychom mohli fyzický procesor do takto uloženého stavu zase vrátit.
Předpokládejme, že operace z bodů 2 a 3 skutečně existují, a že je může operační systém provést bez
součinnosti aktuálně prováděného vlákna. Pak už je jednoduše vidět, jak realizovat několik logických
procesorů pomocí jednoho fyzického, a tím dosáhnout virtualizace procesoru
`,incorrect:`Logický procesor
Definice vlákna se odvolává na nepřerušenou činnost procesoru. Pro účely této
definice si ale vystačíme s velmi abstraktním chápáním procesoru:
1. procesor má stav, který sestává právě z hodnot registrů,
2. procesor svůj stav mění vykonáváním instrukcí (a nijak jinak).
Takto popsaný procesor budeme nazývat logickým procesorem. Má několik zajímavých vlastností:
1. je zřejmé, že výpočet logického procesoru lze přímočaře realizovat na fyzickém procesoru,
2. stav logického procesoru je velmi složitý a tedy není možné ho uložit do paměti 
`},{uuid:"53447778-7381-4f94-9654-0ad066ba6a3e",correct:`Přepnutí vlákna
Protože můžeme uložit, a později obnovit, stav logického procesoru, můžeme na
jednom fyzickém procesoru provádět střídavě několik různých vláken, a zároveň zabezpečit, že každé
vlákno má, ze svého vlastního pohledu, pomyslný vlastní procesor.
Co obnáší uložení a obnova registru závisí na jejich typu:
1. aritmetické registry – teoreticky nepředstavují problém, ale protože bez aritmetických registrů
nelze nic počítat, nelze bez asistence procesoru uložit ani obnovit všechny,
2. ukazatel zásobníku v principu jednoduché jak uložit tak obnovit, problém ale nastane, používáme-li
zásobníkové instrukce k manipulaci s ostatními registry,
3. programový čítač představuje největší problém: nelze přímo ani uložit (vyžadovalo by součinnost
prováděného programu), ani obnovit (obnovou automaticky ztrácíme kontrolu nad procesorem, musí
tedy být provedena v posledním kroku, kdy už ale nemáme k dispozici žádné aritmetické registry).
`,incorrect:`Přepnutí vlákna
Protože můžeme uložit, a později obnovit, stav logického procesoru, můžeme na
jednom fyzickém procesoru provádět střídavě několik různých vláken, a zároveň zabezpečit, že každé
vlákno má, ze svého vlastního pohledu, pomyslný vlastní procesor.
Co obnáší uložení a obnova registru závisí na jejich typu:
1. aritmetické registry – teoreticky nepředstavují problém, protože je lze obnovit všechny,
2. ukazatel zásobníku v principu jednoduché jak uložit tak obnovit, problém ale nastane, používáme-li
zásobníkové instrukce k manipulaci s ostatními registry,
3. programový čítač představuje největší problém: nelze přímo ani uložit (vyžadovalo by součinnost
prováděného programu), ani obnovit (obnovou automaticky ztrácíme kontrolu nad procesorem, musí
tedy být provedena v posledním kroku, kdy už ale nemáme k dispozici žádné aritmetické registry).
`},{uuid:"7e9a4b08-e60e-4df7-b41a-20437c17ae03",correct:`Plánovač
Části jádra operačního systému, která je odpovědná za přidělování procesorů vláknům
říkáme plánovač vláken, často také z historických důvodů plánovač procesů. Plánovač je na každém
procesoru aktivován v pravidelných intervalech a je mu tedy umožněno odebrat procesor aktivnímu
vláknu i bez součinnosti tohoto vlákna.
Základním rozhodnutím plánovače při každé aktivaci je: „Má aktivní vlákno (logický procesor) pokračovat
ve výpočtu, nebo má být přerušeno (preempted). Které vlákno má být na procesoru spuštěno jako další?
`,incorrect:`Plánovač
Části jádra operačního systému, která je odpovědná za přidělování procesorů vláknům
říkáme plánovač vláken, často také z historických důvodů plánovač procesů. Plánovač je jen na hlavním
procesoru aktivován v pravidelných intervalech a je mu tedy umožněno odebrat procesor aktivnímu
vláknu i bez součinnosti tohoto vlákna.
Základním rozhodnutím plánovače při každé aktivaci je: „Má aktivní vlákno (logický procesor) pokračovat
ve výpočtu, nebo má být přerušeno (preempted). Které vlákno má být na procesoru spuštěno jako další?
`},{uuid:"a807cb62-7b73-4c6d-a1b3-885a7b62172d",correct:`Cíle plánovače
Na plánovací algoritmus (a plánovač jako celek) máme několik základních požadavků:
1. maximalizovat propustnost
2. minimalizovat latenci (prodlevu)
3. udržovat férovost
Je na první pohled vidět, že některé požadavky jsou protichůdné: zejména latence a propustnost často
stojí proti sobě, a zlepšení jednoho parametru vede ke zhoršení toho druhého.`,incorrect:`Cíle plánovače
Na plánovací algoritmus (a plánovač jako celek) máme několik základních požadavků:
1. minimalizovat propustnost
2. maximalizovat latenci (prodlevu)
3. udržovat férovost
Je na první pohled vidět, že některé požadavky jsou protichůdné: zejména latence a propustnost často
stojí proti sobě, a zlepšení jednoho parametru vede ke zhoršení toho druhého.`},{uuid:"09258925-1c6f-418f-9249-066118f9cb02",correct:`Stav vlákna
Vlákno (které ještě neskončilo) může být, z pohledu plánovače, ve třech základních
stavech:
1. právě běží – má aktuálně přidělený procesor,
2. připraveno ke běhu, ale čeká na procesor – vlákno bylo přerušeno plánovačem (nebo nebylo dosud nikdy
spuštěno), ale jinak mu nic nebrání pokračovat ve výpočtu,
3. čeká na událost – vlákno je „zaseknuté“ v synchronizační smyčce a nemůže pokračovat ve výpočtu,
dokud nenastane nějaká externí událost (plánovači musí být tento stav explicitně oznámen, jinak jej
nemá jak rozeznat od běžného výpočtu).

nemůže se stát, že by vlákno, které čekalo na procesor, přešlo do stavu čekání na událost
– tento přechod totiž vyžaduje nějakou akci, kterou musí provést samotné vlákno.
`,incorrect:`Stav vlákna
Vlákno (které ještě neskončilo) může být, z pohledu plánovače, ve třech základních
stavech:
1. právě běží – má aktuálně přidělený procesor,
2. připraveno ke běhu, ale čeká na procesor – vlákno bylo přerušeno plánovačem (nebo nebylo dosud nikdy
spuštěno), ale jinak mu nic nebrání pokračovat ve výpočtu,
3. čeká na událost – vlákno je „zaseknuté“ v synchronizační smyčce a nemůže pokračovat ve výpočtu,
dokud nenastane nějaká externí událost (plánovači musí být tento stav explicitně oznámen, jinak jej
nemá jak rozeznat od běžného výpočtu).

Vlákno může libovolně přecházet mezi všemi stavy, tyto přechody jsou řízeny procesorem`},{uuid:"0062ed2f-5b53-47e1-967f-438071449e4e",correct:`Fronta úloh
Základním pracovním nástrojem plánovače jsou běhové fronty úloh (angl. run queue),
do kterých plánovač řadí vlákna, která čekají na procesor. Konkrétní plánovací algoritmy se pak liší
zejména v tom, jak se tyto fronty chovají.
`,incorrect:`Fronta úloh
Základním pracovním nástrojem plánovače jsou běhové fronty úloh (angl. run queue),
do kterých plánovač řadí vlákna, která čekají na událost. Konkrétní plánovací algoritmy se pak liší
zejména v tom, jak se tyto fronty chovají.
`},{uuid:"dc0cea85-6120-4820-81f0-66da52c1cd8a",correct:`Afinita
Protože migrace vlákna na jiný fyzický procesor není zadarmo, je žádoucí zbytečným
migracím vláken zamezit. Mluvíme v takovém případě o afinitě vlákna ke konkrétnímu fyzickému procesoru:
plánovač má snahu vlákno opakovaně plánovat na stejný fyzický procesor.
Mezní situace jsou:
1. plánovač zcela bez afinity: např. proto, že má globální frontu a tedy je prvnímu čekajícímu vláknu
vždy přidělen první uvolněný procesor,
2. plánovač bez možnosti migrace: např. proto, že má lokální fronty, a neumožňuje přesun vláken mezi
nimi.`,incorrect:`Afinita
Protože migrace vlákna na jiný fyzický procesor není zadarmo, je žádoucí zbytečným
migracím vláken zamezit. Mluvíme v takovém případě o afinitě vlákna ke konkrétnímu fyzickému procesoru:
plánovač má snahu vlákno opakovaně plánovat na stejný fyzický procesor.
Mezní situace jsou:
1. plánovač zcela bez afinity: např. proto, že má lokální fronty, a neumožňuje přesun vláken mezi
nim,
2. plánovač bez možnosti migrace: např. proto,že má globální frontu a tedy je prvnímu čekajícímu vláknu
vždy přidělen první uvolněný procesor.`},{uuid:"9632cc6a-3d1b-42d0-ae93-530f771477c4",correct:`Prioritní fronty
Interaktivní plánovače používají téměř výhradně nějakou formu prioritního
plánování – vlákna mají přidělenu prioritu (staticky nebo dynamicky), která ovlivňuje jejich schopnost
získat procesor – a to jak latenci (jak dlouho musí vlákno čekat ve frontě) tak celkový přidělený
výpočetní čas (jaký díl procesorového času je vláknu přidělen).
`,incorrect:`Prioritní fronty
Interaktivní plánovače používají téměř výhradně nějakou formu prioritního
plánování – vlákna mají přidělenu prioritu (staticky nebo dynamicky), která ovlivňuje jejich schopnost
získat procesor – a to jen latenci (jak dlouho musí vlákno čekat ve frontě), celkový přidělený
výpočetní čas ovlivňovat nemůže
`},{uuid:"d7717bf6-1f50-45fe-bb97-a71a92e79b96",correct:`Prioritní fronty
výhody:
• používá pouze jednoduché datové struktury,
• všechny operace jsou asymptoticky konstantní (vzhledem k počtu čekajících vláken – počet prioritních
tříd je pevný).
A také jednu důležitou nevýhodu:
• dlouho běžící výpočetní vlákno s vysokou prioritou zablokuje procesor pro všechna ostatní vlákna.
Tuto nevýhodu lze vyřešit dynamickou úpravou priority: za každou přidělenou jednotku výpočetního času
je vlákno „potrestáno“ snížením priority. Existují-li jiná čekající vlákna, dříve nebo později se tak
dostanou ke slovu.`,incorrect:`Prioritní fronty
výhody:
• používá pouze jednoduché datové struktury,
• všechny operace jsou asymptoticky konstantní (vzhledem k počtu čekajících vláken – počet prioritních
tříd je pevný).
A také jednu důležitou nevýhodu:
• dlouho běžící výpočetní vlákno s vysokou prioritou zablokuje procesor pro všechna ostatní vlákna.
Tuto nevýhodu nelze vyřešit dynamickou úpravou priority, docházelo by k takzvanému hladovění vláken.`},{uuid:"ce22047e-936a-4239-9913-883084508e88",correct:`Férové plánování
Cílem férového plánovače je, aby každé vlákno dostalo přiděleno podle možnosti
stejné množství výpočetního času (případně váženo prioritou). V tomto se podobá na systém s dynamickou
úpravou priority z předchozí sekce, ale místo pevného systému prioritních tříd má priority v libovolném
rozsahu. Realizuje se proto klasickou (monolitickou) prioritní frontou – např. binární haldou nebo
binárním vyhledávacím stromem.`,incorrect:`Férové plánování
Cílem férového plánovače je, aby každé vlákno dostalo přiděleno podle možnosti
stejné množství výpočetního času (případně váženo prioritou). V tomto se podobá na systém s dynamickou
úpravou priority z předchozí sekce, ale místo pevného systému prioritních tříd má priority v libovolném
rozsahu. Realizuje se proto zásobníkem.`},{uuid:"3edc6104-4785-437e-be03-f29fcc069178",correct:`Odebrání procesoru
Rozhodnutí o odebrání procesoru (tzn. přesunu vlákna ze stavu „běží“ do
stavu „čeká na procesor“) má dva základní vstupy:
1. jak dlouho již běží právě aktivní vlákno,
2. srovnání aktivního vlákna a následujícího vlákna ve frontě.
Konkrétní rozhodnutí opět závisí na konkrétním plánovacím algoritmu. Je ale obvyklé nechat aktivní
vlákno běžet nějaký minimální čas, i v případě, že další naplánované vlákno má vyšší prioritu (tímto se
brání příliš častému přepínání vláken) – tento minimální čas je plánovací kvantum. Delší kvantum má
pozitivní vliv na propustnost, ale negativní vliv na latenci (reakční dobu).`,incorrect:`Odebrání procesoru
Rozhodnutí o odebrání procesoru (tzn. přesunu vlákna ze stavu „běží“ do
stavu „čeká na procesor“) má dva základní vstupy:
1. jak dlouho již běží právě aktivní vlákno,
2. srovnání aktivního vlákna a následujícího vlákna ve frontě.
Konkrétní rozhodnutí opět závisí na konkrétním plánovacím algoritmu. Je ale obvyklé nechat aktivní
vlákno běžet nějaký minimální čas, i v případě, že další naplánované vlákno má vyšší prioritu (tímto se
brání příliš častému přepínání vláken) – tento minimální čas je plánovací kvantum. Delší kvantum má
negativní vliv na propustnost, ale pozitivní vliv na latenci (reakční dobu).`},{uuid:"15b43073-f837-4595-9955-1d4f5aa705f8",correct:`Čekající vlákna
Vlákno je označeno jako čekající na událost (říkáme o něm také, že je uspané)
buď na vlastní žádost (umožňuje-li to operační systém a povaha události), nebo na popud některé jiné
části operačního systému:
• vyžádá-li například vlákno čtení ze souboru, a operační systém nemá aktuálně data k dispozici, zařádí
požadavek na data do fronty a vlákno uspí,
• pokusí-li se vstoupit do kritické sekce, která je aktuálně zamčená jiným vláknem,
• vyžádá vstup z klávesnice (a zrovna není žádný k dispozici),
`,incorrect:`Čekající vlákna
Vlákno je označeno jako čekající na událost (říkáme o něm také, že je uspané) na žádost pouze operačního systému, příklad:
• vyžádá-li například vlákno čtení ze souboru, a operační systém nemá aktuálně data k dispozici, zařádí
požadavek na data do fronty a vlákno uspí,
• pokusí-li se vstoupit do kritické sekce, která je aktuálně zamčená jiným vláknem,
• vyžádá vstup z klávesnice (a zrovna není žádný k dispozici),
`},{uuid:"04a66110-d893-4fdb-b17a-cdb0717b8a5a",correct:`Čekající vlákna
Události čekání jsou v zásadě dvou typů:
• čekání na vyřízení „soukromého“ požadavku: takto uspané vlákno je poznačeno u příslušného požadavku,
a jakmile je tento vyřízen, odpovědná komponenta vlákno probudí (aktivuje plánovač, který vlákno
přesune do běhové fronty, nebo mu ihned přidělí procesor),
• soutěž o nějaký zdroj (např. zmiňovaná kritická sekce), který může vlastnit v danou chvíli nejvýše
jedno vlákno, ale na který jich může zároveň čekat několik: takové zdroje mají čekací frontu (angl.
wait queue) a příslušná událost probudí (přesune do běhové fronty) pouze první vlákno z čekací fronty:
nemá smysl probouzet všechna, protože by okamžitě všechna krom jednoho musela být zase uspána
(vyhrát soutěž může nejvýše jedno).
`,incorrect:`Čekající vlákna
Události čekání jsou v zásadě dvou typů:
• čekání na vyřízení „soukromého“ požadavku: takto uspané vlákno je poznačeno u příslušného požadavku,
a jakmile je tento vyřízen, odpovědná komponenta vlákno přesune na jiný procesor.
• soutěž o nějaký zdroj (např. zmiňovaná kritická sekce), který může vlastnit v danou chvíli nejvýše
jedno vlákno, ale na který jich může zároveň čekat několik: takové zdroje mají čekací frontu (angl.
wait queue) a příslušná událost probudí (přesune do běhové fronty) pouze první vlákno z čekací fronty:
nemá smysl probouzet všechna, protože by okamžitě všechna krom jednoho musela být zase uspána
(vyhrát soutěž může nejvýše jedno).
`}]},{uuid:"bb007866-d6bd-417d-9646-a312826bca5d",sectionNumber:"3",sectionTitle:"Souborové systémy",statements:[{uuid:"4586a34d-edac-49a2-a467-4b0003ad8eb8",correct:` Bloková zařízení
Tento typ zařízení představuje abstrakci perzistentních úložišť. Operace (abstraktního) blokového
zařízení jsou přizpůsobené běžným schopnostem odpovídajících reálných zařízení:
• zápis a čtení je prováděno po blocích pevné velikosti,
• v libovolném pořadí, ale
• s velkou latencí a malou propustností (relativně k operační paměti).`,incorrect:` Bloková zařízení
Tento typ zařízení představuje abstrakci perzistentních úložišť. Operace (abstraktního) blokového
zařízení jsou přizpůsobené běžným schopnostem odpovídajících reálných zařízení:
• zápis a čtení je prováděno po bajtech,
• v libovolném pořadí, ale
• s velkou latencí a malou propustností (relativně k operační paměti).`},{uuid:"f62d928a-415e-4d19-b205-558e72a55e94",correct:`Trvalé úložiště
je fyzické zařízení, které se podobá na operační paměť (pamatuje si data),
s několika klíčovými rozdíly:
1. data zde uložená přetrvávají „dlouhodobě“, tedy zejména i po vypnutí počítače (nebo restartu
operačního systému),
2. přístup k datům je pomalejší – zejména má mnohem vyšší latenci (prodlevu) mezi vystavením požadavku
a odpovědí zařízení; je proto nepraktické adresovat takové zařízení po jednotlivých bajtech (jako
tomu je u operační paměti),
3. proto je obvyklé, že poskytují operace, které pracují s celými bloky dat najednou (velikost 512 bajtů
a víc, často 4 KiB) – základní operací je pak přesun takového bloku mezi zařízením a operační pamětí.`,incorrect:`Trvalé úložiště
je fyzické zařízení, které se podobá na operační paměť (pamatuje si data),
s několika klíčovými rozdíly:
1. data zde uložená přetrvávají „krátkodobě“, tedy zejména po vypnutí počítače jsou odstraněna,
2. přístup k datům je pomalejší – zejména má mnohem vyšší latenci (prodlevu) mezi vystavením požadavku
a odpovědí zařízení; je proto nepraktické adresovat takové zařízení po jednotlivých bajtech (jako
tomu je u operační paměti),
3. proto je obvyklé, že poskytují operace, které pracují s celými bloky dat najednou (velikost 512 bajtů
a víc, často 4 KiB) – základní operací je pak přesun takového bloku mezi zařízením a operační pamětí.`},{uuid:"defaabea-8663-42c7-a691-8c6d966116e0",correct:`Latence
doba mezi požadavkem a odpovědí; příliš velká, než aby bylo lze ignorovat; rozdíl proti
operační paměti: nelze skrýt hardwarově, musí řešit OS; problém zejména pro spolehlivé uložení dat –
durability v ACID – nutné čekat na potvrzení zápisu`,incorrect:`Latence
doba mezi požadavkem a odpovědí; příliš velká, než aby bylo lze ignorovat; rozdíl proti
operační paměti: nelze skrýt softwarově, musí řešit HW`},{uuid:"89dd5e94-96de-45ad-8251-70bd46393adb",correct:` Mezipaměť
Hlavní problém, který mezipaměť řeší, je opakovaný přístup ke stejným adresám daného
datového úložiště. Přístup k datům obvykle není rovnoměrný – některá data jsou potřebná často (např.
aktivně využívaná databáze), zatímco jiná (archiv dat z minulého roku) jen velmi zřídka. Proto je výhodné
si nedávno čtená data pamatovat v rychlejší paměti: může se totiž lehce stát, že je bude potřeba přečíst
v blízké budoucnosti znovu.
Podobně má smysl některá data načíst do mezipaměti s předstihem (existuje-li volná přenosová kapacita;
této technice se angl. říká prefetch)`,incorrect:` Mezipaměť
Hlavní problém, který mezipaměť řeší, je opakovaný přístup ke stejným adresám daného
datového úložiště. Přístup k datům obvykle není rovnoměrný – některá data jsou potřebná často (např.
aktivně využívaná databáze), zatímco jiná (archiv dat z minulého roku) jen velmi zřídka. Proto je výhodné
si nedávno čtená data úkládat v procesoru: může se totiž lehce stát, že je bude potřeba přečíst
v blízké budoucnosti znovu.
Podobně má smysl některá data načíst do mezipaměti s předstihem (existuje-li volná přenosová kapacita;
této technice se angl. říká prefetch)`},{uuid:"d7afb4ca-9ecc-4927-a268-aeb8cd40db52",correct:`Vyrovnávací paměť
Existují dvě základní možnosti, jak vyrovnávací paměti realizovat:
1. oddělené od mezipaměti: vyrovnávací paměť obsahuje jak samotné požadavky, tak veškerá data s nimi
spojená; jsou-li některé dotčené bloky uložené v mezipaměti, tyto jsou buď zneplatněny, nebo (častěji)
upraveny na místě,
2. propojená s mezipamětí: vyrovnávací paměť obsahuje pouze frontu požadavků na zápis – samotné
datové bloky se ukládají vždy do mezipaměti, fronta nevyřízených zápisů do ní pouze odkazuje; takto
koncipovaný systém se, jako celek, chová jako mezipaměť s opožděným zápisem (angl. write-back
cache).`,incorrect:`Vyrovnávací paměť
Existují dvě základní možnosti, jak vyrovnávací paměti realizovat:
1. oddělené od mezipaměti: vyrovnávací paměť obsahuje jak samotné požadavky, tak veškerá data s nimi
spojená; jsou-li některé dotčené bloky uložené v mezipaměti, tyto jsou buď zneplatněny, nebo (častěji)
upraveny na místě,
2. propojená s mezipamětí: vyrovnávací paměť obsahuje pouze počítadlo požadavků na zápis – samotné
datové bloky se ukládají vždy do operační paměti.`},{uuid:"cdb7dad9-d3df-4ed8-b1f7-b3a74d2b3b4c",correct:` Plánování operací
U většiny úložišť platí, že sekvenční přístup (čtení po sobě následujících
adres) je mnohem rychlejší, než nahodilý přístup (postupné čtení adres, které spolu nijak nesouvisí).
Různé technologie navíc kladou další omezení na rychlost reakce – klasickým příkladem jsou rotační disky,
kde prodleva další operace závisí na vzdálenosti hlavy od místa, kde se potřebná data fyzicky nachází.
Naopak polovodičové paměti jsou často složené z nezávislých celků, které mohou pracovat souběžně, ale
požadavky do stejné části paměti musí vyčkat na dokončení těch předchozích.
Bez ohledu na technologii ukládání dat ale platí, že operace s trvalým úložištěm vykazují vysokou míru
souběžnosti: do systému přichází mnoho nezávislých požadavků na diskové operace a existuje tedy jistá
volnost odpovídat na tyto požadavky v různém pořadí. Je to způsobeno zejména tím, že je často spuštěno
několik (souběžných) vláken a každé z nich provádí vstupně-výstupní operace nezávisle na ostatních.`,incorrect:` Plánování operací
U většiny úložišť platí, že sekvenční přístup (čtení po sobě následujících
adres) je mnohem rychlejší, než nahodilý přístup (postupné čtení adres, které spolu nijak nesouvisí).
Různé technologie navíc kladou další omezení na rychlost reakce – klasickým příkladem jsoupolovodičové paměti,
kde prodleva další operace závisí na vzdálenosti hlavy od místa, kde se potřebná data fyzicky nachází.
Naopak rotační disky jsou často složené z nezávislých celků, které mohou pracovat souběžně, ale
požadavky do stejné části paměti musí vyčkat na dokončení těch předchozích.
Bez ohledu na technologii ukládání dat ale platí, že operace s trvalým úložištěm vykazují vysokou míru
souběžnosti: do systému přichází mnoho nezávislých požadavků na diskové operace a existuje tedy jistá
volnost odpovídat na tyto požadavky v různém pořadí. Je to způsobeno zejména tím, že je často spuštěno
několik (souběžných) vláken a každé z nich provádí vstupně-výstupní operace nezávisle na ostatních.`},{uuid:"e198c0ef-5604-41f5-8a1e-b4934a5d5d74",correct:`Přeuspořádání operací má určitá úskalí, zejména v případech, kdy jsou prohozeny zápisy, které náleží
stejné aplikaci, nebo se jedná o operace související s údržbou metadat souborového systému. Vzniká tak
napětí mezi výkonem (více přeuspořádání → vyšší propustnost) a spolehlivostí (více přeuspořádání →
větší šance nekonzistence v případě výpadku).
Pokud jde o operace čtení, zde je prostor pro přeuspořádání obvykle menší, protože aplikace, která čtení
vyžádala, obvykle nemůže pokračovat ve své činnosti dříve, než jsou data k dispozici (a tedy zejména
nemůže vyžádat další operace čtení).`,incorrect:`Přeuspořádání operací má určitá úskalí, zejména v případech, kdy jsou prohozeny zápisy, které náleží
stejné aplikaci, nebo se jedná o operace související s údržbou metadat souborového systému. Vzniká tak
napětí mezi výkonem (více přeuspořádání → vyšší propustnost) a spolehlivostí (více přeuspořádání →
větší šance nekonzistence v případě výpadku).
Pokud jde o operace čtení, zde je prostor pro přeuspořádání obvykle větší, protože aplikace, která čtení
vyžádala, obvykle může pokračovat ve své činnosti i když nejsou data k dispozici.`},{uuid:"25c5006f-5b13-4b7d-9ac8-4264d26a5340",correct:`Problémy virtualizace
Náš dosavadní přístup k virtualizaci nebude v případě trvalých úložišť
příliš dobře fungovat. Vzpomeňte si, že v případě paměti a procesoru řešení spočívalo ve vytvoření
soukromých (virtuálních) instancí příslušného zařízení. Taková instance je pak vždy ve výlučném užívání
jednoho programu.
Zde ale narážíme na to, že trvalé úložiště slouží především k ukládání uživatelsky zajímavých dat. Je
tedy potřebné, aby mohl uživatel s těmito daty nějak interagovat, a zejména tedy nemůžou být skryta
v soukromém prostoru jednoho programu.`,incorrect:`Problémy virtualizace
Náš dosavadní přístup k virtualizaci bude v případě trvalých úložišť fungovat.
Vzpomeňte si, že v případě paměti a procesoru řešení spočívalo ve vytvoření
soukromých (virtuálních) instancí příslušného zařízení. Taková instance je pak vždy ve výlučném užívání
jednoho programu.
Trvalé úložiště slouží především k ukládání uživatelsky zajímavých dat. Je
tedy nežádoučí, aby mohl uživatel s těmito daty nějak interagovat, a zejména tedy musí být skryta
v soukromém prostoru jednoho programu.`},{uuid:"ee207de4-2917-45aa-9691-dacadec4acc8",correct:`Problémy virtualizace
dvě možnosti řešení:
1. můžeme zcela změnit přístup k virtualizaci: místo toho, abychom virtualizací vytvořili věrný obraz
skutečného zařízení, může operační systém poskytovat nějaký jiný druh abstrakce, a trvalé úložiště
nebude aplikacím vůbec přístupné,
2. vyčleníme nějakou aplikaci, která bude odpovědná za správu uživatelských dat v trvalém úložišti, a
ostatní aplikace budou své požadavky na interakci s těmito daty řešit skrze tuto speciální aplikaci.

Obě řešení jsou ve skutečnosti (s trochou nadsázky) vlastně totéž řešení. V obou případech je přímý
přístup k úložišti omezen na jeden nebo několik málo programů (v prvním případě je tento program
součástí operačního systému), tento program rozhoduje o tom, jak budou data „fyzicky“ organizovaná,
jaké operace lze nad daty provádět, které další programy k nim budou mít přístup, atp.`,incorrect:`Problémy virtualizace
dvě možnosti řešení:
1. můžeme zcela změnit přístup k virtualizaci: místo toho, abychom virtualizací vytvořili věrný obraz
skutečného zařízení, může operační systém poskytovat nějaký jiný druh abstrakce, a trvalé úložiště
nebude aplikacím vůbec přístupné,
2. vyčleníme nějakou aplikaci, která bude odpovědná za správu uživatelských dat v trvalém úložišti, a
ostatní aplikace budou své požadavky na interakci s těmito daty řešit skrze tuto speciální aplikaci.

Obě řešení jsou ve skutečnosti (s trochou nadsázky) vlastně totéž řešení. V obou případech je přímý
přístup k úložišti omezen na procesorové jádro, to rozhoduje o tom, jak budou data „fyzicky“ organizovaná a
jaké další operace lze nad daty provádět.`},{uuid:"ca3cb30b-6855-48b9-a844-53284e4fcb3e",correct:`Metody virtualizace
1. souborový systém, nebo obecněji abstrakce na vyšší úrovni poskytovaná jako služba operačního systému,
která umožňuje řízený přístup k datům mnoha aplikacím současně, a zároveň umožňuje uživateli data
organizovat a spravovat,
2. virtualizace na aplikační úrovni, kdy je přímý přístup k úložišti poskytnut některé aplikaci, která
spravuje data a ostatním aplikacím poskytuje přístup pomocí vhodného aplikačního protokolu (typickým
příkladem jsou databázové systémy),`,incorrect:`Metody virtualizace
1. souborový systém, nebo obecněji abstrakce na vyšší úrovni poskytovaná jako služba operačního systému,
která umožňuje řízený přístup k datům mnoha aplikacím současně, a zároveň umožňuje uživateli data
organizovat a spravovat,
2. virtualizace na aplikační úrovni, kdy je přímý přístup k úložišti řízen procesorem, který
spravuje data a ostatním částem OS poskytuje přístup pomocí vhodného mapování adres.`},{uuid:"f8a887e8-a402-43ac-9b0e-bc9823544316",correct:`RAID
Zatímco standardním řešením problému s nízkou propustností a/nebo velkou prodlevou paměťových operací jsou mezipaměti,
standardním řešením problémů se spolehlivostí paměti je redundance.
Nejjednodušší formou redundance je pořízení kopie (zálohy) – v případě ztráty primárních dat obnovíme
data ze záložní kopie. S tím jsou spojeny dva problémy:
1. aby byla užitečná, musíme takovou kopii udržovat aktuální a zároveň konzistentní,
2. při poruše musíme vyměnit dotčené zařízení a data překopírovat ze zálohy, přitom obě operace mohou
být poměrně zdlouhavé.`,incorrect:`RAID
Zatímco standardním řešením problému s nízkou propustností a/nebo velkou prodlevou paměťových operací jsou vyrovnávací paměti,
standardním řešením problémů se spolehlivostí paměti je redundance.
Nejjednodušší formou redundance je pořízení kopie (zálohy) – v případě ztráty primárních dat obnovíme
data ze záložní kopie. S tím jsou spojeny dva problémy:
1. aby byla užitečná, musíme takovou kopii udržovat aktuální ale nemusí být konzistentní,
2. při poruše musíme vyměnit dotčené zařízení a data překopírovat ze zálohy, přitom obě operace mohou
být poměrně zdlouhavé.`},{uuid:"45e6e5a9-b966-4818-b9ae-a6c8d5d04ba3",correct:`Operace nad soubory
Základními operacemi pro práci se souborem je čtení (v POSIX-u voláním read) a zápis
(v POSIX-u write) souvislé posloupnosti bajtů (libovolné velikosti – abstrakce souboru skrývá blokový
charakter zařízení, na kterém je soubor uložen). Podobně může být libovolná velikost souboru (samozřejmě
ale musí soubor obsahovat celočíselný počet bajtů) – tuto velikost je navíc možné dynamicky měnit. Zápis
„za konec“ souboru jej automaticky prodlouží, zkrácení je nutné explicitně vyžádat (v POSIX-u voláním
ftruncate).`,incorrect:`Operace nad soubory
Základními operacemi pro práci se souborem je čtení (v POSIX-u voláním read) a zápis
(v POSIX-u write) souvislé posloupnosti bajtů (libovolné velikosti – abstrakce souboru skrývá blokový
charakter zařízení, na kterém je soubor uložen). Velikost souboru je ale pevně daná a to velikostí bitmapy.`},{uuid:"9b40a9e5-db7e-4511-9820-d1b7d1e774f9",correct:`soubory jsou obvykle perzistentní
– existují dlouhodobě, nezávisle na běžících procesech, nebo dokonce na tom, je-li vůbec aktivní operační
systém (nebo samotný hardware). Abychom mohli s perzistentními soubory rozumně pracovat, musí být
navíc tyto opatřeny identitou.
Abychom mohli se souborem pracovat, ve většině systémů je nutné jej otevřít – v systémech POSIX
k tomu slouží volání open, kterého výsledkem je popisovač otevřeného souboru (angl. file descriptor)`,incorrect:`soubory jsou obvykle perzistentní
– existují dlouhodobě, jsou závislé na běžících procesech, ale nezávisí na tom, je-li vůbec aktivní operační
systém (nebo samotný hardware). Abychom mohli s perzistentními soubory rozumně pracovat, musí být
navíc tyto opatřeny identitou.
Abychom mohli se souborem pracovat, ve většině systémů je nutné jej otevřít – v systémech POSIX
k tomu slouží volání open, kterého výsledkem je popisovač otevřeného souboru (angl. file descriptor)`},{uuid:"4bf8f5fe-1b2b-4611-b51d-0dd0419544b8",correct:`Obyčejný soubor
je právě oním „motivačním případem“ – obyčejný soubor reprezentuje paměť, tzn.
jeho smyslem je uchovávat data (obyčejný soubor si tedy pamatuje posloupnost bajtů). Jaké konkrétní
bajty to jsou je irelevantní – souborový systém obsah obyčejných souborů nijak neinterpretuje.
Krom abstrakce (perzistentní – trvalé) paměti je obyčejný soubor také abstrakcí nad pevným úložištěm
v tom smyslu, že skrývá detaily přístupu k tomuto zařízení. Operace nad pevným úložištěm pracují po
jednotlivých blocích, přičemž bloky mají pevnou velikost a jejich počáteční adresa musí být dělitelná
touto velikostí – pro soubory žádné takové omezení neplatí. Zároveň je aplikace odstíněna od fyzického
umístění dat na pevném úložišti (funguje zde opět analogie s virtuálním adresním prostorem a překladem
virtuálních adres na fyzické). Analogie překladu adres je v tomto případě ale zcela v režii operačního
systému`,incorrect:`Obyčejný soubor
je právě oním „motivačním případem“ – obyčejný soubor reprezentuje paměť, tzn.
jeho smyslem je uchovávat data (obyčejný soubor si tedy pamatuje posloupnost bajtů). Jaké konkrétní
bajty to jsou je irelevantní – souborový systém obsah obyčejných souborů nijak neinterpretuje.
Krom abstrakce (perzistentní – trvalé) paměti je obyčejný soubor také abstrakcí nad pevným úložištěm
v tom smyslu, že skrývá detaily přístupu k tomuto zařízení. Operace nad pevným úložištěm pracují po
jednotlivých blocích, přičemž bloky mají pevnou velikost a jejich počáteční adresa musí být dělitelná
touto velikostí – pro soubory platí stejná omezení. Zároveň je aplikace odstíněna od fyzického
umístění dat na pevném úložišti (funguje zde opět analogie s virtuálním adresním prostorem a překladem
virtuálních adres na fyzické). Analogie překladu adres je v tomto případě ale zcela v režii operačního
systému`},{uuid:"0eea0402-376f-48e3-972c-85643770d278",correct:`Mapováni do paměti
Operace read a write nejsou vždy efektivní, protože musí mimo jiné kopírovat
data mezi mezipamětí a pamětí, která náleží žádajícímu procesu.
Efektivita aplikací, které data
především čtou, může být výrazně zlepšena mapováním souborů do paměti za pomoci líného načítání.
V tomto režimu jsou externí stránky uloženy v jinak běžném souboru, ale místo komplikovaných vstupněvýstupních
operací může program s obsahem souboru pracovat stejně, jako by byl uložen v operační paměti.
Využijeme-li tohoto mechanismu také k zápisu změněných stránek zpátky do souboru, může program soubor
i zcela transparentně upravovat.`,incorrect:`Mapováni do paměti
Operace read a write jsou vždy efektivní, protože nemusí kopírovat
data mezi mezipamětí a pamětí, která náleží žádajícímu procesu.
Efektivita aplikací, které data
především čtou, může být výrazně zlepšena mapováním souborů do paměti za pomoci líného načítání.
V tomto režimu jsou externí stránky uloženy v jinak běžném souboru, ale místo komplikovaných vstupněvýstupních
operací může program s obsahem souboru pracovat stejně, jako by byl uložen v operační paměti.
Využijeme-li tohoto mechanismu také k zápisu změněných stránek zpátky do souboru, může program soubor
i zcela transparentně upravovat.`},{uuid:"81f6fc70-79f2-47a3-befa-7dbc592a4813",correct:`Souběžný přístup
Jmenný prostor souborového systému (blíže jej popíšeme v další sekci) je
sdílený mezi všemi procesy, může se tedy lehce stát, že více procesů bude pracovat s jedním souborem.
Tato situace je analogická tomu, že stejná oblast operační paměti může být namapovaná ve více virtuálních
adresních prostorech. Jde-li o souběžný přístup pouze pro čtení, nevznikají žádné významnější problémy.
Vstoupí-li ale do hry zápisy, jak čtení tak jiné zápisy mohou způsobovat problémy – zejména různé
instance hazardu souběhu.
Aby se těmto problémům předešlo, operační systémy umožňují soubory zamykat čím je umožněno programům
k souboru přistupovat bezpečně – tzn. bez rizika poškození dat`,incorrect:`Souběžný přístup
Jmenný prostor souborového systému (blíže jej popíšeme v další sekci) je
sdílený mezi všemi procesy, může se tedy lehce stát, že více procesů bude pracovat s jedním souborem.
Tato situace je analogická tomu, že stejná oblast operační paměti může být namapovaná ve více virtuálních
adresních prostorech. Jde-li o souběžný přístup pouze pro čtení, nevznikají žádné významnější problémy.
Vstoupí-li ale do hry zápisy, jak čtení tak jiné zápisy mohou způsobovat problémy – zejména různé
instance hazardu souběhu.
Operační systémy neumožňují soubory zamykat proto musí být tento problém řešen jinak`},{uuid:"0847f9b3-b784-43b5-aeb6-3874ca610cbd",correct:`Spustitelný soubor
Spustitelné soubory představují programy v klidu (tzn. ve stavu, kdy nejsou spuštěné) a obsahují veškeré
informace, které jsou potřeba k tomu, aby bylo možné v nich obsažený program spustit. Hlavní část
spustitelného souboru je tvořena počátečním obrazem paměti, podle kterého se při spuštění programu
(v POSIX-u voláním exec v již existujícím procesu) inicializuje virtuální adresní prostor`,incorrect:`Spustitelný soubor
Spustitelné soubory představují jak programy v klidu tak i ty spuštěné a obsahují veškeré
informace, které jsou potřeba k tomu, aby bylo možné v nich obsažený program probíhat. Hlavní část
spustitelného souboru je tvořena počátečním obrazem paměti, podle kterého se při spuštění programu
(v POSIX-u voláním exec v již existujícím procesu) inicializuje virtuální adresní prostor`},{uuid:"afd4bd6a-a693-4355-ae0b-dbbd445dbe3e",correct:`Roura
Roury se podobají na obyčejné soubory v tom, že je možné do nich zapisovat a číst z nich
data (bajty). Ve většině případů data jeden program (proces) zapisuje a jiný je čte – na rozdíl od
obyčejného souboru nejsou tato data nikde trvale uložena – z roury zmizí jakmile jsou přečtena.
S rourou je samozřejmě svázán buffer, ale je uložen pouze v operační paměti. Díky tomu lze do roury data
zapisovat i ve chvíli, kdy je právě druhá strana nečte – operační systém zapsaná data dočasně uchová.
Za normálních okolností je roura anonymní a přístupná pouze skrze popisovače otevřených souborů.`,incorrect:`Roura
Roury se podobají na obyčejné soubory v tom, že je možné do nich zapisovat a číst z nich
data (bajty). Ve většině případů data jeden program (proces) zapisuje a jiný je čte – na rozdíl od
obyčejného souboru nejsou tato data nikde trvale uložena – z roury zmizí po čase určeném speciálním registrem.
S rourou je samozřejmě svázán buffer, ale je uložen pouze v operační paměti. Díky tomu lze do roury data
zapisovat i ve chvíli, kdy je právě druhá strana nečte – operační systém zapsaná data dočasně uchová.
Za normálních okolností je roura anonymní a přístupná pouze skrze popisovače otevřených souborů.`},{uuid:"c1d42a11-ffcb-4708-b183-00fb0bf9ac09",correct:`Tvrdé odkazy
Jasným důsledkem výše popsané organizace složek je existence tzv. tvrdých odkazů
– situace, kdy několik adresářových položek (v jedné nebo několika složkách) odkazuje tutéž entitu
(i-uzel). Všechny odkazy na tentýž soubor jsou zcela rovnocenné a z pohledu uživatele se pouze tentýž
soubor objevuje na různých místech adresářové struktury.
I-uzly si navíc udržují počítadlo odkazů – samotný soubor (i-uzel) je zničen pouze v případě, kdy toto
počítadlo dojde na nulu. To mimo jiné znamená, že odstraněním adresářové položky (angl. unlinking) může,
ale nemusí způsobit smazání souboru.`,incorrect:`Tvrdé odkazy
Jasným důsledkem výše popsané organizace složek je existence tzv. tvrdých odkazů
– situace, kdy několik adresářových položek (v jedné nebo několika složkách) odkazuje tutéž entitu
(i-uzel). Existuje jeden hlavní a poté libovolný počet jiných odkazu, ale z pohledu uživatele se pouze tentýž
soubor objevuje na různých místech adresářové struktury.
I-uzly si navíc udržují počítadlo odkazů – samotný soubor (i-uzel) je zničen pouze v případě, kdy toto
počítadlo dojde na nulu. To mimo jiné znamená, že odstraněním adresářové položky (angl. unlinking) může,
ale nemusí způsobit smazání souboru.`},{uuid:"b8eca577-525e-447c-a77c-a829e277820a",correct:`Měkké odkazy
Občas je užitečné odkazovat soubor nikoliv přímo, ale skrze nějakou cestu která
k němu vede. Toho lze dosáhnout tzv. měkkým odkazem: tento je (na rozdíl od tvrdého odkazu) skutečným
objektem v souborovém systému, který je reprezentován samostatným i-uzlem. Narazí-li při procházení
adresářové struktury (zejména při hledání i-uzlů podle cesty) operační systém přečte cestu obsaženou
v tomto měkkém odkazu a ve vyhledávání pokračuje touto cestou.`,incorrect:`Měkké odkazy
Občas je užitečné odkazovat soubor nikoliv přímo, ale skrze nějakou cestu která
k němu vede. Toho lze dosáhnout tzv. měkkým odkazem: tento je (na rozdíl od tvrdého odkazu) skutečným
objektem v souborovém systému, který ale není reprezentován i-uzlem. Narazí-li při procházení
adresářové struktury (zejména při hledání souborů podle cesty) operační systém přečte cestu obsaženou
v tomto měkkém odkazu a ve vyhledávání pokračuje touto cestou.`},{uuid:"b891b0c1-18d1-470d-8f3d-a12db78e7c33",correct:`Bitmapa 
V souborových systémech se využívá několik velmi jednoduchých datových struktur, které
jsou díky své jednoduchosti zároveň relativně robustní. Asi nejjednodušší strukturou tohoto typu je
bitmapa, která se používá k mapování využitých resp. volných bloků nebo řádků v tabulkách (přiblížíme
si za chvíli).
Bitmapa udržuje informaci o lineárním sledu bloků a informace o jednotlivém bloku se omezuje na jediný
bit (obvykle právě ona využitost).`,incorrect:`Bitmapa 
V souborových systémech se využívá několik velmi jednoduchých datových struktur, které
jsou díky své jednoduchosti zároveň relativně robustní. Asi nejjednodušší strukturou tohoto typu je
bitmapa, která se používá k mapování využitých resp. volných bloků nebo řádků v tabulkách (přiblížíme
si za chvíli).
Bitmapa udržuje informaci o lineárním sledu bloků a informace o jednotlivém bloku se omezuje na jediný
bajt.`},{uuid:"f4147fd5-5a01-416c-b02d-9603fe1c85bd",correct:`Tabulka
Bitmapa je sice jednoduchá a rychlá, neumí ale uchovat příliš mnoho zajímavých informací.
O něco málo složitější datovou strukturou je tabulka, která v podstatě odpovídá klasickému poli:
1. je to souvislá oblast fixně velkých struktur (řádků, položek), zvolených tak, aby se jich do jednoho
bloku vešel celočíselný počet (vyhovuje například velikost jednoho řádku 128 nebo 256 bajtů),
2. alokace položek se provede např. bitmapou (určuje které řádky jsou resp. nejsou použité, aby bylo
v případě potřeby možné rychle najít řádek, do kterého můžeme zapsat novou položku),
3. chceme-li se do takové tabulky odkázat (např. proto, že se jedná o tabulku záznamů o souborech),
stačí nám znát číslo řádku (index).`,incorrect:`Tabulka
Bitmapa je sice jednoduchá a rychlá, neumí ale uchovat příliš mnoho zajímavých informací.
O něco málo složitější datovou strukturou je tabulka, která v podstatě odpovídá klasickému poli:
1. je to souvislá oblast fixně velkých struktur (řádků, položek), libovolné velikosti.
2. alokace položek se provede např. bitmapou (určuje které řádky jsou resp. nejsou použité, aby bylo
v případě potřeby možné rychle najít řádek, do kterého můžeme zapsat novou položku),
3. chceme-li se do takové tabulky odkázat (např. proto, že se jedná o tabulku záznamů o souborech),
stačí nám znát číslo řádku (index).`},{uuid:"8ddf271d-ffab-4a77-8be6-0c0b89356eee",correct:`Konzistence
Důležitým problémem souborového systému je udržení konzistence metadat (jak
různých typů nebo složek metadat mezi sebou, tak se samotnými daty). Porušení konzistence může být
trojího typu:
1. narušení jednotlivé datové struktury, např.
∘ B-strom obsahuje uzel, který ve skutečnosti není platným uzlem, např. proto, že nový odkaz byl
zapsán dříve, než odkazovaný uzel,
2. konfliktní informace v různých datových strukturách, např.:
∘ bitmapa označuje řádek tabulky za volný, ale tento je zároveň vyplněn smysluplnými metadaty, nebo
∘ datový blok je označený jako volný (v bitmapě nebo B-stromě), ale zároveň je odkazován jako
součást nějakého souboru,
3. nesoulad mezi metadaty a datovými bloky – např.
∘ podle metadat je vlastníkem souboru uživatel B, ale odkazované datové bloky obsahují data uživatele
A`,incorrect:`Konzistence
Důležitým problémem souborového systému je udržení konzistence metadat (jak
různých typů nebo složek metadat mezi sebou, tak se samotnými daty). K porušení konzistence nemůže dojít.`},{uuid:"0a41d340-11a3-490f-8371-0895b56aa233",correct:`Existují dva hlavní důvody, proč by mohlo dojít  k porušení konzistence u datových struktur:
1. přerušením kritické operace, která provádí více souvisejících změn, např. výpadkem napájení, nebo
kritickou chybou („pádem“) celého systému,
2. i v případě, kdy je souborový systém vůči takovému přerušení robustní, tato jeho vlastnost může být
narušena přeuspořádáním zápisů (plánovačem nebo samotným zařízením).
Existuje několik metod, jak se s problémem vypořádat. Jednou je detekce problému (např. příznakem,
který se zapíše při korektním ukončení operačního systému) a následná křížová kontrola všech metadat
v situaci, kdy mohlo k poškození teoreticky dojít. Tato kontrola může a nemusí být schopna souborový
systém vrátit do konzistentního stavu (v závislosti na rozsahu resp. povaze poškození).`,incorrect:`Existují dva hlavní důvody, proč by mohlo dojít  k porušení konzistence u datových struktur:
1. přerušením kritické operace, která provádí více souvisejících změn, např. výpadkem napájení, nebo
kritickou chybou („pádem“) celého systému,
2. i v případě, kdy je souborový systém vůči takovému přerušení robustní, tato jeho vlastnost může být
narušena přeuspořádáním zápisů (plánovačem nebo samotným zařízením).
Existuje několik metod, jak se s problémem vypořádat. Jednou je detekce problému (např. příznakem,
který se zapíše při korektním ukončení operačního systému) a následná křížová kontrola všech metadat
v situaci, kdy mohlo k poškození teoreticky dojít. Tato kontrola je vždy schopna souborový
systém vrátit do konzistentního stavu.`},{uuid:"efbe938e-3a55-4c45-b29e-ed47b1230e72",correct:`Žurnál
Oproti klasickým metadatům souborového systému má žurnál jednoduchou strukturu – záznamy jsou na
disku uloženy sekvenčně (obvykle „do kruhu“ – nový záznam přepíše nejstarší, už neplatný, záznam). Tato
struktura je velmi robustní, jak vůči nahodilému přerušení, tak proti typickým vzorům přeuspořádání.
Záznamy v žurnálu jsou obvykle seskupeny do transakcí (podobných těm, které znáte z relačních databázových systémů),
které mohou sestávat z několika provázaných operací. Změny v metadatech se začnou na
pevné úložiště posílat až ve chvíli, kdy je transakce ukončena a je potvrzen zápis příslušných položek
v žurnálu. Transakce, která není ukončená, se při obnově přeskočí, čím je zabezpečeno, že se ve výsledku
provede buď celá, nebo vůbec.`,incorrect:`Žurnál
Oproti klasickým metadatům souborového systému má žurnál jednoduchou strukturu – záznamy jsou na
disku uloženy sekvenčně (obvykle „do kruhu“ – nový záznam přepíše nejstarší, už neplatný, záznam). Tato
struktura je velmi robustní, jak vůči nahodilému přerušení, tak proti typickým vzorům přeuspořádání.
Záznamy v žurnálu jsou obvykle seskupeny do transakcí (podobných těm, které znáte z relačních databázových systémů),
které mohou sestávat z několika provázaných operací. Změny v metadatech se začnou na
pevné úložiště posílat hned jak je transakce zahájena. Transakce, která není ukončená,
se při obnově přeskočí, čím je zabezpečeno, že se ve výsledku provede buď celá, nebo vůbec.`},{uuid:"7ab0725e-3dee-4109-ad98-f8f143cafbc2",correct:`Žurnál
Přerušená operace na datové struktuře může vést k nejednoznačnému stavu, kdy lze datovou strukturu
opravit více než jedním způsobem. Žurnál tento problém řeší tím, že existuje záznam o tom, jaká operace
probíhala a tedy je možné ji na základě této informace dokončit. Zároveň není potřeba kontrolovat resp.
opravovat konzistenci všech datových struktur (to může ve velkém souborovém systému trvat dlouhou
dobu), ale pouze těch (resp. těch jejich částí), kterých se dotýkají operace zanesené v žurnálu.`,incorrect:`Žurnál
Přerušená operace na datové struktuře může vést k nejednoznačnému stavu, kdy lze datovou strukturu
opravit více než jedním způsobem. Žurnál tento problém řeší tím, že existuje záznam o tom, jaká operace
probíhala a tedy je možné ji na základě této informace dokončit. Je ale nutné kontrolovat resp.
opravovat konzistenci všech datových struktur (to může ve velkém souborovém systému trvat dlouhou
dobu), toto není nutné pouze u těch (resp. těch jejich částí), kterých se dotýkají operace zanesené v žurnálu.`},{uuid:"70133ce5-aa87-4149-bea9-9f14959e477b",correct:`Funkcionální metadata
inou možností jak předejít nekonzistenci je uspořádat metadata tak, že
použité datové struktury nebudeme na místě upravovat vůbec. Podobně jako ve funkcionálním programování
můžeme místo úpravy existující struktury vytvořit její novou verzi. Přitom využijeme toho, že nezměněné
části můžeme z nové verze odkázat – nemusíme tedy kopírovat celou datovou strukturu.
Takovému přístupu musí být ale příslušná datová struktura uzpůsobena – vhodné jsou zejména stromové
struktury (v souborových systémech tedy především B-stromy), kde změna v libovolném uzlu znamená
vytvoření nové verze tohoto uzlu a jeho předků (v předcích totiž nemůžeme upravit ukazatel na potomka
– to by narušilo princip neměnnosti staré verze), přitom ve vyváženém stromě je takových nejvýše
logaritmický počet. Všechny ostatní uzly ale zůstávají nezměněné.
`,incorrect:`Funkcionální metadata
inou možností jak předejít nekonzistenci je uspořádat metadata tak, že
použité datové struktury nebudeme na místě upravovat vůbec. Podobně jako ve funkcionálním programování
můžeme místo úpravy existující struktury vytvořit její novou verzi. Přitom využijeme toho, že nezměněné
části můžeme z nové verze odkázat – nemusíme tedy kopírovat celou datovou strukturu.
Takovému přístupu musí být ale příslušná datová struktura uzpůsobena – vhodné jsou zejména tabulky nikoliv stromové struktury, kde změna v libovolném uzlu znamená
vytvoření nové verze tohoto uzlu a jeho předků.
`},{uuid:"8df310b2-d21c-43fe-ae26-53806f73b986",correct:`Prázdné místo
Jsme tedy konečně vyzbrojeni datovými strukturami vhodnými pro použití v souborovém systému a můžeme se blíže podívat na jejich konkrétní využití.
Prvním úkolem bude organizace volných bloků, do kterých lze uložit nově příchozí data (např. proto, že
uživatel vytvořil nový soubor, přidal data do existujícího, ale třeba i proto, že vytvořil novou složku).
Vyhledání vhodného datového bloku je častá operace, musí být proto efektivní – jak samotné nalezení,
tak poznačení informace o tom, že vybraný blok (resp. bloky) již nejsou volné.
`,incorrect:`Prázdné místo
Jsme tedy konečně vyzbrojeni datovými strukturami vhodnými pro použití v souborovém systému a můžeme se blíže podívat na jejich konkrétní využití.
Prvním úkolem bude organizace volných bloků, do kterých lze uložit nově příchozí data (např. proto, že
uživatel vytvořil nový soubor, přidal data do existujícího, ale třeba i proto, že vytvořil novou složku).
Vyhledání vhodného datového bloku je častá operace, musí být proto efektivní platí hlavně pro nalezení takového bloku.
Poznačení informace o tom, že vybraný blok (resp. bloky) již nejsou volné nejsou prováděny často, tedy efektivní být nemusí.
`},{uuid:"fdc68354-e0e6-48c9-88be-a9f7e328470d",correct:`Externí a datová fragmentace
Ukládání strukturovaných dat do nestrukturovaného pole bajtů
vyžaduje vždy určité kompromisy. Jedním z nich je efektivita využití kapacity – ukládání dat více natěsno
většinou vede k pomalejším operacím a složitějším metadatům.
V případě souborů se musíme vypořádat jednak se situací, kdy se postupným vytvářením a mazáním souborů
prázdné místo rozptýlí mezi alokované bloky. Při vytváření nových souborů to znamená pracnější hledání
volných bloků, protože je nutné potřebné místo „slepit“ z několika nesouvislých oblastí (fragmentů).
Tím se jednak zvětšují potřebná metadata (průměrná délka spojitého rozsahu klesá) a zároveň dochází
k roztroušení – fragmentaci – samotných dat, která jsou do takto alokovaného souboru uložena. Přístup
k takovým souborům je pak méně efektivní, protože s každým skokem z jedné spojité oblasti do jiné je
spojena prodleva (daná povahou blokových zařízení).
`,incorrect:`Externí a datová fragmentace
Ukládání strukturovaných dat do nestrukturovaného pole bajtů
vyžaduje vždy určité kompromisy. Jedním z nich je efektivita využití kapacity – ukládání dat více natěsno
většinou vede k pomalejším operacím a složitějším metadatům.
V případě souborů se musíme vypořádat jednak se situací, kdy se postupným vytvářením a mazáním souborů
prázdné místo rozptýlí mezi alokované bloky. Při vytváření nových souborů to znamená pracnější hledání
volných bloků, protože je nutné potřebné místo „slepit“ z několika nesouvislých oblastí (fragmentů).
Tím se jednak zvětšují potřebná metadata (průměrná délka spojitého rozsahu klesá) a zároveň dochází
k roztroušení – fragmentaci – samotných dat, která jsou do takto alokovaného souboru uložena. Přístup
k takovým souborům je asymptoticky stejně efektivní, protože takovýto přístup je realizovaný přes tvrdé odkazy.
`},{uuid:"870cb4b0-c517-48ea-be43-6d9253df8b4c",correct:`Obyčejné soubory 
Tradiční reprezentace obyčejného souboru na disku odkazuje každý datový
blok samostatně, pomocí krátké tabulky uvnitř i-uzlu (u větších souborů rozšířené pomocnými tabulkami
v tzv. nepřímých blocích). Běžným zlepšením je místo odkazu na jeden blok odkazovat celý spojitý rozsah
datových bloků (angl. extent). Hlavní nevýhodou tohoto přístupu je, že vyhledání bloku podle adresy
bajtu (offsetu) je v takto organizovaných metadatech lineární vzhledem k délce takové tabulky.`,incorrect:`Obyčejné soubory 
Tradiční reprezentace obyčejného souboru na disku odkazuje každý datový
blok samostatně, pomocí krátké tabulky uvnitř i-uzlu (u větších souborů rozšířené pomocnými tabulkami
v tzv. nepřímých blocích). Běžným zlepšením je místo odkazu na jeden blok odkazovat celý spojitý rozsah
datových bloků (angl. extent). Tímto zajistíme že vyhledání bloku podle adresy
bajtu (offsetu) je v takto organizovaných metadatech konstantí.`},{uuid:"e32886a8-4988-4de6-890e-b98f15b30966",correct:`Vnitřní fragmentace
Vnitřní fragmentace je způsobena zarovnáním – některé operace jsou
mnohem efektivnější, když každý soubor začíná na hranici bloku, a tedy je pro něj alokován bloků
celočíselný počet. Protože mají ale soubory libovolnou velikost, často je na konci souboru nějaké
nevyužité místo. Toto nevyužité místo představuje režii – neobsahuje žádná užitečná data. Jinými slovy
je na většiny souborů malý fragment paměti který nelze využít (protože je menší než nejmenší možná
velikost souboru – jeden blok).`,incorrect:`Vnitřní fragmentace
Vnitřní fragmentace je způsobena zarovnáním – některé operace jsou
mnohem efektivnější, když každý soubor začíná na hranici bloku, a tedy je pro něj alokován bloků
celočíselný počet. Protože mají ale soubory libovolnou velikost, často je na konci souboru nějaké
nevyužité místo. Toto nevyužité místo lze spojit pomocí vnější fragmentace v blok, který již využitelný bude.`},{uuid:"cef58fb5-ca16-4f4b-abef-15c80b26e922",correct:`Adresáře
Existují tři základní možnosti, jak v souborovém systému reprezentovat složky:
1. Klasické → hledání podle jména a odstranění položky jsou lineární operace, vkládání je naopak
konstantní – takový přístup funguje dobře pro malé složky, ale protože souborový systém nemůže
obecně předvídat, kolik položek bude mít daný adresář, tato organizace se spíše nepoužívá.
2. Hašované → položky jsou uloženy v hašovací tabulce a jsou tedy „pravděpodobně“ konstantní – přesné
chování záleží na hašovací funkci a výběru jmen. Iterace vrací položky ve zdánlivě náhodném pořadí.
3. Stromové → položky jsou uloženy jako B-strom, jména položek jsou klíče – všechny operace jsou
zaručeně logaritmické a iterace vrací položky seřazené podle jména.
`,incorrect:`Adresáře
Existují tři základní možnosti, jak v souborovém systému reprezentovat složky:
1. Klasické → hledání podle jména a odstranění položky jsou lineární operace, vkládání je naopak
konstantní – takový přístup funguje dobře pro malé složky, a proto je i nejčastěji používaný.
2. Hašované → položky jsou uloženy v hašovací tabulce a jsou tedy „pravděpodobně“ konstantní – přesné
chování záleží na hašovací funkci a výběru jmen. Iterace vrací položky ve zdánlivě náhodném pořadí.
3. Stromové → položky jsou uloženy jako B-strom, jména položek jsou klíče – všechny operace jsou
zaručeně logaritmické, ale nelze je vracet jako seřazené.
`}]},{uuid:"33155a93-c51e-49a2-9edc-36100f100cf7",sectionNumber:"4",sectionTitle:"Virtualizace periférií",statements:[{uuid:"0e86da29-65b6-4d7e-bdbd-e38f172fee74",correct:`Periferie
Zařízení, které produkuje a konzumuje data, případně události. Komunikace
v malém objemu se obvykle realizuje mapováním registrů zařízení na fyzické adresy. Pozor, je zde
důležitý rozdíl proti operační paměti: hodnoty se „samovolně“ (bez účasti hlavního procesoru, a tedy i
operačního systému) mění v čase – takovou změnu lze považovat za událost.`,incorrect:`Periferie
Zařízení, které produkuje a konzumuje data, případně události. Komunikace
v malém objemu se obvykle realizuje mapováním registrů zařízení na fyzické adresy. Pozor, je zde
důležitý rozdíl proti operační paměti: hodnoty se s vzájemnou účastí procesoru a
operačního systém mění v čase – takovou změnu lze považovat za událost.`},{uuid:"3f2eb488-8dd9-41ac-8a52-8290ab8aec16",correct:`Programovaný vstup/výstup (PIO)
Nejjednodušší metodou komunikace se zařízením je přenos dat
postupným čtením z paměti (registrů) zařízení (již zmiňovaným mapováním paměti zařízení na fyzické
adresy procesoru). Je-li tato činnost prováděna hlavním procesorem, mluvíme o tzv. „programovaném“
vstupu resp. výstupu (angl. programmed IO, PIO).
Tento způsob komunikace tedy vyžaduje aktivní účast procesoru v stanovených časových intervalech
(podle přenosové rychlosti, velikosti vyrovnávací paměti, atp.). Tato metoda je použitelná pro občasné
přenosy a/nebo přenosy s velmi malou šířkou pásma (počtem bajtů přenesených za sekundu). Při větších
objemech dat vede tento způsob komunikace k příliš vysoké režii.`,incorrect:`Programovaný vstup/výstup (PIO)
Nejjednodušší metodou komunikace se zařízením je přenos dat
postupným čtením z paměti (registrů) zařízení (již zmiňovaným mapováním paměti zařízení na fyzické
adresy procesoru). Je-li tato činnost prováděna hlavním procesorem, mluvíme o tzv. „programovaném“
vstupu resp. výstupu (angl. programmed IO, PIO).
Tento způsob komunikace tedy nevyžaduje aktivní účast procesoru. Tato metoda je použitelná pro občasné
přenosy a/nebo přenosy s velmi malou šířkou pásma (počtem bajtů přenesených za sekundu). Při větších
objemech dat vede tento způsob komunikace k příliš vysoké režii.`},{uuid:"5026943e-8e5f-47db-a0fa-7a597b7a0d0f",correct:` Přímý přístup do paměti (DMA)
Zdaleka nejčastějším cílem přenosu dat z periferie je jejich uložení do operační paměti – další
zpracování zpravidla musí vyčkat do doby, než je v operační paměti nějaký kompletní celek (blok, rámec,
atp.).
Asynchronní přenos dat (bez účasti procesoru, resp. bez účasti softwaru) může být realizován dvěma
základními metodami:
1. dedikovaným pomocným procesorem, který od hlavního procesoru přijímá pokyny na provedení přenosu
(z jaké periferie, na jakou adresu v operační paměti, kolik bajtů, případně opačně, z jaké adresy
v operační paměti a jaké periferii), a který je de-facto součástí sběrnice,
2. přenos je řízen přímo periferií (na základě podobného pokynu od hlavního procesoru).
Výhodou první metody je, že periferie nemusí nijak rozlišovat DMA a PIO režimy přenosu dat a může být
tedy jednodušší. Druhá metoda je obvykle efektivnější a v moderních systémech mnohem běžnější.
`,incorrect:` Přímý přístup do paměti (DMA)
Zdaleka nejčastějším cílem přenosu dat z periferie je jejich uložení do operační paměti – další
zpracování zpravidla musí vyčkat do doby, než je v operační paměti nějaký kompletní celek (blok, rámec,
atp.).
Asynchronní přenos dat (bez účasti procesoru, resp. bez účasti softwaru) může být realizován dvěma
základními metodami:
1.  přenos je řízen přímo periferií (na základě podobného pokynu od hlavního procesoru).
2. dedikovaným pomocným procesorem, který od hlavního procesoru přijímá pokyny na provedení přenosu
(z jaké periferie, na jakou adresu v operační paměti, kolik bajtů, případně opačně, z jaké adresy
v operační paměti a jaké periferii), a který je de-facto součástí sběrnice
Výhodou první metody je, že periferie nemusí nijak rozlišovat DMA a PIO režimy přenosu dat a může být
tedy jednodušší. Druhá metoda je obvykle efektivnější a v moderních systémech mnohem běžnější.
`},{uuid:"f6a5adcd-e298-40b7-a9a7-726ae7c37693",correct:` Je důležité rozlišovat přímý přístup do paměti (komunikuje periferie a operační paměť, bez účasti
procesoru) a mapování paměti zařízení do fyzického adresního prostoru (komunikuje procesor s periferií,
bez účasti operační paměti).`,incorrect:` Je důležité rozlišovat přímý přístup do paměti (komunikuje periferie a operační paměť, bez účasti
procesoru) a mapování paměti zařízení do fyzického adresního prostoru (komunikuje procesor s periferií za pomocí operační paměti).`},{uuid:"0564ce3c-6053-4a36-a4a0-821ad39a8df2",correct:`IO-MMU
Přestože pro zařízení, které přenáší velké objemy dat (pevná úložiště, síťová rozhraní,
atp.), je DMA nepostradatelné, jsou s ním spojeny určitá bezpečnostní rizika. V klasické implementaci
DMA má totiž každá periferie neomezený přístup do fyzické paměti – operační systém sice dává periferii
pokyn, které fyzické adresy má použít, ale nemá jak vynutit, aby periferie takový pokyn dodržela.
V takovém systému tedy periferiím tedy nic tedy nebrání v tom libovolně upravovat obsah paměti –
například i přepsat kód jádra a získat tak plnou kontrolu nad systémem. Toto se týká nejen případných
podvratných periferií, ale i ovladačů, které mohou jinak nevinnou periferii naprogramovat tak, aby
narušila bezpečnost systému.
Toto je jistě nežádoucí, zejména chceme-li izolovat ovladače od zbytku jádra, nebo v případech, kdy
samotná periferie není nutně důvěryhodná. IO-MMU je zařízení, které tento problém řeší, a to tím, že
realizuje překlad adres pro periferie (podobně jako MMU realizuje překlad adres pro software). IO-MMU
je programovatelná operačním systémem (a pouze operačním systémem) a umožňuje tedy izolovat periferie
jak vzájemně, tak od operačního systému a softwaru obecně. Je-li IO-MMU správně naprogramovaná, je
DMA bezpečné.`,incorrect:`IO-MMU
Přestože pro zařízení, které přenáší velké objemy dat (pevná úložiště, síťová rozhraní,
atp.), je DMA nepostradatelné, jsou s ním spojeny určitá bezpečnostní rizika. V klasické implementaci
DMA má totiž každá periferie neomezený přístup do fyzické paměti – operační systém sice dává periferii
pokyn, které fyzické adresy má použít, ale nemá jak vynutit, aby periferie takový pokyn dodržela.
V takovém systému tedy periferiím tedy nic tedy nebrání v tom libovolně upravovat obsah paměti –
například i přepsat kód jádra a získat tak plnou kontrolu nad systémem. Toto se týká nejen případných
podvratných periferií, ale i ovladačů, které mohou jinak nevinnou periferii naprogramovat tak, aby
narušila bezpečnost systému.
Toto je jistě nežádoucí, zejména chceme-li izolovat ovladače od zbytku jádra, nebo v případech, kdy
samotná periferie není nutně důvěryhodná. IO-MMU je zařízení, které tento problém řeší, a to tím, že
realizuje překlad adres pro periferie (podobně jako MMU realizuje překlad adres pro software). IO-MMU
není programovatelná za normálních podmínek, pouze při konstrukci zařízení`},{uuid:"8c710d40-d39c-4371-b4f4-ec2296a34b35",correct:`Sběrnice 
Má dvě základní vrstvy:
1. fyzickou, která odpovídá za signalizaci a časování a
2. logickou (protokolovou), která popisuje chování zařízení na sběrnici na vyšší úrovni – adresaci,
konfiguraci zařízení, přenosy dat atp.
Sběrnic existuje v počítači celá řada a jsou vzájemně propojené. Ta strana sběrnice, která je blíže
hlavnímu procesoru, se obvykle nazývá hostitelská.`,incorrect:`Sběrnice 
Má dvě základní vrstvy:
1. fyzickou, která odpovídá za enumeraci
2. logickou (protokolovou), která popisuje chování zařízení na sběrnici na vyšší úrovni – adresaci,
konfiguraci zařízení, přenosy dat atp.
Sběrnic existuje v počítači celá řada a jsou vzájemně propojené. Ta strana sběrnice, která je blíže
hlavnímu procesoru, se obvykle nazývá hostitelská.`},{uuid:"fd01c97c-fd94-4c27-98bb-84fa960671d6",correct:`Sběrnice
Hlavním úkolem sběrnice je přenos dat (a s tím související adresace) a signalizace událostí, vedlejším
pak konfigurace a enumerace připojených periferií. Má-li řadič sběrnice přidělen rozsah fyzických adres,
je také jeho úkolem tento dále rozdělit mezi připojené periferie (včetně podružných řadičů dalších
sběrnic).`,incorrect:`Sběrnice
Hlavním úkolem sběrnice je přenos dat (a s tím související adresace) a signalizace událostí, vedlejším
pak konfigurace a enumerace připojených periferií. Má-li řadič sběrnice přidělen rozsah fyzických adres,
je také jeho úkolem tuto informaci sdělit procesoru.`},{uuid:"1f186295-d010-457e-81aa-b5c52ccc77a9",correct:`Ovladač
Jakmile je známý konkrétní typ zařízení, komunikaci s ním převezme ovladač – program,
který poskytuje softwarovou abstrakci dané třídy zařízení zbytku operačního systému (a nepřímo i
aplikacím).
Na jedné straně komunikuje ovladač se zbytkem operačního systému (pomocí vhodného rozhraní, které je
ale obvykle specifické pro daný operační systém), na straně druhé komunikuje s konkrétním fyzickým
zařízením (které je zase často specifické pro daný model, nebo alespoň modelovou řadu).
Připomínáme zde, že komunikace probíhá čtením a zápisem dat, a zpracování takových dat není nic jiného
než výpočet`,incorrect:`Ovladač
Jakmile je známý konkrétní typ zařízení, komunikaci s ním převezme ovladač – program,
který převezme kontrolu nad jádrem a následně spustí komunikaci s operačním systémem
Na jedné straně komunikuje ovladač se zbytkem operačního systému (pomocí vhodného rozhraní, které je
ale obvykle specifické pro daný operační systém), na straně druhé komunikuje s konkrétním fyzickým
zařízením (které je zase často specifické pro daný model, nebo alespoň modelovou řadu).
Připomínáme zde, že komunikace probíhá čtením a zápisem dat, a zpracování takových dat není nic jiného
než výpočet`},{uuid:"c2a9fc89-eadd-4fbb-b845-106b25a63efc",correct:`Ovladač
Hlavním úkolem ovladače je:
1. zpracování příchozích dat do formy, která je přijatelná pro zbytek systému (tzn. do formy nezávislé
na konkrétním modelu zařízení),
2. převod dat příchozích ze systému (které jsou ve formě nezávislé na konkrétním zařízení) do formy,
kterou umí daná periferie zpracovat,
3. to vše v reakci na události – buď požadavky ze systému na periferii, nebo naopak.
Data v tomto případě nemusí být pouze užitná data (bloky uložené na disku, rámce přijímané nebo odesílané
síťovým rozhraním, atp.), ale také řídící data, která ovlivňují jak se bude zařízení chovat, nebo přímo
aktivují další funkce zařízení (jiné, než je samotný přenos užitných dat).`,incorrect:`Ovladač
Hlavním úkolem ovladače je:
1. zpracování příchozích dat do formy, kterou může předat sběrnici a ta data přeložit.
kterou umí daná periferie zpracovat.
2. převod dat příchozích ze systému (které jsou ve formě nezávislé na konkrétním zařízení) do formy,
kterou umí daná periferie zpracovat,
3. to vše v reakci na události – buď požadavky ze systému na periferii, nebo naopak.
Data v tomto případě nemusí být pouze užitná data (bloky uložené na disku, rámce přijímané nebo odesílané
síťovým rozhraním, atp.), ale také řídící data, která ovlivňují jak se bude zařízení chovat, nebo přímo
aktivují další funkce zařízení (jiné, než je samotný přenos užitných dat).`},{uuid:"734ca848-f130-4418-8805-73a06860450e",correct:`Tiskárny
1. virtualizace – jak tiskárnu sdílet mezi programy – tento problém je analogický k problému plánováni
úloh v dávkových systémech, a má i analogické řešení: frontu úloh ke zpracování,
2. abstrakce – jak zahladit rozdíly mezi jednotlivými tiskárnami tak, aby byly z pohledu programu podle
možnosti záměnné.
Řešení druhého bodu je trochu složitější, a některé aspekty tiskáren nelze úplně v aplikacích ignorovat
(černobílý vs barevný tisk, jednostranný vs oboustranný, atp.). Částečným řešením je použití společného
formátu pro popis dokumentů k tisku, přičemž operační systém již zařídí konverzi do formátu, který
tiskárna akceptuje. Starším standardem tohoto typu je PostScript, novějším PDF. Některé tiskárny
podporují tisk dokumentů v těchto formátech přímo, bez potřeby dalšího zpracování v operačním systému.
Z pohledu aplikace může mít tedy virtuální tiskárna jako svou hlavní operaci vložení dokumentu ve formátu
PDF do tiskové fronty`,incorrect:`Tiskárny
1. virtualizace – jak tiskárnu sdílet mezi programy – tento problém je analogický k problému plánováni
úloh v dávkových systémech, a má i analogické řešení: frontu úloh ke zpracování,
2. abstrakce – jak zahladit rozdíly mezi jednotlivými tiskárnami tak, aby byly z pohledu programu podle
možnosti záměnné.
Řešení druhého bodu je trochu složitější, a některé aspekty tiskáren nelze úplně v aplikacích ignorovat
(černobílý vs barevný tisk, jednostranný vs oboustranný, atp.). Částečným řešením je použití společného
formátu pro popis dokumentů k tisku, přičemž operační systém již zařídí konverzi do formátu, který
tiskárna akceptuje. Starším standardem tohoto typu je PostScript, novějším NewScript. Některé tiskárny
podporují tisk dokumentů v těchto formátech přímo, bez potřeby dalšího zpracování v operačním systému.
Z pohledu aplikace může mít tedy virtuální tiskárna jako svou hlavní operaci vložení dokumentu ve formátu
NewScript do tiskové fronty`},{uuid:"66ecc093-7379-4922-86f3-696aa9177412",correct:`Síťové vrstvy
1. fyzická – záležitost hardwaru, má ale dopad na vyšší vrstvy,
2. linková – tvoří faktické rozhraní mezi hardwarem a softwarem (operačním systémem),
3. síťová – na koncových stanicích řeší převážně software (operační systém), jejím úkolem je zabezpečit
komunikaci mezi koncovými uzly (resp. mezi operačními systémy na nich provozovanými),
4. transportní doručuje data mezi aplikacemi: tvoří rozhraní mezi operačním systémem a aplikací, a je
tak přirozeným místem pro virtualizaci,
5. a vyšší: záležitost aplikací, staví na virtualizaci poskytované 4. vrstvou.`,incorrect:`Síťové vrstvy
1. fyzická – záležitost hardwaru, má ale dopad na vyšší vrstvy
2. síťová – na koncových stanicích řeší převážně software (operační systém), jejím úkolem je zabezpečit
komunikaci mezi koncovými uzly (resp. mezi operačními systémy na nich provozovanými)
3. , linková – tvoří faktické rozhraní mezi hardwarem a softwarem (operačním systémem)
4. transportní doručuje data mezi aplikacemi: tvoří rozhraní mezi operačním systémem a aplikací, a je
tak přirozeným místem pro virtualizaci
5. a vyšší: záležitost aplikací, staví na virtualizaci poskytované 4. vrstvou.`},{uuid:"ccba70bc-8d6b-49d7-93bd-9fa65e6c6983",correct:`Odchozí fronta
Potřebuje-li operační systém odeslat paket (rámec) do sítě, přidá je na konec
tzv. odchozí fronty (angl. transmit queue, Tx queue). Z této fronty je vyzvedne hardware a jakmile je
to možné, provede fyzický přenos. Odchozí fronta funguje přibližně takto:
1. každá odchozí fronta (může jich existovat několik) má přiřazenu dvojici registrů mapovaných do
fyzického adresního prostoru: jeden reprezentuje hlavový ukazatel a ten druhý koncový (angl. head a
tail),
2. tyto ukazatele popisují kruhovou frontu pevné velikosti, uloženu v operační paměti, ke které síťové
rozhraní přistupuje za pomoci DMA; každá položka (buňka) této kruhové fronty reprezentuje jeden
rámec,
3. ukazatele dělí frontu na dvě části – jedna patří rozhraní a jedna operačnímu systému,
4. operační systém (resp. ovladač síťového rozhraní) upravuje koncový ukazatel:
a. pro odeslání rámce pro něj operační systém nejprve vyhradí paměť a uloží do ni obsah rámce (data),
b. zapíše příslušnou adresu a velikost do své části kruhové fronty,
c. posune koncový ukazatel, čím předá odpovědnost za nově vyplněné buňky síťovému rozhraní,
5. síťové rozhraní ovládá hlavový ukazatel: kdykoliv zpracuje odchozí rámec, posune hlavový ukazatel
tak, že paměť asociovaná s odeslaným rámcem se přesune do části fronty, která patří operačnímu
systému.
Události, které se zpracováním kruhové fronty souvisí, signalizuje síťové rozhraní pomocí přerušení`,incorrect:`Odchozí fronta
Potřebuje-li operační systém odeslat paket (rámec) do sítě, přidá je na konec
tzv. odchozí fronty (angl. transmit queue, Tx queue). Z této fronty je vyzvedne hardware a jakmile je
to možné, provede fyzický přenos. Odchozí fronta funguje přibližně takto:
1. každá odchozí fronta (může jich existovat několik) má přiřazenu dvojici registrů mapovaných do
fyzického adresního prostoru: jeden reprezentuje hlavový ukazatel a ten druhý koncový (angl. head a
tail),
2. tyto ukazatele popisují kruhovou frontu dynamické velikosti, uloženu v operační paměti, ke které síťové
rozhraní přistupuje za pomoci DMA; každá položka (buňka) této kruhové fronty reprezentuje jeden
rámec,
3. ukazatele dělí frontu na dvě části – jedna patří rozhraní a jedna operačnímu systému,
4. operační systém (resp. ovladač síťového rozhraní) upravuje koncový ukazatel:
a. pro odeslání rámce pro něj operační systém nejprve vyhradí paměť a uloží do ni obsah rámce (data),
b. zapíše příslušnou adresu a velikost do své části kruhové fronty,
c. posune koncový ukazatel, čím předá odpovědnost za nově vyplněné buňky síťovému rozhraní,
5. síťové rozhraní ovládá hlavový ukazatel: kdykoliv zpracuje odchozí rámec, posune hlavový ukazatel
tak, že paměť asociovaná s odeslaným rámcem se přesune do části fronty, která patří rozhraní
Události, které se zpracováním kruhové fronty souvisí, signalizuje síťové rozhraní pomocí přerušení`},{uuid:"80f5b358-2720-46ca-b37a-66b5effb4dc0",correct:`Příjmová fronta
Síťové rozhraní popřidání prvků tuto změnu signalizuje přerušením. Alokace paměti pro rámce je v kompetenci operačního
systému – přesune-li operační systém nějakou položku (buňku) do části kruhové fronty, která náleží
síťovému rozhraní, dává tím najevo, že paměť touto položkou odkázaná může být přepsána novými daty.
Jakmile tak síťové rozhraní učiní, příslušnou buňku příjmové fronty přesune do části patřící operačnímu
systému.
Je obvyklé, že každý blok paměti, který operační systém rozhraní předá, má velikost největšího možného
rámce (MTU z angl. maximal transfer unit, obvykle 1500 bajtů), i když některá rozhraní umí příchozí
rámce rozdělit do více buněk, je-li to potřeba.`,incorrect:`Příjmová fronta
Síťové rozhraní po přidání prvků tuto změnu signalizuje přerušením. Alokace paměti pro rámce je v kompetenci operačního
systému – přesune-li operační systém nějakou položku (buňku) do části kruhové fronty, která náleží
síťovému rozhraní, dává tím najevo, že paměť touto položkou odkázaná může být přepsána novými daty.
Jakmile tak síťové rozhraní učiní, příslušnou buňku příjmové fronty přesune do části patřící operačnímu
systému.
Je obvyklé, že každý blok paměti, který operační systém rozhraní předá, má velikost 2 na n (kde n je velikost registrů procesoru).`}]},{uuid:"45309117-9cde-4069-8add-2f2060b1f984",sectionNumber:"5",sectionTitle:"Souběžnost a synchronizace",statements:[{uuid:"d352a06b-9766-449d-b1b4-38a1d983b019",correct:`Relace předcházení
Událost je jev, který nastane v čase (ne nutně pevně určeném nebo známém), který můžeme
pozorovat, a o kterém můžeme říct, že nastal před nebo po nějaké jiné události, případně že s ní
nastal souběžně. Relaci uspořádání, která tuto chronologii popisuje, budeme říkat předcházení (anglicky
„happens before“).
Takto definovaná relace určuje vztah „muselo se stát před“ neboli kauzální návaznost. Grafem předcházení
nazveme tranzitivní redukci této relace. Protože grafem uspořádání je acyklický orientovaný graf (angl.
DAG = directed acyclic graph), jeho tranzitivní redukce je určena jednoznačně (znáte nejspíš jako
Hasseův diagram).`,incorrect:`Relace předcházení
Událost je jev, který nastane v čase (ne nutně pevně určeném nebo známém), který můžeme
pozorovat, a o kterém můžeme říct, že nastal před nebo po nějaké jiné události, případně že s ní
nastal souběžně. Relaci uspořádání, která tuto chronologii popisuje, budeme říkat předcházení (anglicky
„happens before“).
Takto definovaná relace určuje vztah „muselo se stát před“ neboli kauzální návaznost. Grafem předcházení
nazveme tranzitivní redukci této relace. Protože grafem uspořádání je cyklický orientovaný graf (angl.
DCG = directed cyclic graph), jeho tranzitivní redukce je určena jednoznačně (znáte nejspíš jako
Hasseův diagram).`},{uuid:"94a368a6-ffb6-40fc-abdf-06e05a30366a",correct:`Relace předcházení
Vrcholy grafu předcházení jsou události (něco se stalo), jeho hrany budeme nazývat akce (něco se děje).
Akce tedy vedou od jedné události k nějaké další, ale nemohou je „přeskakovat“ (formálněji: existuje-li
mezi událostmi A a B cesta délky alespoň 2, neexistuje hrana/akce která vede z A do B přímo).`,incorrect:`Relace předcházení
Vrcholy grafu předcházení jsou události (něco se stalo), jeho hrany budeme nazývat akce (něco se děje).
Akce tedy vedou od jedné události k nějaké další, ale mohou je „přeskakovat“ (formálněji: existuje-li
mezi událostmi A a B cesta délky alespoň 2, může existovat hrana/akce která vede z A do B přímo).`},{uuid:"9d1d6d20-e04b-4ed9-99c4-2dc72eecef16",correct:`Časový sled
 Je-li nějaká relace předcházení lineární, mluvíme o časovém sledu.
Připomenutí: Časovým sledem událostí rozumíme lineární uspořádání událostí, tedy takové, že pro každou
dvojici A, B událostí platí buď:
• A předchází B nebo
• B předchází A.
Časový sled si můžeme představit i jako přiřazení časového razítka každé události takové, že žádné dvě
události nenastanou ve stejné chvíli.`,incorrect:`Časový sled
Je-li nějaká relace předcházení souběžná, mluvíme o časovém sledu.
Připomenutí: Časovým sledem událostí rozumíme souběžná uspořádání událostí, tedy takové, že pro každou
dvojici A, B událostí platí:
A a B nastanou libovoně, tedy nezávisle na sobě
Časový sled si můžeme představit i jako přiřazení časového razítka každé události takové, že žádné dvě
události nenastanou ve stejné chvíli.`},{uuid:"d4e2e9d9-bb7b-4214-be20-728d7d7b4275",correct:`Hazard souběhu
Předcházení je abstrakce, která skrývá vnitřní detaily procesů (dějů odehrávajících se v
čase), které se mohou stát v různém pořadí díky náhodným vlivům, a snažíme se jejich vnější chování
popsat pomocí této relace. Vnější chování nějakého systému závisí pouze na jeho relaci předcházení,
nikoliv už na tom, jak přesně budou v čase rozloženy konkrétní události.
Je-li takto zavedená abstrakce porušena, mluvíme o hazardu souběhu. Jinými slovy, hazard souběhu nastává
kdykoliv vedou dva různé časové sledy, které jsou oba konzistentní s relací předcházení pro daný systém,
k různému vnějšímu chování.`,incorrect:`Předcházení je abstrakce, která skrývá vnitřní detaily procesů (dějů odehrávajících se v
čase), které se mohou stát v různém pořadí díky náhodným vlivům, a snažíme se jejich vnější chování
popsat pomocí této relace. Vnější chování nějakého systému závisí pouze na jeho relaci předcházení,
nikoliv už na tom, jak přesně budou v čase rozloženy konkrétní události.
Je-li takto zavedená abstrakce porušena, mluvíme o chybě atomicity. Jinými slovy, chyba atomicity nastává
kdykoliv vedou dva různé časové sledy, které jsou oba konzistentní s relací předcházení pro daný systém,
k různému vnějšímu chování.`},{uuid:"d36f9be2-3654-45e2-90bc-00a807749a58",correct:`Hybatel
Akce (které reprezentujeme hranami v grafu předcházení) jsou prováděny vždy nějakým
hybatelem (v našem kontextu obvykle vláknem nebo periferií). Hrany (akce) tedy můžeme tomuto hybateli
přisoudit (např. můžeme říct, že vlákno T má modré hrany a periferie P má žluté hrany). Zároveň hybatele
můžeme považovat za „peška“ který se v grafu předcházení pohybuje po hranách své vlastní barvy.`,incorrect:`Hybatel
Akce (které reprezentujeme hranami v grafu předcházení) jsou prováděny vždy nějakým
hybatelem (v našem kontextu obvykle vláknem nebo periferií). Hrany (akce) tedy můžeme tomuto hybateli
přisoudit (např. můžeme říct, že vlákno T má modré hrany a periferie P má žluté hrany). Zároveň hybatele
můžeme považovat za „peška“ který se v grafu předcházení pohybuje po hranách libovoné barvy.`},{uuid:"e07e79d2-bdad-4e74-aff5-215d3ccba4c7",correct:`Synchronizace
Akce jsou souběžné právě tehdy, když jsou souběžné libovolné dvě události, kterých
se tyto akce týkají. Událost zejména nemůže být souběžná sama se sebou, a nemohou být souběžné ani
události spojené nějakou akcí.`,incorrect:`Synchronizace
Akce jsou souběžné právě tehdy, když jsou souběžné libovolné dvě události, kterých
se tyto akce týkají. Událost můžou být souběžná sama se sebou, a také mohou být souběžné události spojené nějakou akcí.`},{uuid:"5535a125-0bd1-451f-a1ea-59afc2a90c12",correct:`Stavový prostor je orientovaný graf kde vrcholy jsou stavy a hrany jsou akce (ve stejném smyslu jako
v grafu předcházení). Pojem „stav“ je v tomto kontextu velmi abstraktní, nicméně můžeme si bez velké
újmy nadále představovat stav jako:
• hodnoty procesorových registrů,
• buněk paměti (jak operační, tak paměti a registrů periferií).`,incorrect:`Stavový prostor je orientovaný graf kde vrcholy jsou akce a hrany jsou stavy (ve stejném smyslu jako
v grafu předcházení). Pojem „stav“ je v tomto kontextu velmi abstraktní, nicméně můžeme si bez velké
újmy nadále představovat stav jako:
• hodnoty procesorových registrů,
• buněk paměti (jak operační, tak paměti a registrů periferií).`},{uuid:"11839346-62d6-4eb2-934c-b773f1a49f51",correct:`Běh
Orientovanou cestu ve stavovém prostoru označíme za běh. Je zde jasná korespondence mezi
během (posloupnost stavů propojených akcemi) a časovým sledem (posloupnost událostí propojených
akcemi). Sekvenci akcí můžeme chápat i jako běh i jako sled – v obou případech stačí určit počáteční
stav (událost) a zbytek běhu (sledu) je již určen akcemi jednoznačně.`,incorrect:`Běh
Orientovanou cestu ve stavovém prostoru označíme za běh. Je zde jasná korespondence mezi
během (posloupnost stavů propojených akcemi) a časovým sledem (posloupnost událostí propojených
akcemi). Sekvenci akcí můžeme chápat i jako běh ale nikoliv jako sled – v případě běhu stačí určit počáteční
stav (událost) a zbytek běhu je již určen akcemi jednoznačně.`},{uuid:"30259068-35c7-48a8-a7b6-8e6774fe3fa1",correct:`Kritická sekce Uvažme běh R ≡ (r1, r2, ..., rn) nějakého vlákna (nebo jiného hybatele) T1asouběžný běh S ≡ (s1, ..., sn).
Říkáme, že R je kritickou sekcí vůči S, vede-li (r1, ..., S, ..., rn) k události „chyba“, a to přesto, že samotné běhy R ani S k chybě nevedou.
Proto se tomuto typu problému také říká chyba atomicity.`,incorrect:`Kritická sekce Uvažme běh R ≡ (r1, r2, ..., rn) nějakého vlákna (nebo jiného hybatele) T1asouběžný běh S ≡ (s1, ..., sn).
Říkáme, že S je kritickou sekcí vůči R, vede-li (r1, ..., S, ..., rn) k události „chyba“, a to přesto, že samotné běhy R ani S k chybě nevedou.
Proto se tomuto typu problému také říká chyba atomicity.`},{uuid:"4ef4b807-5b49-4c69-8ed3-9b76c4eaa4c1",correct:`Čtenáři a písaři
Představme si situaci, kdy máme běhy R1, R2, … Rn a běhy W1, W2, …, Wm,
pro které platí:
1. ∀.i, j platí Ri není kritickou sekcí vůči Rj
2. ∀.i, j platí Ri je kritickou sekcí vůči Wj,
3. ∀.i, j platí Wi je kritickou sekcí vůči Wj
Takovou situaci nazýváme „čtenáři a písaři“ – máme tedy n čtenářů Ri a m písařů Wi.
Čtenáři si vzájemně nepřekáží – mohou číst zároveň v libovolném pořadí. 
Písaři se chovají jinak: sdílená data nejen čtou, ale i modifikují – proto čtenář,
který by byl přerušen písařem, by mohl přečíst nekonzistentní data.
Podobně si překáží dva různí písaři – protože data jak čtou tak modifikují, může být výsledek opět nekonzistentní.`,incorrect:`Čtenáři a písaři
Představme si situaci, kdy máme běhy R1, R2, … Rn a běhy W1, W2, …, Wm,
pro které platí:
1. ∀.i, j platí Wi není kritickou sekcí vůči Wj
2. ∀.i, j platí Ri je kritickou sekcí vůči Wj,
3. ∀.i, j platí Ri je kritickou sekcí vůči Rj
Takovou situaci nazýváme „čtenáři a písaři“ – máme tedy n čtenářů Ri a m písařů Wi.
Čtenáři si vzájemně nepřekáží – mohou číst zároveň v libovolném pořadí.
Písaři se chovají jinak: sdílená data nejen čtou, ale i modifikují – proto čtenář
 který by byl přerušen písařem, by mohl přečíst nekonzistentní data.
Podobně si překáží dva různí písaři – protože data jak čtou tak modifikují, může být výsledek opět nekonzistentní.`},{uuid:"d234e287-055b-4d79-90f7-f0632cc6e5c3",correct:`Souběžná datová závislost 
je vztah mezi akcemi, který je nejlépe vidět ve stavovém prostoru:
je-li vstupem nějaké akce Z paměťová buňka nebo registr, do které naposled zapisovala akce X, říkáme,
že Z má datovou závislost na X.
Uvažme zároveň situaci, kdy máme dva běhy, A ≡ (a1, ..., X, ...an), B ≡ (b1, ..., Z, ..., bm), které jsou
zcela souběžné. To se v programu může lehce stát, a často je těžké takovou chybu odhalit, zejména je-li
výpočet (a1, ..., X) krátký, zatímco (b1, ..., Z) dlouhý (časově náročný)`,incorrect:`Souběžná datová závislost
je vztah mezi akcemi, který je nejlépe vidět ve stavovém prostoru:
je-li vstupem nějaké akce Z paměťová buňka nebo registr, do které naposled zapisovala akce X, říkáme,
že X má datovou závislost na Z.
Uvažme zároveň situaci, kdy máme dva běhy, A ≡ (a1, ..., X, ...an), B ≡ (b1, ..., Z, ..., bm), které jsou
zcela souběžné. To se v programu může lehce stát, a často je těžké takovou chybu odhalit, zejména je-li
výpočet (a1, ..., X) krátký, zatímco (b1, ..., Z) dlouhý (časově náročný)`},{uuid:"558d19a1-6430-4a21-a974-653ed15dae8e",correct:`Producenti a konzumenti
Uvažme situaci, kdy účelem několika vláken je vytvářet mezivýsledky
určené k dalšímu zpracování (tato vlákna – producenty – označíme P1...Pn), a několik dalších vláken
tyto mezivýsledky dále zpracovává (tato nazveme konzumenty a označíme K1...Km).
Všechna vlákna Pi jsou souběžná jak vzájemně tak s vlákny Ki.
Tato souběžnost je důležitá a užitečná:
umožňuje nám práci distribuovat na různá procesorová jádra a tím celý proces značně urychlit. Protože
jsou ale všechna vlákna souběžná, můžou lehce nastat dvě problémové situace:
1. producenti mohou generovat výsledky rychleji, než je konzumenti dokáží zpracovávat – mezivýsledky
se budou hromadit a postupně zaberou veškerou vyhrazenou paměť, nebo se začnou ztrácet (protože je
producenti začnou přepisovat dříve, než jsou zpracovány),
2. konzumenti mohou zpracovávat výsledky rychleji, než je producenti dokáží vytvářet – bez synchronizace
by taková situace vedla k opakovanému zpracování stejného mezivýsledku, případně k pokusu o zpracování
nějaké nesmyslné informace (je-li mezivýsledek očekáván na adrese, kam ještě nebyl producentem
zapsán).

V těchto dvou situacích se tedy musí konzumenti a producenti synchronizovat – je-li mezivýsledků
nedostatek, upřednostníme práci producentů, naopak je-li jich přebytek, upřednostníme práci konzumentů.
V ideálním případě tak, aby existovala nějaká pevná mez na počet nezpracovaných mezivýsledků (a tedy i
na množství paměti potřebné pro jejich uložení).`,incorrect:`Producenti a konzumenti
Uvažme situaci, kdy účelem několika vláken je vytvářet mezivýsledky
určené k dalšímu zpracování (tato vlákna – producenty – označíme P1...Pn), a několik dalších vláken
tyto mezivýsledky dále zpracovává (tato nazveme konzumenty a označíme K1...Km).
Všechna vlákna Pi jsou souběžná jak vzájemně tak s vlákny Ki.
Tato souběžnost je důležitá a užitečná:
umožňuje nám práci distribuovat na různá procesorová jádra a tím celý proces značně urychlit. Protože
jsou ale všechna vlákna souběžná, můžou lehce nastat dvě problémové situace:
1. producenti mohou generovat výsledky rychleji, než je konzumenti dokáží zpracovávat – mezivýsledky
se budou hromadit a postupně zaberou veškerou vyhrazenou paměť, nebo se začnou ztrácet (protože je
producenti začnou přepisovat dříve, než jsou zpracovány),
2. konzumenti mohou zpracovávat výsledky rychleji, než je producenti dokáží vytvářet – bez synchronizace
by taková situace vedla k opakovanému zpracování stejného mezivýsledku, případně k pokusu o zpracování
nějaké nesmyslné informace (je-li mezivýsledek očekáván na adrese, kam ještě nebyl producentem
zapsán).

V těchto dvou situacích se tedy musí konzumenti a producenti synchronizovat – je-li mezivýsledků
nedostatek, upřednostníme práci producentů, naopak je-li jich přebytek, upřednostníme práci konzumentů.
V ideálním případě tak, aby existovala nějaká dynamická mez, která se podle potřeb systému mění.`},{uuid:"9c248fd7-195a-4f57-8234-1bb0429c9faa",correct:`Rozvětvení a setkán
Akce, které nejsou souběžné, nelze provádět paralelně. Máme-li tedy více výpočetních jader, než máme
vláken, nevyužíváme hardwarové zdroje efektivně. Relativně častým jevem je, že výpočet má dva (nebo
několik) bloků, které lze provést v libovolném pořadí, aniž by se změnil výsledek. V takovém případě
bychom chtěli výpočet rozvětvit tak, aby byl každý takový blok (běh) souběžný s těmi ostatními. Máme-li
procesorů málo, vykonají se v libovolném pořadí (to nám nevadí), ale máme-ji jich dostatek (nebo
přebytek), mohou se tyto běhy provést najednou (každý na jiném procesoru).
Tím ale vzniká nový problém – výpočet nemůže pokračovat, než skončí všechny takto vyčleněné bloky
– jinak bychom se dostali do situace „výpočetní závislost“ (a tím do známého terénu „příliš mnoho
souběžnosti“). Proto je potřeba, aby se běhy i setkaly.`,incorrect:`Rozvětvení a setkán
Akce, které nejsou souběžné, nelze provádět paralelně. Máme-li tedy více výpočetních jader, než máme
vláken, nevyužíváme hardwarové zdroje efektivně. Relativně častým jevem je, že výpočet má dva (nebo
několik) bloků, které lze provést v libovolném pořadí, aniž by se změnil výsledek. V takovém případě
bychom chtěli výpočet rozvětvit tak, aby byl každý takový blok (běh) souběžný s těmi ostatními. Máme-li
procesorů málo, vykonají se v libovolném pořadí (to nám nevadí), ale máme-ji jich dostatek (nebo
přebytek), mohou se tyto běhy provést najednou (každý na jiném procesoru).
Tím ale vzniká nový problém – výpočet nemůže pokračovat, než skončí alespoň některé takto vyčleněné bloky
– jinak bychom se dostali do situace „výpočetní závislost“ (a tím do známého terénu „příliš mnoho
souběžnosti“).`}]},{uuid:"05038f02-9d9b-4922-a291-26653c34b40b",sectionNumber:"6",sectionTitle:"Synchronizace",statements:[{uuid:"0812706c-3e3f-4de4-83d9-c3cd37cf4f24",correct:`Synchronizační zařízení
synchronizační zařízení je (de facto) datová struktura – v programu může existovat v mnoha
nezávislých instancích. Mezi různými instancemi se žádná synchronizace neděje. Každé synchronizační
zařízení má nějaký stav, který musí být někde uložen: instanci synchronizačního zařízení tedy ztotožníme
s adresou, na které je uložen jeho stav`,incorrect:`Synchronizační zařízení
synchronizační zařízení je (de facto) datová struktura – v programu může existovat v mnoha
nezávislých instancích. Mezi různými instancemi  může probíhat synchronizace. Každé synchronizační
zařízení má nějaký stav, který musí být někde uložen: instanci synchronizačního zařízení tedy ztotožníme
s adresou, na které je uložen jeho stav`},{uuid:"c90cb1be-0fd1-4293-9294-03d3263788d5",correct:`Vzájemné vyloučení (mutex) 
Zřejmě úplně nejjednodušším synchronizačním zařízením je mutex,
určený k ochraně kritické sekce. Aby byla kritická sekce ochráněna, musí být chráněná jak kritická sekce
samotná, tak i všechny běhy, vůči kterým je kritická, a to tím stejným mutexem.`,incorrect:`Vzájemné vyloučení (mutex) 
Zřejmě úplně nejjednodušším synchronizačním zařízením je mutex,
určený k ochraně kritické sekce. Aby byla kritická sekce ochráněna,stačí když  bude chráněná samotná kritická sekce,
 nic ostatního není potřeba, vychází z relace předcházení.`},{uuid:"97fcefb0-1467-4db7-a323-f073361896a2",correct:`Spinlock
je synchronizační smyčka bez interakce s plánovačem (komunikace s plánovačem je
potenciálně drahá operace – neplánujeme-li čekat dlouho, může být nevýhodné ji provést).
V moderních systémech se spinlock implementuje pomocí atomické instrukce, která umožní provést
operaci ld, úpravu hodnoty a st jako jediný krok, který je pro všechny procesory v systému pozorovatelný
pouze jako celek. Atomických operací existuje celá řada, my použijeme operaci cmpxchg (z angl. „compare
and exchange“), která má 3 operandy: adresu, očekávanou hodnotu a požadovanou hodnotu.`,incorrect:`Spinlock
je synchronizační smyčka, která interaguje s plánovačem (komunikace s plánovačem je
potenciálně drahá operace – neplánujeme-li čekat dlouho, může být nevýhodné ji provést).
V moderních systémech se spinlock implementuje pomocí atomické instrukce, která umožní provést
operaci ld, úpravu hodnoty a st jako jediný krok, který je pro všechny procesory v systému pozorovatelný
pouze jako celek. Atomických operací existuje celá řada, my použijeme operaci cmpxchg (z angl. „compare
and exchange“), která má 3 operandy: adresu, očekávanou hodnotu a požadovanou hodnotu.`},{uuid:"e5540698-d3b7-4642-9116-475c0e80fe2d",correct:`Spinlock (resp. aktivní čekání obecně) má ale jednu důležitou nevýhodu: soutěží-li o stejný zámek dvě
vlákna, která sdílí procesorové jádro, čekajícímu vláknu se nemůže podařit zámek získat, dokud nebude
vlastník zámku probuzen. Proto je použití spinlocku v uživatelských programech obvykle chybou (nelze
zaručit, že vlákna budou naplánována na různá procesorová jádra).`,incorrect:`Spinlock (resp. aktivní čekání obecně) má ale jednu důležitou nevýhodu: soutěží-li o stejný zámek dvě
vlákna, která sdílí procesorové jádro, čekajícímu vláknu se nemůže podařit zámek získat, dokud nebude
vlastník zámku probuzen. Proto je použití spinlocku v uživatelských programech obvykle chybou (vlákna budou vždy naplánována na různá procesorová jádra).`},{uuid:"47fb8d1d-a948-48dc-9d09-1749360f9704",correct:`Uspávající mutex 
Operace lock je realizována jako služba operačního systému (systémové volání); jádro nejprve ověří, je-li zámek odemčen:
1. pokud ano, poznačí ho jako zamčený a vrátí kontrolu vláknu, které zámek vyžádalo,
2. v opačném případě zařadí vlákno do fronty, která danému mutexu náleží, a nechá plánovač probudit
nějaké jiné vlákno.
Odemčení zámku pak ověří, je-li nějaké další vlákno ve frontě, a pokud ano, mutex ihned zase zamkne a
předá ho prvnímu vláknu z této fronty`,incorrect:`Uspávající mutex 
Operace lock je realizována bez interakce s plánovačem; jádro nejprve ověří, je-li zámek odemčen:
1. pokud ano, poznačí ho jako zamčený a vrátí kontrolu vláknu, které zámek vyžádalo,
2. v opačném případě zařadí vlákno do fronty, která danému mutexu náleží, a nechá plánovač probudit
nějaké jiné vlákno.
Odemčení zámku pak ověří, je-li nějaké další vlákno ve frontě, a pokud ano, mutex ihned zase zamkne a
předá ho prvnímu vláknu z této fronty`},{uuid:"61ce7504-594a-48ad-99c5-9bd013d20269",correct:`Rychlý mutex
rozdělení odpovědnosti za dvě části stavu
mezi uživatelské vlákno a operační systém. Rozhodnutí o tom, je-li zámek zamčený nebo nikoliv, vyřeší
vlákno ve vlastní režii (stejně, jako by se jednalo o spinlock – pomocí atomické instrukce). Systémové
volání se provede pouze v případě, kdy pokus o zamčení selže.
Systémová část stavu se jmenuje futex (z angl. „fast mutex“), a sestává pouze z fronty uspaných
vláken. Fronty jsou s jednotlivými uživatelskými mutexy svázány adresou (tzn. operační systém má
pomyslný slovník front, kde klíčem je adresa příslušného mutexu)`,incorrect:`Rychlý mutex
rozdělení odpovědnosti za dvě části stavu
mezi uživatelské vlákno a operační systém. Rozhodnutí o tom, je-li zámek zamčený nebo nikoliv, vyřeší
vlákno ve vlastní režii (stejně, jako by se jednalo o spinlock – pomocí atomické instrukce). Systémové
volání se provede pouze v případě, kdy pokus o zamčení selže.
Systémová část stavu se jmenuje futex (z angl. „fast mutex“), a sestává pouze z fronty uspaných
vláken. Fronty jsou mezi jednotlivými uživatelskými mutexy sdílené napříč celým systémem.`},{uuid:"262245dc-1124-4224-9160-fe79478ea645",correct:` Read-Copy-Update
Princip fungování je jednoduchý: místo aby písař měnil datovou strukturu na místě, vytvoří její kopii
(skutečnou nebo pomyslnou resp. částečnou) a tuto kopii upraví – obě operace jsou bezpečné, protože
kopírování je vzhledem k původní datové struktuře forma čtení, a nová kopie je prozatím ve výlučném
vlastnictví písaře (jiná vlákna k ní nemají vůbec přístup). Jakmile je úprava hotová, přesměruje všechny
budoucí čtenáře na tuto novou verzi, obvykle tím, že upraví sdílený ukazatel. 
Starší kopie je možné uvolnit až ve chvíli, kdy je jisté, že k nim nepřistupuje žádný čtenář – protože
čtenáři jsou se zapisujícím písařem souběžní, potřebujeme další synchronizační mechanismus – častou
volbou je počítadlo odkazů, které čtenáři udržují; poslední čtenář pak již nepotřebnou starší verzi dat
uvolní.`,incorrect:`Read-Copy-Update
Princip fungování je jednoduchý: místo aby písař měnil datovou strukturu na místě, vytvoří její kopii
(skutečnou nebo pomyslnou resp. částečnou) a tuto kopii upraví – obě operace jsou bezpečné, protože
kopírování je vzhledem k původní datové struktuře forma čtení, a nová kopie je prozatím ve výlučném
vlastnictví písaře (jiná vlákna k ní nemají vůbec přístup). Jakmile je úprava hotová, přesměřujeme všechny aktuální i budoucí čtenáře na aktuální verzi.`},{uuid:"12e38f08-b37c-4119-89a6-127d34de50be",correct:`Monitor
Monitor je jednoduchou, ale velmi užitečnou abstrakcí – uvažme datovou strukturu, která sestává z nějaké
datové reprezentace a operací nad ní. Realizace jednotlivé operace je často kritickou sekcí vůči ostatním
operacím (to platí zejména pro ty operace, které strukturu mění).
Organizujeme-li program tak, že jediný přístup přímo k datům takové struktury je skrze operace
definované v podprogramech, lze datové struktuře jako celku přidružit jeden mutex, který se na začátku
každé operace zamkne a na konci odemkne. Lze si zde představit dvě implementační strategie:
1. v ideálním případě zamykáni a odemykání v operacích řeší překladač (týká se některých OOP jazyků);
pak lze navíc v situaci, kdy jedna operace volá jinou operaci jako podprogram, zamykání přeskočit
(„staticky“ víme, že mutex je již zamčený),
2. v méně ideálním případě, kdy je „monitor“ pouze ručně udržovaný invariant, můžeme využít rekurzivního
mutexu (vnořené zamykání se tak vyřeší „dynamicky“ – za běhu).`,incorrect:`Monitor
Monitor je jednoduchou, ale velmi užitečnou abstrakcí – uvažme datovou strukturu, která sestává z nějaké
datové reprezentace a operací nad ní. Realizace jednotlivé operace je často kritickou sekcí vůči ostatním
operacím (to platí zejména pro ty operace, které strukturu mění).
Organizujeme-li program tak, že jediný přístup přímo k datům takové struktury je skrze operace
definované v podprogramech, lze datové struktuře jako celku přidružit několik mutexů, které vybere podle potřeby na začátku
každé operace a daný mutex zamkne a na konc zasei odemkne. Lze si zde představit dvě implementační strategie:
1. v ideálním případě zamykáni a odemykání v operacích řeší překladač (týká se některých OOP jazyků);
pak lze navíc v situaci, kdy jedna operace volá jinou operaci jako podprogram, zamykání přeskočit
(„staticky“ víme, že mutex je již zamčený),
2. v méně ideálním případě, kdy je „monitor“ pouze ručně udržovaný invariant, můžeme využít rekurzivního
mutexu (vnořené zamykání se tak vyřeší „dynamicky“ – za běhu).`},{uuid:"9a598e03-6f13-4dd2-88b2-9fe236c77394",correct:`Monitor nemůže zaručit, že program jako celek nebude obsahovat chyby synchronizace – není
těžké představit si invariant, který přesahuje hranice jedné datové struktury, a kterého dočasné
porušení je kritickou sekcí.
`,incorrect:"Monitor pomáhá zaručit, že program jako celek nebude obsahovat chyby synchronizace a chrání tak celou datovou strukturu a operace nad ní."},{uuid:"e19f7102-d24e-4dee-a4db-6573a6edb0e8",correct:`Podmínková proměnná
Pro řešení problému souběžné datové závislosti lze použít synchronizační
zařízení, kterému se říká podmínková proměnná (angl. condition variable). Operace jsou jednoduché:
• wait – čekej – zablokuje volající vlákno až do chvíle, kdy nějaké jiné vlákno provede operaci signal,
• signal odblokuje vlákno (tzn. umožní mu pokračovat ve výpočtu) zablokované operací wait.`,incorrect:`Podmínková proměnná
Pro řešení problému čtenářů a písařů lze použít synchronizační
zařízení, kterému se říká podmínková proměnná (angl. condition variable). Operace jsou jednoduché:
• wait – čekej – zablokuje volající vlákno až do chvíle, kdy nějaké jiné vlákno provede operaci signal,
• signal odblokuje vlákno (tzn. umožní mu pokračovat ve výpočtu) zablokované operací wait.`},{uuid:"fd5b64b3-f64b-4754-98a1-4c4b428cd008",correct:`Semafor
Klasický semafor přímo neřeší žádný zajímavý problém (který by mutex nebo některá
jeho varianta neřešila lépe), nicméně ze dvou semaforů lze sestavit řešení problému producentů a
konzumentů.
Semafor lze také mírně upravit tak, aby problém producentů a konzumentů řešil přímo – stačí změnit
operaci post tak, aby při pokusu o překročení hodnoty n blokovala. Takovému semaforu bychom mohli říkat
třeba symetrický (díky nově získané symetrii operací wait a post). Klasické řešení problému producentů
a konzumentů pak není nic jiného, než kombinace dvou klasických, asymetrických semaforů do jednoho
symetrického.
Význam semaforu E je počet volných míst ve frontě mezivýsledků, zatímco význam semaforu F je počet
zabraných míst ve frontě mezivýsledků. Operace udržují invariant E + F = n.`,incorrect:`Semafor
Klasický semafor přímo neřeší žádný zajímavý problém (který by mutex nebo některá
jeho varianta neřešila lépe), nicméně ze dvou semaforů lze sestavit řešení problému producentů a
konzumentů.
Semafor lze také mírně upravit tak, aby problém producentů a konzumentů řešil přímo – stačí změnit
operaci post tak, aby při pokusu o překročení hodnoty n blokovala. Takovému semaforu bychom mohli říkat
třeba symetrický (díky nově získané symetrii operací wait a post). Klasické řešení problému producentů
a konzumentů pak není nic jiného, než kombinace dvou klasických, asymetrických semaforů do jednoho
symetrického.
Význam semaforu E je počet volných míst ve frontě mezivýsledků, zatímco význam semaforu F je počet
zabraných míst ve frontě mezivýsledků. Operace udržují invariant E * F = n.`},{uuid:"98671845-ba91-43ef-aa4f-3ebebe9abfc5",correct:` Bariéra
Inverzní semafor – umožňuje pokračovat ve výpočtu, až když na bariéru čeká dostatek
vláken. Smyslem bariéry je řešit problém rozvětvení a setkání (zejména jeho druhou část – setkání
většího počtu vláken, které řeší nezávislé podproblémy nějakého většího výpočetního celku).
Bariéru lze implementovat například jako počítadlo + podmínkovou proměnnou.`,incorrect:` Bariéra
Inverzní semafor – umožňuje pokračovat ve výpočtu, až když na bariéru čeká dostatek
vláken. Smyslem bariéry je řešit problém rozvětvení většího 
počtu vláken, které řeší nezávislé podproblémy nějakého většího výpočetního celku).
Bariéru lze implementovat například jako počítadlo + spinlock.`}]},{uuid:"837eff1d-7f14-47b8-866e-e8759fa5804b",sectionNumber:"7",sectionTitle:"Komunikace, uváznutí",statements:[{uuid:"8fb057e1-a892-4c79-bed7-a2184ab89039",correct:`Komunikace a Synchronizace
Každá komunikace je zároveň formou synchronizace: každé čtení
nějaké informace musí být předcházeno odpovídajícím zápisem. Nelze dost dobře obdržet zprávu, která
dosud nebyla odeslána. Proto je každé komunikační zařízení také zařízením synchronizačním. Opačný vztah
ale neplatí: komunikace přidává možnost předat nějakou informaci.`,incorrect:`Komunikace a Synchronizace
Každá synchronizace je zároveň formou komunikace: každé čtení
nějaké informace musí být předcházeno odpovídajícím zápisem. Nelze dost dobře obdržet zprávu, která
dosud nebyla odeslána. Proto je každé synchronizační zařízení také zařízením komunikačním. Opačný vztah
ale neplatí.`},{uuid:"1dfd70b8-a5c1-4556-93bd-93d24df5f6c2",correct:`Datové struktury pro komunikaci
Ke komunikaci lze použít celkem libovolnou datovou strukturu, je-li chráněna
mutexem nebo jiným vhodným synchronizačním zařízením (např. je realizována jako monitor).
Problém, který zde vzniká, je soutěž (angl. contention) o příslušný zámek. Takové kombinované
komunikační zařízení si lze představit jako klasickou poštovní schránku – vkládá-li právě pošťák psaní
do schránky, nemůžete si z ní dost dobře ve stejnou chvíli vyzvedávat nějaké jiné – jak přesně datová
struktura funguje vnitřně z tohoto pohledu není důležité.`,incorrect:`Datové struktury pro komunikaci
Ke komunikaci lze použít celkem libovolnou datovou strukturu,nesmí být ale chráněna žádným synchronizačním zařízením.
Problém, který zde vzniká, je soutěž (angl. contention) o příslušný zámek. Takové kombinované
komunikační zařízení si lze představit jako klasickou poštovní schránku – vkládá-li právě pošťák psaní
do schránky, nemůžete si z ní dost dobře ve stejnou chvíli vyzvedávat nějaké jiné – jak přesně datová
struktura funguje vnitřně z tohoto pohledu není důležité.`},{uuid:"4ee2be46-0e4d-4025-b774-17caf9218c46",correct:`Roura
Specializace fronty, která pracuje s bajty. Vyznačuje se zejména efektivními dávkovými
operacemi – zápisem resp. čtením většího počtu položek (bajtů) najednou. Často je poskytována operačním
systémem. Prakticky vždy implementovaná jako omezená – existuje nějaký maximální objem dat, který lze
do roury zapsat, než musí další zápis vyčkat na čtení. Stejně jako omezená fronta má tedy synchronizační
chování stejné jako symetrický semafor.`,incorrect:`Roura
Specializace fronty, která pracuje s bajty. Vyznačuje se zejména efektivními dávkovými
operacemi – zápisem resp. čtením většího počtu položek (bajtů) najednou. Často je poskytována operačním
systémem. Prakticky neomezená –  neexistuje maximální objem dat, který je roura schopna pojmout.`},{uuid:"819ecf3e-17eb-4590-af1f-1803bc118a2a",correct:`Alternativou ke sdílené paměti je předávání zpráv – má dvě výhody:
1. je bezpečnější na použití – méně problémů s hazardy souběhu,
2. lze použít i mezi různými počítači (po síti),
a dvě nevýhody:
1. méně pohodlné, protože nelze odkazovat do jiných datových struktur – všechna relevantní data je
potřeba „přibalit“ do samotné zprávy,
2. méně efektivní, jednak kvůli samotné konstrukci zpráv, jednak kvůli režii s kopírováním a předáváním
zprávy.`,incorrect:`Alternativou ke sdílené paměti je předávání zpráv – má dvě výhody:
1. efektivnější
2. lze použít i mezi různými počítači (po síti),
a dvě nevýhody:
1. méně pohodlné, protože nelze odkazovat do jiných datových struktur – všechna relevantní data je
potřeba „přibalit“ do samotné zprávy,
2. je méně bezpečné na použití – více problémů s hazardy souběhu,`},{uuid:"4d1ce8ab-4146-4974-81ad-45dac498762b",correct:`Zpráva 
Z pohledu systému pro předávání zpráv je obvykle obsah zprávy neprůhledný (jsou to pouze
bajty), důležitá jsou připojená metadata: zejména adresát. Způsob adresace je zároveň hlavní rozdíl 
mezi předáváním zpráv a frontami – mezi pevnou dvojicí komunikujících vláken je jinak předávání zpráv
ekvivalentní dvojici komunikačních front`,incorrect:`Zpráva 
Z pohledu systému pro předávání zpráv je obvykle obsah zprávy neprůhledný (jsou to pouze
bajty), důležitá jsou připojená metadata: zejména adresát. Způsob adresace je zároveň hlavní rozdíl 
mezi předáváním zpráv a frontami – mezi pevnou dvojicí komunikujících vláken je jinak předávání zpráv
ekvivalentní bitmapě.`},{uuid:"ffe41c48-1cb0-455e-b60e-6e03fee92677",correct:`Základní opreace
Je-li maximální počet nedoručených zpráv, které je systém ochoten uložit, nulový, mluvíme o tzv.
„setkání“ (rendezvous) – odesílající a přijímající vlákno se musí „sejít“ aby si mohly zprávu předat.
Synchronizační aspekt komunikace je zde obzvláště výrazný – dokonce mnohem výraznější, než je obvyklé
u synchronizačních zařízení.`,incorrect:`Základní opreace
Je-li maximální počet nedoručených zpráv, v daný moment roven nule, mluvíme o tzv.
„setkání“ (rendezvous) – odesílající a přijímající vlákno se setkaly aby si mohly zprávu předat.
Synchronizační aspekt komunikace je zde obzvláště výrazný – dokonce mnohem výraznější, než je obvyklé
u komunikační zařízení.`},{uuid:"3caedd77-3e80-44c5-958c-1ebe0a31866e",correct:`Zprostředkovatel
Úkolem zprostředkovatele je zprávu od odesílatele přebrat a doručit ji adresátovi. Předáni zprávy může
probíhat ve 3 režimech:
• Je-li operace odeslání synchronní a systém doručení spolehlivý, za zprávu je již dále odpovědný
zprostředkovatel – klient může věc považovat za vyřízenou.
• Je-li operace asynchronní, klient musí paměť se zprávou zachovat až do doby, než zprostředkovatel
potvrdí, že ji převzal.
• Je-li doručení zpráv nespolehlivé, a klient potřebuje zajištěné doručení, musí zprávu zachovat až do
doby, než mu ji příjemce potvrdí (opět odesláním zprávy).
Příjem zprávy obvykle funguje v jednom ze dvou režimů:
1. Synchronní, kdy se příjemce dotáže na další zprávu (případně na ni vyčká, není-li právě žádná
k dispozici), tuto zpracuje a poté se zeptá na další.
2. Asynchronní – klient zpracovává větší počet zpráv souběžně, a zpracováni příchozí zprávy začne na
výzvu zprostředkovatele. Lze realizovat buď pomocí klasických vláken, nebo tzv. fibrů.`,incorrect:`Zprostředkovatel
Úkolem zprostředkovatele je zprávu od odesílatele přebrat a doručit ji adresátovi. Předáni zprávy může
probíhat ve 3 režimech:
• Je-li operace odeslání synchronní a systém doručení spolehlivý, za zprávu je již dále odpovědný
zprostředkovatel – klient může věc považovat za vyřízenou.
• Je-li operace asynchronní, klient musí paměť se zprávou zachovat až do doby, než zprostředkovatel
potvrdí, že ji převzal.
• Je-li doručení zpráv nespolehlivé, a klient potřebuje zajištěné doručení, musí zprávu zachovat až do
doby, než mu ji příjemce potvrdí (opět odesláním zprávy).
Příjem zprávy obvykle funguje v jednom ze dvou režimů:
1. Synchronní, kdy se příjemce dotáže na další zprávu (případně na ni vyčká, není-li právě žádná
k dispozici), tuto zpracuje a poté se zeptá na další.
2. Asynchronní – klient zpracovává větší počet zpráv souběžně, a zpracováni příchozí zprávy začne na
výzvu zprostředkovatele. Lze realizovat buď pomocí klasických vláken, nebo tzv. fibrů.`},{uuid:"30107838-41c5-48d6-a272-1990c66c5f40",correct:`Existuje typ operačních systémů, kde je předávání zpráv základním mechanismem meziprocesové komunikace.
Tento návrh silně koreluje s mikrojádrovou architekturou. V takovém systému
jsou služby operačního systému z velké části realizovány „běžnými“ procesy, a proto je komunikace mezi
procesy v takových systémech velmi důležitá. Zprostředkovatelem je v takových systémech často samotné
mikrojádro.`,incorrect:`Existuje typ operačních systémů, kde je předávání zpráv základním mechanismem meziprocesové komunikace.
Tento návrh silně koreluje s makrojádrovou architekturou. V takovém systému
jsou služby operačního systému z velké části realizovány „běžnými“ procesy, a proto je komunikace mezi
procesy v takových systémech velmi důležitá. Zprostředkovatelem je v takových systémech často samotné
makrojádro.`},{uuid:"b6369098-3033-4205-98c7-9d324688e0f1",correct:`Hardwarové zdroje nejpřirozenějším typem zdroje je hardware: jak výpočetní (procesor, paměť)
tak periferie. V první části kurzu jsme se zabývali virtualizací, která nám umožňuje předstírat, že
zdroje vlastníme ve více instancích, než jich fyzicky existuje. To je sice velmi užitečná a úspěšná
taktika, ale není bez limitů.
Virtualizaci zdroje lze uplatnit jen v situacích, kdy každý uživatel daného zdroje využívá jen část jeho
skutečné kapacity – část obrazovky (okno), část procesorového jádra (vlákno), část operační paměti
(proces), část šířky přenosového pásma (síťové spojení) atp.`,incorrect:`Hardwarové zdroje nejpřirozenějším typem zdroje je hardware: jak výpočetní (procesor, paměť)
tak periferie. V první části kurzu jsme se zabývali virtualizací, která nám umožňuje předstírat, že
zdroje vlastníme ve více instancích, než jich fyzicky existuje. To je sice velmi užitečná a úspěšná
taktika, ale není bez limitů.
Virtualizaci zdroje lze uplatnit jen v situacích, kdy uživatel využívá zdroje jako celek.`},{uuid:"b28c484b-d609-4a95-91ed-769265a5972c",correct:`Rezervace
 Alternativou je rezervace, kterou využijeme v situacích, kdy virtualizaci použít nelze:
• neumožňuje to povaha zdroje (např. pásková jednotka nebo optická zapisovací mechanika) nebo
• nečekané selhání zdroje je nepřípustné (např. by došlo k ohrožení zdraví, života nebo majetku).
Rezervace a virtualizace není vzájemně výlučná – daný zdroj může být virtualizován, ale zároveň může
systém poskytovat možnost rezervovat zaručenou kapacitu – v takovém případě je rezervovaný zdroj
(dočasně) nepřístupný pro systém virtualizace. Operační systémy například běžně poskytují možnost
rezervovat pro daný proces nějaké množství fyzické paměti. Takto rezervovanou fyzickou paměť pak
systém nebude používat pro stránky jiných procesů, ani nebude stránky vlastníka z takto rezervované
paměti přesouvat do trvalého úložiště.`,incorrect:`Rezervace
 Alternativou je rezervace, kterou využijeme v situacích, kdy virtualizaci použít nelze:
• neumožňuje to povaha zdroje (např. pásková jednotka nebo optická zapisovací mechanika) nebo
• nečekané selhání zdroje je nepřípustné (např. by došlo k ohrožení zdraví, života nebo majetku).
Rezervace a virtualizace je vzájemně výlučná – daný zdroj může být virtualizován, ale zároveň nemůže
systém poskytovat možnost rezervovat zaručenou kapacitu – v takovém případě by byl rezervovaný zdroj
(dočasně) nepřístupný pro celý systém. Operační systémy například běžně poskytují možnost
rezervovat pro daný proces nějaké množství fyzické paměti. Takto rezervovanou fyzickou paměť pak
systém nebude používat pro stránky jiných procesů, ani nebude stránky vlastníka z takto rezervované
paměti přesouvat do trvalého úložiště.`},{uuid:"3316f8df-3fa9-4d79-8235-9113d7092dfe",correct:`Rezervace sestává ze dvou operací:
1. samotná rezervace, která od systému vyžádá nějaký zdroj (resp. nějaký počet jednotek zdroje), pro
výlučné použití daným programem (procesem, vláknem, atp.), – po úspěšném provedení rezervace je
zdroj ve vlastnictví příslušného programu,
2. uvolnění zdroje kdy vlastník zdroje oznámí systému, že již zdroj nebude využívat, a tento může být
vrácen „do oběhu“ (může být předán jinému programu, procesu, vláknu, …).`,incorrect:`Rezervace sestává ze dvou operací:
1. samotná rezervace, která od systému vyžádá nějaký zdroj (resp. nějaký počet jednotek zdroje), pro
výlučné použití daným programem (procesem, vláknem, atp.), – po úspěšném provedení rezervace je
zdroj ve vlastnictví příslušného programu,
2.odebrání zdroje, kdy systém odebere zdroj vlastníkovy, aby tento mohl být
vrácen „do oběhu“ (může být předán jinému programu, procesu, vláknu, …).`},{uuid:"81803512-3542-4840-9955-1fa27e203d9b",correct:`Komunikace
Protože komunikace je zároveň synchronizací, jedná se (možná ne zcela intuitivně)
také o abstraktní zdroj. Novým aspektem je zde skutečnost, že rezervaci a uvolnění neprovádí nutně
tentýž aktér – předání zprávy (resp. obecně informace) může zároveň předat vlastnictví tohoto typu
„zdroje“.
Tento jev je vázán k problému producentů a konzumentů (který, jak jsme zmiňovali výše, s komunikací úzce
souvisí): vytvoření a (zejména) uložení mezivýsledku je formou rezervace – počet mezivýsledků, které
jsme si ochotni pamatovat, je omezené, a jedná se tedy o konečný zdroj, který musí být producentovi
přidělen. Takto zablokovaná instance se ale uvolní tím, že konzument mezivýsledek použije.`,incorrect:`Komunikace
Protože komunikace je zároveň synchronizací, jedná se (možná ne zcela intuitivně)
také o abstraktní zdroj. Novým aspektem je zde skutečnost, že rezervaci a uvolnění musí provést stejný aktér – předání zprávy (resp. obecně informace) může zároveň předat vlastnictví tohoto typu
„zdroje“.
Tento jev je vázán k problému producentů a konzumentů (který, jak jsme zmiňovali výše, s komunikací úzce
souvisí): vytvoření a (zejména) uložení mezivýsledku je formou rezervace – počet mezivýsledků, které
jsme si ochotni pamatovat, je omezené, a jedná se tedy o konečný zdroj, který musí být producentovi
přidělen. Takto zablokovaná instance se ale uvolní tím, že konzument mezivýsledek použije.`},{uuid:"94f622ac-23d7-4dff-b7b5-bd702983fdad",correct:`Odnímatelné zdroje
Implicitně považujeme zdroje za neodnímatelné, ve smyslu, že jediný způsob,
jak může dojít k uvolnění zdroje, je dobrovolné vrácení vlastníkem. U řady zdrojů by mělo odebrání
pravděpodobně fatální následky minimálně pro dotčený program, a někdy také pro dotčený zdroj (3D
tiskárna, optická zapisovací mechanika, fotografická tiskárna, atp.). Uvážíme-li abstraktní zdroje,
násilné odebrání např. zmiňovaného mutex-u jistě nemůže mít pozitivní dopad na další fungování vlákna,
resp. programu jako celku.
Jiná je situace u zdrojů virtualizovaných, kde odebrání fyzického prostředku obvykle nepředstavuje
zásadní problém – plánovač vláken zcela běžně odebírá procesor běžícímu vláknu bez jeho souhlasu,
správce virtuální paměti může stránku přestěhovat z operační paměti do externí, atp. Na dotčený proces
(vlákno) to má jistě dopad, ale důsledky obvykle nejsou zdaleka tak závažné, jako v případě zdrojů
neodnímatelných.`,incorrect:`Odnímatelné zdroje
Implicitně považujeme zdroje za neodnímatelné, ve smyslu, že jediný způsob,
jak může dojít k uvolnění zdroje, je dobrovolné vrácení vlastníkem. U řady zdrojů by mělo odebrání
pravděpodobně fatální následky minimálně pro dotčený program, a někdy také pro dotčený zdroj (3D
tiskárna, optická zapisovací mechanika, fotografická tiskárna, atp.). Uvážíme-li abstraktní zdroje,
násilné odebrání např. zmiňovaného mutex-u jistě nemůže mít pozitivní dopad na další fungování vlákna,
resp. programu jako celku.
Situace u zdrojů virtualizovaných, je obdobná.`},{uuid:"4aee6a80-1900-437f-90f1-c34c4d7bda64",correct:`Podmínky uváznutí - Uváznutí může nastat, jsou-li splněny všechny 4 následující podmínky – přitom
požadovat umožnění každé z nich je samo o sobě přirozené a smysluplné
1. Vzájemné vyloučení
2. čekající vlastník
3. neodnímatelnost
4. kruhové čekání
Tyto podmínky nejsou postačující na to aby systém mohl uváznout.`,incorrect:`Podmínky uváznutí - Uváznutí může nastat, jsou-li splněny všechny 4 následující podmínky – přitom
požadovat umožnění každé z nich je samo o sobě přirozené a smysluplné
1. Vzájemné vyloučení
2. čekající vlastník
3. neodnímatelnost
4. kruhové čekání
Tyto podmínky jsou postačující na to aby systém mohl uváznout.`},{uuid:"3831d174-cc28-415f-b09f-25dc31e8dec4",correct:`Podmínky uváznutí - Uváznutí může nastat, jsou-li splněny všechny 4 následující podmínky – přitom
požadovat umožnění každé z nich je samo o sobě přirozené a smysluplné
1. Vzájemné vyloučení
2. čekající vlastník
3. neodnímatelnost
4. kruhové čekání
Tyto podmínky nejsou postačující na to aby systém mohl uváznout.`,incorrect:`Podmínky uváznutí - Uváznutí může nastat, je li splněna alespoň jedna z následující podmínek
1. Vzájemné vyloučení
2. čekající vlastník
3. neodnímatelnost
4. kruhové čekání
Jakákoliv z těchto podmínek je postačující aby systém mohl uváznout.`},{uuid:"b307278d-e4b7-4420-b750-500dcc4f5c47",correct:`Detekce uváznutí
Jednou možností jak uváznutí detekovat je použít dynamickou variantu grafu
závislostí zdrojů, který jsme použili k definici kruhového čekání. V tomto případě obsahuje graf dva
různé typy uzlů: vlákna, nebo jiné potenciální vlastníky a zdroje`,incorrect:`Detekce uváznutí
Jednou možností jak uváznutí detekovat je použít statickou variantu grafu
závislostí zdrojů, který jsme použili k definici globálního uspořádání. V tomto případě obsahuje graf dva
různé typy uzlů: vlákna, nebo jiné potenciální vlastníky a zdroje`},{uuid:"21ba46f6-79bf-4117-8b16-484e201efa76",correct:`Zotavení z uváznutí 
Účastní-li se cyklického čekání alespoň jeden odnímatelný zdroj, může
k uváznutí sice dojít, ale na rozdíl od standardní situace se lze z tohoto typu uváznutí relativně lehce 
zotavit (zejména se lze zotavit bez násilného ukončování vláken). Dočasným odebráním odnímatelného
zdroje se totiž cyklus čekajících vláken přeruší, a systém může pokračovat.`,incorrect:`Zotavení z uváznutí 
Účastní-li se cyklického čekání alespoň jeden odnímatelný zdroj, může
k uváznutí sice dojít, ale na rozdíl od standardní situace se lze z tohoto typu uváznutí relativně lehce 
zotavit a to násilným ukončením vlákna.`},{uuid:"da371ef6-831e-41da-b01d-6c728c94c69b",correct:`Vyhýbání uváznutí
Jinou možností jak se s uváznutím vypořádat je technika vyhýbání (angl.
avoidance). Klíčovým prvkem je zamítnout některé požadavky na rezervaci, i když je příslušný zdroj
dostupný, může-li taková rezervace vést k pozdějšímu uváznutí. Stavy, ze kterých může vždy alespoň
jedno vlákno vyváznout a úspěšně skončit (resp. uvolnit zdroje) označíme jako bezpečné.
Asi nejznámějším algoritmem pro vyhýbání uváznutí je tzv. bankéřův algoritmus, navržený E. Dijkstrou.`,incorrect:`Vyhýbání uváznutí
Jinou možností jak se s uváznutím vypořádat je technika vyhýbání (angl.
avoidance). Klíčovým prvkem je zamítnout některé požadavky na rezervaci, i když je příslušný zdroj
dostupný, může-li taková rezervace vést k pozdějšímu uváznutí. Stavy, ze kterých může vždy alespoň
jedno vlákno vyváznout a úspěšně skončit (resp. uvolnit zdroje) označíme jako bezpečné.
Asi nejznámějším algoritmem pro vyhýbání uváznutí je tzv. makleřův algoritmus, navržený E. Dijkstrou.`},{uuid:"3fdb637d-6062-46f7-a824-f88a8d1c7e54",correct:`Zamezení předrezervací Myšlenka předrezervace je jednoduchá – nesmíme připustit, aby vlákno,
které nějaký zdroj již vlastní, čekalo na nějaký zdroj (je lehce vidět, že systém pak nemůže uváznout).
Rezervace proto připustíme pouze v situaci, kdy žádající vlákno žádné zdroje nevlastní – aby byl systém
prakticky použitelný, musíme ovšem povolit rezervaci několika zdrojů najednou (dávkově).
Potřebuje-li tedy vlákno využít více zdrojů, musí je vyžádat všechny jedinou atomickou akcí (uvolňovat
je ovšem může postupně). Je-li potřeba rezervovat nějaký zdroj v situaci, kdy už dané vlákno nějaký
jiný zdroj vlastní, musí nejprve všechny zdroje uvolnit a opět je rezervovat společně s tím novým.`,incorrect:`Zamezení předrezervací Myšlenka předrezervace je jednoduchá – nesmíme připustit, aby vlákno,
které nějaký zdroj již vlastní, čekalo na nějaký zdroj (je lehce vidět, že systém pak nemůže uváznout).
Rezervace proto připustíme pouze v situaci, kdy žádající vlákno vlastní nějaké zdroje – aby byl systém
prakticky použitelný, musíme ovšem povolit rezervaci několika zdrojů najednou (dávkově).
Potřebuje-li tedy vlákno využít více zdrojů, musí je vyžádat všechny jedinou atomickou akcí (uvolňovat
je ovšem může postupně). Je-li potřeba rezervovat nějaký zdroj v situaci, kdy už dané vlákno nějaký
jiný zdroj vlastní, musí nejprve všechny zdroje uvolnit a opět je rezervovat společně s tím novým.`},{uuid:"9af94173-0918-4578-97da-b6b1999b2df7",correct:`Zamezení virtualizací 
Virtualizací jsme se podrobně zabývali v prvních 4 kapitolách – zdroje,
které jsou virtualizované, vůbec nepoužívají systém výlučné rezervace, nesplňují tedy podmínku vzá-
jemného vyloučení a nemohou přímo způsobit uváznutí. Mezi zdroje, které lze virtualizovat, patří
samozřejmě paměť, procesor a pevné úložiště (kapitoly 1–3) a některé periferie – terminál (obrazovka,
tiskárna, atp.) nebo síťová rozhraní (kapitola 4).`,incorrect:`Zamezení virtualizací 
Virtualizací jsme se podrobně zabývali v prvních 4 kapitolách – zdroje,
které jsou virtualizované, používají systém výlučné rezervace, splňují tedy podmínku vzá-
jemného vyloučení a nemohou přímo způsobit uváznutí. Mezi zdroje, které lze virtualizovat, patří
samozřejmě paměť, procesor a pevné úložiště (kapitoly 1–3) a některé periferie – terminál (obrazovka,
tiskárna, atp.) nebo síťová rozhraní (kapitola 4).`},{uuid:"a658e9ee-7da7-4159-a081-9ce8b0b896fc",correct:`Zamezení uspořádáním
Zbývá nám podmínka kruhového čekání – tomu lze zamezit například tím,
že se na zdrojích ustaví globální lineární uspořádání, které musí každé vlákno při rezervacích dodržet:
rezervovat lze pouze zdroj, který je v uspořádání větší než dosud největší zdroj vláknu přisouzený.
V takovém systému je statický graf závislostí zdrojů acyklický, k uváznutí tak nemůže dojít.
Podobně jako v případě předrezervace lze řešit i situace, kdy potřebujeme globální pořadí porušit –
vlákno se musí nejprve vzdát některých zdrojů a pak je znovu rezervovat ve správném pořadí.
Tento přístup je poměrně praktický na úrovni jednotlivého programu, nebo jiného uzavřeného systému,
nicméně pro operační systém jako celek se nehodí`,incorrect:`Zamezení uspořádáním
Zbývá nám podmínka kruhového čekání – tomu lze zamezit například tím,
že se na zdrojích ustaví globální lineární uspořádání, které musí každé vlákno při rezervacích dodržet:
rezervovat lze pouze zdroj, který je v uspořádání menší než dosud největší zdroj vláknu přisouzený.
V takovém systému je statický graf závislostí zdrojů acyklický, k uváznutí tak nemůže dojít.
Podobně jako v případě předrezervace lze řešit i situace, kdy potřebujeme globální pořadí porušit –
vlákno se musí nejprve vzdát některých zdrojů a pak je znovu rezervovat ve správném pořadí.
Tento přístup je poměrně praktický na úrovni jednotlivého programu, nebo jiného uzavřeného systému,
nicméně pro operační systém jako celek se nehodí`}]},{uuid:"be6acf2f-f519-492f-960d-17723f0fa0c6",sectionNumber:"8",sectionTitle:"Přerušení a periferie",statements:[{uuid:"90f6b117-8002-48c4-8fe8-2737e9763bb6",correct:`Přerušení je mechanismus, který umožňuje synchronizovat periferii a software –
v abstraktní rovině lze tedy o přerušení uvažovat jako o synchronizačním zařízení.
– přerušení je asymetrické v tom smyslu, že ho může vyvolat pouze periferie, nikoliv operační systém
nebo software obecně. Máme tedy zařízení, které je vždy aktivováno periferií – operační systém je
vždy pasivním účastníkem. Až na tyto rozdíly se přerušení podobá na podmínkovou proměnnou – slouží
k signalizaci nějaké události.`,incorrect:`Přerušení je mechanismus, který umožňuje synchronizovat periferii a software –
v abstraktní rovině lze tedy o přerušení uvažovat jako o synchronizačním zařízení.
– přerušení je symetrické v tom smyslu, že ho může vyvolat jak periferie tak i operační systém.
 Máme tedy zařízení, které je vždy aktivováno periferií nebo operačním systémem a ten druhý je
vždy pasivním účastníkem. Až na tyto rozdíly se přerušení podobá na podmínkovou proměnnou – slouží
k signalizaci nějaké události.`},{uuid:"7d9c4edb-206b-4c37-b5f1-06e4229974d2",correct:`Operační systém je samozřejmě program, který musí být vykonáván procesorem – proto
krom periferie a operačního systému musí do hry vstoupit i procesor.
Zejména se může stát, že ve chvíli, kdy přerušení nastane (je periferií vyvoláno), procesor nějaký
program právě vykonává. Navíc je často důležité, aby byla reakce na přerušení dostatečně rychlá – velká
prodleva obsluhy může mít řadu důsledků, od uživatelského nepohodlí až ke ztrátě dat.
Aby se prodleva minimalizovala, přerušení je realizováno preemptivně – cokoliv procesor v danou chvíli
prováděl je pozastaveno, aktuální stav vlákna (hodnoty registrů) je uložen do paměti a je spuštěna
obsluha přerušení.`,incorrect:`Operační systém je samozřejmě program, který musí být vykonáván procesorem – proto
krom periferie a operačního systému musí do hry vstoupit i procesor.
Zejména se může stát, že ve chvíli, kdy přerušení nastane (je periferií vyvoláno), procesor nějaký
program právě vykonává. Navíc je často důležité, aby operační systém daný program nepřerušil násilím,
proto je přerušení realizováno postemptivně – cokoliv procesor v danou chvíli prováděl je dokončeno a
až poté se spustí obsluha přerušení.`},{uuid:"0b567d26-8f97-4c3a-b252-a8ea74eca494",correct:`Instance přerušení
Obsluha přerušení je realizována podprogramem, kterého adresa je uvedena ve speciální
tabulce obsluhy přerušení. Chápeme-li přerušení jako synchronizační zařízení (podobné podmínkové
proměnné), je přirozené, že může existovat ve vícero instancích. Protože je ale realizováno hardwarově
na relativně nízké úrovni, těchto instancí je pevný počet (často do 256). Tabulka obsluhy přerušení
má pak pro každou instanci jednu položku, která určí který podprogram je daným přerušením aktivován.
Různé periferie pak typicky používají různé instance přerušení (instance jsou identifikovány číslem).`,incorrect:`Instance přerušení
Obsluha přerušení je realizována podprogramem, kterého adresa je uvedena ve speciální
registru. Chápeme-li přerušení jako synchronizační zařízení (podobné podmínkové
proměnné), je přirozené, že může existovat ve vícero instancích. Protože je ale realizováno hardwarově
na relativně nízké úrovni, těchto instancí je pevný počet (často do 256).
Podprogram má pak pro každou instanci speciální funkci, tzv. řadič přerušení,
který určí který podprogram je daným přerušením aktivován.
Různé periferie pak typicky používají různé instance přerušení (instance jsou identifikovány číslem).`},{uuid:"38ab12d8-a05c-4d0b-9611-6e555b36a7f2",correct:`Obslužný podprogram přerušení je (až na speciální prolog a epilog) stejný jako
libovolný jiný – může být třeba zapsaný v jazyce C, a zejména může volat další podprogramy. Proto musí
mít k dispozici jak registry (zabezpečeno uložením stavu procesoru před jeho aktivací), tak zásobník.
Protože na zásobníku, který byl ve chvíli kdy k přerušení došlo, nemusí být volné místo, je obvyklé, že
dojde také k přepnutí zásobníku. Konečně procesor se přepne do režimu jádra (privilegovaného režimu)
– obsluha přerušení má tedy stejný privilegovaný přístup k výpočetním zdrojům jako jakákoliv jiná
součást jádra.`,incorrect:`Obslužný podprogram přerušení je (až na speciální prolog a epilog) stejný jako
libovolný jiný až na jednu vyjímku – může být třeba zapsaný v jazyce C, ale nemůže volat další podprogramy, protože jádro je jen jedno.
Proto musí mít k dispozici jak registry (zabezpečeno uložením stavu procesoru před jeho aktivací), tak zásobník.
Protože na zásobníku, který byl ve chvíli kdy k přerušení došlo, nemusí být volné místo, je obvyklé, že
dojde také k přepnutí zásobníku. Konečně procesor se přepne do režimu jádra (privilegovaného režimu)
– obsluha přerušení má tedy stejný privilegovaný přístup k výpočetním zdrojům jako jakákoliv jiná
součást jádra.`},{uuid:"d6d5f1d5-2620-4c14-9ea2-0684888804f0",correct:`Obsluha přerušení
se nápadně podobá na aktivaci vlákna. Zároveň má ale vlastnosti aktivace podprogramu,
protože na rozdíl od vlákna se při ukončení obsluhy stav procesoru neukládá, a v obsluze tedy po jejím
ukončení nelze pokračovat. Můžeme tak obsluhu přerušení chápat jako vlákno s velmi krátkým životem.`,incorrect:`Obsluha přerušení
se nápadně podobá na aktivaci vlákna. Zároveň má ale vlastnosti aktivace podprogramu,
protože může být aktivována, uložena a případně obnovena v budoucnu. Můžeme tak obsluhu přerušení chápat jako speciální typ vlákna.`},{uuid:"a916f046-5652-436e-bcf1-260b3258ed55",correct:`Obsluha přerušení musí řešit 3 synchronizační scénáře:
1. synchronizace se zbytkem systému, který běží paralelně na jiných procesorových jádrech (včetně
případné obsluhy přerušení tam probíhající) – zde je v nějakém smyslu největší volnost, obvykle lze
použít spinlocky, případně některé nezamykající komunikační zařízení,
2. synchronizace se zbytkem systému, který běžel na stejném procesorovém jádře a byl obsluhou přerušen
– zde spinlock nepřichází v úvahu, protože přerušený podprogram nemůže být spuštěn před ukončením
obsluhy,
3. synchronizace s obsluhou souběžného přerušení vyvolané na stejném procesorovém jádře – spinlock
opět nepřichází v úvahu (ze stejného důvodu), pomůže zde ale speciální jednoúčelové synchronizační
zařízení – zákaz přerušení.
Je-li v platnosti zákaz daného přerušení, obsluha případného příchozího přerušení je odložena až do
chvíle, kdy je přerušení opět povoleno. Jedná se tak o formu vzájemného vyloučení specifickou pro
obslužné podprogramy.`,incorrect:`Obsluha přerušení musí řešit 3 synchronizační scénáře:
1. synchronizace s obsluhou souběžného přerušení vyvolané na stejném procesorovém jádře – zde je v nějakém smyslu největší volnost, obvykle lze
použít spinlocky, případně některé nezamykající komunikační zařízení,
2. synchronizace se zbytkem systému, který běžel na stejném procesorovém jádře a byl obsluhou přerušen
– zde spinlock nepřichází v úvahu, protože přerušený podprogram nemůže být spuštěn před ukončením
obsluhy,
3.  synchronizace se zbytkem systému, který běží paralelně na jiných procesorových jádrech (včetně
případné obsluhy přerušení tam probíhající) – spinlock
opět nepřichází v úvahu (ze stejného důvodu), pomůže zde ale speciální jednoúčelové synchronizační
zařízení – zákaz přerušení.
Je-li v platnosti zákaz daného přerušení, obsluha případného příchozího přerušení je odložena až do
chvíle, kdy je přerušení opět povoleno. Jedná se tak o formu vzájemného vyloučení specifickou pro
obslužné podprogramy.`},{uuid:"bcb652d7-e47a-4b53-b61f-3cfa02a478d7",correct:`Vzpomeňme, že aktivace procesu je relativně drahá operace: musí se změnit mapování paměti.
Proto se při aktivaci obsluhy přerušení proces nepřepíná: běží v adresním prostoru, který byl zrovna
aktivní. To mimo jiné znamená, že struktury, které obsluha využívá, musí být dostupné ve všech virtuálních
adresních prostorech, a navíc musí být dostupné na stejných adresách. Obsluha přerušení tak vytvoří
pomyslné vlákno v procesu, který je právě aktivní.`,incorrect:`Vzpomeňme, že aktivace procesu je relativně drahá operace: musí se změnit mapování paměti.
Proto se při aktivaci obsluhy přerušení proces nepřepíná: běží v adresním prostoru, který byl zrovna
aktivní. To mimo jiné znamená, že struktury, které obsluha využívá, musí být nějakým způsobem dostupné pro všechny procesory.
Obsluha přerušení tak využívá speciální procesor přímo určený na tuto činnost.`},{uuid:"7b87f202-7015-479a-b5c5-1c1e69aa4cb5",correct:`Struktura obsluhy
1. při vstupu do obsluhy přerušení se zakážou další přerušení (může vykonat přímo procesor jako součást
aktivace obsluhy) –
∘ minimálně toho typu, které bylo právě aktivováno, mají-li přerušení priority tak také všechna
přerušení nižších priorit, a v některých systémech úplně všechna přerušení,
∘ tím jsou ochráněny libovolné kritické sekce obsluhy přerušení vůči sobě samé, a také je tím
omezen počet aktivačních záznamů na zásobníku (jinak by hrozilo, že příliš mnoho rychle příchozích
přerušení zásobník vyčerpá),
2. obsluha vykoná minimální nutnou akci, která uvede systém do provozuschopného stavu:
∘ např. vyprázdní mezipaměti, které by jinak přetekly, a provede další akce, které nelze odložit,
∘ minimálně část plánovače je tohoto charakteru (je aktivován obsluhou přerušení časovače – více
později),
∘ libovolné datové struktury, které zde využívá, a které využívá i jiná část jádra, musí být buď
použitelné zcela bez zamykání (např. některé komunikační zařízení probrané v předchozí kapitole,
které nepoužívá zámky), nebo musí být na straně zbytku jádra chráněny zákazem přerušení,
3. naplánuje zbývající akce (obsluha druhé úrovně) na pozdější vykonání – tento krok vyžaduje komunikaci
se zbytkem jádra (někde musí informaci o potřebné návazné akci převzít jiná část jádra, která je
s obsluhou přerušení jinak souběžná).`,incorrect:`Struktura obsluhy
1. při vstupu do obsluhy přerušení se zakážou další přerušení (může vykonat přímo procesor jako součást
aktivace obsluhy) –
∘ minimálně toho typu, které bylo právě aktivováno, mají-li přerušení priority tak také všechna
přerušení nižších priorit, a v některých systémech úplně všechna přerušení,
∘ tím jsou ochráněny libovolné kritické sekce obsluhy přerušení vůči sobě samé, a také je tím
omezen počet aktivačních záznamů na zásobníku (jinak by hrozilo, že příliš mnoho rychle příchozích
přerušení zásobník vyčerpá),
2. obsluha vykoná minimální nutnou akci, která uvede systém do provozuschopného stavu:
∘ např. vyprázdní mezipaměti, které by jinak přetekly, a provede další akce, které nelze odložit,
∘ minimálně část plánovače je tohoto charakteru (je aktivován obsluhou přerušení časovače – více
později),
∘ libovolné datové struktury, které zde využívá, a které využívá i jiná část jádra, musí být 
zamykatelné (spinlockem nebo jiným synchronizačním zařízením) nebo musí být v části jádra, která není chráněny zákazem přerušení,
3. naplánuje zbývající akce (obsluha druhé úrovně) na pozdější vykonání – tento krok vyžaduje komunikaci
se zbytkem jádra (někde musí informaci o potřebné návazné akci převzít jiná část jádra, která je
s obsluhou přerušení jinak souběžná).`},{uuid:"9e1809e9-5fdf-4047-9f48-88363b7795f2",correct:`Notifikace
Nejzákladnější formou přerušení je notifikace – upozornění na nějakou obecnou událost.
Tento typ přerušení je obvykle relativně nezávazný v tom smyslu, že zdržení nebo i úplný výpadek obsluhy
systém ani zpracovávaná data nijak neohrozí. `,incorrect:`Notifikace
Nejzákladnější formou přerušení je notifikace – upozornění na nějakou obecnou událost.
Tento typ přerušení je extrémně spolehlivý a nedovoluje chyby, protože zdržení nebo i úplný výpadek obsluhy může
systém nebo data ohrozit. `},{uuid:"86349c09-5160-45a1-ab09-76b4586bc5cb",correct:`DMA
Zařízení s větší šířkou pásma obvykle pro přenos dat používají DMA, tzn. režim, kdy periferie
přesouvá data do operační paměti souběžně s běžným provozem zbytku systému. Tyto přenosy je ale
nutné synchronizovat s operačním systémem (resp. s ovladačem zařízení, který je součástí operačního
systému).
Směrem k periferii je synchronizace realizována zápisem do registru, opačným směrem ale podobný
mechanismus použít nelze – periferie místo toho signalizuje dokončení přenosu přerušením.
`,incorrect:`DMA
Zařízení s větší šířkou pásma obvykle pro přenos dat používají DMA, tzn. režim, kdy periferie
přesouvá data do operační paměti souběžně s běžným provozem zbytku systému. Tyto přenosy je ale
nutné synchronizovat s operačním systémem (resp. s ovladačem zařízení, který je součástí operačního
systému).
Směrem k periferii je synchronizace realizována přerušením, opačným směrem ale podobný
mechanismus použít nelze – periferie místo toho zapisuje přímo do registrů procesoru.
`},{uuid:"af9e81df-3822-4a55-990a-1752b064c05e",correct:`Časovač - mainupalce s frontami vláken
Tyto operace musí být:
1. chráněny proti zásahům jiných procesorových jader (obvykle spinlockem, alternativně by mohl být
celý plánovač postaven na komunikačních zařízeních bez zámků; uspání zde nepřichází v úvahu),
2. chráněny proti přerušení (zákazem) a tedy musí být zároveň
3. efektivní (konstantní nebo nejvýše logaritmické v počtu vláken),
4. synchronizace v bodech 1 a 2 musí být velmi důsledně koordinovaná: plánovač nesmí zamknout spinlock,
aniž by byla zároveň zakázána přerušení (jinak by mohlo dojít k uváznutí), ale zároveň nesmí na
spinlock příliš dlouho čekat (protože musí být při čekání zakázaná přerušení, tzn. jedná se o časově
kritickou operaci).
`,incorrect:`Časovač - mainupalce s frontami vláken
Tyto operace musí být:
1. chráněny proti zásahům jiných procesorových jader (obvykle spinlockem, alternativně by mohl být
celý plánovač postaven na komunikačních zařízeních bez zámků; uspání zde nepřichází v úvahu),
2. chráněny proti přerušení (zákazem) a tedy musí být zároveň
3. efektivní (konstantní nebo nejvýše logaritmické v počtu vláken),
4. synchronizace v bodech 1 a 2 musí být velmi důsledně koordinovaná: plánovač musí zamknout spinlock,
a zároveň musí být platný zakáz přerušení (jinak by mohlo dojít k uváznutí), ale zároveň nesmí na
spinlock příliš dlouho čekat (protože musí být při čekání zakázaná přerušení, tzn. jedná se o časově
kritickou operaci).
`}]}];function Fz(){return g.jsxs(g.Fragment,{children:[g.jsxs("p",{className:"font-light mb-4 text-sm ",children:["Tato aplikace slouží na procvičení znalostí z předmětu PB152.",g.jsx("br",{})," Akékoliv chyby, připomínky, nápady na vylepšení, nebo návrhy na nové otázky můžete nahlásit na"," ",g.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"underline hover:text-blue-500",target:"_blank",children:["Discord",g.jsx(zt,{className:"w-3 h-3 inline self-center"})]})]}),g.jsxs("div",{className:"grid grid-cols-1 md:grid-cols-[1fr_auto_1fr] gap-4",children:[g.jsxs("div",{className:"flex flex-col gap-1",children:[g.jsx("h2",{className:"text-xl",children:"Zápočet"}),g.jsx(pt,{to:"/credit",children:g.jsx(Vo,{className:"w-full",children:"Všechny části"})}),At.map((e,o)=>g.jsx(pt,{to:`/credit/${e.uuid}`,children:g.jsxs(Vo,{variant:"outline",className:"w-full",children:["Část ",e.sectionNumber,": ",e.sectionTitle]},o)},o))]}),g.jsx("div",{className:"h-[0.1rem] md:h-full w-full md:w-[0.1rem] bg-border rounded-full"}),g.jsxs("div",{className:"flex flex-col gap-1",children:[g.jsx("h2",{className:"text-xl",children:"Zkouška"}),g.jsx(pt,{to:"/exam",children:g.jsx(Vo,{className:"w-full",children:"Všechny části"})}),It.map((e,o)=>g.jsx(pt,{to:`/exam/${e.uuid}`,children:g.jsxs(Vo,{variant:"outline",className:"w-full",children:["Část ",e.sectionNumber,": ",e.sectionTitle]},o)},o))]})]})]})}function Bz({uuid:e}){const o=At.find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Section not found")]}function Kz(){return[At,null]}function $z({uuid:e}){const o=At.map(n=>n.statements).flat().find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Statement not found")]}function Hz(){return[At.map(o=>o.statements).flat(),null]}function Wz({count:e=5,sections:o}){const n=At.filter(a=>o?o.includes(a.uuid):!0),t=n[Math.floor(Math.random()*n.length)];return t.statements.length<e?[null,new Error("Not enough statements")]:[t.statements.sort(()=>Math.random()-.5).slice(0,e),null]}const ms={getSingleSection:Bz,getAllSections:Kz,getSingleStatement:$z,getAllStatements:Hz,getRandomStatements:Wz};function hn(){return hn=Object.assign?Object.assign.bind():function(e){for(var o=1;o<arguments.length;o++){var n=arguments[o];for(var t in n)({}).hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},hn.apply(null,arguments)}function Zz(e,o){typeof e=="function"?e(o):e!=null&&(e.current=o)}function xm(...e){return o=>e.forEach(n=>Zz(n,o))}function wm(...e){return l.useCallback(xm(...e),e)}function Xz(e,o=[]){let n=[];function t(a,i){const c=l.createContext(i),s=n.length;n=[...n,i];function u(p){const{scope:v,children:y,...z}=p,b=(v==null?void 0:v[e][s])||c,N=l.useMemo(()=>z,Object.values(z));return l.createElement(b.Provider,{value:N},y)}function d(p,v){const y=(v==null?void 0:v[e][s])||c,z=l.useContext(y);if(z)return z;if(i!==void 0)return i;throw new Error(`\`${p}\` must be used within \`${a}\``)}return u.displayName=a+"Provider",[u,d]}const r=()=>{const a=n.map(i=>l.createContext(i));return function(c){const s=(c==null?void 0:c[e])||a;return l.useMemo(()=>({[`__scope${e}`]:{...c,[e]:s}}),[c,s])}};return r.scopeName=e,[t,Gz(r,...o)]}function Gz(...e){const o=e[0];if(e.length===1)return o;const n=()=>{const t=e.map(r=>({useScope:r(),scopeName:r.scopeName}));return function(a){const i=t.reduce((c,{useScope:s,scopeName:u})=>{const p=s(a)[`__scope${u}`];return{...c,...p}},{});return l.useMemo(()=>({[`__scope${o.scopeName}`]:i}),[i])}};return n.scopeName=o.scopeName,n}function yd(e,o,{checkForDefaultPrevented:n=!0}={}){return function(r){if(e==null||e(r),n===!1||!r.defaultPrevented)return o==null?void 0:o(r)}}function Cm(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)===null||t===void 0?void 0:t.call(o,...n)},[])}function Jz({prop:e,defaultProp:o,onChange:n=()=>{}}){const[t,r]=Qz({defaultProp:o,onChange:n}),a=e!==void 0,i=a?e:t,c=Cm(n),s=l.useCallback(u=>{if(a){const p=typeof u=="function"?u(e):u;p!==e&&c(p)}else r(u)},[a,e,r,c]);return[i,s]}function Qz({defaultProp:e,onChange:o}){const n=l.useState(e),[t]=n,r=l.useRef(t),a=Cm(o);return l.useEffect(()=>{r.current!==t&&(a(t),r.current=t)},[t,r,a]),n}function Yz(e){const o=l.useRef({value:e,previous:e});return l.useMemo(()=>(o.current.value!==e&&(o.current.previous=o.current.value,o.current.value=e),o.current.previous),[e])}const ks=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{};function qz(e){const[o,n]=l.useState(void 0);return ks(()=>{if(e){n({width:e.offsetWidth,height:e.offsetHeight});const t=new ResizeObserver(r=>{if(!Array.isArray(r)||!r.length)return;const a=r[0];let i,c;if("borderBoxSize"in a){const s=a.borderBoxSize,u=Array.isArray(s)?s[0]:s;i=u.inlineSize,c=u.blockSize}else i=e.offsetWidth,c=e.offsetHeight;n({width:i,height:c})});return t.observe(e,{box:"border-box"}),()=>t.unobserve(e)}else n(void 0)},[e]),o}function ej(e,o){return l.useReducer((n,t)=>{const r=o[n][t];return r??n},e)}const Em=e=>{const{present:o,children:n}=e,t=oj(o),r=typeof n=="function"?n({present:t.isPresent}):l.Children.only(n),a=wm(t.ref,r.ref);return typeof n=="function"||t.isPresent?l.cloneElement(r,{ref:a}):null};Em.displayName="Presence";function oj(e){const[o,n]=l.useState(),t=l.useRef({}),r=l.useRef(e),a=l.useRef("none"),i=e?"mounted":"unmounted",[c,s]=ej(i,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return l.useEffect(()=>{const u=da(t.current);a.current=c==="mounted"?u:"none"},[c]),ks(()=>{const u=t.current,d=r.current;if(d!==e){const v=a.current,y=da(u);e?s("MOUNT"):y==="none"||(u==null?void 0:u.display)==="none"?s("UNMOUNT"):s(d&&v!==y?"ANIMATION_OUT":"UNMOUNT"),r.current=e}},[e,s]),ks(()=>{if(o){const u=p=>{const y=da(t.current).includes(p.animationName);p.target===o&&y&&_r.flushSync(()=>s("ANIMATION_END"))},d=p=>{p.target===o&&(a.current=da(t.current))};return o.addEventListener("animationstart",d),o.addEventListener("animationcancel",u),o.addEventListener("animationend",u),()=>{o.removeEventListener("animationstart",d),o.removeEventListener("animationcancel",u),o.removeEventListener("animationend",u)}}else s("ANIMATION_END")},[o,s]),{isPresent:["mounted","unmountSuspended"].includes(c),ref:l.useCallback(u=>{u&&(t.current=getComputedStyle(u)),n(u)},[])}}function da(e){return(e==null?void 0:e.animationName)||"none"}const Mm=l.forwardRef((e,o)=>{const{children:n,...t}=e,r=l.Children.toArray(n),a=r.find(tj);if(a){const i=a.props.children,c=r.map(s=>s===a?l.Children.count(i)>1?l.Children.only(null):l.isValidElement(i)?i.props.children:null:s);return l.createElement(bs,hn({},t,{ref:o}),l.isValidElement(i)?l.cloneElement(i,void 0,c):null)}return l.createElement(bs,hn({},t,{ref:o}),n)});Mm.displayName="Slot";const bs=l.forwardRef((e,o)=>{const{children:n,...t}=e;return l.isValidElement(n)?l.cloneElement(n,{...rj(t,n.props),ref:o?xm(o,n.ref):n.ref}):l.Children.count(n)>1?l.Children.only(null):null});bs.displayName="SlotClone";const nj=({children:e})=>l.createElement(l.Fragment,null,e);function tj(e){return l.isValidElement(e)&&e.type===nj}function rj(e,o){const n={...o};for(const t in o){const r=e[t],a=o[t];/^on[A-Z]/.test(t)?r&&a?n[t]=(...c)=>{a(...c),r(...c)}:r&&(n[t]=r):t==="style"?n[t]={...r,...a}:t==="className"&&(n[t]=[r,a].filter(Boolean).join(" "))}return{...e,...n}}const aj=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Om=aj.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,c=a?Mm:o;return l.useEffect(()=>{window[Symbol.for("radix-ui")]=!0},[]),l.createElement(c,hn({},i,{ref:r}))});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{}),Rm="Checkbox",[ij,k4]=Xz(Rm),[cj,sj]=ij(Rm),uj=l.forwardRef((e,o)=>{const{__scopeCheckbox:n,name:t,checked:r,defaultChecked:a,required:i,disabled:c,value:s="on",onCheckedChange:u,...d}=e,[p,v]=l.useState(null),y=wm(o,f=>v(f)),z=l.useRef(!1),b=p?!!p.closest("form"):!0,[N=!1,k]=Jz({prop:r,defaultProp:a,onChange:u}),m=l.useRef(N);return l.useEffect(()=>{const f=p==null?void 0:p.form;if(f){const T=()=>k(m.current);return f.addEventListener("reset",T),()=>f.removeEventListener("reset",T)}},[p,k]),l.createElement(cj,{scope:n,state:N,disabled:c},l.createElement(Om.button,hn({type:"button",role:"checkbox","aria-checked":On(N)?"mixed":N,"aria-required":i,"data-state":Am(N),"data-disabled":c?"":void 0,disabled:c,value:s},d,{ref:y,onKeyDown:yd(e.onKeyDown,f=>{f.key==="Enter"&&f.preventDefault()}),onClick:yd(e.onClick,f=>{k(T=>On(T)?!0:!T),b&&(z.current=f.isPropagationStopped(),z.current||f.stopPropagation())})})),b&&l.createElement(pj,{control:p,bubbles:!z.current,name:t,value:s,checked:N,required:i,disabled:c,style:{transform:"translateX(-100%)"}}))}),lj="CheckboxIndicator",dj=l.forwardRef((e,o)=>{const{__scopeCheckbox:n,forceMount:t,...r}=e,a=sj(lj,n);return l.createElement(Em,{present:t||On(a.state)||a.state===!0},l.createElement(Om.span,hn({"data-state":Am(a.state),"data-disabled":a.disabled?"":void 0},r,{ref:o,style:{pointerEvents:"none",...e.style}})))}),pj=e=>{const{control:o,checked:n,bubbles:t=!0,...r}=e,a=l.useRef(null),i=Yz(n),c=qz(o);return l.useEffect(()=>{const s=a.current,u=window.HTMLInputElement.prototype,p=Object.getOwnPropertyDescriptor(u,"checked").set;if(i!==n&&p){const v=new Event("click",{bubbles:t});s.indeterminate=On(n),p.call(s,On(n)?!1:n),s.dispatchEvent(v)}},[i,n,t]),l.createElement("input",hn({type:"checkbox","aria-hidden":!0,defaultChecked:On(n)?!1:n},r,{tabIndex:-1,ref:a,style:{...e.style,...c,position:"absolute",pointerEvents:"none",opacity:0,margin:0}}))};function On(e){return e==="indeterminate"}function Am(e){return On(e)?"indeterminate":e?"checked":"unchecked"}const Im=uj,vj=dj,Vm=l.forwardRef(({className:e,...o},n)=>g.jsx(Im,{ref:n,className:Ko("peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",e),...o,children:g.jsx(vj,{className:Ko("flex items-center justify-center text-current"),children:g.jsx(sm,{className:"h-4 w-4"})})}));Vm.displayName=Im.displayName;function kr(e,o,{checkForDefaultPrevented:n=!0}={}){return function(r){if(e==null||e(r),n===!1||!r.defaultPrevented)return o==null?void 0:o(r)}}function zd(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function mj(...e){return o=>{let n=!1;const t=e.map(r=>{const a=zd(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():zd(e[r],null)}}}}function Ni(...e){return l.useCallback(mj(...e),e)}function kj(e,o){const n=l.createContext(o),t=a=>{const{children:i,...c}=a,s=l.useMemo(()=>c,Object.values(c));return g.jsx(n.Provider,{value:s,children:i})};t.displayName=e+"Provider";function r(a){const i=l.useContext(n);if(i)return i;if(o!==void 0)return o;throw new Error(`\`${a}\` must be used within \`${e}\``)}return[t,r]}function bj(e,o=[]){let n=[];function t(a,i){const c=l.createContext(i),s=n.length;n=[...n,i];const u=p=>{var k;const{scope:v,children:y,...z}=p,b=((k=v==null?void 0:v[e])==null?void 0:k[s])||c,N=l.useMemo(()=>z,Object.values(z));return g.jsx(b.Provider,{value:N,children:y})};u.displayName=a+"Provider";function d(p,v){var b;const y=((b=v==null?void 0:v[e])==null?void 0:b[s])||c,z=l.useContext(y);if(z)return z;if(i!==void 0)return i;throw new Error(`\`${p}\` must be used within \`${a}\``)}return[u,d]}const r=()=>{const a=n.map(i=>l.createContext(i));return function(c){const s=(c==null?void 0:c[e])||a;return l.useMemo(()=>({[`__scope${e}`]:{...c,[e]:s}}),[c,s])}};return r.scopeName=e,[t,fj(r,...o)]}function fj(...e){const o=e[0];if(e.length===1)return o;const n=()=>{const t=e.map(r=>({useScope:r(),scopeName:r.scopeName}));return function(a){const i=t.reduce((c,{useScope:s,scopeName:u})=>{const p=s(a)[`__scope${u}`];return{...c,...p}},{});return l.useMemo(()=>({[`__scope${o.scopeName}`]:i}),[i])}};return n.scopeName=o.scopeName,n}var hj=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{},yj=Jd.useId||(()=>{}),zj=0;function ic(e){const[o,n]=l.useState(yj());return hj(()=>{e||n(t=>t??String(zj++))},[e]),e||(o?`radix-${o}`:"")}function Dm(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}function jj({prop:e,defaultProp:o,onChange:n=()=>{}}){const[t,r]=gj({defaultProp:o,onChange:n}),a=e!==void 0,i=a?e:t,c=Dm(n),s=l.useCallback(u=>{if(a){const p=typeof u=="function"?u(e):u;p!==e&&c(p)}else r(u)},[a,e,r,c]);return[i,s]}function gj({defaultProp:e,onChange:o}){const n=l.useState(e),[t]=n,r=l.useRef(t),a=Dm(o);return l.useEffect(()=>{r.current!==t&&(a(t),r.current=t)},[t,r,a]),n}function cc(e,o,{checkForDefaultPrevented:n=!0}={}){return function(r){if(e==null||e(r),n===!1||!r.defaultPrevented)return o==null?void 0:o(r)}}var Nj=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Lm=Nj.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,c=a?Kn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),g.jsx(c,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{});function Tj(e,o){e&&_r.flushSync(()=>e.dispatchEvent(o))}function jd(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function Sj(...e){return o=>{let n=!1;const t=e.map(r=>{const a=jd(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():jd(e[r],null)}}}}function Um(...e){return l.useCallback(Sj(...e),e)}function _m(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}function Pj(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}function xj(e,o=globalThis==null?void 0:globalThis.document){const n=Pj(e);l.useEffect(()=>{const t=r=>{r.key==="Escape"&&n(r)};return o.addEventListener("keydown",t,{capture:!0}),()=>o.removeEventListener("keydown",t,{capture:!0})},[n,o])}var wj="DismissableLayer",fs="dismissableLayer.update",Cj="dismissableLayer.pointerDownOutside",Ej="dismissableLayer.focusOutside",gd,Fm=l.createContext({layers:new Set,layersWithOutsidePointerEventsDisabled:new Set,branches:new Set}),Bm=l.forwardRef((e,o)=>{const{disableOutsidePointerEvents:n=!1,onEscapeKeyDown:t,onPointerDownOutside:r,onFocusOutside:a,onInteractOutside:i,onDismiss:c,...s}=e,u=l.useContext(Fm),[d,p]=l.useState(null),v=(d==null?void 0:d.ownerDocument)??(globalThis==null?void 0:globalThis.document),[,y]=l.useState({}),z=Um(o,h=>p(h)),b=Array.from(u.layers),[N]=[...u.layersWithOutsidePointerEventsDisabled].slice(-1),k=b.indexOf(N),m=d?b.indexOf(d):-1,f=u.layersWithOutsidePointerEventsDisabled.size>0,T=m>=k,x=Rj(h=>{const C=h.target,V=[...u.branches].some(R=>R.contains(C));!T||V||(r==null||r(h),i==null||i(h),h.defaultPrevented||c==null||c())},v),O=Aj(h=>{const C=h.target;[...u.branches].some(R=>R.contains(C))||(a==null||a(h),i==null||i(h),h.defaultPrevented||c==null||c())},v);return xj(h=>{m===u.layers.size-1&&(t==null||t(h),!h.defaultPrevented&&c&&(h.preventDefault(),c()))},v),l.useEffect(()=>{if(d)return n&&(u.layersWithOutsidePointerEventsDisabled.size===0&&(gd=v.body.style.pointerEvents,v.body.style.pointerEvents="none"),u.layersWithOutsidePointerEventsDisabled.add(d)),u.layers.add(d),Nd(),()=>{n&&u.layersWithOutsidePointerEventsDisabled.size===1&&(v.body.style.pointerEvents=gd)}},[d,v,n,u]),l.useEffect(()=>()=>{d&&(u.layers.delete(d),u.layersWithOutsidePointerEventsDisabled.delete(d),Nd())},[d,u]),l.useEffect(()=>{const h=()=>y({});return document.addEventListener(fs,h),()=>document.removeEventListener(fs,h)},[]),g.jsx(Lm.div,{...s,ref:z,style:{pointerEvents:f?T?"auto":"none":void 0,...e.style},onFocusCapture:cc(e.onFocusCapture,O.onFocusCapture),onBlurCapture:cc(e.onBlurCapture,O.onBlurCapture),onPointerDownCapture:cc(e.onPointerDownCapture,x.onPointerDownCapture)})});Bm.displayName=wj;var Mj="DismissableLayerBranch",Oj=l.forwardRef((e,o)=>{const n=l.useContext(Fm),t=l.useRef(null),r=Um(o,t);return l.useEffect(()=>{const a=t.current;if(a)return n.branches.add(a),()=>{n.branches.delete(a)}},[n.branches]),g.jsx(Lm.div,{...e,ref:r})});Oj.displayName=Mj;function Rj(e,o=globalThis==null?void 0:globalThis.document){const n=_m(e),t=l.useRef(!1),r=l.useRef(()=>{});return l.useEffect(()=>{const a=c=>{if(c.target&&!t.current){let s=function(){Km(Cj,n,u,{discrete:!0})};const u={originalEvent:c};c.pointerType==="touch"?(o.removeEventListener("click",r.current),r.current=s,o.addEventListener("click",r.current,{once:!0})):s()}else o.removeEventListener("click",r.current);t.current=!1},i=window.setTimeout(()=>{o.addEventListener("pointerdown",a)},0);return()=>{window.clearTimeout(i),o.removeEventListener("pointerdown",a),o.removeEventListener("click",r.current)}},[o,n]),{onPointerDownCapture:()=>t.current=!0}}function Aj(e,o=globalThis==null?void 0:globalThis.document){const n=_m(e),t=l.useRef(!1);return l.useEffect(()=>{const r=a=>{a.target&&!t.current&&Km(Ej,n,{originalEvent:a},{discrete:!1})};return o.addEventListener("focusin",r),()=>o.removeEventListener("focusin",r)},[o,n]),{onFocusCapture:()=>t.current=!0,onBlurCapture:()=>t.current=!1}}function Nd(){const e=new CustomEvent(fs);document.dispatchEvent(e)}function Km(e,o,n,{discrete:t}){const r=n.originalEvent.target,a=new CustomEvent(e,{bubbles:!1,cancelable:!0,detail:n});o&&r.addEventListener(e,o,{once:!0}),t?Tj(r,a):r.dispatchEvent(a)}function Td(e,o){if(typeof e=="function")return e(o);e!=null&&(e.current=o)}function Ij(...e){return o=>{let n=!1;const t=e.map(r=>{const a=Td(r,o);return!n&&typeof a=="function"&&(n=!0),a});if(n)return()=>{for(let r=0;r<t.length;r++){const a=t[r];typeof a=="function"?a():Td(e[r],null)}}}}function Vj(...e){return l.useCallback(Ij(...e),e)}var Dj=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Lj=Dj.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,c=a?Kn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),g.jsx(c,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{});function Sd(e){const o=l.useRef(e);return l.useEffect(()=>{o.current=e}),l.useMemo(()=>(...n)=>{var t;return(t=o.current)==null?void 0:t.call(o,...n)},[])}var sc="focusScope.autoFocusOnMount",uc="focusScope.autoFocusOnUnmount",Pd={bubbles:!1,cancelable:!0},Uj="FocusScope",$m=l.forwardRef((e,o)=>{const{loop:n=!1,trapped:t=!1,onMountAutoFocus:r,onUnmountAutoFocus:a,...i}=e,[c,s]=l.useState(null),u=Sd(r),d=Sd(a),p=l.useRef(null),v=Vj(o,b=>s(b)),y=l.useRef({paused:!1,pause(){this.paused=!0},resume(){this.paused=!1}}).current;l.useEffect(()=>{if(t){let b=function(f){if(y.paused||!c)return;const T=f.target;c.contains(T)?p.current=T:en(p.current,{select:!0})},N=function(f){if(y.paused||!c)return;const T=f.relatedTarget;T!==null&&(c.contains(T)||en(p.current,{select:!0}))},k=function(f){if(document.activeElement===document.body)for(const x of f)x.removedNodes.length>0&&en(c)};document.addEventListener("focusin",b),document.addEventListener("focusout",N);const m=new MutationObserver(k);return c&&m.observe(c,{childList:!0,subtree:!0}),()=>{document.removeEventListener("focusin",b),document.removeEventListener("focusout",N),m.disconnect()}}},[t,c,y.paused]),l.useEffect(()=>{if(c){wd.add(y);const b=document.activeElement;if(!c.contains(b)){const k=new CustomEvent(sc,Pd);c.addEventListener(sc,u),c.dispatchEvent(k),k.defaultPrevented||(_j(Hj(Hm(c)),{select:!0}),document.activeElement===b&&en(c))}return()=>{c.removeEventListener(sc,u),setTimeout(()=>{const k=new CustomEvent(uc,Pd);c.addEventListener(uc,d),c.dispatchEvent(k),k.defaultPrevented||en(b??document.body,{select:!0}),c.removeEventListener(uc,d),wd.remove(y)},0)}}},[c,u,d,y]);const z=l.useCallback(b=>{if(!n&&!t||y.paused)return;const N=b.key==="Tab"&&!b.altKey&&!b.ctrlKey&&!b.metaKey,k=document.activeElement;if(N&&k){const m=b.currentTarget,[f,T]=Fj(m);f&&T?!b.shiftKey&&k===T?(b.preventDefault(),n&&en(f,{select:!0})):b.shiftKey&&k===f&&(b.preventDefault(),n&&en(T,{select:!0})):k===m&&b.preventDefault()}},[n,t,y.paused]);return g.jsx(Lj.div,{tabIndex:-1,...i,ref:v,onKeyDown:z})});$m.displayName=Uj;function _j(e,{select:o=!1}={}){const n=document.activeElement;for(const t of e)if(en(t,{select:o}),document.activeElement!==n)return}function Fj(e){const o=Hm(e),n=xd(o,e),t=xd(o.reverse(),e);return[n,t]}function Hm(e){const o=[],n=document.createTreeWalker(e,NodeFilter.SHOW_ELEMENT,{acceptNode:t=>{const r=t.tagName==="INPUT"&&t.type==="hidden";return t.disabled||t.hidden||r?NodeFilter.FILTER_SKIP:t.tabIndex>=0?NodeFilter.FILTER_ACCEPT:NodeFilter.FILTER_SKIP}});for(;n.nextNode();)o.push(n.currentNode);return o}function xd(e,o){for(const n of e)if(!Bj(n,{upTo:o}))return n}function Bj(e,{upTo:o}){if(getComputedStyle(e).visibility==="hidden")return!0;for(;e;){if(o!==void 0&&e===o)return!1;if(getComputedStyle(e).display==="none")return!0;e=e.parentElement}return!1}function Kj(e){return e instanceof HTMLInputElement&&"select"in e}function en(e,{select:o=!1}={}){if(e&&e.focus){const n=document.activeElement;e.focus({preventScroll:!0}),e!==n&&Kj(e)&&o&&e.select()}}var wd=$j();function $j(){let e=[];return{add(o){const n=e[0];o!==n&&(n==null||n.pause()),e=Cd(e,o),e.unshift(o)},remove(o){var n;e=Cd(e,o),(n=e[0])==null||n.resume()}}}function Cd(e,o){const n=[...e],t=n.indexOf(o);return t!==-1&&n.splice(t,1),n}function Hj(e){return e.filter(o=>o.tagName!=="A")}var Wj=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Zj=Wj.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,c=a?Kn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),g.jsx(c,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{}),Xj=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{},Gj="Portal",Wm=l.forwardRef((e,o)=>{var c;const{container:n,...t}=e,[r,a]=l.useState(!1);Xj(()=>a(!0),[]);const i=n||r&&((c=globalThis==null?void 0:globalThis.document)==null?void 0:c.body);return i?qv.createPortal(g.jsx(Zj.div,{...t,ref:o}),i):null});Wm.displayName=Gj;var Ed=globalThis!=null&&globalThis.document?l.useLayoutEffect:()=>{};function Jj(e,o){return l.useReducer((n,t)=>o[n][t]??n,e)}var Ti=e=>{const{present:o,children:n}=e,t=Qj(o),r=typeof n=="function"?n({present:t.isPresent}):l.Children.only(n),a=Ni(t.ref,Yj(r));return typeof n=="function"||t.isPresent?l.cloneElement(r,{ref:a}):null};Ti.displayName="Presence";function Qj(e){const[o,n]=l.useState(),t=l.useRef({}),r=l.useRef(e),a=l.useRef("none"),i=e?"mounted":"unmounted",[c,s]=Jj(i,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return l.useEffect(()=>{const u=pa(t.current);a.current=c==="mounted"?u:"none"},[c]),Ed(()=>{const u=t.current,d=r.current;if(d!==e){const v=a.current,y=pa(u);e?s("MOUNT"):y==="none"||(u==null?void 0:u.display)==="none"?s("UNMOUNT"):s(d&&v!==y?"ANIMATION_OUT":"UNMOUNT"),r.current=e}},[e,s]),Ed(()=>{if(o){let u;const d=o.ownerDocument.defaultView??window,p=y=>{const b=pa(t.current).includes(y.animationName);if(y.target===o&&b&&(s("ANIMATION_END"),!r.current)){const N=o.style.animationFillMode;o.style.animationFillMode="forwards",u=d.setTimeout(()=>{o.style.animationFillMode==="forwards"&&(o.style.animationFillMode=N)})}},v=y=>{y.target===o&&(a.current=pa(t.current))};return o.addEventListener("animationstart",v),o.addEventListener("animationcancel",p),o.addEventListener("animationend",p),()=>{d.clearTimeout(u),o.removeEventListener("animationstart",v),o.removeEventListener("animationcancel",p),o.removeEventListener("animationend",p)}}else s("ANIMATION_END")},[o,s]),{isPresent:["mounted","unmountSuspended"].includes(c),ref:l.useCallback(u=>{u&&(t.current=getComputedStyle(u)),n(u)},[])}}function pa(e){return(e==null?void 0:e.animationName)||"none"}function Yj(e){var t,r;let o=(t=Object.getOwnPropertyDescriptor(e.props,"ref"))==null?void 0:t.get,n=o&&"isReactWarning"in o&&o.isReactWarning;return n?e.ref:(o=(r=Object.getOwnPropertyDescriptor(e,"ref"))==null?void 0:r.get,n=o&&"isReactWarning"in o&&o.isReactWarning,n?e.props.ref:e.props.ref||e.ref)}var qj=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","span","svg","ul"],Br=qj.reduce((e,o)=>{const n=l.forwardRef((t,r)=>{const{asChild:a,...i}=t,c=a?Kn:o;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),g.jsx(c,{...i,ref:r})});return n.displayName=`Primitive.${o}`,{...e,[o]:n}},{}),lc=0;function e1(){l.useEffect(()=>{const e=document.querySelectorAll("[data-radix-focus-guard]");return document.body.insertAdjacentElement("afterbegin",e[0]??Md()),document.body.insertAdjacentElement("beforeend",e[1]??Md()),lc++,()=>{lc===1&&document.querySelectorAll("[data-radix-focus-guard]").forEach(o=>o.remove()),lc--}},[])}function Md(){const e=document.createElement("span");return e.setAttribute("data-radix-focus-guard",""),e.tabIndex=0,e.style.outline="none",e.style.opacity="0",e.style.position="fixed",e.style.pointerEvents="none",e}var xo=function(){return xo=Object.assign||function(o){for(var n,t=1,r=arguments.length;t<r;t++){n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(o[a]=n[a])}return o},xo.apply(this,arguments)};function Zm(e,o){var n={};for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&o.indexOf(t)<0&&(n[t]=e[t]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var r=0,t=Object.getOwnPropertySymbols(e);r<t.length;r++)o.indexOf(t[r])<0&&Object.prototype.propertyIsEnumerable.call(e,t[r])&&(n[t[r]]=e[t[r]]);return n}function o1(e,o,n){if(n||arguments.length===2)for(var t=0,r=o.length,a;t<r;t++)(a||!(t in o))&&(a||(a=Array.prototype.slice.call(o,0,t)),a[t]=o[t]);return e.concat(a||Array.prototype.slice.call(o))}var Ca="right-scroll-bar-position",Ea="width-before-scroll-bar",n1="with-scroll-bars-hidden",t1="--removed-body-scroll-bar-size";function dc(e,o){return typeof e=="function"?e(o):e&&(e.current=o),e}function r1(e,o){var n=l.useState(function(){return{value:e,callback:o,facade:{get current(){return n.value},set current(t){var r=n.value;r!==t&&(n.value=t,n.callback(t,r))}}}})[0];return n.callback=o,n.facade}var a1=typeof window<"u"?l.useLayoutEffect:l.useEffect,Od=new WeakMap;function i1(e,o){var n=r1(null,function(t){return e.forEach(function(r){return dc(r,t)})});return a1(function(){var t=Od.get(n);if(t){var r=new Set(t),a=new Set(e),i=n.current;r.forEach(function(c){a.has(c)||dc(c,null)}),a.forEach(function(c){r.has(c)||dc(c,i)})}Od.set(n,e)},[e]),n}function c1(e){return e}function s1(e,o){o===void 0&&(o=c1);var n=[],t=!1,r={read:function(){if(t)throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");return n.length?n[n.length-1]:e},useMedium:function(a){var i=o(a,t);return n.push(i),function(){n=n.filter(function(c){return c!==i})}},assignSyncMedium:function(a){for(t=!0;n.length;){var i=n;n=[],i.forEach(a)}n={push:function(c){return a(c)},filter:function(){return n}}},assignMedium:function(a){t=!0;var i=[];if(n.length){var c=n;n=[],c.forEach(a),i=n}var s=function(){var d=i;i=[],d.forEach(a)},u=function(){return Promise.resolve().then(s)};u(),n={push:function(d){i.push(d),u()},filter:function(d){return i=i.filter(d),n}}}};return r}function u1(e){e===void 0&&(e={});var o=s1(null);return o.options=xo({async:!0,ssr:!1},e),o}var Xm=function(e){var o=e.sideCar,n=Zm(e,["sideCar"]);if(!o)throw new Error("Sidecar: please provide `sideCar` property to import the right car");var t=o.read();if(!t)throw new Error("Sidecar medium not found");return l.createElement(t,xo({},n))};Xm.isSideCarExport=!0;function l1(e,o){return e.useMedium(o),Xm}var Gm=u1(),pc=function(){},Si=l.forwardRef(function(e,o){var n=l.useRef(null),t=l.useState({onScrollCapture:pc,onWheelCapture:pc,onTouchMoveCapture:pc}),r=t[0],a=t[1],i=e.forwardProps,c=e.children,s=e.className,u=e.removeScrollBar,d=e.enabled,p=e.shards,v=e.sideCar,y=e.noIsolation,z=e.inert,b=e.allowPinchZoom,N=e.as,k=N===void 0?"div":N,m=e.gapMode,f=Zm(e,["forwardProps","children","className","removeScrollBar","enabled","shards","sideCar","noIsolation","inert","allowPinchZoom","as","gapMode"]),T=v,x=i1([n,o]),O=xo(xo({},f),r);return l.createElement(l.Fragment,null,d&&l.createElement(T,{sideCar:Gm,removeScrollBar:u,shards:p,noIsolation:y,inert:z,setCallbacks:a,allowPinchZoom:!!b,lockRef:n,gapMode:m}),i?l.cloneElement(l.Children.only(c),xo(xo({},O),{ref:x})):l.createElement(k,xo({},O,{className:s,ref:x}),c))});Si.defaultProps={enabled:!0,removeScrollBar:!0,inert:!1};Si.classNames={fullWidth:Ea,zeroRight:Ca};var d1=function(){if(typeof __webpack_nonce__<"u")return __webpack_nonce__};function p1(){if(!document)return null;var e=document.createElement("style");e.type="text/css";var o=d1();return o&&e.setAttribute("nonce",o),e}function v1(e,o){e.styleSheet?e.styleSheet.cssText=o:e.appendChild(document.createTextNode(o))}function m1(e){var o=document.head||document.getElementsByTagName("head")[0];o.appendChild(e)}var k1=function(){var e=0,o=null;return{add:function(n){e==0&&(o=p1())&&(v1(o,n),m1(o)),e++},remove:function(){e--,!e&&o&&(o.parentNode&&o.parentNode.removeChild(o),o=null)}}},b1=function(){var e=k1();return function(o,n){l.useEffect(function(){return e.add(o),function(){e.remove()}},[o&&n])}},Jm=function(){var e=b1(),o=function(n){var t=n.styles,r=n.dynamic;return e(t,r),null};return o},f1={left:0,top:0,right:0,gap:0},vc=function(e){return parseInt(e||"",10)||0},h1=function(e){var o=window.getComputedStyle(document.body),n=o[e==="padding"?"paddingLeft":"marginLeft"],t=o[e==="padding"?"paddingTop":"marginTop"],r=o[e==="padding"?"paddingRight":"marginRight"];return[vc(n),vc(t),vc(r)]},y1=function(e){if(e===void 0&&(e="margin"),typeof window>"u")return f1;var o=h1(e),n=document.documentElement.clientWidth,t=window.innerWidth;return{left:o[0],top:o[1],right:o[2],gap:Math.max(0,t-n+o[2]-o[0])}},z1=Jm(),jt="data-scroll-locked",j1=function(e,o,n,t){var r=e.left,a=e.top,i=e.right,c=e.gap;return n===void 0&&(n="margin"),`
  .`.concat(n1,` {
   overflow: hidden `).concat(t,`;
   padding-right: `).concat(c,"px ").concat(t,`;
  }
  body[`).concat(jt,`] {
    overflow: hidden `).concat(t,`;
    overscroll-behavior: contain;
    `).concat([o&&"position: relative ".concat(t,";"),n==="margin"&&`
    padding-left: `.concat(r,`px;
    padding-top: `).concat(a,`px;
    padding-right: `).concat(i,`px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c,"px ").concat(t,`;
    `),n==="padding"&&"padding-right: ".concat(c,"px ").concat(t,";")].filter(Boolean).join(""),`
  }
  
  .`).concat(Ca,` {
    right: `).concat(c,"px ").concat(t,`;
  }
  
  .`).concat(Ea,` {
    margin-right: `).concat(c,"px ").concat(t,`;
  }
  
  .`).concat(Ca," .").concat(Ca,` {
    right: 0 `).concat(t,`;
  }
  
  .`).concat(Ea," .").concat(Ea,` {
    margin-right: 0 `).concat(t,`;
  }
  
  body[`).concat(jt,`] {
    `).concat(t1,": ").concat(c,`px;
  }
`)},Rd=function(){var e=parseInt(document.body.getAttribute(jt)||"0",10);return isFinite(e)?e:0},g1=function(){l.useEffect(function(){return document.body.setAttribute(jt,(Rd()+1).toString()),function(){var e=Rd()-1;e<=0?document.body.removeAttribute(jt):document.body.setAttribute(jt,e.toString())}},[])},N1=function(e){var o=e.noRelative,n=e.noImportant,t=e.gapMode,r=t===void 0?"margin":t;g1();var a=l.useMemo(function(){return y1(r)},[r]);return l.createElement(z1,{styles:j1(a,!o,r,n?"":"!important")})},hs=!1;if(typeof window<"u")try{var va=Object.defineProperty({},"passive",{get:function(){return hs=!0,!0}});window.addEventListener("test",va,va),window.removeEventListener("test",va,va)}catch{hs=!1}var Jn=hs?{passive:!1}:!1,T1=function(e){return e.tagName==="TEXTAREA"},Qm=function(e,o){if(!(e instanceof Element))return!1;var n=window.getComputedStyle(e);return n[o]!=="hidden"&&!(n.overflowY===n.overflowX&&!T1(e)&&n[o]==="visible")},S1=function(e){return Qm(e,"overflowY")},P1=function(e){return Qm(e,"overflowX")},Ad=function(e,o){var n=o.ownerDocument,t=o;do{typeof ShadowRoot<"u"&&t instanceof ShadowRoot&&(t=t.host);var r=Ym(e,t);if(r){var a=qm(e,t),i=a[1],c=a[2];if(i>c)return!0}t=t.parentNode}while(t&&t!==n.body);return!1},x1=function(e){var o=e.scrollTop,n=e.scrollHeight,t=e.clientHeight;return[o,n,t]},w1=function(e){var o=e.scrollLeft,n=e.scrollWidth,t=e.clientWidth;return[o,n,t]},Ym=function(e,o){return e==="v"?S1(o):P1(o)},qm=function(e,o){return e==="v"?x1(o):w1(o)},C1=function(e,o){return e==="h"&&o==="rtl"?-1:1},E1=function(e,o,n,t,r){var a=C1(e,window.getComputedStyle(o).direction),i=a*t,c=n.target,s=o.contains(c),u=!1,d=i>0,p=0,v=0;do{var y=qm(e,c),z=y[0],b=y[1],N=y[2],k=b-N-a*z;(z||k)&&Ym(e,c)&&(p+=k,v+=z),c instanceof ShadowRoot?c=c.host:c=c.parentNode}while(!s&&c!==document.body||s&&(o.contains(c)||o===c));return(d&&(Math.abs(p)<1||!r)||!d&&(Math.abs(v)<1||!r))&&(u=!0),u},ma=function(e){return"changedTouches"in e?[e.changedTouches[0].clientX,e.changedTouches[0].clientY]:[0,0]},Id=function(e){return[e.deltaX,e.deltaY]},Vd=function(e){return e&&"current"in e?e.current:e},M1=function(e,o){return e[0]===o[0]&&e[1]===o[1]},O1=function(e){return`
  .block-interactivity-`.concat(e,` {pointer-events: none;}
  .allow-interactivity-`).concat(e,` {pointer-events: all;}
`)},R1=0,Qn=[];function A1(e){var o=l.useRef([]),n=l.useRef([0,0]),t=l.useRef(),r=l.useState(R1++)[0],a=l.useState(Jm)[0],i=l.useRef(e);l.useEffect(function(){i.current=e},[e]),l.useEffect(function(){if(e.inert){document.body.classList.add("block-interactivity-".concat(r));var b=o1([e.lockRef.current],(e.shards||[]).map(Vd),!0).filter(Boolean);return b.forEach(function(N){return N.classList.add("allow-interactivity-".concat(r))}),function(){document.body.classList.remove("block-interactivity-".concat(r)),b.forEach(function(N){return N.classList.remove("allow-interactivity-".concat(r))})}}},[e.inert,e.lockRef.current,e.shards]);var c=l.useCallback(function(b,N){if("touches"in b&&b.touches.length===2||b.type==="wheel"&&b.ctrlKey)return!i.current.allowPinchZoom;var k=ma(b),m=n.current,f="deltaX"in b?b.deltaX:m[0]-k[0],T="deltaY"in b?b.deltaY:m[1]-k[1],x,O=b.target,h=Math.abs(f)>Math.abs(T)?"h":"v";if("touches"in b&&h==="h"&&O.type==="range")return!1;var C=Ad(h,O);if(!C)return!0;if(C?x=h:(x=h==="v"?"h":"v",C=Ad(h,O)),!C)return!1;if(!t.current&&"changedTouches"in b&&(f||T)&&(t.current=x),!x)return!0;var V=t.current||x;return E1(V,N,b,V==="h"?f:T,!0)},[]),s=l.useCallback(function(b){var N=b;if(!(!Qn.length||Qn[Qn.length-1]!==a)){var k="deltaY"in N?Id(N):ma(N),m=o.current.filter(function(x){return x.name===N.type&&(x.target===N.target||N.target===x.shadowParent)&&M1(x.delta,k)})[0];if(m&&m.should){N.cancelable&&N.preventDefault();return}if(!m){var f=(i.current.shards||[]).map(Vd).filter(Boolean).filter(function(x){return x.contains(N.target)}),T=f.length>0?c(N,f[0]):!i.current.noIsolation;T&&N.cancelable&&N.preventDefault()}}},[]),u=l.useCallback(function(b,N,k,m){var f={name:b,delta:N,target:k,should:m,shadowParent:I1(k)};o.current.push(f),setTimeout(function(){o.current=o.current.filter(function(T){return T!==f})},1)},[]),d=l.useCallback(function(b){n.current=ma(b),t.current=void 0},[]),p=l.useCallback(function(b){u(b.type,Id(b),b.target,c(b,e.lockRef.current))},[]),v=l.useCallback(function(b){u(b.type,ma(b),b.target,c(b,e.lockRef.current))},[]);l.useEffect(function(){return Qn.push(a),e.setCallbacks({onScrollCapture:p,onWheelCapture:p,onTouchMoveCapture:v}),document.addEventListener("wheel",s,Jn),document.addEventListener("touchmove",s,Jn),document.addEventListener("touchstart",d,Jn),function(){Qn=Qn.filter(function(b){return b!==a}),document.removeEventListener("wheel",s,Jn),document.removeEventListener("touchmove",s,Jn),document.removeEventListener("touchstart",d,Jn)}},[]);var y=e.removeScrollBar,z=e.inert;return l.createElement(l.Fragment,null,z?l.createElement(a,{styles:O1(r)}):null,y?l.createElement(N1,{gapMode:e.gapMode}):null)}function I1(e){for(var o=null;e!==null;)e instanceof ShadowRoot&&(o=e.host,e=e.host),e=e.parentNode;return o}const V1=l1(Gm,A1);var ek=l.forwardRef(function(e,o){return l.createElement(Si,xo({},e,{ref:o,sideCar:V1}))});ek.classNames=Si.classNames;var D1=function(e){if(typeof document>"u")return null;var o=Array.isArray(e)?e[0]:e;return o.ownerDocument.body},Yn=new WeakMap,ka=new WeakMap,ba={},mc=0,ok=function(e){return e&&(e.host||ok(e.parentNode))},L1=function(e,o){return o.map(function(n){if(e.contains(n))return n;var t=ok(n);return t&&e.contains(t)?t:(console.error("aria-hidden",n,"in not contained inside",e,". Doing nothing"),null)}).filter(function(n){return!!n})},U1=function(e,o,n,t){var r=L1(o,Array.isArray(e)?e:[e]);ba[n]||(ba[n]=new WeakMap);var a=ba[n],i=[],c=new Set,s=new Set(r),u=function(p){!p||c.has(p)||(c.add(p),u(p.parentNode))};r.forEach(u);var d=function(p){!p||s.has(p)||Array.prototype.forEach.call(p.children,function(v){if(c.has(v))d(v);else try{var y=v.getAttribute(t),z=y!==null&&y!=="false",b=(Yn.get(v)||0)+1,N=(a.get(v)||0)+1;Yn.set(v,b),a.set(v,N),i.push(v),b===1&&z&&ka.set(v,!0),N===1&&v.setAttribute(n,"true"),z||v.setAttribute(t,"true")}catch(k){console.error("aria-hidden: cannot operate on ",v,k)}})};return d(o),c.clear(),mc++,function(){i.forEach(function(p){var v=Yn.get(p)-1,y=a.get(p)-1;Yn.set(p,v),a.set(p,y),v||(ka.has(p)||p.removeAttribute(t),ka.delete(p)),y||p.removeAttribute(n)}),mc--,mc||(Yn=new WeakMap,Yn=new WeakMap,ka=new WeakMap,ba={})}},_1=function(e,o,n){n===void 0&&(n="data-aria-hidden");var t=Array.from(Array.isArray(e)?e:[e]),r=D1(e);return r?(t.push.apply(t,Array.from(r.querySelectorAll("[aria-live]"))),U1(t,r,n,"aria-hidden")):function(){return null}},gu="Dialog",[nk,b4]=bj(gu),[F1,go]=nk(gu),tk=e=>{const{__scopeDialog:o,children:n,open:t,defaultOpen:r,onOpenChange:a,modal:i=!0}=e,c=l.useRef(null),s=l.useRef(null),[u=!1,d]=jj({prop:t,defaultProp:r,onChange:a});return g.jsx(F1,{scope:o,triggerRef:c,contentRef:s,contentId:ic(),titleId:ic(),descriptionId:ic(),open:u,onOpenChange:d,onOpenToggle:l.useCallback(()=>d(p=>!p),[d]),modal:i,children:n})};tk.displayName=gu;var rk="DialogTrigger",ak=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=go(rk,n),a=Ni(o,r.triggerRef);return g.jsx(Br.button,{type:"button","aria-haspopup":"dialog","aria-expanded":r.open,"aria-controls":r.contentId,"data-state":Su(r.open),...t,ref:a,onClick:kr(e.onClick,r.onOpenToggle)})});ak.displayName=rk;var Nu="DialogPortal",[B1,ik]=nk(Nu,{forceMount:void 0}),ck=e=>{const{__scopeDialog:o,forceMount:n,children:t,container:r}=e,a=go(Nu,o);return g.jsx(B1,{scope:o,forceMount:n,children:l.Children.map(t,i=>g.jsx(Ti,{present:n||a.open,children:g.jsx(Wm,{asChild:!0,container:r,children:i})}))})};ck.displayName=Nu;var ti="DialogOverlay",sk=l.forwardRef((e,o)=>{const n=ik(ti,e.__scopeDialog),{forceMount:t=n.forceMount,...r}=e,a=go(ti,e.__scopeDialog);return a.modal?g.jsx(Ti,{present:t||a.open,children:g.jsx(K1,{...r,ref:o})}):null});sk.displayName=ti;var K1=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=go(ti,n);return g.jsx(ek,{as:Kn,allowPinchZoom:!0,shards:[r.contentRef],children:g.jsx(Br.div,{"data-state":Su(r.open),...t,ref:o,style:{pointerEvents:"auto",...t.style}})})}),_n="DialogContent",uk=l.forwardRef((e,o)=>{const n=ik(_n,e.__scopeDialog),{forceMount:t=n.forceMount,...r}=e,a=go(_n,e.__scopeDialog);return g.jsx(Ti,{present:t||a.open,children:a.modal?g.jsx($1,{...r,ref:o}):g.jsx(H1,{...r,ref:o})})});uk.displayName=_n;var $1=l.forwardRef((e,o)=>{const n=go(_n,e.__scopeDialog),t=l.useRef(null),r=Ni(o,n.contentRef,t);return l.useEffect(()=>{const a=t.current;if(a)return _1(a)},[]),g.jsx(lk,{...e,ref:r,trapFocus:n.open,disableOutsidePointerEvents:!0,onCloseAutoFocus:kr(e.onCloseAutoFocus,a=>{var i;a.preventDefault(),(i=n.triggerRef.current)==null||i.focus()}),onPointerDownOutside:kr(e.onPointerDownOutside,a=>{const i=a.detail.originalEvent,c=i.button===0&&i.ctrlKey===!0;(i.button===2||c)&&a.preventDefault()}),onFocusOutside:kr(e.onFocusOutside,a=>a.preventDefault())})}),H1=l.forwardRef((e,o)=>{const n=go(_n,e.__scopeDialog),t=l.useRef(!1),r=l.useRef(!1);return g.jsx(lk,{...e,ref:o,trapFocus:!1,disableOutsidePointerEvents:!1,onCloseAutoFocus:a=>{var i,c;(i=e.onCloseAutoFocus)==null||i.call(e,a),a.defaultPrevented||(t.current||(c=n.triggerRef.current)==null||c.focus(),a.preventDefault()),t.current=!1,r.current=!1},onInteractOutside:a=>{var s,u;(s=e.onInteractOutside)==null||s.call(e,a),a.defaultPrevented||(t.current=!0,a.detail.originalEvent.type==="pointerdown"&&(r.current=!0));const i=a.target;((u=n.triggerRef.current)==null?void 0:u.contains(i))&&a.preventDefault(),a.detail.originalEvent.type==="focusin"&&r.current&&a.preventDefault()}})}),lk=l.forwardRef((e,o)=>{const{__scopeDialog:n,trapFocus:t,onOpenAutoFocus:r,onCloseAutoFocus:a,...i}=e,c=go(_n,n),s=l.useRef(null),u=Ni(o,s);return e1(),g.jsxs(g.Fragment,{children:[g.jsx($m,{asChild:!0,loop:!0,trapped:t,onMountAutoFocus:r,onUnmountAutoFocus:a,children:g.jsx(Bm,{role:"dialog",id:c.contentId,"aria-describedby":c.descriptionId,"aria-labelledby":c.titleId,"data-state":Su(c.open),...i,ref:u,onDismiss:()=>c.onOpenChange(!1)})}),g.jsxs(g.Fragment,{children:[g.jsx(W1,{titleId:c.titleId}),g.jsx(X1,{contentRef:s,descriptionId:c.descriptionId})]})]})}),Tu="DialogTitle",dk=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=go(Tu,n);return g.jsx(Br.h2,{id:r.titleId,...t,ref:o})});dk.displayName=Tu;var pk="DialogDescription",vk=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=go(pk,n);return g.jsx(Br.p,{id:r.descriptionId,...t,ref:o})});vk.displayName=pk;var mk="DialogClose",kk=l.forwardRef((e,o)=>{const{__scopeDialog:n,...t}=e,r=go(mk,n);return g.jsx(Br.button,{type:"button",...t,ref:o,onClick:kr(e.onClick,()=>r.onOpenChange(!1))})});kk.displayName=mk;function Su(e){return e?"open":"closed"}var bk="DialogTitleWarning",[f4,fk]=kj(bk,{contentName:_n,titleName:Tu,docsSlug:"dialog"}),W1=({titleId:e})=>{const o=fk(bk),n=`\`${o.contentName}\` requires a \`${o.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${o.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${o.docsSlug}`;return l.useEffect(()=>{e&&(document.getElementById(e)||console.error(n))},[n,e]),null},Z1="DialogDescriptionWarning",X1=({contentRef:e,descriptionId:o})=>{const t=`Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${fk(Z1).contentName}}.`;return l.useEffect(()=>{var a;const r=(a=e.current)==null?void 0:a.getAttribute("aria-describedby");o&&r&&(document.getElementById(o)||console.warn(t))},[t,e,o]),null},G1=tk,J1=ak,Q1=ck,hk=sk,yk=uk,zk=dk,jk=vk,Y1=kk;const q1=G1,e4=J1,o4=Q1,gk=l.forwardRef(({className:e,...o},n)=>g.jsx(hk,{ref:n,className:Ko("fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",e),...o}));gk.displayName=hk.displayName;const Nk=l.forwardRef(({className:e,children:o,...n},t)=>g.jsxs(o4,{children:[g.jsx(gk,{}),g.jsxs(yk,{ref:t,className:Ko("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",e),...n,children:[o,g.jsxs(Y1,{className:"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",children:[g.jsx(um,{className:"h-4 w-4"}),g.jsx("span",{className:"sr-only",children:"Close"})]})]})]}));Nk.displayName=yk.displayName;const Tk=({className:e,...o})=>g.jsx("div",{className:Ko("flex flex-col space-y-1.5 text-center sm:text-left",e),...o});Tk.displayName="DialogHeader";const Sk=l.forwardRef(({className:e,...o},n)=>g.jsx(zk,{ref:n,className:Ko("text-lg font-semibold leading-none tracking-tight",e),...o}));Sk.displayName=zk.displayName;const Pk=l.forwardRef(({className:e,...o},n)=>g.jsx(jk,{ref:n,className:Ko("text-sm text-muted-foreground",e),...o}));Pk.displayName=jk.displayName;function Pi({title:e,correct:o,incorrect:n,refresh:t}){const[r,a]=l.useState(!1),[i,c]=l.useState(new Array(o.length+n.length).fill(!1)),s=l.useMemo(()=>(c(new Array(o.length+n.length).fill(!1)),qh([...o,...n])),[o,n]);return g.jsxs("div",{className:"flex flex-col gap-4",children:[g.jsxs("div",{children:[g.jsx("h2",{className:"text-2xl",children:e}),g.jsxs("p",{className:"font-medium text-sm",children:["Zaškrtněte správné výroky(",o.length,")"]})]}),g.jsx("div",{children:s.map((u,d)=>g.jsx(n4,{statement:u,type:o.find(p=>p.uuid==u.uuid)?"correct":"incorrect",submited:r,checked:i[d],onChange:p=>{const v=[...i];v[d]=p,c(v)}},ey(u.uuid)))}),g.jsx(Vo,{className:"w-full",onClick:()=>{r?(a(!1),t()):a(!0)},children:r?"Další otázka":"Odeslat"}),g.jsx("div",{className:"w-full flex justify-end",children:g.jsx(t4,{})})]})}function n4({statement:e,type:o,submited:n,checked:t,onChange:r}){const[a,i]=l.useState(o=="correct");return g.jsxs("div",{className:Ko(["p-2 flex gap-2 items-center",n&&(o=="correct"?"bg-green-200":"bg-red-200"),n?"cursor-default":"cursor-pointer",n?o=="correct"?"hover:bg-green-300":"hover:bg-red-300":"hover:bg-gray-200"]),onClick:()=>{n||r(!t)},children:[g.jsx(Vm,{id:e.uuid,name:o,disabled:n,checked:t}),g.jsxs("div",{className:"flex-1",children:[g.jsx("p",{className:"whitespace-pre-wrap",children:a?e.correct:e.incorrect}),n&&o=="incorrect"&&g.jsxs("div",{className:"flex items-center pt-2 gap-2 select-none",children:[g.jsx("p",{onMouseDown:()=>i(c=>!c),className:"font-bold underline italic cursor-pointer",children:a?"zobrazit nesprávnou":"zobrazit správnou"}),g.jsx("p",{className:"text-gray-600",children:a?"(Zobrazuje se správna odpověď)":"(Zobrazuje se nesprávna odpověď)"})]}),n&&e.sectionNumber&&e.sectionTitle&&g.jsxs("p",{className:"text-gray-600",children:["Fakt z části: ",e.sectionNumber,". ",e.sectionTitle]})]}),n&&t&&(o=="correct"?g.jsx("span",{children:g.jsx(sm,{className:"w-10 h-10"})}):g.jsx("span",{children:g.jsx(um,{className:"w-10 h-10"})}))]})}function t4(){return g.jsxs(q1,{children:[g.jsx(e4,{asChild:!0,children:g.jsx(Vo,{variant:"outline",children:"Nahlásit chybu"})}),g.jsx(Nk,{children:g.jsxs(Tk,{children:[g.jsx(Sk,{children:"Vyberte si jak nahlásit chybu"}),g.jsxs(Pk,{children:["Nahlášení chyby můžete provést buď přes Discord nebo přes Github.",g.jsx("br",{}),g.jsx("br",{}),"Pokud chcete nahlásit chybu přes Discord, pripojte se na náš server a napište nám (",g.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"underline text-foreground hover:text-blue-500",target:"_blank",children:["link pro připojení",g.jsx(zt,{className:"w-3 h-3 inline self-center"})]}),").",g.jsx("br",{}),g.jsx("br",{}),"Pokud chcete nahlásit chybu přes Github, vytvořte issue(",g.jsxs("a",{href:"https://github.com/tomz197/os-drill/issues/new",className:"underline text-foreground hover:text-blue-500",target:"_blank",children:["link pro vytoření issue",g.jsx(zt,{className:"w-3 h-3 inline self-center"})]}),")."]})]})})]})}function r4(){const{sectionUUID:e}=Nm(),[o,n]=l.useState(null),[t,r]=l.useState([]),[a,i]=l.useState([]);l.useEffect(()=>{if(!e){console.error("Section not found"),wo("/");return}const[s,u]=ms.getSingleSection({uuid:e});if(u){console.error("Section not found"),wo("/");return}n(s)},[e]);const c=l.useCallback(()=>{if(!e){console.error("Section or name not found"),wo("/");return}const[s,u]=ms.getRandomStatements({count:5,sections:[e]});if(u){console.error("Statements not found"),wo("/");return}r(s.slice(0,2)),i(s.slice(2,5))},[o]);return l.useEffect(()=>{c()},[c]),!t||!a||!o?null:g.jsx(Pi,{title:`Část ${o.sectionNumber}: ${o.sectionTitle}`,correct:t,incorrect:a,refresh:c})}function a4(){const[e,o]=l.useState([]),[n,t]=l.useState([]),r=l.useCallback(()=>{const[a,i]=ms.getRandomStatements({count:5});if(i){console.error("Statements not found"),wo("/");return}o(a.slice(0,2)),t(a.slice(2,5))},[]);return l.useEffect(()=>{r()},[r]),!e||!n?null:g.jsx(Pi,{title:"Všechny části",correct:e,incorrect:n,refresh:r})}function i4(){return g.jsxs("div",{className:"max-w-prose w-full mx-auto",children:[g.jsx("h1",{className:"text-xl font-semibold text-center",children:"O nás"}),g.jsx("div",{className:"h-[0.1rem] w-full bg-border rounded-full my-4"}),g.jsxs("div",{className:"grid gap-2",children:[g.jsxs("p",{className:"inline",children:["Táto aplikácia bola vytvorená"," ",g.jsxs("a",{href:"https://zifcak.dev",target:"_blank",className:"underline hover:text-blue-500",children:["Tomášom Žifčákom",g.jsx(zt,{className:"w-3 h-3 inline self-center"})]})," ","pretože neexistoval žiadny spôsob ako si preveriť svoje znalosti z predmetu PB152(Operačné systémy) v zkúškovej/zápočtovej forme."]}),g.jsxs("p",{children:["Kód tejto aplikácie je otvorený a dostupný na"," ",g.jsxs("a",{href:"https://github.com/tomz197/os-drill",className:"underline hover:text-blue-500",target:"_blank",children:["Githube",g.jsx(zt,{className:"w-3 h-3 inline self-center"})]}),"."]}),g.jsxs("p",{children:["V prípade akýchkoľvek problémov, nápadov na vylepšenie alebo akýchkoľvek otázok napíš na"," ",g.jsxs("a",{href:"https://discord.gg/ztabDQ4jNv",className:"underline hover:text-blue-500",target:"_blank",children:["Discord",g.jsx(zt,{className:"w-3 h-3 inline self-center"})]})," ","alebo vytvor issue, pull request alebo diskusiu na Githube."]}),g.jsx("p",{className:"font-semibold",children:"Každá pomoc je vítaná!"})]})]})}function c4({uuid:e}){const o=It.find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Section not found")]}function s4(){return[It,null]}function u4({uuid:e}){const o=It.map(n=>n.statements).flat().find(n=>n.uuid===e);return o?[o,null]:[null,new Error("Statement not found")]}function l4(){return[It.map(o=>o.statements).flat(),null]}function d4({count:e=5,sections:o}){const n=It.filter(a=>o?o.includes(a.uuid):!0),t=n[Math.floor(Math.random()*n.length)];return t.statements.length<e?[null,new Error("Not enough statements")]:[t.statements.sort(()=>Math.random()-.5).slice(0,e),null]}const ys={getSingleSection:c4,getAllSections:s4,getSingleStatement:u4,getAllStatements:l4,getRandomStatements:d4};function p4(){const{sectionUUID:e}=Nm(),[o,n]=l.useState(null),[t,r]=l.useState([]),[a,i]=l.useState([]);l.useEffect(()=>{if(!e){console.error("Section not found"),wo("/");return}const[s,u]=ys.getSingleSection({uuid:e});if(u){console.error("Section not found"),wo("/");return}n(s)},[e]);const c=l.useCallback(()=>{if(!e){console.error("Section or name not found"),wo("/");return}const[s,u]=ys.getRandomStatements({count:5,sections:[e]});if(u){console.error("Statements not found"),wo("/");return}r(s.slice(0,2)),i(s.slice(2,5))},[o]);return l.useEffect(()=>{c()},[c]),!t||!a||!o?null:g.jsx(Pi,{title:`Část ${o.sectionNumber}: ${o.sectionTitle}`,correct:t,incorrect:a,refresh:c})}function v4(){const[e,o]=l.useState([]),[n,t]=l.useState([]),r=l.useCallback(()=>{const[a,i]=ys.getRandomStatements({count:5});if(i){console.error("Statements not found"),wo("/");return}o(a.slice(0,2)),t(a.slice(2,5))},[]);return l.useEffect(()=>{r()},[r]),!e||!n?null:g.jsx(Pi,{title:"Všechny části",correct:e,incorrect:n,refresh:r})}const m4=Pz([{path:"/",element:g.jsx(_z,{}),children:[{path:"",element:g.jsx(Fz,{})},{path:"about",element:g.jsx(i4,{})},{path:"exam/:sectionUUID",element:g.jsx(p4,{})},{path:"exam",element:g.jsx(v4,{})},{path:"credit/:sectionUUID",element:g.jsx(r4,{})},{path:"credit",element:g.jsx(a4,{})}]}],{basename:"/"});kc.createRoot(document.getElementById("root")).render(g.jsx(Gd.StrictMode,{children:g.jsx(Iz,{router:m4})}));
